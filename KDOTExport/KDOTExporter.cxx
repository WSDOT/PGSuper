// Copyright (C) 2005-2010 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "KDOTExporter.hxx"

namespace KDOT
{
  // IndexType1
  // 


  // GirderKeyType
  // 

  const GirderKeyType::SpanIndex_type& GirderKeyType::
  SpanIndex () const
  {
    return this->SpanIndex_.get ();
  }

  GirderKeyType::SpanIndex_type& GirderKeyType::
  SpanIndex ()
  {
    return this->SpanIndex_.get ();
  }

  void GirderKeyType::
  SpanIndex (const SpanIndex_type& x)
  {
    this->SpanIndex_.set (x);
  }

  const GirderKeyType::GirderIndex_type& GirderKeyType::
  GirderIndex () const
  {
    return this->GirderIndex_.get ();
  }

  GirderKeyType::GirderIndex_type& GirderKeyType::
  GirderIndex ()
  {
    return this->GirderIndex_.get ();
  }

  void GirderKeyType::
  GirderIndex (const GirderIndex_type& x)
  {
    this->GirderIndex_.set (x);
  }


  // NamedDoubleType
  // 

  const NamedDoubleType::ParameterName_type& NamedDoubleType::
  ParameterName () const
  {
    return this->ParameterName_.get ();
  }

  NamedDoubleType::ParameterName_type& NamedDoubleType::
  ParameterName ()
  {
    return this->ParameterName_.get ();
  }

  void NamedDoubleType::
  ParameterName (const ParameterName_type& x)
  {
    this->ParameterName_.set (x);
  }

  void NamedDoubleType::
  ParameterName (::std::auto_ptr< ParameterName_type > x)
  {
    this->ParameterName_.set (x);
  }

  const NamedDoubleType::Value_type& NamedDoubleType::
  Value () const
  {
    return this->Value_.get ();
  }

  NamedDoubleType::Value_type& NamedDoubleType::
  Value ()
  {
    return this->Value_.get ();
  }

  void NamedDoubleType::
  Value (const Value_type& x)
  {
    this->Value_.set (x);
  }


  // Point2DType
  // 

  const Point2DType::X_type& Point2DType::
  X () const
  {
    return this->X_.get ();
  }

  Point2DType::X_type& Point2DType::
  X ()
  {
    return this->X_.get ();
  }

  void Point2DType::
  X (const X_type& x)
  {
    this->X_.set (x);
  }

  const Point2DType::Y_type& Point2DType::
  Y () const
  {
    return this->Y_.get ();
  }

  Point2DType::Y_type& Point2DType::
  Y ()
  {
    return this->Y_.get ();
  }

  void Point2DType::
  Y (const Y_type& x)
  {
    this->Y_.set (x);
  }


  // DebondDataType
  // 

  const DebondDataType::StrandIndex_type& DebondDataType::
  StrandIndex () const
  {
    return this->StrandIndex_.get ();
  }

  DebondDataType::StrandIndex_type& DebondDataType::
  StrandIndex ()
  {
    return this->StrandIndex_.get ();
  }

  void DebondDataType::
  StrandIndex (const StrandIndex_type& x)
  {
    this->StrandIndex_.set (x);
  }

  const DebondDataType::StartDebondLength_type& DebondDataType::
  StartDebondLength () const
  {
    return this->StartDebondLength_.get ();
  }

  DebondDataType::StartDebondLength_type& DebondDataType::
  StartDebondLength ()
  {
    return this->StartDebondLength_.get ();
  }

  void DebondDataType::
  StartDebondLength (const StartDebondLength_type& x)
  {
    this->StartDebondLength_.set (x);
  }

  const DebondDataType::EndDebondLength_type& DebondDataType::
  EndDebondLength () const
  {
    return this->EndDebondLength_.get ();
  }

  DebondDataType::EndDebondLength_type& DebondDataType::
  EndDebondLength ()
  {
    return this->EndDebondLength_.get ();
  }

  void DebondDataType::
  EndDebondLength (const EndDebondLength_type& x)
  {
    this->EndDebondLength_.set (x);
  }


  // StrandExtensionDataType
  // 

  const StrandExtensionDataType::StrandIndex_type& StrandExtensionDataType::
  StrandIndex () const
  {
    return this->StrandIndex_.get ();
  }

  StrandExtensionDataType::StrandIndex_type& StrandExtensionDataType::
  StrandIndex ()
  {
    return this->StrandIndex_.get ();
  }

  void StrandExtensionDataType::
  StrandIndex (const StrandIndex_type& x)
  {
    this->StrandIndex_.set (x);
  }

  const StrandExtensionDataType::IsStartExtended_type& StrandExtensionDataType::
  IsStartExtended () const
  {
    return this->IsStartExtended_.get ();
  }

  StrandExtensionDataType::IsStartExtended_type& StrandExtensionDataType::
  IsStartExtended ()
  {
    return this->IsStartExtended_.get ();
  }

  void StrandExtensionDataType::
  IsStartExtended (const IsStartExtended_type& x)
  {
    this->IsStartExtended_.set (x);
  }

  const StrandExtensionDataType::IsEndExtended_type& StrandExtensionDataType::
  IsEndExtended () const
  {
    return this->IsEndExtended_.get ();
  }

  StrandExtensionDataType::IsEndExtended_type& StrandExtensionDataType::
  IsEndExtended ()
  {
    return this->IsEndExtended_.get ();
  }

  void StrandExtensionDataType::
  IsEndExtended (const IsEndExtended_type& x)
  {
    this->IsEndExtended_.set (x);
  }


  // HarpingPointDataType
  // 

  const HarpingPointDataType::Location_type& HarpingPointDataType::
  Location () const
  {
    return this->Location_.get ();
  }

  HarpingPointDataType::Location_type& HarpingPointDataType::
  Location ()
  {
    return this->Location_.get ();
  }

  void HarpingPointDataType::
  Location (const Location_type& x)
  {
    this->Location_.set (x);
  }

  const HarpingPointDataType::HoldDownForce_type& HarpingPointDataType::
  HoldDownForce () const
  {
    return this->HoldDownForce_.get ();
  }

  HarpingPointDataType::HoldDownForce_type& HarpingPointDataType::
  HoldDownForce ()
  {
    return this->HoldDownForce_.get ();
  }

  void HarpingPointDataType::
  HoldDownForce (const HoldDownForce_type& x)
  {
    this->HoldDownForce_.set (x);
  }


  // PierDataType
  // 

  const PierDataType::Station_type& PierDataType::
  Station () const
  {
    return this->Station_.get ();
  }

  PierDataType::Station_type& PierDataType::
  Station ()
  {
    return this->Station_.get ();
  }

  void PierDataType::
  Station (const Station_type& x)
  {
    this->Station_.set (x);
  }

  const PierDataType::Skew_type& PierDataType::
  Skew () const
  {
    return this->Skew_.get ();
  }

  PierDataType::Skew_type& PierDataType::
  Skew ()
  {
    return this->Skew_.get ();
  }

  void PierDataType::
  Skew (const Skew_type& x)
  {
    this->Skew_.set (x);
  }

  const PierDataType::backGirderEndOffset_type& PierDataType::
  backGirderEndOffset () const
  {
    return this->backGirderEndOffset_.get ();
  }

  PierDataType::backGirderEndOffset_type& PierDataType::
  backGirderEndOffset ()
  {
    return this->backGirderEndOffset_.get ();
  }

  void PierDataType::
  backGirderEndOffset (const backGirderEndOffset_type& x)
  {
    this->backGirderEndOffset_.set (x);
  }

  const PierDataType::aheadGirderEndOffset_type& PierDataType::
  aheadGirderEndOffset () const
  {
    return this->aheadGirderEndOffset_.get ();
  }

  PierDataType::aheadGirderEndOffset_type& PierDataType::
  aheadGirderEndOffset ()
  {
    return this->aheadGirderEndOffset_.get ();
  }

  void PierDataType::
  aheadGirderEndOffset (const aheadGirderEndOffset_type& x)
  {
    this->aheadGirderEndOffset_.set (x);
  }


  // PrestressingStrandType
  // 

  const PrestressingStrandType::Name_type& PrestressingStrandType::
  Name () const
  {
    return this->Name_.get ();
  }

  PrestressingStrandType::Name_type& PrestressingStrandType::
  Name ()
  {
    return this->Name_.get ();
  }

  void PrestressingStrandType::
  Name (const Name_type& x)
  {
    this->Name_.set (x);
  }

  void PrestressingStrandType::
  Name (::std::auto_ptr< Name_type > x)
  {
    this->Name_.set (x);
  }

  const PrestressingStrandType::NominalDiameter_type& PrestressingStrandType::
  NominalDiameter () const
  {
    return this->NominalDiameter_.get ();
  }

  PrestressingStrandType::NominalDiameter_type& PrestressingStrandType::
  NominalDiameter ()
  {
    return this->NominalDiameter_.get ();
  }

  void PrestressingStrandType::
  NominalDiameter (const NominalDiameter_type& x)
  {
    this->NominalDiameter_.set (x);
  }


  // RebarMaterialType
  // 

  const RebarMaterialType::Grade_type& RebarMaterialType::
  Grade () const
  {
    return this->Grade_.get ();
  }

  RebarMaterialType::Grade_type& RebarMaterialType::
  Grade ()
  {
    return this->Grade_.get ();
  }

  void RebarMaterialType::
  Grade (const Grade_type& x)
  {
    this->Grade_.set (x);
  }

  void RebarMaterialType::
  Grade (::std::auto_ptr< Grade_type > x)
  {
    this->Grade_.set (x);
  }

  const RebarMaterialType::Type_type& RebarMaterialType::
  Type () const
  {
    return this->Type_.get ();
  }

  RebarMaterialType::Type_type& RebarMaterialType::
  Type ()
  {
    return this->Type_.get ();
  }

  void RebarMaterialType::
  Type (const Type_type& x)
  {
    this->Type_.set (x);
  }

  void RebarMaterialType::
  Type (::std::auto_ptr< Type_type > x)
  {
    this->Type_.set (x);
  }


  // RebarRowInstanceType
  // 

  const RebarRowInstanceType::BarStart_type& RebarRowInstanceType::
  BarStart () const
  {
    return this->BarStart_.get ();
  }

  RebarRowInstanceType::BarStart_type& RebarRowInstanceType::
  BarStart ()
  {
    return this->BarStart_.get ();
  }

  void RebarRowInstanceType::
  BarStart (const BarStart_type& x)
  {
    this->BarStart_.set (x);
  }

  const RebarRowInstanceType::BarEnd_type& RebarRowInstanceType::
  BarEnd () const
  {
    return this->BarEnd_.get ();
  }

  RebarRowInstanceType::BarEnd_type& RebarRowInstanceType::
  BarEnd ()
  {
    return this->BarEnd_.get ();
  }

  void RebarRowInstanceType::
  BarEnd (const BarEnd_type& x)
  {
    this->BarEnd_.set (x);
  }

  const RebarRowInstanceType::Face_type& RebarRowInstanceType::
  Face () const
  {
    return this->Face_.get ();
  }

  RebarRowInstanceType::Face_type& RebarRowInstanceType::
  Face ()
  {
    return this->Face_.get ();
  }

  void RebarRowInstanceType::
  Face (const Face_type& x)
  {
    this->Face_.set (x);
  }

  void RebarRowInstanceType::
  Face (::std::auto_ptr< Face_type > x)
  {
    this->Face_.set (x);
  }

  const RebarRowInstanceType::Cover_type& RebarRowInstanceType::
  Cover () const
  {
    return this->Cover_.get ();
  }

  RebarRowInstanceType::Cover_type& RebarRowInstanceType::
  Cover ()
  {
    return this->Cover_.get ();
  }

  void RebarRowInstanceType::
  Cover (const Cover_type& x)
  {
    this->Cover_.set (x);
  }

  const RebarRowInstanceType::NumberOfBars_type& RebarRowInstanceType::
  NumberOfBars () const
  {
    return this->NumberOfBars_.get ();
  }

  RebarRowInstanceType::NumberOfBars_type& RebarRowInstanceType::
  NumberOfBars ()
  {
    return this->NumberOfBars_.get ();
  }

  void RebarRowInstanceType::
  NumberOfBars (const NumberOfBars_type& x)
  {
    this->NumberOfBars_.set (x);
  }

  const RebarRowInstanceType::Spacing_type& RebarRowInstanceType::
  Spacing () const
  {
    return this->Spacing_.get ();
  }

  RebarRowInstanceType::Spacing_type& RebarRowInstanceType::
  Spacing ()
  {
    return this->Spacing_.get ();
  }

  void RebarRowInstanceType::
  Spacing (const Spacing_type& x)
  {
    this->Spacing_.set (x);
  }

  const RebarRowInstanceType::Size_type& RebarRowInstanceType::
  Size () const
  {
    return this->Size_.get ();
  }

  RebarRowInstanceType::Size_type& RebarRowInstanceType::
  Size ()
  {
    return this->Size_.get ();
  }

  void RebarRowInstanceType::
  Size (const Size_type& x)
  {
    this->Size_.set (x);
  }

  void RebarRowInstanceType::
  Size (::std::auto_ptr< Size_type > x)
  {
    this->Size_.set (x);
  }


  // StirrupZoneType
  // 

  const StirrupZoneType::StartLocation_type& StirrupZoneType::
  StartLocation () const
  {
    return this->StartLocation_.get ();
  }

  StirrupZoneType::StartLocation_type& StirrupZoneType::
  StartLocation ()
  {
    return this->StartLocation_.get ();
  }

  void StirrupZoneType::
  StartLocation (const StartLocation_type& x)
  {
    this->StartLocation_.set (x);
  }

  const StirrupZoneType::EndLocation_type& StirrupZoneType::
  EndLocation () const
  {
    return this->EndLocation_.get ();
  }

  StirrupZoneType::EndLocation_type& StirrupZoneType::
  EndLocation ()
  {
    return this->EndLocation_.get ();
  }

  void StirrupZoneType::
  EndLocation (const EndLocation_type& x)
  {
    this->EndLocation_.set (x);
  }

  const StirrupZoneType::BarSize_type& StirrupZoneType::
  BarSize () const
  {
    return this->BarSize_.get ();
  }

  StirrupZoneType::BarSize_type& StirrupZoneType::
  BarSize ()
  {
    return this->BarSize_.get ();
  }

  void StirrupZoneType::
  BarSize (const BarSize_type& x)
  {
    this->BarSize_.set (x);
  }

  void StirrupZoneType::
  BarSize (::std::auto_ptr< BarSize_type > x)
  {
    this->BarSize_.set (x);
  }

  const StirrupZoneType::BarSpacing_type& StirrupZoneType::
  BarSpacing () const
  {
    return this->BarSpacing_.get ();
  }

  StirrupZoneType::BarSpacing_type& StirrupZoneType::
  BarSpacing ()
  {
    return this->BarSpacing_.get ();
  }

  void StirrupZoneType::
  BarSpacing (const BarSpacing_type& x)
  {
    this->BarSpacing_.set (x);
  }

  const StirrupZoneType::NumVerticalLegs_type& StirrupZoneType::
  NumVerticalLegs () const
  {
    return this->NumVerticalLegs_.get ();
  }

  StirrupZoneType::NumVerticalLegs_type& StirrupZoneType::
  NumVerticalLegs ()
  {
    return this->NumVerticalLegs_.get ();
  }

  void StirrupZoneType::
  NumVerticalLegs (const NumVerticalLegs_type& x)
  {
    this->NumVerticalLegs_.set (x);
  }

  const StirrupZoneType::NumLegsExtendedIntoDeck_type& StirrupZoneType::
  NumLegsExtendedIntoDeck () const
  {
    return this->NumLegsExtendedIntoDeck_.get ();
  }

  StirrupZoneType::NumLegsExtendedIntoDeck_type& StirrupZoneType::
  NumLegsExtendedIntoDeck ()
  {
    return this->NumLegsExtendedIntoDeck_.get ();
  }

  void StirrupZoneType::
  NumLegsExtendedIntoDeck (const NumLegsExtendedIntoDeck_type& x)
  {
    this->NumLegsExtendedIntoDeck_.set (x);
  }

  const StirrupZoneType::ConfinementBarSize_type& StirrupZoneType::
  ConfinementBarSize () const
  {
    return this->ConfinementBarSize_.get ();
  }

  StirrupZoneType::ConfinementBarSize_type& StirrupZoneType::
  ConfinementBarSize ()
  {
    return this->ConfinementBarSize_.get ();
  }

  void StirrupZoneType::
  ConfinementBarSize (const ConfinementBarSize_type& x)
  {
    this->ConfinementBarSize_.set (x);
  }

  void StirrupZoneType::
  ConfinementBarSize (::std::auto_ptr< ConfinementBarSize_type > x)
  {
    this->ConfinementBarSize_.set (x);
  }


  // CamberResultType
  // 

  const CamberResultType::FractionalLocation_type& CamberResultType::
  FractionalLocation () const
  {
    return this->FractionalLocation_.get ();
  }

  CamberResultType::FractionalLocation_type& CamberResultType::
  FractionalLocation ()
  {
    return this->FractionalLocation_.get ();
  }

  void CamberResultType::
  FractionalLocation (const FractionalLocation_type& x)
  {
    this->FractionalLocation_.set (x);
  }

  const CamberResultType::Location_type& CamberResultType::
  Location () const
  {
    return this->Location_.get ();
  }

  CamberResultType::Location_type& CamberResultType::
  Location ()
  {
    return this->Location_.get ();
  }

  void CamberResultType::
  Location (const Location_type& x)
  {
    this->Location_.set (x);
  }

  const CamberResultType::LocationFromEndOfGirder_type& CamberResultType::
  LocationFromEndOfGirder () const
  {
    return this->LocationFromEndOfGirder_.get ();
  }

  CamberResultType::LocationFromEndOfGirder_type& CamberResultType::
  LocationFromEndOfGirder ()
  {
    return this->LocationFromEndOfGirder_.get ();
  }

  void CamberResultType::
  LocationFromEndOfGirder (const LocationFromEndOfGirder_type& x)
  {
    this->LocationFromEndOfGirder_.set (x);
  }

  const CamberResultType::TopOfDeckElevation_type& CamberResultType::
  TopOfDeckElevation () const
  {
    return this->TopOfDeckElevation_.get ();
  }

  CamberResultType::TopOfDeckElevation_type& CamberResultType::
  TopOfDeckElevation ()
  {
    return this->TopOfDeckElevation_.get ();
  }

  void CamberResultType::
  TopOfDeckElevation (const TopOfDeckElevation_type& x)
  {
    this->TopOfDeckElevation_.set (x);
  }

  const CamberResultType::TopOfGirderChordElevation_type& CamberResultType::
  TopOfGirderChordElevation () const
  {
    return this->TopOfGirderChordElevation_.get ();
  }

  CamberResultType::TopOfGirderChordElevation_type& CamberResultType::
  TopOfGirderChordElevation ()
  {
    return this->TopOfGirderChordElevation_.get ();
  }

  void CamberResultType::
  TopOfGirderChordElevation (const TopOfGirderChordElevation_type& x)
  {
    this->TopOfGirderChordElevation_.set (x);
  }

  const CamberResultType::TopOfGirderElevationPriorToSlabCasting_type& CamberResultType::
  TopOfGirderElevationPriorToSlabCasting () const
  {
    return this->TopOfGirderElevationPriorToSlabCasting_.get ();
  }

  CamberResultType::TopOfGirderElevationPriorToSlabCasting_type& CamberResultType::
  TopOfGirderElevationPriorToSlabCasting ()
  {
    return this->TopOfGirderElevationPriorToSlabCasting_.get ();
  }

  void CamberResultType::
  TopOfGirderElevationPriorToSlabCasting (const TopOfGirderElevationPriorToSlabCasting_type& x)
  {
    this->TopOfGirderElevationPriorToSlabCasting_.set (x);
  }

  const CamberResultType::TopOfGirderElevationAtFinal_type& CamberResultType::
  TopOfGirderElevationAtFinal () const
  {
    return this->TopOfGirderElevationAtFinal_.get ();
  }

  CamberResultType::TopOfGirderElevationAtFinal_type& CamberResultType::
  TopOfGirderElevationAtFinal ()
  {
    return this->TopOfGirderElevationAtFinal_.get ();
  }

  void CamberResultType::
  TopOfGirderElevationAtFinal (const TopOfGirderElevationAtFinal_type& x)
  {
    this->TopOfGirderElevationAtFinal_.set (x);
  }

  const CamberResultType::GirderCamberAtRelease_type& CamberResultType::
  GirderCamberAtRelease () const
  {
    return this->GirderCamberAtRelease_.get ();
  }

  CamberResultType::GirderCamberAtRelease_type& CamberResultType::
  GirderCamberAtRelease ()
  {
    return this->GirderCamberAtRelease_.get ();
  }

  void CamberResultType::
  GirderCamberAtRelease (const GirderCamberAtRelease_type& x)
  {
    this->GirderCamberAtRelease_.set (x);
  }

  const CamberResultType::GirderCamberPriorToDeckCasting_type& CamberResultType::
  GirderCamberPriorToDeckCasting () const
  {
    return this->GirderCamberPriorToDeckCasting_.get ();
  }

  CamberResultType::GirderCamberPriorToDeckCasting_type& CamberResultType::
  GirderCamberPriorToDeckCasting ()
  {
    return this->GirderCamberPriorToDeckCasting_.get ();
  }

  void CamberResultType::
  GirderCamberPriorToDeckCasting (const GirderCamberPriorToDeckCasting_type& x)
  {
    this->GirderCamberPriorToDeckCasting_.set (x);
  }

  const CamberResultType::GirderCamberAtFinal_type& CamberResultType::
  GirderCamberAtFinal () const
  {
    return this->GirderCamberAtFinal_.get ();
  }

  CamberResultType::GirderCamberAtFinal_type& CamberResultType::
  GirderCamberAtFinal ()
  {
    return this->GirderCamberAtFinal_.get ();
  }

  void CamberResultType::
  GirderCamberAtFinal (const GirderCamberAtFinal_type& x)
  {
    this->GirderCamberAtFinal_.set (x);
  }


  // GirderDataType
  // 

  const GirderDataType::GirderKey_type& GirderDataType::
  GirderKey () const
  {
    return this->GirderKey_.get ();
  }

  GirderDataType::GirderKey_type& GirderDataType::
  GirderKey ()
  {
    return this->GirderKey_.get ();
  }

  void GirderDataType::
  GirderKey (const GirderKey_type& x)
  {
    this->GirderKey_.set (x);
  }

  void GirderDataType::
  GirderKey (::std::auto_ptr< GirderKey_type > x)
  {
    this->GirderKey_.set (x);
  }

  const GirderDataType::GirderType_type& GirderDataType::
  GirderType () const
  {
    return this->GirderType_.get ();
  }

  GirderDataType::GirderType_type& GirderDataType::
  GirderType ()
  {
    return this->GirderType_.get ();
  }

  void GirderDataType::
  GirderType (const GirderType_type& x)
  {
    this->GirderType_.set (x);
  }

  void GirderDataType::
  GirderType (::std::auto_ptr< GirderType_type > x)
  {
    this->GirderType_.set (x);
  }

  const GirderDataType::SectionDimensions_sequence& GirderDataType::
  SectionDimensions () const
  {
    return this->SectionDimensions_;
  }

  GirderDataType::SectionDimensions_sequence& GirderDataType::
  SectionDimensions ()
  {
    return this->SectionDimensions_;
  }

  void GirderDataType::
  SectionDimensions (const SectionDimensions_sequence& s)
  {
    this->SectionDimensions_ = s;
  }

  const GirderDataType::Fci_type& GirderDataType::
  Fci () const
  {
    return this->Fci_.get ();
  }

  GirderDataType::Fci_type& GirderDataType::
  Fci ()
  {
    return this->Fci_.get ();
  }

  void GirderDataType::
  Fci (const Fci_type& x)
  {
    this->Fci_.set (x);
  }

  const GirderDataType::Fc_type& GirderDataType::
  Fc () const
  {
    return this->Fc_.get ();
  }

  GirderDataType::Fc_type& GirderDataType::
  Fc ()
  {
    return this->Fc_.get ();
  }

  void GirderDataType::
  Fc (const Fc_type& x)
  {
    this->Fc_.set (x);
  }

  const GirderDataType::Eci_type& GirderDataType::
  Eci () const
  {
    return this->Eci_.get ();
  }

  GirderDataType::Eci_type& GirderDataType::
  Eci ()
  {
    return this->Eci_.get ();
  }

  void GirderDataType::
  Eci (const Eci_type& x)
  {
    this->Eci_.set (x);
  }

  const GirderDataType::Ec_type& GirderDataType::
  Ec () const
  {
    return this->Ec_.get ();
  }

  GirderDataType::Ec_type& GirderDataType::
  Ec ()
  {
    return this->Ec_.get ();
  }

  void GirderDataType::
  Ec (const Ec_type& x)
  {
    this->Ec_.set (x);
  }

  const GirderDataType::GirderLength_type& GirderDataType::
  GirderLength () const
  {
    return this->GirderLength_.get ();
  }

  GirderDataType::GirderLength_type& GirderDataType::
  GirderLength ()
  {
    return this->GirderLength_.get ();
  }

  void GirderDataType::
  GirderLength (const GirderLength_type& x)
  {
    this->GirderLength_.set (x);
  }

  const GirderDataType::SpacingLeftStart_type& GirderDataType::
  SpacingLeftStart () const
  {
    return this->SpacingLeftStart_.get ();
  }

  GirderDataType::SpacingLeftStart_type& GirderDataType::
  SpacingLeftStart ()
  {
    return this->SpacingLeftStart_.get ();
  }

  void GirderDataType::
  SpacingLeftStart (const SpacingLeftStart_type& x)
  {
    this->SpacingLeftStart_.set (x);
  }

  const GirderDataType::SpacingRightStart_type& GirderDataType::
  SpacingRightStart () const
  {
    return this->SpacingRightStart_.get ();
  }

  GirderDataType::SpacingRightStart_type& GirderDataType::
  SpacingRightStart ()
  {
    return this->SpacingRightStart_.get ();
  }

  void GirderDataType::
  SpacingRightStart (const SpacingRightStart_type& x)
  {
    this->SpacingRightStart_.set (x);
  }

  const GirderDataType::SpacingLeftEnd_type& GirderDataType::
  SpacingLeftEnd () const
  {
    return this->SpacingLeftEnd_.get ();
  }

  GirderDataType::SpacingLeftEnd_type& GirderDataType::
  SpacingLeftEnd ()
  {
    return this->SpacingLeftEnd_.get ();
  }

  void GirderDataType::
  SpacingLeftEnd (const SpacingLeftEnd_type& x)
  {
    this->SpacingLeftEnd_.set (x);
  }

  const GirderDataType::SpacingRightEnd_type& GirderDataType::
  SpacingRightEnd () const
  {
    return this->SpacingRightEnd_.get ();
  }

  GirderDataType::SpacingRightEnd_type& GirderDataType::
  SpacingRightEnd ()
  {
    return this->SpacingRightEnd_.get ();
  }

  void GirderDataType::
  SpacingRightEnd (const SpacingRightEnd_type& x)
  {
    this->SpacingRightEnd_.set (x);
  }

  const GirderDataType::NumberOfHarpingPoints_type& GirderDataType::
  NumberOfHarpingPoints () const
  {
    return this->NumberOfHarpingPoints_.get ();
  }

  GirderDataType::NumberOfHarpingPoints_type& GirderDataType::
  NumberOfHarpingPoints ()
  {
    return this->NumberOfHarpingPoints_.get ();
  }

  void GirderDataType::
  NumberOfHarpingPoints (const NumberOfHarpingPoints_type& x)
  {
    this->NumberOfHarpingPoints_.set (x);
  }

  void GirderDataType::
  NumberOfHarpingPoints (::std::auto_ptr< NumberOfHarpingPoints_type > x)
  {
    this->NumberOfHarpingPoints_.set (x);
  }

  const GirderDataType::HarpingPoints_sequence& GirderDataType::
  HarpingPoints () const
  {
    return this->HarpingPoints_;
  }

  GirderDataType::HarpingPoints_sequence& GirderDataType::
  HarpingPoints ()
  {
    return this->HarpingPoints_;
  }

  void GirderDataType::
  HarpingPoints (const HarpingPoints_sequence& s)
  {
    this->HarpingPoints_ = s;
  }

  const GirderDataType::LiftingLocation_type& GirderDataType::
  LiftingLocation () const
  {
    return this->LiftingLocation_.get ();
  }

  GirderDataType::LiftingLocation_type& GirderDataType::
  LiftingLocation ()
  {
    return this->LiftingLocation_.get ();
  }

  void GirderDataType::
  LiftingLocation (const LiftingLocation_type& x)
  {
    this->LiftingLocation_.set (x);
  }

  const GirderDataType::LeadingHaulingLocation_type& GirderDataType::
  LeadingHaulingLocation () const
  {
    return this->LeadingHaulingLocation_.get ();
  }

  GirderDataType::LeadingHaulingLocation_type& GirderDataType::
  LeadingHaulingLocation ()
  {
    return this->LeadingHaulingLocation_.get ();
  }

  void GirderDataType::
  LeadingHaulingLocation (const LeadingHaulingLocation_type& x)
  {
    this->LeadingHaulingLocation_.set (x);
  }

  const GirderDataType::TrailingHaulingLocation_type& GirderDataType::
  TrailingHaulingLocation () const
  {
    return this->TrailingHaulingLocation_.get ();
  }

  GirderDataType::TrailingHaulingLocation_type& GirderDataType::
  TrailingHaulingLocation ()
  {
    return this->TrailingHaulingLocation_.get ();
  }

  void GirderDataType::
  TrailingHaulingLocation (const TrailingHaulingLocation_type& x)
  {
    this->TrailingHaulingLocation_.set (x);
  }

  const GirderDataType::StartADimension_type& GirderDataType::
  StartADimension () const
  {
    return this->StartADimension_.get ();
  }

  GirderDataType::StartADimension_type& GirderDataType::
  StartADimension ()
  {
    return this->StartADimension_.get ();
  }

  void GirderDataType::
  StartADimension (const StartADimension_type& x)
  {
    this->StartADimension_.set (x);
  }

  const GirderDataType::EndADimension_type& GirderDataType::
  EndADimension () const
  {
    return this->EndADimension_.get ();
  }

  GirderDataType::EndADimension_type& GirderDataType::
  EndADimension ()
  {
    return this->EndADimension_.get ();
  }

  void GirderDataType::
  EndADimension (const EndADimension_type& x)
  {
    this->EndADimension_.set (x);
  }

  const GirderDataType::GirderHaunchVolume_type& GirderDataType::
  GirderHaunchVolume () const
  {
    return this->GirderHaunchVolume_.get ();
  }

  GirderDataType::GirderHaunchVolume_type& GirderDataType::
  GirderHaunchVolume ()
  {
    return this->GirderHaunchVolume_.get ();
  }

  void GirderDataType::
  GirderHaunchVolume (const GirderHaunchVolume_type& x)
  {
    this->GirderHaunchVolume_.set (x);
  }

  const GirderDataType::IsPrismatic_type& GirderDataType::
  IsPrismatic () const
  {
    return this->IsPrismatic_.get ();
  }

  GirderDataType::IsPrismatic_type& GirderDataType::
  IsPrismatic ()
  {
    return this->IsPrismatic_.get ();
  }

  void GirderDataType::
  IsPrismatic (const IsPrismatic_type& x)
  {
    this->IsPrismatic_.set (x);
  }

  const GirderDataType::Area_type& GirderDataType::
  Area () const
  {
    return this->Area_.get ();
  }

  GirderDataType::Area_type& GirderDataType::
  Area ()
  {
    return this->Area_.get ();
  }

  void GirderDataType::
  Area (const Area_type& x)
  {
    this->Area_.set (x);
  }

  const GirderDataType::Ix_type& GirderDataType::
  Ix () const
  {
    return this->Ix_.get ();
  }

  GirderDataType::Ix_type& GirderDataType::
  Ix ()
  {
    return this->Ix_.get ();
  }

  void GirderDataType::
  Ix (const Ix_type& x)
  {
    this->Ix_.set (x);
  }

  const GirderDataType::Iy_type& GirderDataType::
  Iy () const
  {
    return this->Iy_.get ();
  }

  GirderDataType::Iy_type& GirderDataType::
  Iy ()
  {
    return this->Iy_.get ();
  }

  void GirderDataType::
  Iy (const Iy_type& x)
  {
    this->Iy_.set (x);
  }

  const GirderDataType::d_type& GirderDataType::
  d () const
  {
    return this->d_.get ();
  }

  GirderDataType::d_type& GirderDataType::
  d ()
  {
    return this->d_.get ();
  }

  void GirderDataType::
  d (const d_type& x)
  {
    this->d_.set (x);
  }

  const GirderDataType::Yt_type& GirderDataType::
  Yt () const
  {
    return this->Yt_.get ();
  }

  GirderDataType::Yt_type& GirderDataType::
  Yt ()
  {
    return this->Yt_.get ();
  }

  void GirderDataType::
  Yt (const Yt_type& x)
  {
    this->Yt_.set (x);
  }

  const GirderDataType::Yb_type& GirderDataType::
  Yb () const
  {
    return this->Yb_.get ();
  }

  GirderDataType::Yb_type& GirderDataType::
  Yb ()
  {
    return this->Yb_.get ();
  }

  void GirderDataType::
  Yb (const Yb_type& x)
  {
    this->Yb_.set (x);
  }

  const GirderDataType::St_type& GirderDataType::
  St () const
  {
    return this->St_.get ();
  }

  GirderDataType::St_type& GirderDataType::
  St ()
  {
    return this->St_.get ();
  }

  void GirderDataType::
  St (const St_type& x)
  {
    this->St_.set (x);
  }

  const GirderDataType::Sb_type& GirderDataType::
  Sb () const
  {
    return this->Sb_.get ();
  }

  GirderDataType::Sb_type& GirderDataType::
  Sb ()
  {
    return this->Sb_.get ();
  }

  void GirderDataType::
  Sb (const Sb_type& x)
  {
    this->Sb_.set (x);
  }

  const GirderDataType::P_type& GirderDataType::
  P () const
  {
    return this->P_.get ();
  }

  GirderDataType::P_type& GirderDataType::
  P ()
  {
    return this->P_.get ();
  }

  void GirderDataType::
  P (const P_type& x)
  {
    this->P_.set (x);
  }

  const GirderDataType::W_type& GirderDataType::
  W () const
  {
    return this->W_.get ();
  }

  GirderDataType::W_type& GirderDataType::
  W ()
  {
    return this->W_.get ();
  }

  void GirderDataType::
  W (const W_type& x)
  {
    this->W_.set (x);
  }

  const GirderDataType::Wtotal_type& GirderDataType::
  Wtotal () const
  {
    return this->Wtotal_.get ();
  }

  GirderDataType::Wtotal_type& GirderDataType::
  Wtotal ()
  {
    return this->Wtotal_.get ();
  }

  void GirderDataType::
  Wtotal (const Wtotal_type& x)
  {
    this->Wtotal_.set (x);
  }

  const GirderDataType::Area_c_type& GirderDataType::
  Area_c () const
  {
    return this->Area_c_.get ();
  }

  GirderDataType::Area_c_type& GirderDataType::
  Area_c ()
  {
    return this->Area_c_.get ();
  }

  void GirderDataType::
  Area_c (const Area_c_type& x)
  {
    this->Area_c_.set (x);
  }

  const GirderDataType::Ix_c_type& GirderDataType::
  Ix_c () const
  {
    return this->Ix_c_.get ();
  }

  GirderDataType::Ix_c_type& GirderDataType::
  Ix_c ()
  {
    return this->Ix_c_.get ();
  }

  void GirderDataType::
  Ix_c (const Ix_c_type& x)
  {
    this->Ix_c_.set (x);
  }

  const GirderDataType::Iy_c_type& GirderDataType::
  Iy_c () const
  {
    return this->Iy_c_.get ();
  }

  GirderDataType::Iy_c_type& GirderDataType::
  Iy_c ()
  {
    return this->Iy_c_.get ();
  }

  void GirderDataType::
  Iy_c (const Iy_c_type& x)
  {
    this->Iy_c_.set (x);
  }

  const GirderDataType::d_c_type& GirderDataType::
  d_c () const
  {
    return this->d_c_.get ();
  }

  GirderDataType::d_c_type& GirderDataType::
  d_c ()
  {
    return this->d_c_.get ();
  }

  void GirderDataType::
  d_c (const d_c_type& x)
  {
    this->d_c_.set (x);
  }

  const GirderDataType::Yt_c_type& GirderDataType::
  Yt_c () const
  {
    return this->Yt_c_.get ();
  }

  GirderDataType::Yt_c_type& GirderDataType::
  Yt_c ()
  {
    return this->Yt_c_.get ();
  }

  void GirderDataType::
  Yt_c (const Yt_c_type& x)
  {
    this->Yt_c_.set (x);
  }

  const GirderDataType::Yb_c_type& GirderDataType::
  Yb_c () const
  {
    return this->Yb_c_.get ();
  }

  GirderDataType::Yb_c_type& GirderDataType::
  Yb_c ()
  {
    return this->Yb_c_.get ();
  }

  void GirderDataType::
  Yb_c (const Yb_c_type& x)
  {
    this->Yb_c_.set (x);
  }

  const GirderDataType::St_c_type& GirderDataType::
  St_c () const
  {
    return this->St_c_.get ();
  }

  GirderDataType::St_c_type& GirderDataType::
  St_c ()
  {
    return this->St_c_.get ();
  }

  void GirderDataType::
  St_c (const St_c_type& x)
  {
    this->St_c_.set (x);
  }

  const GirderDataType::Sb_c_type& GirderDataType::
  Sb_c () const
  {
    return this->Sb_c_.get ();
  }

  GirderDataType::Sb_c_type& GirderDataType::
  Sb_c ()
  {
    return this->Sb_c_.get ();
  }

  void GirderDataType::
  Sb_c (const Sb_c_type& x)
  {
    this->Sb_c_.set (x);
  }

  const GirderDataType::StrandEccentricityAtEnds_type& GirderDataType::
  StrandEccentricityAtEnds () const
  {
    return this->StrandEccentricityAtEnds_.get ();
  }

  GirderDataType::StrandEccentricityAtEnds_type& GirderDataType::
  StrandEccentricityAtEnds ()
  {
    return this->StrandEccentricityAtEnds_.get ();
  }

  void GirderDataType::
  StrandEccentricityAtEnds (const StrandEccentricityAtEnds_type& x)
  {
    this->StrandEccentricityAtEnds_.set (x);
  }

  const GirderDataType::StrandEccentricityAtHPs_type& GirderDataType::
  StrandEccentricityAtHPs () const
  {
    return this->StrandEccentricityAtHPs_.get ();
  }

  GirderDataType::StrandEccentricityAtHPs_type& GirderDataType::
  StrandEccentricityAtHPs ()
  {
    return this->StrandEccentricityAtHPs_.get ();
  }

  void GirderDataType::
  StrandEccentricityAtHPs (const StrandEccentricityAtHPs_type& x)
  {
    this->StrandEccentricityAtHPs_.set (x);
  }

  const GirderDataType::PrestressingStrandMaterial_type& GirderDataType::
  PrestressingStrandMaterial () const
  {
    return this->PrestressingStrandMaterial_.get ();
  }

  GirderDataType::PrestressingStrandMaterial_type& GirderDataType::
  PrestressingStrandMaterial ()
  {
    return this->PrestressingStrandMaterial_.get ();
  }

  void GirderDataType::
  PrestressingStrandMaterial (const PrestressingStrandMaterial_type& x)
  {
    this->PrestressingStrandMaterial_.set (x);
  }

  void GirderDataType::
  PrestressingStrandMaterial (::std::auto_ptr< PrestressingStrandMaterial_type > x)
  {
    this->PrestressingStrandMaterial_.set (x);
  }

  const GirderDataType::NumberOfStraightStrands_type& GirderDataType::
  NumberOfStraightStrands () const
  {
    return this->NumberOfStraightStrands_.get ();
  }

  GirderDataType::NumberOfStraightStrands_type& GirderDataType::
  NumberOfStraightStrands ()
  {
    return this->NumberOfStraightStrands_.get ();
  }

  void GirderDataType::
  NumberOfStraightStrands (const NumberOfStraightStrands_type& x)
  {
    this->NumberOfStraightStrands_.set (x);
  }

  const GirderDataType::StraightStrandCoordinates_sequence& GirderDataType::
  StraightStrandCoordinates () const
  {
    return this->StraightStrandCoordinates_;
  }

  GirderDataType::StraightStrandCoordinates_sequence& GirderDataType::
  StraightStrandCoordinates ()
  {
    return this->StraightStrandCoordinates_;
  }

  void GirderDataType::
  StraightStrandCoordinates (const StraightStrandCoordinates_sequence& s)
  {
    this->StraightStrandCoordinates_ = s;
  }

  const GirderDataType::NumberOfDebondedStraightStrands_type& GirderDataType::
  NumberOfDebondedStraightStrands () const
  {
    return this->NumberOfDebondedStraightStrands_.get ();
  }

  GirderDataType::NumberOfDebondedStraightStrands_type& GirderDataType::
  NumberOfDebondedStraightStrands ()
  {
    return this->NumberOfDebondedStraightStrands_.get ();
  }

  void GirderDataType::
  NumberOfDebondedStraightStrands (const NumberOfDebondedStraightStrands_type& x)
  {
    this->NumberOfDebondedStraightStrands_.set (x);
  }

  const GirderDataType::StraightStrandDebonding_sequence& GirderDataType::
  StraightStrandDebonding () const
  {
    return this->StraightStrandDebonding_;
  }

  GirderDataType::StraightStrandDebonding_sequence& GirderDataType::
  StraightStrandDebonding ()
  {
    return this->StraightStrandDebonding_;
  }

  void GirderDataType::
  StraightStrandDebonding (const StraightStrandDebonding_sequence& s)
  {
    this->StraightStrandDebonding_ = s;
  }

  const GirderDataType::NumberOfExtendedStraightStrands_type& GirderDataType::
  NumberOfExtendedStraightStrands () const
  {
    return this->NumberOfExtendedStraightStrands_.get ();
  }

  GirderDataType::NumberOfExtendedStraightStrands_type& GirderDataType::
  NumberOfExtendedStraightStrands ()
  {
    return this->NumberOfExtendedStraightStrands_.get ();
  }

  void GirderDataType::
  NumberOfExtendedStraightStrands (const NumberOfExtendedStraightStrands_type& x)
  {
    this->NumberOfExtendedStraightStrands_.set (x);
  }

  const GirderDataType::StraightStrandExtensions_sequence& GirderDataType::
  StraightStrandExtensions () const
  {
    return this->StraightStrandExtensions_;
  }

  GirderDataType::StraightStrandExtensions_sequence& GirderDataType::
  StraightStrandExtensions ()
  {
    return this->StraightStrandExtensions_;
  }

  void GirderDataType::
  StraightStrandExtensions (const StraightStrandExtensions_sequence& s)
  {
    this->StraightStrandExtensions_ = s;
  }

  const GirderDataType::NumberOfHarpedStrands_type& GirderDataType::
  NumberOfHarpedStrands () const
  {
    return this->NumberOfHarpedStrands_.get ();
  }

  GirderDataType::NumberOfHarpedStrands_type& GirderDataType::
  NumberOfHarpedStrands ()
  {
    return this->NumberOfHarpedStrands_.get ();
  }

  void GirderDataType::
  NumberOfHarpedStrands (const NumberOfHarpedStrands_type& x)
  {
    this->NumberOfHarpedStrands_.set (x);
  }

  const GirderDataType::HarpedStrandCoordinatesAtEnds_sequence& GirderDataType::
  HarpedStrandCoordinatesAtEnds () const
  {
    return this->HarpedStrandCoordinatesAtEnds_;
  }

  GirderDataType::HarpedStrandCoordinatesAtEnds_sequence& GirderDataType::
  HarpedStrandCoordinatesAtEnds ()
  {
    return this->HarpedStrandCoordinatesAtEnds_;
  }

  void GirderDataType::
  HarpedStrandCoordinatesAtEnds (const HarpedStrandCoordinatesAtEnds_sequence& s)
  {
    this->HarpedStrandCoordinatesAtEnds_ = s;
  }

  const GirderDataType::HarpedStrandCoordinatesAtHP_sequence& GirderDataType::
  HarpedStrandCoordinatesAtHP () const
  {
    return this->HarpedStrandCoordinatesAtHP_;
  }

  GirderDataType::HarpedStrandCoordinatesAtHP_sequence& GirderDataType::
  HarpedStrandCoordinatesAtHP ()
  {
    return this->HarpedStrandCoordinatesAtHP_;
  }

  void GirderDataType::
  HarpedStrandCoordinatesAtHP (const HarpedStrandCoordinatesAtHP_sequence& s)
  {
    this->HarpedStrandCoordinatesAtHP_ = s;
  }

  const GirderDataType::NumberOfTemporaryStrands_type& GirderDataType::
  NumberOfTemporaryStrands () const
  {
    return this->NumberOfTemporaryStrands_.get ();
  }

  GirderDataType::NumberOfTemporaryStrands_type& GirderDataType::
  NumberOfTemporaryStrands ()
  {
    return this->NumberOfTemporaryStrands_.get ();
  }

  void GirderDataType::
  NumberOfTemporaryStrands (const NumberOfTemporaryStrands_type& x)
  {
    this->NumberOfTemporaryStrands_.set (x);
  }

  const GirderDataType::TemporaryStrandCoordinates_sequence& GirderDataType::
  TemporaryStrandCoordinates () const
  {
    return this->TemporaryStrandCoordinates_;
  }

  GirderDataType::TemporaryStrandCoordinates_sequence& GirderDataType::
  TemporaryStrandCoordinates ()
  {
    return this->TemporaryStrandCoordinates_;
  }

  void GirderDataType::
  TemporaryStrandCoordinates (const TemporaryStrandCoordinates_sequence& s)
  {
    this->TemporaryStrandCoordinates_ = s;
  }

  const GirderDataType::LongitudinalRebarMaterial_type& GirderDataType::
  LongitudinalRebarMaterial () const
  {
    return this->LongitudinalRebarMaterial_.get ();
  }

  GirderDataType::LongitudinalRebarMaterial_type& GirderDataType::
  LongitudinalRebarMaterial ()
  {
    return this->LongitudinalRebarMaterial_.get ();
  }

  void GirderDataType::
  LongitudinalRebarMaterial (const LongitudinalRebarMaterial_type& x)
  {
    this->LongitudinalRebarMaterial_.set (x);
  }

  void GirderDataType::
  LongitudinalRebarMaterial (::std::auto_ptr< LongitudinalRebarMaterial_type > x)
  {
    this->LongitudinalRebarMaterial_.set (x);
  }

  const GirderDataType::NumberOfLongitudinalRebarRows_type& GirderDataType::
  NumberOfLongitudinalRebarRows () const
  {
    return this->NumberOfLongitudinalRebarRows_.get ();
  }

  GirderDataType::NumberOfLongitudinalRebarRows_type& GirderDataType::
  NumberOfLongitudinalRebarRows ()
  {
    return this->NumberOfLongitudinalRebarRows_.get ();
  }

  void GirderDataType::
  NumberOfLongitudinalRebarRows (const NumberOfLongitudinalRebarRows_type& x)
  {
    this->NumberOfLongitudinalRebarRows_.set (x);
  }

  const GirderDataType::LongitudinalRebarRows_sequence& GirderDataType::
  LongitudinalRebarRows () const
  {
    return this->LongitudinalRebarRows_;
  }

  GirderDataType::LongitudinalRebarRows_sequence& GirderDataType::
  LongitudinalRebarRows ()
  {
    return this->LongitudinalRebarRows_;
  }

  void GirderDataType::
  LongitudinalRebarRows (const LongitudinalRebarRows_sequence& s)
  {
    this->LongitudinalRebarRows_ = s;
  }

  const GirderDataType::TransverseReinforcementMaterial_type& GirderDataType::
  TransverseReinforcementMaterial () const
  {
    return this->TransverseReinforcementMaterial_.get ();
  }

  GirderDataType::TransverseReinforcementMaterial_type& GirderDataType::
  TransverseReinforcementMaterial ()
  {
    return this->TransverseReinforcementMaterial_.get ();
  }

  void GirderDataType::
  TransverseReinforcementMaterial (const TransverseReinforcementMaterial_type& x)
  {
    this->TransverseReinforcementMaterial_.set (x);
  }

  void GirderDataType::
  TransverseReinforcementMaterial (::std::auto_ptr< TransverseReinforcementMaterial_type > x)
  {
    this->TransverseReinforcementMaterial_.set (x);
  }

  const GirderDataType::NumberOfStirrupZones_type& GirderDataType::
  NumberOfStirrupZones () const
  {
    return this->NumberOfStirrupZones_.get ();
  }

  GirderDataType::NumberOfStirrupZones_type& GirderDataType::
  NumberOfStirrupZones ()
  {
    return this->NumberOfStirrupZones_.get ();
  }

  void GirderDataType::
  NumberOfStirrupZones (const NumberOfStirrupZones_type& x)
  {
    this->NumberOfStirrupZones_.set (x);
  }

  const GirderDataType::StirrupZones_sequence& GirderDataType::
  StirrupZones () const
  {
    return this->StirrupZones_;
  }

  GirderDataType::StirrupZones_sequence& GirderDataType::
  StirrupZones ()
  {
    return this->StirrupZones_;
  }

  void GirderDataType::
  StirrupZones (const StirrupZones_sequence& s)
  {
    this->StirrupZones_ = s;
  }

  const GirderDataType::CamberResults_sequence& GirderDataType::
  CamberResults () const
  {
    return this->CamberResults_;
  }

  GirderDataType::CamberResults_sequence& GirderDataType::
  CamberResults ()
  {
    return this->CamberResults_;
  }

  void GirderDataType::
  CamberResults (const CamberResults_sequence& s)
  {
    this->CamberResults_ = s;
  }


  // BridgeDataType
  // 

  const BridgeDataType::LeftRailingType_type& BridgeDataType::
  LeftRailingType () const
  {
    return this->LeftRailingType_.get ();
  }

  BridgeDataType::LeftRailingType_type& BridgeDataType::
  LeftRailingType ()
  {
    return this->LeftRailingType_.get ();
  }

  void BridgeDataType::
  LeftRailingType (const LeftRailingType_type& x)
  {
    this->LeftRailingType_.set (x);
  }

  void BridgeDataType::
  LeftRailingType (::std::auto_ptr< LeftRailingType_type > x)
  {
    this->LeftRailingType_.set (x);
  }

  const BridgeDataType::RightRailingType_type& BridgeDataType::
  RightRailingType () const
  {
    return this->RightRailingType_.get ();
  }

  BridgeDataType::RightRailingType_type& BridgeDataType::
  RightRailingType ()
  {
    return this->RightRailingType_.get ();
  }

  void BridgeDataType::
  RightRailingType (const RightRailingType_type& x)
  {
    this->RightRailingType_.set (x);
  }

  void BridgeDataType::
  RightRailingType (::std::auto_ptr< RightRailingType_type > x)
  {
    this->RightRailingType_.set (x);
  }

  const BridgeDataType::SlabFc_type& BridgeDataType::
  SlabFc () const
  {
    return this->SlabFc_.get ();
  }

  BridgeDataType::SlabFc_type& BridgeDataType::
  SlabFc ()
  {
    return this->SlabFc_.get ();
  }

  void BridgeDataType::
  SlabFc (const SlabFc_type& x)
  {
    this->SlabFc_.set (x);
  }

  const BridgeDataType::SlabThickness_type& BridgeDataType::
  SlabThickness () const
  {
    return this->SlabThickness_.get ();
  }

  BridgeDataType::SlabThickness_type& BridgeDataType::
  SlabThickness ()
  {
    return this->SlabThickness_.get ();
  }

  void BridgeDataType::
  SlabThickness (const SlabThickness_type& x)
  {
    this->SlabThickness_.set (x);
  }

  const BridgeDataType::OverhangThickness_type& BridgeDataType::
  OverhangThickness () const
  {
    return this->OverhangThickness_.get ();
  }

  BridgeDataType::OverhangThickness_type& BridgeDataType::
  OverhangThickness ()
  {
    return this->OverhangThickness_.get ();
  }

  void BridgeDataType::
  OverhangThickness (const OverhangThickness_type& x)
  {
    this->OverhangThickness_.set (x);
  }

  const BridgeDataType::NumberOfSpans_type& BridgeDataType::
  NumberOfSpans () const
  {
    return this->NumberOfSpans_.get ();
  }

  BridgeDataType::NumberOfSpans_type& BridgeDataType::
  NumberOfSpans ()
  {
    return this->NumberOfSpans_.get ();
  }

  void BridgeDataType::
  NumberOfSpans (const NumberOfSpans_type& x)
  {
    this->NumberOfSpans_.set (x);
  }

  void BridgeDataType::
  NumberOfSpans (::std::auto_ptr< NumberOfSpans_type > x)
  {
    this->NumberOfSpans_.set (x);
  }

  const BridgeDataType::NumberOfGirdersPerSpan_sequence& BridgeDataType::
  NumberOfGirdersPerSpan () const
  {
    return this->NumberOfGirdersPerSpan_;
  }

  BridgeDataType::NumberOfGirdersPerSpan_sequence& BridgeDataType::
  NumberOfGirdersPerSpan ()
  {
    return this->NumberOfGirdersPerSpan_;
  }

  void BridgeDataType::
  NumberOfGirdersPerSpan (const NumberOfGirdersPerSpan_sequence& s)
  {
    this->NumberOfGirdersPerSpan_ = s;
  }

  const BridgeDataType::SpanLengths_sequence& BridgeDataType::
  SpanLengths () const
  {
    return this->SpanLengths_;
  }

  BridgeDataType::SpanLengths_sequence& BridgeDataType::
  SpanLengths ()
  {
    return this->SpanLengths_;
  }

  void BridgeDataType::
  SpanLengths (const SpanLengths_sequence& s)
  {
    this->SpanLengths_ = s;
  }

  const BridgeDataType::PierData_sequence& BridgeDataType::
  PierData () const
  {
    return this->PierData_;
  }

  BridgeDataType::PierData_sequence& BridgeDataType::
  PierData ()
  {
    return this->PierData_;
  }

  void BridgeDataType::
  PierData (const PierData_sequence& s)
  {
    this->PierData_ = s;
  }

  const BridgeDataType::GirderData_sequence& BridgeDataType::
  GirderData () const
  {
    return this->GirderData_;
  }

  BridgeDataType::GirderData_sequence& BridgeDataType::
  GirderData ()
  {
    return this->GirderData_;
  }

  void BridgeDataType::
  GirderData (const GirderData_sequence& s)
  {
    this->GirderData_ = s;
  }

  const BridgeDataType::HaunchVolumeForAllSelectedGirders_type& BridgeDataType::
  HaunchVolumeForAllSelectedGirders () const
  {
    return this->HaunchVolumeForAllSelectedGirders_.get ();
  }

  BridgeDataType::HaunchVolumeForAllSelectedGirders_type& BridgeDataType::
  HaunchVolumeForAllSelectedGirders ()
  {
    return this->HaunchVolumeForAllSelectedGirders_.get ();
  }

  void BridgeDataType::
  HaunchVolumeForAllSelectedGirders (const HaunchVolumeForAllSelectedGirders_type& x)
  {
    this->HaunchVolumeForAllSelectedGirders_.set (x);
  }

  const BridgeDataType::HaunchWeightForAllSelectedGirders_type& BridgeDataType::
  HaunchWeightForAllSelectedGirders () const
  {
    return this->HaunchWeightForAllSelectedGirders_.get ();
  }

  BridgeDataType::HaunchWeightForAllSelectedGirders_type& BridgeDataType::
  HaunchWeightForAllSelectedGirders ()
  {
    return this->HaunchWeightForAllSelectedGirders_.get ();
  }

  void BridgeDataType::
  HaunchWeightForAllSelectedGirders (const HaunchWeightForAllSelectedGirders_type& x)
  {
    this->HaunchWeightForAllSelectedGirders_.set (x);
  }


  // KDOTExport
  // 

  const KDOTExport::BridgeData_optional& KDOTExport::
  BridgeData () const
  {
    return this->BridgeData_;
  }

  KDOTExport::BridgeData_optional& KDOTExport::
  BridgeData ()
  {
    return this->BridgeData_;
  }

  void KDOTExport::
  BridgeData (const BridgeData_type& x)
  {
    this->BridgeData_.set (x);
  }

  void KDOTExport::
  BridgeData (const BridgeData_optional& x)
  {
    this->BridgeData_ = x;
  }

  void KDOTExport::
  BridgeData (::std::auto_ptr< BridgeData_type > x)
  {
    this->BridgeData_.set (x);
  }

  const KDOTExport::version_type& KDOTExport::
  version () const
  {
    return this->version_.get ();
  }

  KDOTExport::version_type KDOTExport::
  version_default_value ()
  {
    return version_type (1.0);
  }
}

#include <xsd/cxx/xml/dom/parsing-source.hxx>

namespace KDOT
{
  // IndexType1
  //

  IndexType1::
  IndexType1 ()
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::integer, wchar_t, ::xml_schema::simple_type > ()
  {
  }

  IndexType1::
  IndexType1 (const ::xml_schema::integer& _xsd_integer_base)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::integer, wchar_t, ::xml_schema::simple_type > (_xsd_integer_base)
  {
  }

  IndexType1::
  IndexType1 (const IndexType1& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::integer, wchar_t, ::xml_schema::simple_type > (x, f, c)
  {
  }

  IndexType1::
  IndexType1 (const xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::integer, wchar_t, ::xml_schema::simple_type > (e, f, c)
  {
  }

  IndexType1::
  IndexType1 (const xercesc::DOMAttr& a,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::integer, wchar_t, ::xml_schema::simple_type > (a, f, c)
  {
  }

  IndexType1::
  IndexType1 (const ::std::wstring& s,
              const xercesc::DOMElement* e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::integer, wchar_t, ::xml_schema::simple_type > (s, e, f, c)
  {
  }

  IndexType1* IndexType1::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class IndexType1 (*this, f, c);
  }

  IndexType1::
  ~IndexType1 ()
  {
  }

  // GirderKeyType
  //

  GirderKeyType::
  GirderKeyType ()
  : ::xml_schema::type (),
    SpanIndex_ (::xml_schema::flags (), this),
    GirderIndex_ (::xml_schema::flags (), this)
  {
  }

  GirderKeyType::
  GirderKeyType (const SpanIndex_type& SpanIndex,
                 const GirderIndex_type& GirderIndex)
  : ::xml_schema::type (),
    SpanIndex_ (SpanIndex, ::xml_schema::flags (), this),
    GirderIndex_ (GirderIndex, ::xml_schema::flags (), this)
  {
  }

  GirderKeyType::
  GirderKeyType (const GirderKeyType& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    SpanIndex_ (x.SpanIndex_, f, this),
    GirderIndex_ (x.GirderIndex_, f, this)
  {
  }

  GirderKeyType::
  GirderKeyType (const xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    SpanIndex_ (f, this),
    GirderIndex_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false);
      this->parse (p, f);
    }
  }

  void GirderKeyType::
  parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (i));

      // SpanIndex
      //
      if (n.name () == L"SpanIndex" && n.namespace_ ().empty ())
      {
        if (!SpanIndex_.present ())
        {
          this->SpanIndex_.set (SpanIndex_traits::create (i, f, this));
          continue;
        }
      }

      // GirderIndex
      //
      if (n.name () == L"GirderIndex" && n.namespace_ ().empty ())
      {
        if (!GirderIndex_.present ())
        {
          this->GirderIndex_.set (GirderIndex_traits::create (i, f, this));
          continue;
        }
      }

      break;
    }

    if (!SpanIndex_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< wchar_t > (
        L"SpanIndex",
        L"");
    }

    if (!GirderIndex_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< wchar_t > (
        L"GirderIndex",
        L"");
    }
  }

  GirderKeyType* GirderKeyType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class GirderKeyType (*this, f, c);
  }

  GirderKeyType::
  ~GirderKeyType ()
  {
  }

  // NamedDoubleType
  //

  NamedDoubleType::
  NamedDoubleType ()
  : ::xml_schema::type (),
    ParameterName_ (::xml_schema::flags (), this),
    Value_ (::xml_schema::flags (), this)
  {
  }

  NamedDoubleType::
  NamedDoubleType (const ParameterName_type& ParameterName,
                   const Value_type& Value)
  : ::xml_schema::type (),
    ParameterName_ (ParameterName, ::xml_schema::flags (), this),
    Value_ (Value, ::xml_schema::flags (), this)
  {
  }

  NamedDoubleType::
  NamedDoubleType (const NamedDoubleType& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    ParameterName_ (x.ParameterName_, f, this),
    Value_ (x.Value_, f, this)
  {
  }

  NamedDoubleType::
  NamedDoubleType (const xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    ParameterName_ (f, this),
    Value_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false);
      this->parse (p, f);
    }
  }

  void NamedDoubleType::
  parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (i));

      // ParameterName
      //
      if (n.name () == L"ParameterName" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< ParameterName_type > r (
          ParameterName_traits::create (i, f, this));

        if (!ParameterName_.present ())
        {
          this->ParameterName_.set (r);
          continue;
        }
      }

      // Value
      //
      if (n.name () == L"Value" && n.namespace_ ().empty ())
      {
        if (!Value_.present ())
        {
          this->Value_.set (Value_traits::create (i, f, this));
          continue;
        }
      }

      break;
    }

    if (!ParameterName_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< wchar_t > (
        L"ParameterName",
        L"");
    }

    if (!Value_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< wchar_t > (
        L"Value",
        L"");
    }
  }

  NamedDoubleType* NamedDoubleType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class NamedDoubleType (*this, f, c);
  }

  NamedDoubleType::
  ~NamedDoubleType ()
  {
  }

  // Point2DType
  //

  Point2DType::
  Point2DType ()
  : ::xml_schema::type (),
    X_ (::xml_schema::flags (), this),
    Y_ (::xml_schema::flags (), this)
  {
  }

  Point2DType::
  Point2DType (const X_type& X,
               const Y_type& Y)
  : ::xml_schema::type (),
    X_ (X, ::xml_schema::flags (), this),
    Y_ (Y, ::xml_schema::flags (), this)
  {
  }

  Point2DType::
  Point2DType (const Point2DType& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    X_ (x.X_, f, this),
    Y_ (x.Y_, f, this)
  {
  }

  Point2DType::
  Point2DType (const xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    X_ (f, this),
    Y_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false);
      this->parse (p, f);
    }
  }

  void Point2DType::
  parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (i));

      // X
      //
      if (n.name () == L"X" && n.namespace_ ().empty ())
      {
        if (!X_.present ())
        {
          this->X_.set (X_traits::create (i, f, this));
          continue;
        }
      }

      // Y
      //
      if (n.name () == L"Y" && n.namespace_ ().empty ())
      {
        if (!Y_.present ())
        {
          this->Y_.set (Y_traits::create (i, f, this));
          continue;
        }
      }

      break;
    }

    if (!X_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< wchar_t > (
        L"X",
        L"");
    }

    if (!Y_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< wchar_t > (
        L"Y",
        L"");
    }
  }

  Point2DType* Point2DType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Point2DType (*this, f, c);
  }

  Point2DType::
  ~Point2DType ()
  {
  }

  // DebondDataType
  //

  DebondDataType::
  DebondDataType ()
  : ::xml_schema::type (),
    StrandIndex_ (::xml_schema::flags (), this),
    StartDebondLength_ (::xml_schema::flags (), this),
    EndDebondLength_ (::xml_schema::flags (), this)
  {
  }

  DebondDataType::
  DebondDataType (const StrandIndex_type& StrandIndex,
                  const StartDebondLength_type& StartDebondLength,
                  const EndDebondLength_type& EndDebondLength)
  : ::xml_schema::type (),
    StrandIndex_ (StrandIndex, ::xml_schema::flags (), this),
    StartDebondLength_ (StartDebondLength, ::xml_schema::flags (), this),
    EndDebondLength_ (EndDebondLength, ::xml_schema::flags (), this)
  {
  }

  DebondDataType::
  DebondDataType (const DebondDataType& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    StrandIndex_ (x.StrandIndex_, f, this),
    StartDebondLength_ (x.StartDebondLength_, f, this),
    EndDebondLength_ (x.EndDebondLength_, f, this)
  {
  }

  DebondDataType::
  DebondDataType (const xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    StrandIndex_ (f, this),
    StartDebondLength_ (f, this),
    EndDebondLength_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false);
      this->parse (p, f);
    }
  }

  void DebondDataType::
  parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (i));

      // StrandIndex
      //
      if (n.name () == L"StrandIndex" && n.namespace_ ().empty ())
      {
        if (!StrandIndex_.present ())
        {
          this->StrandIndex_.set (StrandIndex_traits::create (i, f, this));
          continue;
        }
      }

      // StartDebondLength
      //
      if (n.name () == L"StartDebondLength" && n.namespace_ ().empty ())
      {
        if (!StartDebondLength_.present ())
        {
          this->StartDebondLength_.set (StartDebondLength_traits::create (i, f, this));
          continue;
        }
      }

      // EndDebondLength
      //
      if (n.name () == L"EndDebondLength" && n.namespace_ ().empty ())
      {
        if (!EndDebondLength_.present ())
        {
          this->EndDebondLength_.set (EndDebondLength_traits::create (i, f, this));
          continue;
        }
      }

      break;
    }

    if (!StrandIndex_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< wchar_t > (
        L"StrandIndex",
        L"");
    }

    if (!StartDebondLength_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< wchar_t > (
        L"StartDebondLength",
        L"");
    }

    if (!EndDebondLength_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< wchar_t > (
        L"EndDebondLength",
        L"");
    }
  }

  DebondDataType* DebondDataType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class DebondDataType (*this, f, c);
  }

  DebondDataType::
  ~DebondDataType ()
  {
  }

  // StrandExtensionDataType
  //

  StrandExtensionDataType::
  StrandExtensionDataType ()
  : ::xml_schema::type (),
    StrandIndex_ (::xml_schema::flags (), this),
    IsStartExtended_ (::xml_schema::flags (), this),
    IsEndExtended_ (::xml_schema::flags (), this)
  {
  }

  StrandExtensionDataType::
  StrandExtensionDataType (const StrandIndex_type& StrandIndex,
                           const IsStartExtended_type& IsStartExtended,
                           const IsEndExtended_type& IsEndExtended)
  : ::xml_schema::type (),
    StrandIndex_ (StrandIndex, ::xml_schema::flags (), this),
    IsStartExtended_ (IsStartExtended, ::xml_schema::flags (), this),
    IsEndExtended_ (IsEndExtended, ::xml_schema::flags (), this)
  {
  }

  StrandExtensionDataType::
  StrandExtensionDataType (const StrandExtensionDataType& x,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    StrandIndex_ (x.StrandIndex_, f, this),
    IsStartExtended_ (x.IsStartExtended_, f, this),
    IsEndExtended_ (x.IsEndExtended_, f, this)
  {
  }

  StrandExtensionDataType::
  StrandExtensionDataType (const xercesc::DOMElement& e,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    StrandIndex_ (f, this),
    IsStartExtended_ (f, this),
    IsEndExtended_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false);
      this->parse (p, f);
    }
  }

  void StrandExtensionDataType::
  parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (i));

      // StrandIndex
      //
      if (n.name () == L"StrandIndex" && n.namespace_ ().empty ())
      {
        if (!StrandIndex_.present ())
        {
          this->StrandIndex_.set (StrandIndex_traits::create (i, f, this));
          continue;
        }
      }

      // IsStartExtended
      //
      if (n.name () == L"IsStartExtended" && n.namespace_ ().empty ())
      {
        if (!IsStartExtended_.present ())
        {
          this->IsStartExtended_.set (IsStartExtended_traits::create (i, f, this));
          continue;
        }
      }

      // IsEndExtended
      //
      if (n.name () == L"IsEndExtended" && n.namespace_ ().empty ())
      {
        if (!IsEndExtended_.present ())
        {
          this->IsEndExtended_.set (IsEndExtended_traits::create (i, f, this));
          continue;
        }
      }

      break;
    }

    if (!StrandIndex_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< wchar_t > (
        L"StrandIndex",
        L"");
    }

    if (!IsStartExtended_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< wchar_t > (
        L"IsStartExtended",
        L"");
    }

    if (!IsEndExtended_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< wchar_t > (
        L"IsEndExtended",
        L"");
    }
  }

  StrandExtensionDataType* StrandExtensionDataType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class StrandExtensionDataType (*this, f, c);
  }

  StrandExtensionDataType::
  ~StrandExtensionDataType ()
  {
  }

  // HarpingPointDataType
  //

  HarpingPointDataType::
  HarpingPointDataType ()
  : ::xml_schema::type (),
    Location_ (::xml_schema::flags (), this),
    HoldDownForce_ (::xml_schema::flags (), this)
  {
  }

  HarpingPointDataType::
  HarpingPointDataType (const Location_type& Location,
                        const HoldDownForce_type& HoldDownForce)
  : ::xml_schema::type (),
    Location_ (Location, ::xml_schema::flags (), this),
    HoldDownForce_ (HoldDownForce, ::xml_schema::flags (), this)
  {
  }

  HarpingPointDataType::
  HarpingPointDataType (const HarpingPointDataType& x,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    Location_ (x.Location_, f, this),
    HoldDownForce_ (x.HoldDownForce_, f, this)
  {
  }

  HarpingPointDataType::
  HarpingPointDataType (const xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    Location_ (f, this),
    HoldDownForce_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false);
      this->parse (p, f);
    }
  }

  void HarpingPointDataType::
  parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (i));

      // Location
      //
      if (n.name () == L"Location" && n.namespace_ ().empty ())
      {
        if (!Location_.present ())
        {
          this->Location_.set (Location_traits::create (i, f, this));
          continue;
        }
      }

      // HoldDownForce
      //
      if (n.name () == L"HoldDownForce" && n.namespace_ ().empty ())
      {
        if (!HoldDownForce_.present ())
        {
          this->HoldDownForce_.set (HoldDownForce_traits::create (i, f, this));
          continue;
        }
      }

      break;
    }

    if (!Location_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< wchar_t > (
        L"Location",
        L"");
    }

    if (!HoldDownForce_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< wchar_t > (
        L"HoldDownForce",
        L"");
    }
  }

  HarpingPointDataType* HarpingPointDataType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class HarpingPointDataType (*this, f, c);
  }

  HarpingPointDataType::
  ~HarpingPointDataType ()
  {
  }

  // PierDataType
  //

  PierDataType::
  PierDataType ()
  : ::xml_schema::type (),
    Station_ (::xml_schema::flags (), this),
    Skew_ (::xml_schema::flags (), this),
    backGirderEndOffset_ (::xml_schema::flags (), this),
    aheadGirderEndOffset_ (::xml_schema::flags (), this)
  {
  }

  PierDataType::
  PierDataType (const Station_type& Station,
                const Skew_type& Skew,
                const backGirderEndOffset_type& backGirderEndOffset,
                const aheadGirderEndOffset_type& aheadGirderEndOffset)
  : ::xml_schema::type (),
    Station_ (Station, ::xml_schema::flags (), this),
    Skew_ (Skew, ::xml_schema::flags (), this),
    backGirderEndOffset_ (backGirderEndOffset, ::xml_schema::flags (), this),
    aheadGirderEndOffset_ (aheadGirderEndOffset, ::xml_schema::flags (), this)
  {
  }

  PierDataType::
  PierDataType (const PierDataType& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    Station_ (x.Station_, f, this),
    Skew_ (x.Skew_, f, this),
    backGirderEndOffset_ (x.backGirderEndOffset_, f, this),
    aheadGirderEndOffset_ (x.aheadGirderEndOffset_, f, this)
  {
  }

  PierDataType::
  PierDataType (const xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    Station_ (f, this),
    Skew_ (f, this),
    backGirderEndOffset_ (f, this),
    aheadGirderEndOffset_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false);
      this->parse (p, f);
    }
  }

  void PierDataType::
  parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (i));

      // Station
      //
      if (n.name () == L"Station" && n.namespace_ ().empty ())
      {
        if (!Station_.present ())
        {
          this->Station_.set (Station_traits::create (i, f, this));
          continue;
        }
      }

      // Skew
      //
      if (n.name () == L"Skew" && n.namespace_ ().empty ())
      {
        if (!Skew_.present ())
        {
          this->Skew_.set (Skew_traits::create (i, f, this));
          continue;
        }
      }

      // backGirderEndOffset
      //
      if (n.name () == L"backGirderEndOffset" && n.namespace_ ().empty ())
      {
        if (!backGirderEndOffset_.present ())
        {
          this->backGirderEndOffset_.set (backGirderEndOffset_traits::create (i, f, this));
          continue;
        }
      }

      // aheadGirderEndOffset
      //
      if (n.name () == L"aheadGirderEndOffset" && n.namespace_ ().empty ())
      {
        if (!aheadGirderEndOffset_.present ())
        {
          this->aheadGirderEndOffset_.set (aheadGirderEndOffset_traits::create (i, f, this));
          continue;
        }
      }

      break;
    }

    if (!Station_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< wchar_t > (
        L"Station",
        L"");
    }

    if (!Skew_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< wchar_t > (
        L"Skew",
        L"");
    }

    if (!backGirderEndOffset_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< wchar_t > (
        L"backGirderEndOffset",
        L"");
    }

    if (!aheadGirderEndOffset_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< wchar_t > (
        L"aheadGirderEndOffset",
        L"");
    }
  }

  PierDataType* PierDataType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class PierDataType (*this, f, c);
  }

  PierDataType::
  ~PierDataType ()
  {
  }

  // PrestressingStrandType
  //

  PrestressingStrandType::
  PrestressingStrandType ()
  : ::xml_schema::type (),
    Name_ (::xml_schema::flags (), this),
    NominalDiameter_ (::xml_schema::flags (), this)
  {
  }

  PrestressingStrandType::
  PrestressingStrandType (const Name_type& Name,
                          const NominalDiameter_type& NominalDiameter)
  : ::xml_schema::type (),
    Name_ (Name, ::xml_schema::flags (), this),
    NominalDiameter_ (NominalDiameter, ::xml_schema::flags (), this)
  {
  }

  PrestressingStrandType::
  PrestressingStrandType (const PrestressingStrandType& x,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    Name_ (x.Name_, f, this),
    NominalDiameter_ (x.NominalDiameter_, f, this)
  {
  }

  PrestressingStrandType::
  PrestressingStrandType (const xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    Name_ (f, this),
    NominalDiameter_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false);
      this->parse (p, f);
    }
  }

  void PrestressingStrandType::
  parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (i));

      // Name
      //
      if (n.name () == L"Name" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< Name_type > r (
          Name_traits::create (i, f, this));

        if (!Name_.present ())
        {
          this->Name_.set (r);
          continue;
        }
      }

      // NominalDiameter
      //
      if (n.name () == L"NominalDiameter" && n.namespace_ ().empty ())
      {
        if (!NominalDiameter_.present ())
        {
          this->NominalDiameter_.set (NominalDiameter_traits::create (i, f, this));
          continue;
        }
      }

      break;
    }

    if (!Name_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< wchar_t > (
        L"Name",
        L"");
    }

    if (!NominalDiameter_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< wchar_t > (
        L"NominalDiameter",
        L"");
    }
  }

  PrestressingStrandType* PrestressingStrandType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class PrestressingStrandType (*this, f, c);
  }

  PrestressingStrandType::
  ~PrestressingStrandType ()
  {
  }

  // RebarMaterialType
  //

  RebarMaterialType::
  RebarMaterialType ()
  : ::xml_schema::type (),
    Grade_ (::xml_schema::flags (), this),
    Type_ (::xml_schema::flags (), this)
  {
  }

  RebarMaterialType::
  RebarMaterialType (const Grade_type& Grade,
                     const Type_type& Type)
  : ::xml_schema::type (),
    Grade_ (Grade, ::xml_schema::flags (), this),
    Type_ (Type, ::xml_schema::flags (), this)
  {
  }

  RebarMaterialType::
  RebarMaterialType (const RebarMaterialType& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    Grade_ (x.Grade_, f, this),
    Type_ (x.Type_, f, this)
  {
  }

  RebarMaterialType::
  RebarMaterialType (const xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    Grade_ (f, this),
    Type_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false);
      this->parse (p, f);
    }
  }

  void RebarMaterialType::
  parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (i));

      // Grade
      //
      if (n.name () == L"Grade" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< Grade_type > r (
          Grade_traits::create (i, f, this));

        if (!Grade_.present ())
        {
          this->Grade_.set (r);
          continue;
        }
      }

      // Type
      //
      if (n.name () == L"Type" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< Type_type > r (
          Type_traits::create (i, f, this));

        if (!Type_.present ())
        {
          this->Type_.set (r);
          continue;
        }
      }

      break;
    }

    if (!Grade_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< wchar_t > (
        L"Grade",
        L"");
    }

    if (!Type_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< wchar_t > (
        L"Type",
        L"");
    }
  }

  RebarMaterialType* RebarMaterialType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class RebarMaterialType (*this, f, c);
  }

  RebarMaterialType::
  ~RebarMaterialType ()
  {
  }

  // RebarRowInstanceType
  //

  RebarRowInstanceType::
  RebarRowInstanceType ()
  : ::xml_schema::type (),
    BarStart_ (::xml_schema::flags (), this),
    BarEnd_ (::xml_schema::flags (), this),
    Face_ (::xml_schema::flags (), this),
    Cover_ (::xml_schema::flags (), this),
    NumberOfBars_ (::xml_schema::flags (), this),
    Spacing_ (::xml_schema::flags (), this),
    Size_ (::xml_schema::flags (), this)
  {
  }

  RebarRowInstanceType::
  RebarRowInstanceType (const BarStart_type& BarStart,
                        const BarEnd_type& BarEnd,
                        const Face_type& Face,
                        const Cover_type& Cover,
                        const NumberOfBars_type& NumberOfBars,
                        const Spacing_type& Spacing,
                        const Size_type& Size)
  : ::xml_schema::type (),
    BarStart_ (BarStart, ::xml_schema::flags (), this),
    BarEnd_ (BarEnd, ::xml_schema::flags (), this),
    Face_ (Face, ::xml_schema::flags (), this),
    Cover_ (Cover, ::xml_schema::flags (), this),
    NumberOfBars_ (NumberOfBars, ::xml_schema::flags (), this),
    Spacing_ (Spacing, ::xml_schema::flags (), this),
    Size_ (Size, ::xml_schema::flags (), this)
  {
  }

  RebarRowInstanceType::
  RebarRowInstanceType (const RebarRowInstanceType& x,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    BarStart_ (x.BarStart_, f, this),
    BarEnd_ (x.BarEnd_, f, this),
    Face_ (x.Face_, f, this),
    Cover_ (x.Cover_, f, this),
    NumberOfBars_ (x.NumberOfBars_, f, this),
    Spacing_ (x.Spacing_, f, this),
    Size_ (x.Size_, f, this)
  {
  }

  RebarRowInstanceType::
  RebarRowInstanceType (const xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    BarStart_ (f, this),
    BarEnd_ (f, this),
    Face_ (f, this),
    Cover_ (f, this),
    NumberOfBars_ (f, this),
    Spacing_ (f, this),
    Size_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false);
      this->parse (p, f);
    }
  }

  void RebarRowInstanceType::
  parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (i));

      // BarStart
      //
      if (n.name () == L"BarStart" && n.namespace_ ().empty ())
      {
        if (!BarStart_.present ())
        {
          this->BarStart_.set (BarStart_traits::create (i, f, this));
          continue;
        }
      }

      // BarEnd
      //
      if (n.name () == L"BarEnd" && n.namespace_ ().empty ())
      {
        if (!BarEnd_.present ())
        {
          this->BarEnd_.set (BarEnd_traits::create (i, f, this));
          continue;
        }
      }

      // Face
      //
      if (n.name () == L"Face" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< Face_type > r (
          Face_traits::create (i, f, this));

        if (!Face_.present ())
        {
          this->Face_.set (r);
          continue;
        }
      }

      // Cover
      //
      if (n.name () == L"Cover" && n.namespace_ ().empty ())
      {
        if (!Cover_.present ())
        {
          this->Cover_.set (Cover_traits::create (i, f, this));
          continue;
        }
      }

      // NumberOfBars
      //
      if (n.name () == L"NumberOfBars" && n.namespace_ ().empty ())
      {
        if (!NumberOfBars_.present ())
        {
          this->NumberOfBars_.set (NumberOfBars_traits::create (i, f, this));
          continue;
        }
      }

      // Spacing
      //
      if (n.name () == L"Spacing" && n.namespace_ ().empty ())
      {
        if (!Spacing_.present ())
        {
          this->Spacing_.set (Spacing_traits::create (i, f, this));
          continue;
        }
      }

      // Size
      //
      if (n.name () == L"Size" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< Size_type > r (
          Size_traits::create (i, f, this));

        if (!Size_.present ())
        {
          this->Size_.set (r);
          continue;
        }
      }

      break;
    }

    if (!BarStart_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< wchar_t > (
        L"BarStart",
        L"");
    }

    if (!BarEnd_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< wchar_t > (
        L"BarEnd",
        L"");
    }

    if (!Face_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< wchar_t > (
        L"Face",
        L"");
    }

    if (!Cover_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< wchar_t > (
        L"Cover",
        L"");
    }

    if (!NumberOfBars_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< wchar_t > (
        L"NumberOfBars",
        L"");
    }

    if (!Spacing_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< wchar_t > (
        L"Spacing",
        L"");
    }

    if (!Size_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< wchar_t > (
        L"Size",
        L"");
    }
  }

  RebarRowInstanceType* RebarRowInstanceType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class RebarRowInstanceType (*this, f, c);
  }

  RebarRowInstanceType::
  ~RebarRowInstanceType ()
  {
  }

  // StirrupZoneType
  //

  StirrupZoneType::
  StirrupZoneType ()
  : ::xml_schema::type (),
    StartLocation_ (::xml_schema::flags (), this),
    EndLocation_ (::xml_schema::flags (), this),
    BarSize_ (::xml_schema::flags (), this),
    BarSpacing_ (::xml_schema::flags (), this),
    NumVerticalLegs_ (::xml_schema::flags (), this),
    NumLegsExtendedIntoDeck_ (::xml_schema::flags (), this),
    ConfinementBarSize_ (::xml_schema::flags (), this)
  {
  }

  StirrupZoneType::
  StirrupZoneType (const StartLocation_type& StartLocation,
                   const EndLocation_type& EndLocation,
                   const BarSize_type& BarSize,
                   const BarSpacing_type& BarSpacing,
                   const NumVerticalLegs_type& NumVerticalLegs,
                   const NumLegsExtendedIntoDeck_type& NumLegsExtendedIntoDeck,
                   const ConfinementBarSize_type& ConfinementBarSize)
  : ::xml_schema::type (),
    StartLocation_ (StartLocation, ::xml_schema::flags (), this),
    EndLocation_ (EndLocation, ::xml_schema::flags (), this),
    BarSize_ (BarSize, ::xml_schema::flags (), this),
    BarSpacing_ (BarSpacing, ::xml_schema::flags (), this),
    NumVerticalLegs_ (NumVerticalLegs, ::xml_schema::flags (), this),
    NumLegsExtendedIntoDeck_ (NumLegsExtendedIntoDeck, ::xml_schema::flags (), this),
    ConfinementBarSize_ (ConfinementBarSize, ::xml_schema::flags (), this)
  {
  }

  StirrupZoneType::
  StirrupZoneType (const StirrupZoneType& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    StartLocation_ (x.StartLocation_, f, this),
    EndLocation_ (x.EndLocation_, f, this),
    BarSize_ (x.BarSize_, f, this),
    BarSpacing_ (x.BarSpacing_, f, this),
    NumVerticalLegs_ (x.NumVerticalLegs_, f, this),
    NumLegsExtendedIntoDeck_ (x.NumLegsExtendedIntoDeck_, f, this),
    ConfinementBarSize_ (x.ConfinementBarSize_, f, this)
  {
  }

  StirrupZoneType::
  StirrupZoneType (const xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    StartLocation_ (f, this),
    EndLocation_ (f, this),
    BarSize_ (f, this),
    BarSpacing_ (f, this),
    NumVerticalLegs_ (f, this),
    NumLegsExtendedIntoDeck_ (f, this),
    ConfinementBarSize_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false);
      this->parse (p, f);
    }
  }

  void StirrupZoneType::
  parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (i));

      // StartLocation
      //
      if (n.name () == L"StartLocation" && n.namespace_ ().empty ())
      {
        if (!StartLocation_.present ())
        {
          this->StartLocation_.set (StartLocation_traits::create (i, f, this));
          continue;
        }
      }

      // EndLocation
      //
      if (n.name () == L"EndLocation" && n.namespace_ ().empty ())
      {
        if (!EndLocation_.present ())
        {
          this->EndLocation_.set (EndLocation_traits::create (i, f, this));
          continue;
        }
      }

      // BarSize
      //
      if (n.name () == L"BarSize" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< BarSize_type > r (
          BarSize_traits::create (i, f, this));

        if (!BarSize_.present ())
        {
          this->BarSize_.set (r);
          continue;
        }
      }

      // BarSpacing
      //
      if (n.name () == L"BarSpacing" && n.namespace_ ().empty ())
      {
        if (!BarSpacing_.present ())
        {
          this->BarSpacing_.set (BarSpacing_traits::create (i, f, this));
          continue;
        }
      }

      // NumVerticalLegs
      //
      if (n.name () == L"NumVerticalLegs" && n.namespace_ ().empty ())
      {
        if (!NumVerticalLegs_.present ())
        {
          this->NumVerticalLegs_.set (NumVerticalLegs_traits::create (i, f, this));
          continue;
        }
      }

      // NumLegsExtendedIntoDeck
      //
      if (n.name () == L"NumLegsExtendedIntoDeck" && n.namespace_ ().empty ())
      {
        if (!NumLegsExtendedIntoDeck_.present ())
        {
          this->NumLegsExtendedIntoDeck_.set (NumLegsExtendedIntoDeck_traits::create (i, f, this));
          continue;
        }
      }

      // ConfinementBarSize
      //
      if (n.name () == L"ConfinementBarSize" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< ConfinementBarSize_type > r (
          ConfinementBarSize_traits::create (i, f, this));

        if (!ConfinementBarSize_.present ())
        {
          this->ConfinementBarSize_.set (r);
          continue;
        }
      }

      break;
    }

    if (!StartLocation_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< wchar_t > (
        L"StartLocation",
        L"");
    }

    if (!EndLocation_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< wchar_t > (
        L"EndLocation",
        L"");
    }

    if (!BarSize_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< wchar_t > (
        L"BarSize",
        L"");
    }

    if (!BarSpacing_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< wchar_t > (
        L"BarSpacing",
        L"");
    }

    if (!NumVerticalLegs_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< wchar_t > (
        L"NumVerticalLegs",
        L"");
    }

    if (!NumLegsExtendedIntoDeck_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< wchar_t > (
        L"NumLegsExtendedIntoDeck",
        L"");
    }

    if (!ConfinementBarSize_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< wchar_t > (
        L"ConfinementBarSize",
        L"");
    }
  }

  StirrupZoneType* StirrupZoneType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class StirrupZoneType (*this, f, c);
  }

  StirrupZoneType::
  ~StirrupZoneType ()
  {
  }

  // CamberResultType
  //

  CamberResultType::
  CamberResultType ()
  : ::xml_schema::type (),
    FractionalLocation_ (::xml_schema::flags (), this),
    Location_ (::xml_schema::flags (), this),
    LocationFromEndOfGirder_ (::xml_schema::flags (), this),
    TopOfDeckElevation_ (::xml_schema::flags (), this),
    TopOfGirderChordElevation_ (::xml_schema::flags (), this),
    TopOfGirderElevationPriorToSlabCasting_ (::xml_schema::flags (), this),
    TopOfGirderElevationAtFinal_ (::xml_schema::flags (), this),
    GirderCamberAtRelease_ (::xml_schema::flags (), this),
    GirderCamberPriorToDeckCasting_ (::xml_schema::flags (), this),
    GirderCamberAtFinal_ (::xml_schema::flags (), this)
  {
  }

  CamberResultType::
  CamberResultType (const FractionalLocation_type& FractionalLocation,
                    const Location_type& Location,
                    const LocationFromEndOfGirder_type& LocationFromEndOfGirder,
                    const TopOfDeckElevation_type& TopOfDeckElevation,
                    const TopOfGirderChordElevation_type& TopOfGirderChordElevation,
                    const TopOfGirderElevationPriorToSlabCasting_type& TopOfGirderElevationPriorToSlabCasting,
                    const TopOfGirderElevationAtFinal_type& TopOfGirderElevationAtFinal,
                    const GirderCamberAtRelease_type& GirderCamberAtRelease,
                    const GirderCamberPriorToDeckCasting_type& GirderCamberPriorToDeckCasting,
                    const GirderCamberAtFinal_type& GirderCamberAtFinal)
  : ::xml_schema::type (),
    FractionalLocation_ (FractionalLocation, ::xml_schema::flags (), this),
    Location_ (Location, ::xml_schema::flags (), this),
    LocationFromEndOfGirder_ (LocationFromEndOfGirder, ::xml_schema::flags (), this),
    TopOfDeckElevation_ (TopOfDeckElevation, ::xml_schema::flags (), this),
    TopOfGirderChordElevation_ (TopOfGirderChordElevation, ::xml_schema::flags (), this),
    TopOfGirderElevationPriorToSlabCasting_ (TopOfGirderElevationPriorToSlabCasting, ::xml_schema::flags (), this),
    TopOfGirderElevationAtFinal_ (TopOfGirderElevationAtFinal, ::xml_schema::flags (), this),
    GirderCamberAtRelease_ (GirderCamberAtRelease, ::xml_schema::flags (), this),
    GirderCamberPriorToDeckCasting_ (GirderCamberPriorToDeckCasting, ::xml_schema::flags (), this),
    GirderCamberAtFinal_ (GirderCamberAtFinal, ::xml_schema::flags (), this)
  {
  }

  CamberResultType::
  CamberResultType (const CamberResultType& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    FractionalLocation_ (x.FractionalLocation_, f, this),
    Location_ (x.Location_, f, this),
    LocationFromEndOfGirder_ (x.LocationFromEndOfGirder_, f, this),
    TopOfDeckElevation_ (x.TopOfDeckElevation_, f, this),
    TopOfGirderChordElevation_ (x.TopOfGirderChordElevation_, f, this),
    TopOfGirderElevationPriorToSlabCasting_ (x.TopOfGirderElevationPriorToSlabCasting_, f, this),
    TopOfGirderElevationAtFinal_ (x.TopOfGirderElevationAtFinal_, f, this),
    GirderCamberAtRelease_ (x.GirderCamberAtRelease_, f, this),
    GirderCamberPriorToDeckCasting_ (x.GirderCamberPriorToDeckCasting_, f, this),
    GirderCamberAtFinal_ (x.GirderCamberAtFinal_, f, this)
  {
  }

  CamberResultType::
  CamberResultType (const xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    FractionalLocation_ (f, this),
    Location_ (f, this),
    LocationFromEndOfGirder_ (f, this),
    TopOfDeckElevation_ (f, this),
    TopOfGirderChordElevation_ (f, this),
    TopOfGirderElevationPriorToSlabCasting_ (f, this),
    TopOfGirderElevationAtFinal_ (f, this),
    GirderCamberAtRelease_ (f, this),
    GirderCamberPriorToDeckCasting_ (f, this),
    GirderCamberAtFinal_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false);
      this->parse (p, f);
    }
  }

  void CamberResultType::
  parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (i));

      // FractionalLocation
      //
      if (n.name () == L"FractionalLocation" && n.namespace_ ().empty ())
      {
        if (!FractionalLocation_.present ())
        {
          this->FractionalLocation_.set (FractionalLocation_traits::create (i, f, this));
          continue;
        }
      }

      // Location
      //
      if (n.name () == L"Location" && n.namespace_ ().empty ())
      {
        if (!Location_.present ())
        {
          this->Location_.set (Location_traits::create (i, f, this));
          continue;
        }
      }

      // LocationFromEndOfGirder
      //
      if (n.name () == L"LocationFromEndOfGirder" && n.namespace_ ().empty ())
      {
        if (!LocationFromEndOfGirder_.present ())
        {
          this->LocationFromEndOfGirder_.set (LocationFromEndOfGirder_traits::create (i, f, this));
          continue;
        }
      }

      // TopOfDeckElevation
      //
      if (n.name () == L"TopOfDeckElevation" && n.namespace_ ().empty ())
      {
        if (!TopOfDeckElevation_.present ())
        {
          this->TopOfDeckElevation_.set (TopOfDeckElevation_traits::create (i, f, this));
          continue;
        }
      }

      // TopOfGirderChordElevation
      //
      if (n.name () == L"TopOfGirderChordElevation" && n.namespace_ ().empty ())
      {
        if (!TopOfGirderChordElevation_.present ())
        {
          this->TopOfGirderChordElevation_.set (TopOfGirderChordElevation_traits::create (i, f, this));
          continue;
        }
      }

      // TopOfGirderElevationPriorToSlabCasting
      //
      if (n.name () == L"TopOfGirderElevationPriorToSlabCasting" && n.namespace_ ().empty ())
      {
        if (!TopOfGirderElevationPriorToSlabCasting_.present ())
        {
          this->TopOfGirderElevationPriorToSlabCasting_.set (TopOfGirderElevationPriorToSlabCasting_traits::create (i, f, this));
          continue;
        }
      }

      // TopOfGirderElevationAtFinal
      //
      if (n.name () == L"TopOfGirderElevationAtFinal" && n.namespace_ ().empty ())
      {
        if (!TopOfGirderElevationAtFinal_.present ())
        {
          this->TopOfGirderElevationAtFinal_.set (TopOfGirderElevationAtFinal_traits::create (i, f, this));
          continue;
        }
      }

      // GirderCamberAtRelease
      //
      if (n.name () == L"GirderCamberAtRelease" && n.namespace_ ().empty ())
      {
        if (!GirderCamberAtRelease_.present ())
        {
          this->GirderCamberAtRelease_.set (GirderCamberAtRelease_traits::create (i, f, this));
          continue;
        }
      }

      // GirderCamberPriorToDeckCasting
      //
      if (n.name () == L"GirderCamberPriorToDeckCasting" && n.namespace_ ().empty ())
      {
        if (!GirderCamberPriorToDeckCasting_.present ())
        {
          this->GirderCamberPriorToDeckCasting_.set (GirderCamberPriorToDeckCasting_traits::create (i, f, this));
          continue;
        }
      }

      // GirderCamberAtFinal
      //
      if (n.name () == L"GirderCamberAtFinal" && n.namespace_ ().empty ())
      {
        if (!GirderCamberAtFinal_.present ())
        {
          this->GirderCamberAtFinal_.set (GirderCamberAtFinal_traits::create (i, f, this));
          continue;
        }
      }

      break;
    }

    if (!FractionalLocation_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< wchar_t > (
        L"FractionalLocation",
        L"");
    }

    if (!Location_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< wchar_t > (
        L"Location",
        L"");
    }

    if (!LocationFromEndOfGirder_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< wchar_t > (
        L"LocationFromEndOfGirder",
        L"");
    }

    if (!TopOfDeckElevation_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< wchar_t > (
        L"TopOfDeckElevation",
        L"");
    }

    if (!TopOfGirderChordElevation_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< wchar_t > (
        L"TopOfGirderChordElevation",
        L"");
    }

    if (!TopOfGirderElevationPriorToSlabCasting_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< wchar_t > (
        L"TopOfGirderElevationPriorToSlabCasting",
        L"");
    }

    if (!TopOfGirderElevationAtFinal_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< wchar_t > (
        L"TopOfGirderElevationAtFinal",
        L"");
    }

    if (!GirderCamberAtRelease_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< wchar_t > (
        L"GirderCamberAtRelease",
        L"");
    }

    if (!GirderCamberPriorToDeckCasting_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< wchar_t > (
        L"GirderCamberPriorToDeckCasting",
        L"");
    }

    if (!GirderCamberAtFinal_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< wchar_t > (
        L"GirderCamberAtFinal",
        L"");
    }
  }

  CamberResultType* CamberResultType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class CamberResultType (*this, f, c);
  }

  CamberResultType::
  ~CamberResultType ()
  {
  }

  // GirderDataType
  //

  GirderDataType::
  GirderDataType ()
  : ::xml_schema::type (),
    GirderKey_ (::xml_schema::flags (), this),
    GirderType_ (::xml_schema::flags (), this),
    SectionDimensions_ (::xml_schema::flags (), this),
    Fci_ (::xml_schema::flags (), this),
    Fc_ (::xml_schema::flags (), this),
    Eci_ (::xml_schema::flags (), this),
    Ec_ (::xml_schema::flags (), this),
    GirderLength_ (::xml_schema::flags (), this),
    SpacingLeftStart_ (::xml_schema::flags (), this),
    SpacingRightStart_ (::xml_schema::flags (), this),
    SpacingLeftEnd_ (::xml_schema::flags (), this),
    SpacingRightEnd_ (::xml_schema::flags (), this),
    NumberOfHarpingPoints_ (::xml_schema::flags (), this),
    HarpingPoints_ (::xml_schema::flags (), this),
    LiftingLocation_ (::xml_schema::flags (), this),
    LeadingHaulingLocation_ (::xml_schema::flags (), this),
    TrailingHaulingLocation_ (::xml_schema::flags (), this),
    StartADimension_ (::xml_schema::flags (), this),
    EndADimension_ (::xml_schema::flags (), this),
    GirderHaunchVolume_ (::xml_schema::flags (), this),
    IsPrismatic_ (::xml_schema::flags (), this),
    Area_ (::xml_schema::flags (), this),
    Ix_ (::xml_schema::flags (), this),
    Iy_ (::xml_schema::flags (), this),
    d_ (::xml_schema::flags (), this),
    Yt_ (::xml_schema::flags (), this),
    Yb_ (::xml_schema::flags (), this),
    St_ (::xml_schema::flags (), this),
    Sb_ (::xml_schema::flags (), this),
    P_ (::xml_schema::flags (), this),
    W_ (::xml_schema::flags (), this),
    Wtotal_ (::xml_schema::flags (), this),
    Area_c_ (::xml_schema::flags (), this),
    Ix_c_ (::xml_schema::flags (), this),
    Iy_c_ (::xml_schema::flags (), this),
    d_c_ (::xml_schema::flags (), this),
    Yt_c_ (::xml_schema::flags (), this),
    Yb_c_ (::xml_schema::flags (), this),
    St_c_ (::xml_schema::flags (), this),
    Sb_c_ (::xml_schema::flags (), this),
    StrandEccentricityAtEnds_ (::xml_schema::flags (), this),
    StrandEccentricityAtHPs_ (::xml_schema::flags (), this),
    PrestressingStrandMaterial_ (::xml_schema::flags (), this),
    NumberOfStraightStrands_ (::xml_schema::flags (), this),
    StraightStrandCoordinates_ (::xml_schema::flags (), this),
    NumberOfDebondedStraightStrands_ (::xml_schema::flags (), this),
    StraightStrandDebonding_ (::xml_schema::flags (), this),
    NumberOfExtendedStraightStrands_ (::xml_schema::flags (), this),
    StraightStrandExtensions_ (::xml_schema::flags (), this),
    NumberOfHarpedStrands_ (::xml_schema::flags (), this),
    HarpedStrandCoordinatesAtEnds_ (::xml_schema::flags (), this),
    HarpedStrandCoordinatesAtHP_ (::xml_schema::flags (), this),
    NumberOfTemporaryStrands_ (::xml_schema::flags (), this),
    TemporaryStrandCoordinates_ (::xml_schema::flags (), this),
    LongitudinalRebarMaterial_ (::xml_schema::flags (), this),
    NumberOfLongitudinalRebarRows_ (::xml_schema::flags (), this),
    LongitudinalRebarRows_ (::xml_schema::flags (), this),
    TransverseReinforcementMaterial_ (::xml_schema::flags (), this),
    NumberOfStirrupZones_ (::xml_schema::flags (), this),
    StirrupZones_ (::xml_schema::flags (), this),
    CamberResults_ (::xml_schema::flags (), this)
  {
  }

  GirderDataType::
  GirderDataType (const GirderKey_type& GirderKey,
                  const GirderType_type& GirderType,
                  const Fci_type& Fci,
                  const Fc_type& Fc,
                  const Eci_type& Eci,
                  const Ec_type& Ec,
                  const GirderLength_type& GirderLength,
                  const SpacingLeftStart_type& SpacingLeftStart,
                  const SpacingRightStart_type& SpacingRightStart,
                  const SpacingLeftEnd_type& SpacingLeftEnd,
                  const SpacingRightEnd_type& SpacingRightEnd,
                  const NumberOfHarpingPoints_type& NumberOfHarpingPoints,
                  const LiftingLocation_type& LiftingLocation,
                  const LeadingHaulingLocation_type& LeadingHaulingLocation,
                  const TrailingHaulingLocation_type& TrailingHaulingLocation,
                  const StartADimension_type& StartADimension,
                  const EndADimension_type& EndADimension,
                  const GirderHaunchVolume_type& GirderHaunchVolume,
                  const IsPrismatic_type& IsPrismatic,
                  const Area_type& Area,
                  const Ix_type& Ix,
                  const Iy_type& Iy,
                  const d_type& d,
                  const Yt_type& Yt,
                  const Yb_type& Yb,
                  const St_type& St,
                  const Sb_type& Sb,
                  const P_type& P,
                  const W_type& W,
                  const Wtotal_type& Wtotal,
                  const Area_c_type& Area_c,
                  const Ix_c_type& Ix_c,
                  const Iy_c_type& Iy_c,
                  const d_c_type& d_c,
                  const Yt_c_type& Yt_c,
                  const Yb_c_type& Yb_c,
                  const St_c_type& St_c,
                  const Sb_c_type& Sb_c,
                  const StrandEccentricityAtEnds_type& StrandEccentricityAtEnds,
                  const StrandEccentricityAtHPs_type& StrandEccentricityAtHPs,
                  const PrestressingStrandMaterial_type& PrestressingStrandMaterial,
                  const NumberOfStraightStrands_type& NumberOfStraightStrands,
                  const NumberOfDebondedStraightStrands_type& NumberOfDebondedStraightStrands,
                  const NumberOfExtendedStraightStrands_type& NumberOfExtendedStraightStrands,
                  const NumberOfHarpedStrands_type& NumberOfHarpedStrands,
                  const NumberOfTemporaryStrands_type& NumberOfTemporaryStrands,
                  const LongitudinalRebarMaterial_type& LongitudinalRebarMaterial,
                  const NumberOfLongitudinalRebarRows_type& NumberOfLongitudinalRebarRows,
                  const TransverseReinforcementMaterial_type& TransverseReinforcementMaterial,
                  const NumberOfStirrupZones_type& NumberOfStirrupZones)
  : ::xml_schema::type (),
    GirderKey_ (GirderKey, ::xml_schema::flags (), this),
    GirderType_ (GirderType, ::xml_schema::flags (), this),
    SectionDimensions_ (::xml_schema::flags (), this),
    Fci_ (Fci, ::xml_schema::flags (), this),
    Fc_ (Fc, ::xml_schema::flags (), this),
    Eci_ (Eci, ::xml_schema::flags (), this),
    Ec_ (Ec, ::xml_schema::flags (), this),
    GirderLength_ (GirderLength, ::xml_schema::flags (), this),
    SpacingLeftStart_ (SpacingLeftStart, ::xml_schema::flags (), this),
    SpacingRightStart_ (SpacingRightStart, ::xml_schema::flags (), this),
    SpacingLeftEnd_ (SpacingLeftEnd, ::xml_schema::flags (), this),
    SpacingRightEnd_ (SpacingRightEnd, ::xml_schema::flags (), this),
    NumberOfHarpingPoints_ (NumberOfHarpingPoints, ::xml_schema::flags (), this),
    HarpingPoints_ (::xml_schema::flags (), this),
    LiftingLocation_ (LiftingLocation, ::xml_schema::flags (), this),
    LeadingHaulingLocation_ (LeadingHaulingLocation, ::xml_schema::flags (), this),
    TrailingHaulingLocation_ (TrailingHaulingLocation, ::xml_schema::flags (), this),
    StartADimension_ (StartADimension, ::xml_schema::flags (), this),
    EndADimension_ (EndADimension, ::xml_schema::flags (), this),
    GirderHaunchVolume_ (GirderHaunchVolume, ::xml_schema::flags (), this),
    IsPrismatic_ (IsPrismatic, ::xml_schema::flags (), this),
    Area_ (Area, ::xml_schema::flags (), this),
    Ix_ (Ix, ::xml_schema::flags (), this),
    Iy_ (Iy, ::xml_schema::flags (), this),
    d_ (d, ::xml_schema::flags (), this),
    Yt_ (Yt, ::xml_schema::flags (), this),
    Yb_ (Yb, ::xml_schema::flags (), this),
    St_ (St, ::xml_schema::flags (), this),
    Sb_ (Sb, ::xml_schema::flags (), this),
    P_ (P, ::xml_schema::flags (), this),
    W_ (W, ::xml_schema::flags (), this),
    Wtotal_ (Wtotal, ::xml_schema::flags (), this),
    Area_c_ (Area_c, ::xml_schema::flags (), this),
    Ix_c_ (Ix_c, ::xml_schema::flags (), this),
    Iy_c_ (Iy_c, ::xml_schema::flags (), this),
    d_c_ (d_c, ::xml_schema::flags (), this),
    Yt_c_ (Yt_c, ::xml_schema::flags (), this),
    Yb_c_ (Yb_c, ::xml_schema::flags (), this),
    St_c_ (St_c, ::xml_schema::flags (), this),
    Sb_c_ (Sb_c, ::xml_schema::flags (), this),
    StrandEccentricityAtEnds_ (StrandEccentricityAtEnds, ::xml_schema::flags (), this),
    StrandEccentricityAtHPs_ (StrandEccentricityAtHPs, ::xml_schema::flags (), this),
    PrestressingStrandMaterial_ (PrestressingStrandMaterial, ::xml_schema::flags (), this),
    NumberOfStraightStrands_ (NumberOfStraightStrands, ::xml_schema::flags (), this),
    StraightStrandCoordinates_ (::xml_schema::flags (), this),
    NumberOfDebondedStraightStrands_ (NumberOfDebondedStraightStrands, ::xml_schema::flags (), this),
    StraightStrandDebonding_ (::xml_schema::flags (), this),
    NumberOfExtendedStraightStrands_ (NumberOfExtendedStraightStrands, ::xml_schema::flags (), this),
    StraightStrandExtensions_ (::xml_schema::flags (), this),
    NumberOfHarpedStrands_ (NumberOfHarpedStrands, ::xml_schema::flags (), this),
    HarpedStrandCoordinatesAtEnds_ (::xml_schema::flags (), this),
    HarpedStrandCoordinatesAtHP_ (::xml_schema::flags (), this),
    NumberOfTemporaryStrands_ (NumberOfTemporaryStrands, ::xml_schema::flags (), this),
    TemporaryStrandCoordinates_ (::xml_schema::flags (), this),
    LongitudinalRebarMaterial_ (LongitudinalRebarMaterial, ::xml_schema::flags (), this),
    NumberOfLongitudinalRebarRows_ (NumberOfLongitudinalRebarRows, ::xml_schema::flags (), this),
    LongitudinalRebarRows_ (::xml_schema::flags (), this),
    TransverseReinforcementMaterial_ (TransverseReinforcementMaterial, ::xml_schema::flags (), this),
    NumberOfStirrupZones_ (NumberOfStirrupZones, ::xml_schema::flags (), this),
    StirrupZones_ (::xml_schema::flags (), this),
    CamberResults_ (::xml_schema::flags (), this)
  {
  }

  GirderDataType::
  GirderDataType (::std::auto_ptr< GirderKey_type >& GirderKey,
                  const GirderType_type& GirderType,
                  const Fci_type& Fci,
                  const Fc_type& Fc,
                  const Eci_type& Eci,
                  const Ec_type& Ec,
                  const GirderLength_type& GirderLength,
                  const SpacingLeftStart_type& SpacingLeftStart,
                  const SpacingRightStart_type& SpacingRightStart,
                  const SpacingLeftEnd_type& SpacingLeftEnd,
                  const SpacingRightEnd_type& SpacingRightEnd,
                  const NumberOfHarpingPoints_type& NumberOfHarpingPoints,
                  const LiftingLocation_type& LiftingLocation,
                  const LeadingHaulingLocation_type& LeadingHaulingLocation,
                  const TrailingHaulingLocation_type& TrailingHaulingLocation,
                  const StartADimension_type& StartADimension,
                  const EndADimension_type& EndADimension,
                  const GirderHaunchVolume_type& GirderHaunchVolume,
                  const IsPrismatic_type& IsPrismatic,
                  const Area_type& Area,
                  const Ix_type& Ix,
                  const Iy_type& Iy,
                  const d_type& d,
                  const Yt_type& Yt,
                  const Yb_type& Yb,
                  const St_type& St,
                  const Sb_type& Sb,
                  const P_type& P,
                  const W_type& W,
                  const Wtotal_type& Wtotal,
                  const Area_c_type& Area_c,
                  const Ix_c_type& Ix_c,
                  const Iy_c_type& Iy_c,
                  const d_c_type& d_c,
                  const Yt_c_type& Yt_c,
                  const Yb_c_type& Yb_c,
                  const St_c_type& St_c,
                  const Sb_c_type& Sb_c,
                  const StrandEccentricityAtEnds_type& StrandEccentricityAtEnds,
                  const StrandEccentricityAtHPs_type& StrandEccentricityAtHPs,
                  ::std::auto_ptr< PrestressingStrandMaterial_type >& PrestressingStrandMaterial,
                  const NumberOfStraightStrands_type& NumberOfStraightStrands,
                  const NumberOfDebondedStraightStrands_type& NumberOfDebondedStraightStrands,
                  const NumberOfExtendedStraightStrands_type& NumberOfExtendedStraightStrands,
                  const NumberOfHarpedStrands_type& NumberOfHarpedStrands,
                  const NumberOfTemporaryStrands_type& NumberOfTemporaryStrands,
                  ::std::auto_ptr< LongitudinalRebarMaterial_type >& LongitudinalRebarMaterial,
                  const NumberOfLongitudinalRebarRows_type& NumberOfLongitudinalRebarRows,
                  ::std::auto_ptr< TransverseReinforcementMaterial_type >& TransverseReinforcementMaterial,
                  const NumberOfStirrupZones_type& NumberOfStirrupZones)
  : ::xml_schema::type (),
    GirderKey_ (GirderKey, ::xml_schema::flags (), this),
    GirderType_ (GirderType, ::xml_schema::flags (), this),
    SectionDimensions_ (::xml_schema::flags (), this),
    Fci_ (Fci, ::xml_schema::flags (), this),
    Fc_ (Fc, ::xml_schema::flags (), this),
    Eci_ (Eci, ::xml_schema::flags (), this),
    Ec_ (Ec, ::xml_schema::flags (), this),
    GirderLength_ (GirderLength, ::xml_schema::flags (), this),
    SpacingLeftStart_ (SpacingLeftStart, ::xml_schema::flags (), this),
    SpacingRightStart_ (SpacingRightStart, ::xml_schema::flags (), this),
    SpacingLeftEnd_ (SpacingLeftEnd, ::xml_schema::flags (), this),
    SpacingRightEnd_ (SpacingRightEnd, ::xml_schema::flags (), this),
    NumberOfHarpingPoints_ (NumberOfHarpingPoints, ::xml_schema::flags (), this),
    HarpingPoints_ (::xml_schema::flags (), this),
    LiftingLocation_ (LiftingLocation, ::xml_schema::flags (), this),
    LeadingHaulingLocation_ (LeadingHaulingLocation, ::xml_schema::flags (), this),
    TrailingHaulingLocation_ (TrailingHaulingLocation, ::xml_schema::flags (), this),
    StartADimension_ (StartADimension, ::xml_schema::flags (), this),
    EndADimension_ (EndADimension, ::xml_schema::flags (), this),
    GirderHaunchVolume_ (GirderHaunchVolume, ::xml_schema::flags (), this),
    IsPrismatic_ (IsPrismatic, ::xml_schema::flags (), this),
    Area_ (Area, ::xml_schema::flags (), this),
    Ix_ (Ix, ::xml_schema::flags (), this),
    Iy_ (Iy, ::xml_schema::flags (), this),
    d_ (d, ::xml_schema::flags (), this),
    Yt_ (Yt, ::xml_schema::flags (), this),
    Yb_ (Yb, ::xml_schema::flags (), this),
    St_ (St, ::xml_schema::flags (), this),
    Sb_ (Sb, ::xml_schema::flags (), this),
    P_ (P, ::xml_schema::flags (), this),
    W_ (W, ::xml_schema::flags (), this),
    Wtotal_ (Wtotal, ::xml_schema::flags (), this),
    Area_c_ (Area_c, ::xml_schema::flags (), this),
    Ix_c_ (Ix_c, ::xml_schema::flags (), this),
    Iy_c_ (Iy_c, ::xml_schema::flags (), this),
    d_c_ (d_c, ::xml_schema::flags (), this),
    Yt_c_ (Yt_c, ::xml_schema::flags (), this),
    Yb_c_ (Yb_c, ::xml_schema::flags (), this),
    St_c_ (St_c, ::xml_schema::flags (), this),
    Sb_c_ (Sb_c, ::xml_schema::flags (), this),
    StrandEccentricityAtEnds_ (StrandEccentricityAtEnds, ::xml_schema::flags (), this),
    StrandEccentricityAtHPs_ (StrandEccentricityAtHPs, ::xml_schema::flags (), this),
    PrestressingStrandMaterial_ (PrestressingStrandMaterial, ::xml_schema::flags (), this),
    NumberOfStraightStrands_ (NumberOfStraightStrands, ::xml_schema::flags (), this),
    StraightStrandCoordinates_ (::xml_schema::flags (), this),
    NumberOfDebondedStraightStrands_ (NumberOfDebondedStraightStrands, ::xml_schema::flags (), this),
    StraightStrandDebonding_ (::xml_schema::flags (), this),
    NumberOfExtendedStraightStrands_ (NumberOfExtendedStraightStrands, ::xml_schema::flags (), this),
    StraightStrandExtensions_ (::xml_schema::flags (), this),
    NumberOfHarpedStrands_ (NumberOfHarpedStrands, ::xml_schema::flags (), this),
    HarpedStrandCoordinatesAtEnds_ (::xml_schema::flags (), this),
    HarpedStrandCoordinatesAtHP_ (::xml_schema::flags (), this),
    NumberOfTemporaryStrands_ (NumberOfTemporaryStrands, ::xml_schema::flags (), this),
    TemporaryStrandCoordinates_ (::xml_schema::flags (), this),
    LongitudinalRebarMaterial_ (LongitudinalRebarMaterial, ::xml_schema::flags (), this),
    NumberOfLongitudinalRebarRows_ (NumberOfLongitudinalRebarRows, ::xml_schema::flags (), this),
    LongitudinalRebarRows_ (::xml_schema::flags (), this),
    TransverseReinforcementMaterial_ (TransverseReinforcementMaterial, ::xml_schema::flags (), this),
    NumberOfStirrupZones_ (NumberOfStirrupZones, ::xml_schema::flags (), this),
    StirrupZones_ (::xml_schema::flags (), this),
    CamberResults_ (::xml_schema::flags (), this)
  {
  }

  GirderDataType::
  GirderDataType (const GirderDataType& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    GirderKey_ (x.GirderKey_, f, this),
    GirderType_ (x.GirderType_, f, this),
    SectionDimensions_ (x.SectionDimensions_, f, this),
    Fci_ (x.Fci_, f, this),
    Fc_ (x.Fc_, f, this),
    Eci_ (x.Eci_, f, this),
    Ec_ (x.Ec_, f, this),
    GirderLength_ (x.GirderLength_, f, this),
    SpacingLeftStart_ (x.SpacingLeftStart_, f, this),
    SpacingRightStart_ (x.SpacingRightStart_, f, this),
    SpacingLeftEnd_ (x.SpacingLeftEnd_, f, this),
    SpacingRightEnd_ (x.SpacingRightEnd_, f, this),
    NumberOfHarpingPoints_ (x.NumberOfHarpingPoints_, f, this),
    HarpingPoints_ (x.HarpingPoints_, f, this),
    LiftingLocation_ (x.LiftingLocation_, f, this),
    LeadingHaulingLocation_ (x.LeadingHaulingLocation_, f, this),
    TrailingHaulingLocation_ (x.TrailingHaulingLocation_, f, this),
    StartADimension_ (x.StartADimension_, f, this),
    EndADimension_ (x.EndADimension_, f, this),
    GirderHaunchVolume_ (x.GirderHaunchVolume_, f, this),
    IsPrismatic_ (x.IsPrismatic_, f, this),
    Area_ (x.Area_, f, this),
    Ix_ (x.Ix_, f, this),
    Iy_ (x.Iy_, f, this),
    d_ (x.d_, f, this),
    Yt_ (x.Yt_, f, this),
    Yb_ (x.Yb_, f, this),
    St_ (x.St_, f, this),
    Sb_ (x.Sb_, f, this),
    P_ (x.P_, f, this),
    W_ (x.W_, f, this),
    Wtotal_ (x.Wtotal_, f, this),
    Area_c_ (x.Area_c_, f, this),
    Ix_c_ (x.Ix_c_, f, this),
    Iy_c_ (x.Iy_c_, f, this),
    d_c_ (x.d_c_, f, this),
    Yt_c_ (x.Yt_c_, f, this),
    Yb_c_ (x.Yb_c_, f, this),
    St_c_ (x.St_c_, f, this),
    Sb_c_ (x.Sb_c_, f, this),
    StrandEccentricityAtEnds_ (x.StrandEccentricityAtEnds_, f, this),
    StrandEccentricityAtHPs_ (x.StrandEccentricityAtHPs_, f, this),
    PrestressingStrandMaterial_ (x.PrestressingStrandMaterial_, f, this),
    NumberOfStraightStrands_ (x.NumberOfStraightStrands_, f, this),
    StraightStrandCoordinates_ (x.StraightStrandCoordinates_, f, this),
    NumberOfDebondedStraightStrands_ (x.NumberOfDebondedStraightStrands_, f, this),
    StraightStrandDebonding_ (x.StraightStrandDebonding_, f, this),
    NumberOfExtendedStraightStrands_ (x.NumberOfExtendedStraightStrands_, f, this),
    StraightStrandExtensions_ (x.StraightStrandExtensions_, f, this),
    NumberOfHarpedStrands_ (x.NumberOfHarpedStrands_, f, this),
    HarpedStrandCoordinatesAtEnds_ (x.HarpedStrandCoordinatesAtEnds_, f, this),
    HarpedStrandCoordinatesAtHP_ (x.HarpedStrandCoordinatesAtHP_, f, this),
    NumberOfTemporaryStrands_ (x.NumberOfTemporaryStrands_, f, this),
    TemporaryStrandCoordinates_ (x.TemporaryStrandCoordinates_, f, this),
    LongitudinalRebarMaterial_ (x.LongitudinalRebarMaterial_, f, this),
    NumberOfLongitudinalRebarRows_ (x.NumberOfLongitudinalRebarRows_, f, this),
    LongitudinalRebarRows_ (x.LongitudinalRebarRows_, f, this),
    TransverseReinforcementMaterial_ (x.TransverseReinforcementMaterial_, f, this),
    NumberOfStirrupZones_ (x.NumberOfStirrupZones_, f, this),
    StirrupZones_ (x.StirrupZones_, f, this),
    CamberResults_ (x.CamberResults_, f, this)
  {
  }

  GirderDataType::
  GirderDataType (const xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    GirderKey_ (f, this),
    GirderType_ (f, this),
    SectionDimensions_ (f, this),
    Fci_ (f, this),
    Fc_ (f, this),
    Eci_ (f, this),
    Ec_ (f, this),
    GirderLength_ (f, this),
    SpacingLeftStart_ (f, this),
    SpacingRightStart_ (f, this),
    SpacingLeftEnd_ (f, this),
    SpacingRightEnd_ (f, this),
    NumberOfHarpingPoints_ (f, this),
    HarpingPoints_ (f, this),
    LiftingLocation_ (f, this),
    LeadingHaulingLocation_ (f, this),
    TrailingHaulingLocation_ (f, this),
    StartADimension_ (f, this),
    EndADimension_ (f, this),
    GirderHaunchVolume_ (f, this),
    IsPrismatic_ (f, this),
    Area_ (f, this),
    Ix_ (f, this),
    Iy_ (f, this),
    d_ (f, this),
    Yt_ (f, this),
    Yb_ (f, this),
    St_ (f, this),
    Sb_ (f, this),
    P_ (f, this),
    W_ (f, this),
    Wtotal_ (f, this),
    Area_c_ (f, this),
    Ix_c_ (f, this),
    Iy_c_ (f, this),
    d_c_ (f, this),
    Yt_c_ (f, this),
    Yb_c_ (f, this),
    St_c_ (f, this),
    Sb_c_ (f, this),
    StrandEccentricityAtEnds_ (f, this),
    StrandEccentricityAtHPs_ (f, this),
    PrestressingStrandMaterial_ (f, this),
    NumberOfStraightStrands_ (f, this),
    StraightStrandCoordinates_ (f, this),
    NumberOfDebondedStraightStrands_ (f, this),
    StraightStrandDebonding_ (f, this),
    NumberOfExtendedStraightStrands_ (f, this),
    StraightStrandExtensions_ (f, this),
    NumberOfHarpedStrands_ (f, this),
    HarpedStrandCoordinatesAtEnds_ (f, this),
    HarpedStrandCoordinatesAtHP_ (f, this),
    NumberOfTemporaryStrands_ (f, this),
    TemporaryStrandCoordinates_ (f, this),
    LongitudinalRebarMaterial_ (f, this),
    NumberOfLongitudinalRebarRows_ (f, this),
    LongitudinalRebarRows_ (f, this),
    TransverseReinforcementMaterial_ (f, this),
    NumberOfStirrupZones_ (f, this),
    StirrupZones_ (f, this),
    CamberResults_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false);
      this->parse (p, f);
    }
  }

  void GirderDataType::
  parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (i));

      // GirderKey
      //
      if (n.name () == L"GirderKey" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< GirderKey_type > r (
          GirderKey_traits::create (i, f, this));

        if (!GirderKey_.present ())
        {
          this->GirderKey_.set (r);
          continue;
        }
      }

      // GirderType
      //
      if (n.name () == L"GirderType" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< GirderType_type > r (
          GirderType_traits::create (i, f, this));

        if (!GirderType_.present ())
        {
          this->GirderType_.set (r);
          continue;
        }
      }

      // SectionDimensions
      //
      if (n.name () == L"SectionDimensions" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< SectionDimensions_type > r (
          SectionDimensions_traits::create (i, f, this));

        this->SectionDimensions_.push_back (r);
        continue;
      }

      // Fci
      //
      if (n.name () == L"Fci" && n.namespace_ ().empty ())
      {
        if (!Fci_.present ())
        {
          this->Fci_.set (Fci_traits::create (i, f, this));
          continue;
        }
      }

      // Fc
      //
      if (n.name () == L"Fc" && n.namespace_ ().empty ())
      {
        if (!Fc_.present ())
        {
          this->Fc_.set (Fc_traits::create (i, f, this));
          continue;
        }
      }

      // Eci
      //
      if (n.name () == L"Eci" && n.namespace_ ().empty ())
      {
        if (!Eci_.present ())
        {
          this->Eci_.set (Eci_traits::create (i, f, this));
          continue;
        }
      }

      // Ec
      //
      if (n.name () == L"Ec" && n.namespace_ ().empty ())
      {
        if (!Ec_.present ())
        {
          this->Ec_.set (Ec_traits::create (i, f, this));
          continue;
        }
      }

      // GirderLength
      //
      if (n.name () == L"GirderLength" && n.namespace_ ().empty ())
      {
        if (!GirderLength_.present ())
        {
          this->GirderLength_.set (GirderLength_traits::create (i, f, this));
          continue;
        }
      }

      // SpacingLeftStart
      //
      if (n.name () == L"SpacingLeftStart" && n.namespace_ ().empty ())
      {
        if (!SpacingLeftStart_.present ())
        {
          this->SpacingLeftStart_.set (SpacingLeftStart_traits::create (i, f, this));
          continue;
        }
      }

      // SpacingRightStart
      //
      if (n.name () == L"SpacingRightStart" && n.namespace_ ().empty ())
      {
        if (!SpacingRightStart_.present ())
        {
          this->SpacingRightStart_.set (SpacingRightStart_traits::create (i, f, this));
          continue;
        }
      }

      // SpacingLeftEnd
      //
      if (n.name () == L"SpacingLeftEnd" && n.namespace_ ().empty ())
      {
        if (!SpacingLeftEnd_.present ())
        {
          this->SpacingLeftEnd_.set (SpacingLeftEnd_traits::create (i, f, this));
          continue;
        }
      }

      // SpacingRightEnd
      //
      if (n.name () == L"SpacingRightEnd" && n.namespace_ ().empty ())
      {
        if (!SpacingRightEnd_.present ())
        {
          this->SpacingRightEnd_.set (SpacingRightEnd_traits::create (i, f, this));
          continue;
        }
      }

      // NumberOfHarpingPoints
      //
      if (n.name () == L"NumberOfHarpingPoints" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< NumberOfHarpingPoints_type > r (
          NumberOfHarpingPoints_traits::create (i, f, this));

        if (!NumberOfHarpingPoints_.present ())
        {
          this->NumberOfHarpingPoints_.set (r);
          continue;
        }
      }

      // HarpingPoints
      //
      if (n.name () == L"HarpingPoints" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< HarpingPoints_type > r (
          HarpingPoints_traits::create (i, f, this));

        this->HarpingPoints_.push_back (r);
        continue;
      }

      // LiftingLocation
      //
      if (n.name () == L"LiftingLocation" && n.namespace_ ().empty ())
      {
        if (!LiftingLocation_.present ())
        {
          this->LiftingLocation_.set (LiftingLocation_traits::create (i, f, this));
          continue;
        }
      }

      // LeadingHaulingLocation
      //
      if (n.name () == L"LeadingHaulingLocation" && n.namespace_ ().empty ())
      {
        if (!LeadingHaulingLocation_.present ())
        {
          this->LeadingHaulingLocation_.set (LeadingHaulingLocation_traits::create (i, f, this));
          continue;
        }
      }

      // TrailingHaulingLocation
      //
      if (n.name () == L"TrailingHaulingLocation" && n.namespace_ ().empty ())
      {
        if (!TrailingHaulingLocation_.present ())
        {
          this->TrailingHaulingLocation_.set (TrailingHaulingLocation_traits::create (i, f, this));
          continue;
        }
      }

      // StartADimension
      //
      if (n.name () == L"StartADimension" && n.namespace_ ().empty ())
      {
        if (!StartADimension_.present ())
        {
          this->StartADimension_.set (StartADimension_traits::create (i, f, this));
          continue;
        }
      }

      // EndADimension
      //
      if (n.name () == L"EndADimension" && n.namespace_ ().empty ())
      {
        if (!EndADimension_.present ())
        {
          this->EndADimension_.set (EndADimension_traits::create (i, f, this));
          continue;
        }
      }

      // GirderHaunchVolume
      //
      if (n.name () == L"GirderHaunchVolume" && n.namespace_ ().empty ())
      {
        if (!GirderHaunchVolume_.present ())
        {
          this->GirderHaunchVolume_.set (GirderHaunchVolume_traits::create (i, f, this));
          continue;
        }
      }

      // IsPrismatic
      //
      if (n.name () == L"IsPrismatic" && n.namespace_ ().empty ())
      {
        if (!IsPrismatic_.present ())
        {
          this->IsPrismatic_.set (IsPrismatic_traits::create (i, f, this));
          continue;
        }
      }

      // Area
      //
      if (n.name () == L"Area" && n.namespace_ ().empty ())
      {
        if (!Area_.present ())
        {
          this->Area_.set (Area_traits::create (i, f, this));
          continue;
        }
      }

      // Ix
      //
      if (n.name () == L"Ix" && n.namespace_ ().empty ())
      {
        if (!Ix_.present ())
        {
          this->Ix_.set (Ix_traits::create (i, f, this));
          continue;
        }
      }

      // Iy
      //
      if (n.name () == L"Iy" && n.namespace_ ().empty ())
      {
        if (!Iy_.present ())
        {
          this->Iy_.set (Iy_traits::create (i, f, this));
          continue;
        }
      }

      // d
      //
      if (n.name () == L"d" && n.namespace_ ().empty ())
      {
        if (!d_.present ())
        {
          this->d_.set (d_traits::create (i, f, this));
          continue;
        }
      }

      // Yt
      //
      if (n.name () == L"Yt" && n.namespace_ ().empty ())
      {
        if (!Yt_.present ())
        {
          this->Yt_.set (Yt_traits::create (i, f, this));
          continue;
        }
      }

      // Yb
      //
      if (n.name () == L"Yb" && n.namespace_ ().empty ())
      {
        if (!Yb_.present ())
        {
          this->Yb_.set (Yb_traits::create (i, f, this));
          continue;
        }
      }

      // St
      //
      if (n.name () == L"St" && n.namespace_ ().empty ())
      {
        if (!St_.present ())
        {
          this->St_.set (St_traits::create (i, f, this));
          continue;
        }
      }

      // Sb
      //
      if (n.name () == L"Sb" && n.namespace_ ().empty ())
      {
        if (!Sb_.present ())
        {
          this->Sb_.set (Sb_traits::create (i, f, this));
          continue;
        }
      }

      // P
      //
      if (n.name () == L"P" && n.namespace_ ().empty ())
      {
        if (!P_.present ())
        {
          this->P_.set (P_traits::create (i, f, this));
          continue;
        }
      }

      // W
      //
      if (n.name () == L"W" && n.namespace_ ().empty ())
      {
        if (!W_.present ())
        {
          this->W_.set (W_traits::create (i, f, this));
          continue;
        }
      }

      // Wtotal
      //
      if (n.name () == L"Wtotal" && n.namespace_ ().empty ())
      {
        if (!Wtotal_.present ())
        {
          this->Wtotal_.set (Wtotal_traits::create (i, f, this));
          continue;
        }
      }

      // Area_c
      //
      if (n.name () == L"Area_c" && n.namespace_ ().empty ())
      {
        if (!Area_c_.present ())
        {
          this->Area_c_.set (Area_c_traits::create (i, f, this));
          continue;
        }
      }

      // Ix_c
      //
      if (n.name () == L"Ix_c" && n.namespace_ ().empty ())
      {
        if (!Ix_c_.present ())
        {
          this->Ix_c_.set (Ix_c_traits::create (i, f, this));
          continue;
        }
      }

      // Iy_c
      //
      if (n.name () == L"Iy_c" && n.namespace_ ().empty ())
      {
        if (!Iy_c_.present ())
        {
          this->Iy_c_.set (Iy_c_traits::create (i, f, this));
          continue;
        }
      }

      // d_c
      //
      if (n.name () == L"d_c" && n.namespace_ ().empty ())
      {
        if (!d_c_.present ())
        {
          this->d_c_.set (d_c_traits::create (i, f, this));
          continue;
        }
      }

      // Yt_c
      //
      if (n.name () == L"Yt_c" && n.namespace_ ().empty ())
      {
        if (!Yt_c_.present ())
        {
          this->Yt_c_.set (Yt_c_traits::create (i, f, this));
          continue;
        }
      }

      // Yb_c
      //
      if (n.name () == L"Yb_c" && n.namespace_ ().empty ())
      {
        if (!Yb_c_.present ())
        {
          this->Yb_c_.set (Yb_c_traits::create (i, f, this));
          continue;
        }
      }

      // St_c
      //
      if (n.name () == L"St_c" && n.namespace_ ().empty ())
      {
        if (!St_c_.present ())
        {
          this->St_c_.set (St_c_traits::create (i, f, this));
          continue;
        }
      }

      // Sb_c
      //
      if (n.name () == L"Sb_c" && n.namespace_ ().empty ())
      {
        if (!Sb_c_.present ())
        {
          this->Sb_c_.set (Sb_c_traits::create (i, f, this));
          continue;
        }
      }

      // StrandEccentricityAtEnds
      //
      if (n.name () == L"StrandEccentricityAtEnds" && n.namespace_ ().empty ())
      {
        if (!StrandEccentricityAtEnds_.present ())
        {
          this->StrandEccentricityAtEnds_.set (StrandEccentricityAtEnds_traits::create (i, f, this));
          continue;
        }
      }

      // StrandEccentricityAtHPs
      //
      if (n.name () == L"StrandEccentricityAtHPs" && n.namespace_ ().empty ())
      {
        if (!StrandEccentricityAtHPs_.present ())
        {
          this->StrandEccentricityAtHPs_.set (StrandEccentricityAtHPs_traits::create (i, f, this));
          continue;
        }
      }

      // PrestressingStrandMaterial
      //
      if (n.name () == L"PrestressingStrandMaterial" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< PrestressingStrandMaterial_type > r (
          PrestressingStrandMaterial_traits::create (i, f, this));

        if (!PrestressingStrandMaterial_.present ())
        {
          this->PrestressingStrandMaterial_.set (r);
          continue;
        }
      }

      // NumberOfStraightStrands
      //
      if (n.name () == L"NumberOfStraightStrands" && n.namespace_ ().empty ())
      {
        if (!NumberOfStraightStrands_.present ())
        {
          this->NumberOfStraightStrands_.set (NumberOfStraightStrands_traits::create (i, f, this));
          continue;
        }
      }

      // StraightStrandCoordinates
      //
      if (n.name () == L"StraightStrandCoordinates" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< StraightStrandCoordinates_type > r (
          StraightStrandCoordinates_traits::create (i, f, this));

        this->StraightStrandCoordinates_.push_back (r);
        continue;
      }

      // NumberOfDebondedStraightStrands
      //
      if (n.name () == L"NumberOfDebondedStraightStrands" && n.namespace_ ().empty ())
      {
        if (!NumberOfDebondedStraightStrands_.present ())
        {
          this->NumberOfDebondedStraightStrands_.set (NumberOfDebondedStraightStrands_traits::create (i, f, this));
          continue;
        }
      }

      // StraightStrandDebonding
      //
      if (n.name () == L"StraightStrandDebonding" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< StraightStrandDebonding_type > r (
          StraightStrandDebonding_traits::create (i, f, this));

        this->StraightStrandDebonding_.push_back (r);
        continue;
      }

      // NumberOfExtendedStraightStrands
      //
      if (n.name () == L"NumberOfExtendedStraightStrands" && n.namespace_ ().empty ())
      {
        if (!NumberOfExtendedStraightStrands_.present ())
        {
          this->NumberOfExtendedStraightStrands_.set (NumberOfExtendedStraightStrands_traits::create (i, f, this));
          continue;
        }
      }

      // StraightStrandExtensions
      //
      if (n.name () == L"StraightStrandExtensions" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< StraightStrandExtensions_type > r (
          StraightStrandExtensions_traits::create (i, f, this));

        this->StraightStrandExtensions_.push_back (r);
        continue;
      }

      // NumberOfHarpedStrands
      //
      if (n.name () == L"NumberOfHarpedStrands" && n.namespace_ ().empty ())
      {
        if (!NumberOfHarpedStrands_.present ())
        {
          this->NumberOfHarpedStrands_.set (NumberOfHarpedStrands_traits::create (i, f, this));
          continue;
        }
      }

      // HarpedStrandCoordinatesAtEnds
      //
      if (n.name () == L"HarpedStrandCoordinatesAtEnds" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< HarpedStrandCoordinatesAtEnds_type > r (
          HarpedStrandCoordinatesAtEnds_traits::create (i, f, this));

        this->HarpedStrandCoordinatesAtEnds_.push_back (r);
        continue;
      }

      // HarpedStrandCoordinatesAtHP
      //
      if (n.name () == L"HarpedStrandCoordinatesAtHP" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< HarpedStrandCoordinatesAtHP_type > r (
          HarpedStrandCoordinatesAtHP_traits::create (i, f, this));

        this->HarpedStrandCoordinatesAtHP_.push_back (r);
        continue;
      }

      // NumberOfTemporaryStrands
      //
      if (n.name () == L"NumberOfTemporaryStrands" && n.namespace_ ().empty ())
      {
        if (!NumberOfTemporaryStrands_.present ())
        {
          this->NumberOfTemporaryStrands_.set (NumberOfTemporaryStrands_traits::create (i, f, this));
          continue;
        }
      }

      // TemporaryStrandCoordinates
      //
      if (n.name () == L"TemporaryStrandCoordinates" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< TemporaryStrandCoordinates_type > r (
          TemporaryStrandCoordinates_traits::create (i, f, this));

        this->TemporaryStrandCoordinates_.push_back (r);
        continue;
      }

      // LongitudinalRebarMaterial
      //
      if (n.name () == L"LongitudinalRebarMaterial" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< LongitudinalRebarMaterial_type > r (
          LongitudinalRebarMaterial_traits::create (i, f, this));

        if (!LongitudinalRebarMaterial_.present ())
        {
          this->LongitudinalRebarMaterial_.set (r);
          continue;
        }
      }

      // NumberOfLongitudinalRebarRows
      //
      if (n.name () == L"NumberOfLongitudinalRebarRows" && n.namespace_ ().empty ())
      {
        if (!NumberOfLongitudinalRebarRows_.present ())
        {
          this->NumberOfLongitudinalRebarRows_.set (NumberOfLongitudinalRebarRows_traits::create (i, f, this));
          continue;
        }
      }

      // LongitudinalRebarRows
      //
      if (n.name () == L"LongitudinalRebarRows" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< LongitudinalRebarRows_type > r (
          LongitudinalRebarRows_traits::create (i, f, this));

        this->LongitudinalRebarRows_.push_back (r);
        continue;
      }

      // TransverseReinforcementMaterial
      //
      if (n.name () == L"TransverseReinforcementMaterial" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< TransverseReinforcementMaterial_type > r (
          TransverseReinforcementMaterial_traits::create (i, f, this));

        if (!TransverseReinforcementMaterial_.present ())
        {
          this->TransverseReinforcementMaterial_.set (r);
          continue;
        }
      }

      // NumberOfStirrupZones
      //
      if (n.name () == L"NumberOfStirrupZones" && n.namespace_ ().empty ())
      {
        if (!NumberOfStirrupZones_.present ())
        {
          this->NumberOfStirrupZones_.set (NumberOfStirrupZones_traits::create (i, f, this));
          continue;
        }
      }

      // StirrupZones
      //
      if (n.name () == L"StirrupZones" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< StirrupZones_type > r (
          StirrupZones_traits::create (i, f, this));

        this->StirrupZones_.push_back (r);
        continue;
      }

      // CamberResults
      //
      if (n.name () == L"CamberResults" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< CamberResults_type > r (
          CamberResults_traits::create (i, f, this));

        this->CamberResults_.push_back (r);
        continue;
      }

      break;
    }

    if (!GirderKey_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< wchar_t > (
        L"GirderKey",
        L"");
    }

    if (!GirderType_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< wchar_t > (
        L"GirderType",
        L"");
    }

    if (!Fci_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< wchar_t > (
        L"Fci",
        L"");
    }

    if (!Fc_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< wchar_t > (
        L"Fc",
        L"");
    }

    if (!Eci_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< wchar_t > (
        L"Eci",
        L"");
    }

    if (!Ec_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< wchar_t > (
        L"Ec",
        L"");
    }

    if (!GirderLength_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< wchar_t > (
        L"GirderLength",
        L"");
    }

    if (!SpacingLeftStart_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< wchar_t > (
        L"SpacingLeftStart",
        L"");
    }

    if (!SpacingRightStart_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< wchar_t > (
        L"SpacingRightStart",
        L"");
    }

    if (!SpacingLeftEnd_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< wchar_t > (
        L"SpacingLeftEnd",
        L"");
    }

    if (!SpacingRightEnd_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< wchar_t > (
        L"SpacingRightEnd",
        L"");
    }

    if (!NumberOfHarpingPoints_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< wchar_t > (
        L"NumberOfHarpingPoints",
        L"");
    }

    if (!LiftingLocation_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< wchar_t > (
        L"LiftingLocation",
        L"");
    }

    if (!LeadingHaulingLocation_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< wchar_t > (
        L"LeadingHaulingLocation",
        L"");
    }

    if (!TrailingHaulingLocation_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< wchar_t > (
        L"TrailingHaulingLocation",
        L"");
    }

    if (!StartADimension_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< wchar_t > (
        L"StartADimension",
        L"");
    }

    if (!EndADimension_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< wchar_t > (
        L"EndADimension",
        L"");
    }

    if (!GirderHaunchVolume_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< wchar_t > (
        L"GirderHaunchVolume",
        L"");
    }

    if (!IsPrismatic_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< wchar_t > (
        L"IsPrismatic",
        L"");
    }

    if (!Area_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< wchar_t > (
        L"Area",
        L"");
    }

    if (!Ix_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< wchar_t > (
        L"Ix",
        L"");
    }

    if (!Iy_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< wchar_t > (
        L"Iy",
        L"");
    }

    if (!d_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< wchar_t > (
        L"d",
        L"");
    }

    if (!Yt_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< wchar_t > (
        L"Yt",
        L"");
    }

    if (!Yb_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< wchar_t > (
        L"Yb",
        L"");
    }

    if (!St_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< wchar_t > (
        L"St",
        L"");
    }

    if (!Sb_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< wchar_t > (
        L"Sb",
        L"");
    }

    if (!P_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< wchar_t > (
        L"P",
        L"");
    }

    if (!W_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< wchar_t > (
        L"W",
        L"");
    }

    if (!Wtotal_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< wchar_t > (
        L"Wtotal",
        L"");
    }

    if (!Area_c_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< wchar_t > (
        L"Area_c",
        L"");
    }

    if (!Ix_c_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< wchar_t > (
        L"Ix_c",
        L"");
    }

    if (!Iy_c_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< wchar_t > (
        L"Iy_c",
        L"");
    }

    if (!d_c_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< wchar_t > (
        L"d_c",
        L"");
    }

    if (!Yt_c_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< wchar_t > (
        L"Yt_c",
        L"");
    }

    if (!Yb_c_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< wchar_t > (
        L"Yb_c",
        L"");
    }

    if (!St_c_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< wchar_t > (
        L"St_c",
        L"");
    }

    if (!Sb_c_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< wchar_t > (
        L"Sb_c",
        L"");
    }

    if (!StrandEccentricityAtEnds_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< wchar_t > (
        L"StrandEccentricityAtEnds",
        L"");
    }

    if (!StrandEccentricityAtHPs_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< wchar_t > (
        L"StrandEccentricityAtHPs",
        L"");
    }

    if (!PrestressingStrandMaterial_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< wchar_t > (
        L"PrestressingStrandMaterial",
        L"");
    }

    if (!NumberOfStraightStrands_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< wchar_t > (
        L"NumberOfStraightStrands",
        L"");
    }

    if (!NumberOfDebondedStraightStrands_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< wchar_t > (
        L"NumberOfDebondedStraightStrands",
        L"");
    }

    if (!NumberOfExtendedStraightStrands_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< wchar_t > (
        L"NumberOfExtendedStraightStrands",
        L"");
    }

    if (!NumberOfHarpedStrands_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< wchar_t > (
        L"NumberOfHarpedStrands",
        L"");
    }

    if (!NumberOfTemporaryStrands_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< wchar_t > (
        L"NumberOfTemporaryStrands",
        L"");
    }

    if (!LongitudinalRebarMaterial_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< wchar_t > (
        L"LongitudinalRebarMaterial",
        L"");
    }

    if (!NumberOfLongitudinalRebarRows_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< wchar_t > (
        L"NumberOfLongitudinalRebarRows",
        L"");
    }

    if (!TransverseReinforcementMaterial_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< wchar_t > (
        L"TransverseReinforcementMaterial",
        L"");
    }

    if (!NumberOfStirrupZones_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< wchar_t > (
        L"NumberOfStirrupZones",
        L"");
    }
  }

  GirderDataType* GirderDataType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class GirderDataType (*this, f, c);
  }

  GirderDataType::
  ~GirderDataType ()
  {
  }

  // BridgeDataType
  //

  BridgeDataType::
  BridgeDataType ()
  : ::xml_schema::type (),
    LeftRailingType_ (::xml_schema::flags (), this),
    RightRailingType_ (::xml_schema::flags (), this),
    SlabFc_ (::xml_schema::flags (), this),
    SlabThickness_ (::xml_schema::flags (), this),
    OverhangThickness_ (::xml_schema::flags (), this),
    NumberOfSpans_ (::xml_schema::flags (), this),
    NumberOfGirdersPerSpan_ (::xml_schema::flags (), this),
    SpanLengths_ (::xml_schema::flags (), this),
    PierData_ (::xml_schema::flags (), this),
    GirderData_ (::xml_schema::flags (), this),
    HaunchVolumeForAllSelectedGirders_ (::xml_schema::flags (), this),
    HaunchWeightForAllSelectedGirders_ (::xml_schema::flags (), this)
  {
  }

  BridgeDataType::
  BridgeDataType (const LeftRailingType_type& LeftRailingType,
                  const RightRailingType_type& RightRailingType,
                  const SlabFc_type& SlabFc,
                  const SlabThickness_type& SlabThickness,
                  const OverhangThickness_type& OverhangThickness,
                  const NumberOfSpans_type& NumberOfSpans,
                  const HaunchVolumeForAllSelectedGirders_type& HaunchVolumeForAllSelectedGirders,
                  const HaunchWeightForAllSelectedGirders_type& HaunchWeightForAllSelectedGirders)
  : ::xml_schema::type (),
    LeftRailingType_ (LeftRailingType, ::xml_schema::flags (), this),
    RightRailingType_ (RightRailingType, ::xml_schema::flags (), this),
    SlabFc_ (SlabFc, ::xml_schema::flags (), this),
    SlabThickness_ (SlabThickness, ::xml_schema::flags (), this),
    OverhangThickness_ (OverhangThickness, ::xml_schema::flags (), this),
    NumberOfSpans_ (NumberOfSpans, ::xml_schema::flags (), this),
    NumberOfGirdersPerSpan_ (::xml_schema::flags (), this),
    SpanLengths_ (::xml_schema::flags (), this),
    PierData_ (::xml_schema::flags (), this),
    GirderData_ (::xml_schema::flags (), this),
    HaunchVolumeForAllSelectedGirders_ (HaunchVolumeForAllSelectedGirders, ::xml_schema::flags (), this),
    HaunchWeightForAllSelectedGirders_ (HaunchWeightForAllSelectedGirders, ::xml_schema::flags (), this)
  {
  }

  BridgeDataType::
  BridgeDataType (const BridgeDataType& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    LeftRailingType_ (x.LeftRailingType_, f, this),
    RightRailingType_ (x.RightRailingType_, f, this),
    SlabFc_ (x.SlabFc_, f, this),
    SlabThickness_ (x.SlabThickness_, f, this),
    OverhangThickness_ (x.OverhangThickness_, f, this),
    NumberOfSpans_ (x.NumberOfSpans_, f, this),
    NumberOfGirdersPerSpan_ (x.NumberOfGirdersPerSpan_, f, this),
    SpanLengths_ (x.SpanLengths_, f, this),
    PierData_ (x.PierData_, f, this),
    GirderData_ (x.GirderData_, f, this),
    HaunchVolumeForAllSelectedGirders_ (x.HaunchVolumeForAllSelectedGirders_, f, this),
    HaunchWeightForAllSelectedGirders_ (x.HaunchWeightForAllSelectedGirders_, f, this)
  {
  }

  BridgeDataType::
  BridgeDataType (const xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    LeftRailingType_ (f, this),
    RightRailingType_ (f, this),
    SlabFc_ (f, this),
    SlabThickness_ (f, this),
    OverhangThickness_ (f, this),
    NumberOfSpans_ (f, this),
    NumberOfGirdersPerSpan_ (f, this),
    SpanLengths_ (f, this),
    PierData_ (f, this),
    GirderData_ (f, this),
    HaunchVolumeForAllSelectedGirders_ (f, this),
    HaunchWeightForAllSelectedGirders_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false);
      this->parse (p, f);
    }
  }

  void BridgeDataType::
  parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (i));

      // LeftRailingType
      //
      if (n.name () == L"LeftRailingType" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< LeftRailingType_type > r (
          LeftRailingType_traits::create (i, f, this));

        if (!LeftRailingType_.present ())
        {
          this->LeftRailingType_.set (r);
          continue;
        }
      }

      // RightRailingType
      //
      if (n.name () == L"RightRailingType" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< RightRailingType_type > r (
          RightRailingType_traits::create (i, f, this));

        if (!RightRailingType_.present ())
        {
          this->RightRailingType_.set (r);
          continue;
        }
      }

      // SlabFc
      //
      if (n.name () == L"SlabFc" && n.namespace_ ().empty ())
      {
        if (!SlabFc_.present ())
        {
          this->SlabFc_.set (SlabFc_traits::create (i, f, this));
          continue;
        }
      }

      // SlabThickness
      //
      if (n.name () == L"SlabThickness" && n.namespace_ ().empty ())
      {
        if (!SlabThickness_.present ())
        {
          this->SlabThickness_.set (SlabThickness_traits::create (i, f, this));
          continue;
        }
      }

      // OverhangThickness
      //
      if (n.name () == L"OverhangThickness" && n.namespace_ ().empty ())
      {
        if (!OverhangThickness_.present ())
        {
          this->OverhangThickness_.set (OverhangThickness_traits::create (i, f, this));
          continue;
        }
      }

      // NumberOfSpans
      //
      if (n.name () == L"NumberOfSpans" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< NumberOfSpans_type > r (
          NumberOfSpans_traits::create (i, f, this));

        if (!NumberOfSpans_.present ())
        {
          this->NumberOfSpans_.set (r);
          continue;
        }
      }

      // NumberOfGirdersPerSpan
      //
      if (n.name () == L"NumberOfGirdersPerSpan" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< NumberOfGirdersPerSpan_type > r (
          NumberOfGirdersPerSpan_traits::create (i, f, this));

        this->NumberOfGirdersPerSpan_.push_back (r);
        continue;
      }

      // SpanLengths
      //
      if (n.name () == L"SpanLengths" && n.namespace_ ().empty ())
      {
        this->SpanLengths_.push_back (SpanLengths_traits::create (i, f, this));
        continue;
      }

      // PierData
      //
      if (n.name () == L"PierData" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< PierData_type > r (
          PierData_traits::create (i, f, this));

        this->PierData_.push_back (r);
        continue;
      }

      // GirderData
      //
      if (n.name () == L"GirderData" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< GirderData_type > r (
          GirderData_traits::create (i, f, this));

        this->GirderData_.push_back (r);
        continue;
      }

      // HaunchVolumeForAllSelectedGirders
      //
      if (n.name () == L"HaunchVolumeForAllSelectedGirders" && n.namespace_ ().empty ())
      {
        if (!HaunchVolumeForAllSelectedGirders_.present ())
        {
          this->HaunchVolumeForAllSelectedGirders_.set (HaunchVolumeForAllSelectedGirders_traits::create (i, f, this));
          continue;
        }
      }

      // HaunchWeightForAllSelectedGirders
      //
      if (n.name () == L"HaunchWeightForAllSelectedGirders" && n.namespace_ ().empty ())
      {
        if (!HaunchWeightForAllSelectedGirders_.present ())
        {
          this->HaunchWeightForAllSelectedGirders_.set (HaunchWeightForAllSelectedGirders_traits::create (i, f, this));
          continue;
        }
      }

      break;
    }

    if (!LeftRailingType_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< wchar_t > (
        L"LeftRailingType",
        L"");
    }

    if (!RightRailingType_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< wchar_t > (
        L"RightRailingType",
        L"");
    }

    if (!SlabFc_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< wchar_t > (
        L"SlabFc",
        L"");
    }

    if (!SlabThickness_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< wchar_t > (
        L"SlabThickness",
        L"");
    }

    if (!OverhangThickness_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< wchar_t > (
        L"OverhangThickness",
        L"");
    }

    if (!NumberOfSpans_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< wchar_t > (
        L"NumberOfSpans",
        L"");
    }

    if (!HaunchVolumeForAllSelectedGirders_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< wchar_t > (
        L"HaunchVolumeForAllSelectedGirders",
        L"");
    }

    if (!HaunchWeightForAllSelectedGirders_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< wchar_t > (
        L"HaunchWeightForAllSelectedGirders",
        L"");
    }
  }

  BridgeDataType* BridgeDataType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class BridgeDataType (*this, f, c);
  }

  BridgeDataType::
  ~BridgeDataType ()
  {
  }

  // KDOTExport
  //

  KDOTExport::
  KDOTExport ()
  : ::xml_schema::type (),
    BridgeData_ (::xml_schema::flags (), this),
    version_ (version_default_value (), ::xml_schema::flags (), this)
  {
  }

  KDOTExport::
  KDOTExport (const KDOTExport& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    BridgeData_ (x.BridgeData_, f, this),
    version_ (x.version_, f, this)
  {
  }

  KDOTExport::
  KDOTExport (const xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    BridgeData_ (f, this),
    version_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, true);
      this->parse (p, f);
    }
  }

  void KDOTExport::
  parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (i));

      // BridgeData
      //
      if (n.name () == L"BridgeData" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< BridgeData_type > r (
          BridgeData_traits::create (i, f, this));

        if (!this->BridgeData_)
        {
          this->BridgeData_.set (r);
          continue;
        }
      }

      break;
    }

    while (p.more_attributes ())
    {
      const xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (i));

      if (n.name () == L"version" && n.namespace_ ().empty ())
      {
        this->version_.set (version_traits::create (i, f, this));
        continue;
      }
    }

    if (!version_.present ())
    {
      this->version_.set (version_default_value ());
    }
  }

  KDOTExport* KDOTExport::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class KDOTExport (*this, f, c);
  }

  KDOTExport::
  ~KDOTExport ()
  {
  }
}

#include <istream>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

namespace KDOT
{
  ::std::auto_ptr< ::KDOT::KDOTExport >
  KDOTExport_ (const ::std::wstring& u,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< wchar_t > h;

    ::xml_schema::dom::auto_ptr< xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< wchar_t > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

    ::std::auto_ptr< ::KDOT::KDOTExport > r (
      ::KDOT::KDOTExport_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::KDOT::KDOTExport >
  KDOTExport_ (const ::std::wstring& u,
               ::xml_schema::error_handler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::auto_ptr< xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< wchar_t > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< wchar_t > ();

    ::std::auto_ptr< ::KDOT::KDOTExport > r (
      ::KDOT::KDOTExport_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::KDOT::KDOTExport >
  KDOTExport_ (const ::std::wstring& u,
               xercesc::DOMErrorHandler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< wchar_t > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< wchar_t > ();

    ::std::auto_ptr< ::KDOT::KDOTExport > r (
      ::KDOT::KDOTExport_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::KDOT::KDOTExport >
  KDOTExport_ (::std::istream& is,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::KDOT::KDOTExport_ (isrc, f, p);
  }

  ::std::auto_ptr< ::KDOT::KDOTExport >
  KDOTExport_ (::std::istream& is,
               ::xml_schema::error_handler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::KDOT::KDOTExport_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::KDOT::KDOTExport >
  KDOTExport_ (::std::istream& is,
               xercesc::DOMErrorHandler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::KDOT::KDOTExport_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::KDOT::KDOTExport >
  KDOTExport_ (::std::istream& is,
               const ::std::wstring& sid,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::KDOT::KDOTExport_ (isrc, f, p);
  }

  ::std::auto_ptr< ::KDOT::KDOTExport >
  KDOTExport_ (::std::istream& is,
               const ::std::wstring& sid,
               ::xml_schema::error_handler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::KDOT::KDOTExport_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::KDOT::KDOTExport >
  KDOTExport_ (::std::istream& is,
               const ::std::wstring& sid,
               xercesc::DOMErrorHandler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::KDOT::KDOTExport_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::KDOT::KDOTExport >
  KDOTExport_ (xercesc::InputSource& i,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< wchar_t > h;

    ::xml_schema::dom::auto_ptr< xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< wchar_t > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

    ::std::auto_ptr< ::KDOT::KDOTExport > r (
      ::KDOT::KDOTExport_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::KDOT::KDOTExport >
  KDOTExport_ (xercesc::InputSource& i,
               ::xml_schema::error_handler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< wchar_t > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< wchar_t > ();

    ::std::auto_ptr< ::KDOT::KDOTExport > r (
      ::KDOT::KDOTExport_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::KDOT::KDOTExport >
  KDOTExport_ (xercesc::InputSource& i,
               xercesc::DOMErrorHandler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< wchar_t > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< wchar_t > ();

    ::std::auto_ptr< ::KDOT::KDOTExport > r (
      ::KDOT::KDOTExport_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::KDOT::KDOTExport >
  KDOTExport_ (const xercesc::DOMDocument& d,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::auto_ptr< xercesc::DOMDocument > c (
        static_cast< xercesc::DOMDocument* > (d.cloneNode (true)));

      ::std::auto_ptr< ::KDOT::KDOTExport > r (
        ::KDOT::KDOTExport_ (
          c, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    const xercesc::DOMElement& e (*d.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< wchar_t > n (
      ::xsd::cxx::xml::dom::name< wchar_t > (e));

    if (n.name () == L"KDOTExport" &&
        n.namespace_ () == L"http://www.pgsuper.com/KDOT")
    {
      ::std::auto_ptr< ::KDOT::KDOTExport > r (
        ::xsd::cxx::tree::traits< ::KDOT::KDOTExport, wchar_t >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
      n.name (),
      n.namespace_ (),
      L"KDOTExport",
      L"http://www.pgsuper.com/KDOT");
  }

  ::std::auto_ptr< ::KDOT::KDOTExport >
  KDOTExport_ (::xml_schema::dom::auto_ptr< xercesc::DOMDocument >& d,
               ::xml_schema::flags f,
               const ::xml_schema::properties&)
  {
    ::xml_schema::dom::auto_ptr< xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< wchar_t > n (
      ::xsd::cxx::xml::dom::name< wchar_t > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == L"KDOTExport" &&
        n.namespace_ () == L"http://www.pgsuper.com/KDOT")
    {
      ::std::auto_ptr< ::KDOT::KDOTExport > r (
        ::xsd::cxx::tree::traits< ::KDOT::KDOTExport, wchar_t >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
      n.name (),
      n.namespace_ (),
      L"KDOTExport",
      L"http://www.pgsuper.com/KDOT");
  }
}

#include <ostream>
#include <xsd/cxx/tree/error-handler.hxx>
#include <xsd/cxx/xml/dom/serialization-source.hxx>

namespace KDOT
{
  void
  operator<< (xercesc::DOMElement& e, const IndexType1& i)
  {
    e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::integer, wchar_t, ::xml_schema::simple_type >& > (i);
  }

  void
  operator<< (xercesc::DOMAttr& a, const IndexType1& i)
  {
    a << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::integer, wchar_t, ::xml_schema::simple_type >& > (i);
  }

  void
  operator<< (::xml_schema::list_stream& l,
              const IndexType1& i)
  {
    l << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::integer, wchar_t, ::xml_schema::simple_type >& > (i);
  }

  void
  operator<< (xercesc::DOMElement& e, const GirderKeyType& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // SpanIndex
    //
    {
      xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          L"SpanIndex",
          e));

      s << i.SpanIndex ();
    }

    // GirderIndex
    //
    {
      xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          L"GirderIndex",
          e));

      s << i.GirderIndex ();
    }
  }

  void
  operator<< (xercesc::DOMElement& e, const NamedDoubleType& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // ParameterName
    //
    {
      xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          L"ParameterName",
          e));

      s << i.ParameterName ();
    }

    // Value
    //
    {
      xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          L"Value",
          e));

      s << ::xml_schema::as_double(i.Value ());
    }
  }

  void
  operator<< (xercesc::DOMElement& e, const Point2DType& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // X
    //
    {
      xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          L"X",
          e));

      s << ::xml_schema::as_double(i.X ());
    }

    // Y
    //
    {
      xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          L"Y",
          e));

      s << ::xml_schema::as_double(i.Y ());
    }
  }

  void
  operator<< (xercesc::DOMElement& e, const DebondDataType& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // StrandIndex
    //
    {
      xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          L"StrandIndex",
          e));

      s << i.StrandIndex ();
    }

    // StartDebondLength
    //
    {
      xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          L"StartDebondLength",
          e));

      s << ::xml_schema::as_double(i.StartDebondLength ());
    }

    // EndDebondLength
    //
    {
      xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          L"EndDebondLength",
          e));

      s << ::xml_schema::as_double(i.EndDebondLength ());
    }
  }

  void
  operator<< (xercesc::DOMElement& e, const StrandExtensionDataType& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // StrandIndex
    //
    {
      xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          L"StrandIndex",
          e));

      s << i.StrandIndex ();
    }

    // IsStartExtended
    //
    {
      xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          L"IsStartExtended",
          e));

      s << i.IsStartExtended ();
    }

    // IsEndExtended
    //
    {
      xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          L"IsEndExtended",
          e));

      s << i.IsEndExtended ();
    }
  }

  void
  operator<< (xercesc::DOMElement& e, const HarpingPointDataType& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // Location
    //
    {
      xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          L"Location",
          e));

      s << ::xml_schema::as_double(i.Location ());
    }

    // HoldDownForce
    //
    {
      xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          L"HoldDownForce",
          e));

      s << ::xml_schema::as_double(i.HoldDownForce ());
    }
  }

  void
  operator<< (xercesc::DOMElement& e, const PierDataType& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // Station
    //
    {
      xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          L"Station",
          e));

      s << ::xml_schema::as_double(i.Station ());
    }

    // Skew
    //
    {
      xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          L"Skew",
          e));

      s << ::xml_schema::as_double(i.Skew ());
    }

    // backGirderEndOffset
    //
    {
      xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          L"backGirderEndOffset",
          e));

      s << ::xml_schema::as_double(i.backGirderEndOffset ());
    }

    // aheadGirderEndOffset
    //
    {
      xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          L"aheadGirderEndOffset",
          e));

      s << ::xml_schema::as_double(i.aheadGirderEndOffset ());
    }
  }

  void
  operator<< (xercesc::DOMElement& e, const PrestressingStrandType& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // Name
    //
    {
      xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          L"Name",
          e));

      s << i.Name ();
    }

    // NominalDiameter
    //
    {
      xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          L"NominalDiameter",
          e));

      s << ::xml_schema::as_double(i.NominalDiameter ());
    }
  }

  void
  operator<< (xercesc::DOMElement& e, const RebarMaterialType& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // Grade
    //
    {
      xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          L"Grade",
          e));

      s << i.Grade ();
    }

    // Type
    //
    {
      xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          L"Type",
          e));

      s << i.Type ();
    }
  }

  void
  operator<< (xercesc::DOMElement& e, const RebarRowInstanceType& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // BarStart
    //
    {
      xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          L"BarStart",
          e));

      s << ::xml_schema::as_double(i.BarStart ());
    }

    // BarEnd
    //
    {
      xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          L"BarEnd",
          e));

      s << ::xml_schema::as_double(i.BarEnd ());
    }

    // Face
    //
    {
      xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          L"Face",
          e));

      s << i.Face ();
    }

    // Cover
    //
    {
      xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          L"Cover",
          e));

      s << ::xml_schema::as_double(i.Cover ());
    }

    // NumberOfBars
    //
    {
      xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          L"NumberOfBars",
          e));

      s << i.NumberOfBars ();
    }

    // Spacing
    //
    {
      xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          L"Spacing",
          e));

      s << ::xml_schema::as_double(i.Spacing ());
    }

    // Size
    //
    {
      xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          L"Size",
          e));

      s << i.Size ();
    }
  }

  void
  operator<< (xercesc::DOMElement& e, const StirrupZoneType& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // StartLocation
    //
    {
      xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          L"StartLocation",
          e));

      s << ::xml_schema::as_double(i.StartLocation ());
    }

    // EndLocation
    //
    {
      xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          L"EndLocation",
          e));

      s << ::xml_schema::as_double(i.EndLocation ());
    }

    // BarSize
    //
    {
      xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          L"BarSize",
          e));

      s << i.BarSize ();
    }

    // BarSpacing
    //
    {
      xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          L"BarSpacing",
          e));

      s << ::xml_schema::as_double(i.BarSpacing ());
    }

    // NumVerticalLegs
    //
    {
      xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          L"NumVerticalLegs",
          e));

      s << ::xml_schema::as_double(i.NumVerticalLegs ());
    }

    // NumLegsExtendedIntoDeck
    //
    {
      xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          L"NumLegsExtendedIntoDeck",
          e));

      s << ::xml_schema::as_double(i.NumLegsExtendedIntoDeck ());
    }

    // ConfinementBarSize
    //
    {
      xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          L"ConfinementBarSize",
          e));

      s << i.ConfinementBarSize ();
    }
  }

  void
  operator<< (xercesc::DOMElement& e, const CamberResultType& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // FractionalLocation
    //
    {
      xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          L"FractionalLocation",
          e));

      s << ::xml_schema::as_double(i.FractionalLocation ());
    }

    // Location
    //
    {
      xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          L"Location",
          e));

      s << ::xml_schema::as_double(i.Location ());
    }

    // LocationFromEndOfGirder
    //
    {
      xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          L"LocationFromEndOfGirder",
          e));

      s << ::xml_schema::as_double(i.LocationFromEndOfGirder ());
    }

    // TopOfDeckElevation
    //
    {
      xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          L"TopOfDeckElevation",
          e));

      s << ::xml_schema::as_double(i.TopOfDeckElevation ());
    }

    // TopOfGirderChordElevation
    //
    {
      xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          L"TopOfGirderChordElevation",
          e));

      s << ::xml_schema::as_double(i.TopOfGirderChordElevation ());
    }

    // TopOfGirderElevationPriorToSlabCasting
    //
    {
      xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          L"TopOfGirderElevationPriorToSlabCasting",
          e));

      s << ::xml_schema::as_double(i.TopOfGirderElevationPriorToSlabCasting ());
    }

    // TopOfGirderElevationAtFinal
    //
    {
      xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          L"TopOfGirderElevationAtFinal",
          e));

      s << ::xml_schema::as_double(i.TopOfGirderElevationAtFinal ());
    }

    // GirderCamberAtRelease
    //
    {
      xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          L"GirderCamberAtRelease",
          e));

      s << ::xml_schema::as_double(i.GirderCamberAtRelease ());
    }

    // GirderCamberPriorToDeckCasting
    //
    {
      xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          L"GirderCamberPriorToDeckCasting",
          e));

      s << ::xml_schema::as_double(i.GirderCamberPriorToDeckCasting ());
    }

    // GirderCamberAtFinal
    //
    {
      xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          L"GirderCamberAtFinal",
          e));

      s << ::xml_schema::as_double(i.GirderCamberAtFinal ());
    }
  }

  void
  operator<< (xercesc::DOMElement& e, const GirderDataType& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // GirderKey
    //
    {
      xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          L"GirderKey",
          e));

      s << i.GirderKey ();
    }

    // GirderType
    //
    {
      xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          L"GirderType",
          e));

      s << i.GirderType ();
    }

    // SectionDimensions
    //
    for (GirderDataType::SectionDimensions_const_iterator
         b (i.SectionDimensions ().begin ()), n (i.SectionDimensions ().end ());
         b != n; ++b)
    {
      xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          L"SectionDimensions",
          e));

      s << *b;
    }

    // Fci
    //
    {
      xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          L"Fci",
          e));

      s << ::xml_schema::as_double(i.Fci ());
    }

    // Fc
    //
    {
      xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          L"Fc",
          e));

      s << ::xml_schema::as_double(i.Fc ());
    }

    // Eci
    //
    {
      xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          L"Eci",
          e));

      s << ::xml_schema::as_double(i.Eci ());
    }

    // Ec
    //
    {
      xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          L"Ec",
          e));

      s << ::xml_schema::as_double(i.Ec ());
    }

    // GirderLength
    //
    {
      xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          L"GirderLength",
          e));

      s << ::xml_schema::as_double(i.GirderLength ());
    }

    // SpacingLeftStart
    //
    {
      xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          L"SpacingLeftStart",
          e));

      s << ::xml_schema::as_double(i.SpacingLeftStart ());
    }

    // SpacingRightStart
    //
    {
      xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          L"SpacingRightStart",
          e));

      s << ::xml_schema::as_double(i.SpacingRightStart ());
    }

    // SpacingLeftEnd
    //
    {
      xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          L"SpacingLeftEnd",
          e));

      s << ::xml_schema::as_double(i.SpacingLeftEnd ());
    }

    // SpacingRightEnd
    //
    {
      xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          L"SpacingRightEnd",
          e));

      s << ::xml_schema::as_double(i.SpacingRightEnd ());
    }

    // NumberOfHarpingPoints
    //
    {
      xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          L"NumberOfHarpingPoints",
          e));

      s << i.NumberOfHarpingPoints ();
    }

    // HarpingPoints
    //
    for (GirderDataType::HarpingPoints_const_iterator
         b (i.HarpingPoints ().begin ()), n (i.HarpingPoints ().end ());
         b != n; ++b)
    {
      xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          L"HarpingPoints",
          e));

      s << *b;
    }

    // LiftingLocation
    //
    {
      xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          L"LiftingLocation",
          e));

      s << ::xml_schema::as_double(i.LiftingLocation ());
    }

    // LeadingHaulingLocation
    //
    {
      xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          L"LeadingHaulingLocation",
          e));

      s << ::xml_schema::as_double(i.LeadingHaulingLocation ());
    }

    // TrailingHaulingLocation
    //
    {
      xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          L"TrailingHaulingLocation",
          e));

      s << ::xml_schema::as_double(i.TrailingHaulingLocation ());
    }

    // StartADimension
    //
    {
      xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          L"StartADimension",
          e));

      s << ::xml_schema::as_double(i.StartADimension ());
    }

    // EndADimension
    //
    {
      xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          L"EndADimension",
          e));

      s << ::xml_schema::as_double(i.EndADimension ());
    }

    // GirderHaunchVolume
    //
    {
      xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          L"GirderHaunchVolume",
          e));

      s << ::xml_schema::as_double(i.GirderHaunchVolume ());
    }

    // IsPrismatic
    //
    {
      xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          L"IsPrismatic",
          e));

      s << i.IsPrismatic ();
    }

    // Area
    //
    {
      xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          L"Area",
          e));

      s << ::xml_schema::as_double(i.Area ());
    }

    // Ix
    //
    {
      xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          L"Ix",
          e));

      s << ::xml_schema::as_double(i.Ix ());
    }

    // Iy
    //
    {
      xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          L"Iy",
          e));

      s << ::xml_schema::as_double(i.Iy ());
    }

    // d
    //
    {
      xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          L"d",
          e));

      s << ::xml_schema::as_double(i.d ());
    }

    // Yt
    //
    {
      xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          L"Yt",
          e));

      s << ::xml_schema::as_double(i.Yt ());
    }

    // Yb
    //
    {
      xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          L"Yb",
          e));

      s << ::xml_schema::as_double(i.Yb ());
    }

    // St
    //
    {
      xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          L"St",
          e));

      s << ::xml_schema::as_double(i.St ());
    }

    // Sb
    //
    {
      xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          L"Sb",
          e));

      s << ::xml_schema::as_double(i.Sb ());
    }

    // P
    //
    {
      xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          L"P",
          e));

      s << ::xml_schema::as_double(i.P ());
    }

    // W
    //
    {
      xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          L"W",
          e));

      s << ::xml_schema::as_double(i.W ());
    }

    // Wtotal
    //
    {
      xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          L"Wtotal",
          e));

      s << ::xml_schema::as_double(i.Wtotal ());
    }

    // Area_c
    //
    {
      xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          L"Area_c",
          e));

      s << ::xml_schema::as_double(i.Area_c ());
    }

    // Ix_c
    //
    {
      xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          L"Ix_c",
          e));

      s << ::xml_schema::as_double(i.Ix_c ());
    }

    // Iy_c
    //
    {
      xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          L"Iy_c",
          e));

      s << ::xml_schema::as_double(i.Iy_c ());
    }

    // d_c
    //
    {
      xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          L"d_c",
          e));

      s << ::xml_schema::as_double(i.d_c ());
    }

    // Yt_c
    //
    {
      xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          L"Yt_c",
          e));

      s << ::xml_schema::as_double(i.Yt_c ());
    }

    // Yb_c
    //
    {
      xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          L"Yb_c",
          e));

      s << ::xml_schema::as_double(i.Yb_c ());
    }

    // St_c
    //
    {
      xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          L"St_c",
          e));

      s << ::xml_schema::as_double(i.St_c ());
    }

    // Sb_c
    //
    {
      xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          L"Sb_c",
          e));

      s << ::xml_schema::as_double(i.Sb_c ());
    }

    // StrandEccentricityAtEnds
    //
    {
      xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          L"StrandEccentricityAtEnds",
          e));

      s << ::xml_schema::as_double(i.StrandEccentricityAtEnds ());
    }

    // StrandEccentricityAtHPs
    //
    {
      xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          L"StrandEccentricityAtHPs",
          e));

      s << ::xml_schema::as_double(i.StrandEccentricityAtHPs ());
    }

    // PrestressingStrandMaterial
    //
    {
      xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          L"PrestressingStrandMaterial",
          e));

      s << i.PrestressingStrandMaterial ();
    }

    // NumberOfStraightStrands
    //
    {
      xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          L"NumberOfStraightStrands",
          e));

      s << i.NumberOfStraightStrands ();
    }

    // StraightStrandCoordinates
    //
    for (GirderDataType::StraightStrandCoordinates_const_iterator
         b (i.StraightStrandCoordinates ().begin ()), n (i.StraightStrandCoordinates ().end ());
         b != n; ++b)
    {
      xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          L"StraightStrandCoordinates",
          e));

      s << *b;
    }

    // NumberOfDebondedStraightStrands
    //
    {
      xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          L"NumberOfDebondedStraightStrands",
          e));

      s << i.NumberOfDebondedStraightStrands ();
    }

    // StraightStrandDebonding
    //
    for (GirderDataType::StraightStrandDebonding_const_iterator
         b (i.StraightStrandDebonding ().begin ()), n (i.StraightStrandDebonding ().end ());
         b != n; ++b)
    {
      xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          L"StraightStrandDebonding",
          e));

      s << *b;
    }

    // NumberOfExtendedStraightStrands
    //
    {
      xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          L"NumberOfExtendedStraightStrands",
          e));

      s << i.NumberOfExtendedStraightStrands ();
    }

    // StraightStrandExtensions
    //
    for (GirderDataType::StraightStrandExtensions_const_iterator
         b (i.StraightStrandExtensions ().begin ()), n (i.StraightStrandExtensions ().end ());
         b != n; ++b)
    {
      xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          L"StraightStrandExtensions",
          e));

      s << *b;
    }

    // NumberOfHarpedStrands
    //
    {
      xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          L"NumberOfHarpedStrands",
          e));

      s << i.NumberOfHarpedStrands ();
    }

    // HarpedStrandCoordinatesAtEnds
    //
    for (GirderDataType::HarpedStrandCoordinatesAtEnds_const_iterator
         b (i.HarpedStrandCoordinatesAtEnds ().begin ()), n (i.HarpedStrandCoordinatesAtEnds ().end ());
         b != n; ++b)
    {
      xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          L"HarpedStrandCoordinatesAtEnds",
          e));

      s << *b;
    }

    // HarpedStrandCoordinatesAtHP
    //
    for (GirderDataType::HarpedStrandCoordinatesAtHP_const_iterator
         b (i.HarpedStrandCoordinatesAtHP ().begin ()), n (i.HarpedStrandCoordinatesAtHP ().end ());
         b != n; ++b)
    {
      xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          L"HarpedStrandCoordinatesAtHP",
          e));

      s << *b;
    }

    // NumberOfTemporaryStrands
    //
    {
      xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          L"NumberOfTemporaryStrands",
          e));

      s << i.NumberOfTemporaryStrands ();
    }

    // TemporaryStrandCoordinates
    //
    for (GirderDataType::TemporaryStrandCoordinates_const_iterator
         b (i.TemporaryStrandCoordinates ().begin ()), n (i.TemporaryStrandCoordinates ().end ());
         b != n; ++b)
    {
      xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          L"TemporaryStrandCoordinates",
          e));

      s << *b;
    }

    // LongitudinalRebarMaterial
    //
    {
      xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          L"LongitudinalRebarMaterial",
          e));

      s << i.LongitudinalRebarMaterial ();
    }

    // NumberOfLongitudinalRebarRows
    //
    {
      xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          L"NumberOfLongitudinalRebarRows",
          e));

      s << i.NumberOfLongitudinalRebarRows ();
    }

    // LongitudinalRebarRows
    //
    for (GirderDataType::LongitudinalRebarRows_const_iterator
         b (i.LongitudinalRebarRows ().begin ()), n (i.LongitudinalRebarRows ().end ());
         b != n; ++b)
    {
      xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          L"LongitudinalRebarRows",
          e));

      s << *b;
    }

    // TransverseReinforcementMaterial
    //
    {
      xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          L"TransverseReinforcementMaterial",
          e));

      s << i.TransverseReinforcementMaterial ();
    }

    // NumberOfStirrupZones
    //
    {
      xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          L"NumberOfStirrupZones",
          e));

      s << i.NumberOfStirrupZones ();
    }

    // StirrupZones
    //
    for (GirderDataType::StirrupZones_const_iterator
         b (i.StirrupZones ().begin ()), n (i.StirrupZones ().end ());
         b != n; ++b)
    {
      xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          L"StirrupZones",
          e));

      s << *b;
    }

    // CamberResults
    //
    for (GirderDataType::CamberResults_const_iterator
         b (i.CamberResults ().begin ()), n (i.CamberResults ().end ());
         b != n; ++b)
    {
      xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          L"CamberResults",
          e));

      s << *b;
    }
  }

  void
  operator<< (xercesc::DOMElement& e, const BridgeDataType& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // LeftRailingType
    //
    {
      xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          L"LeftRailingType",
          e));

      s << i.LeftRailingType ();
    }

    // RightRailingType
    //
    {
      xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          L"RightRailingType",
          e));

      s << i.RightRailingType ();
    }

    // SlabFc
    //
    {
      xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          L"SlabFc",
          e));

      s << ::xml_schema::as_double(i.SlabFc ());
    }

    // SlabThickness
    //
    {
      xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          L"SlabThickness",
          e));

      s << ::xml_schema::as_double(i.SlabThickness ());
    }

    // OverhangThickness
    //
    {
      xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          L"OverhangThickness",
          e));

      s << ::xml_schema::as_double(i.OverhangThickness ());
    }

    // NumberOfSpans
    //
    {
      xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          L"NumberOfSpans",
          e));

      s << i.NumberOfSpans ();
    }

    // NumberOfGirdersPerSpan
    //
    for (BridgeDataType::NumberOfGirdersPerSpan_const_iterator
         b (i.NumberOfGirdersPerSpan ().begin ()), n (i.NumberOfGirdersPerSpan ().end ());
         b != n; ++b)
    {
      xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          L"NumberOfGirdersPerSpan",
          e));

      s << *b;
    }

    // SpanLengths
    //
    for (BridgeDataType::SpanLengths_const_iterator
         b (i.SpanLengths ().begin ()), n (i.SpanLengths ().end ());
         b != n; ++b)
    {
      xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          L"SpanLengths",
          e));

      s << ::xml_schema::as_double (*b);
    }

    // PierData
    //
    for (BridgeDataType::PierData_const_iterator
         b (i.PierData ().begin ()), n (i.PierData ().end ());
         b != n; ++b)
    {
      xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          L"PierData",
          e));

      s << *b;
    }

    // GirderData
    //
    for (BridgeDataType::GirderData_const_iterator
         b (i.GirderData ().begin ()), n (i.GirderData ().end ());
         b != n; ++b)
    {
      xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          L"GirderData",
          e));

      s << *b;
    }

    // HaunchVolumeForAllSelectedGirders
    //
    {
      xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          L"HaunchVolumeForAllSelectedGirders",
          e));

      s << ::xml_schema::as_double(i.HaunchVolumeForAllSelectedGirders ());
    }

    // HaunchWeightForAllSelectedGirders
    //
    {
      xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          L"HaunchWeightForAllSelectedGirders",
          e));

      s << ::xml_schema::as_double(i.HaunchWeightForAllSelectedGirders ());
    }
  }

  void
  KDOTExport_ (::std::ostream& o,
               const ::KDOT::KDOTExport& s,
               const ::xml_schema::namespace_infomap& m,
               const ::std::wstring& e,
               ::xml_schema::flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0);

    ::xml_schema::dom::auto_ptr< xercesc::DOMDocument > d (
      ::KDOT::KDOTExport_ (s, m, f));

    ::xsd::cxx::tree::error_handler< wchar_t > h;

    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
    }
  }

  void
  KDOTExport_ (::std::ostream& o,
               const ::KDOT::KDOTExport& s,
               ::xml_schema::error_handler& h,
               const ::xml_schema::namespace_infomap& m,
               const ::std::wstring& e,
               ::xml_schema::flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0);

    ::xml_schema::dom::auto_ptr< xercesc::DOMDocument > d (
      ::KDOT::KDOTExport_ (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< wchar_t > ();
    }
  }

  void
  KDOTExport_ (::std::ostream& o,
               const ::KDOT::KDOTExport& s,
               xercesc::DOMErrorHandler& h,
               const ::xml_schema::namespace_infomap& m,
               const ::std::wstring& e,
               ::xml_schema::flags f)
  {
    ::xml_schema::dom::auto_ptr< xercesc::DOMDocument > d (
      ::KDOT::KDOTExport_ (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< wchar_t > ();
    }
  }

  void
  KDOTExport_ (xercesc::XMLFormatTarget& t,
               const ::KDOT::KDOTExport& s,
               const ::xml_schema::namespace_infomap& m,
               const ::std::wstring& e,
               ::xml_schema::flags f)
  {
    ::xml_schema::dom::auto_ptr< xercesc::DOMDocument > d (
      ::KDOT::KDOTExport_ (s, m, f));

    ::xsd::cxx::tree::error_handler< wchar_t > h;

    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
    }
  }

  void
  KDOTExport_ (xercesc::XMLFormatTarget& t,
               const ::KDOT::KDOTExport& s,
               ::xml_schema::error_handler& h,
               const ::xml_schema::namespace_infomap& m,
               const ::std::wstring& e,
               ::xml_schema::flags f)
  {
    ::xml_schema::dom::auto_ptr< xercesc::DOMDocument > d (
      ::KDOT::KDOTExport_ (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< wchar_t > ();
    }
  }

  void
  KDOTExport_ (xercesc::XMLFormatTarget& t,
               const ::KDOT::KDOTExport& s,
               xercesc::DOMErrorHandler& h,
               const ::xml_schema::namespace_infomap& m,
               const ::std::wstring& e,
               ::xml_schema::flags f)
  {
    ::xml_schema::dom::auto_ptr< xercesc::DOMDocument > d (
      ::KDOT::KDOTExport_ (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< wchar_t > ();
    }
  }

  void
  KDOTExport_ (xercesc::DOMDocument& d,
               const ::KDOT::KDOTExport& s,
               ::xml_schema::flags)
  {
    xercesc::DOMElement& e (*d.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< wchar_t > n (
      ::xsd::cxx::xml::dom::name< wchar_t > (e));

    if (n.name () == L"KDOTExport" &&
        n.namespace_ () == L"http://www.pgsuper.com/KDOT")
    {
      e << s;
    }
    else
    {
      throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
        n.name (),
        n.namespace_ (),
        L"KDOTExport",
        L"http://www.pgsuper.com/KDOT");
    }
  }

  ::xml_schema::dom::auto_ptr< xercesc::DOMDocument >
  KDOTExport_ (const ::KDOT::KDOTExport& s,
               const ::xml_schema::namespace_infomap& m,
               ::xml_schema::flags f)
  {
    ::xml_schema::dom::auto_ptr< xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::serialize< wchar_t > (
        L"KDOTExport",
        L"http://www.pgsuper.com/KDOT",
        m, f));

    ::KDOT::KDOTExport_ (*d, s, f);
    return d;
  }

  void
  operator<< (xercesc::DOMElement& e, const KDOTExport& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // BridgeData
    //
    if (i.BridgeData ())
    {
      xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          L"BridgeData",
          e));

      s << *i.BridgeData ();
    }

    // version
    //
    {
      xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          L"version",
          e));

      a << ::xml_schema::as_decimal(i.version ());
    }
  }
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

