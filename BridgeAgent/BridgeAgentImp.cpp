///////////////////////////////////////////////////////////////////////
// PGSuper - Prestressed Girder SUPERstructure Design and Analysis
// Copyright © 1999-2023  Washington State Department of Transportation
//                        Bridge and Structures Office
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the Alternate Route Open Source License as 
// published by the Washington State Department of Transportation, 
// Bridge and Structures Office.
//
// This program is distributed in the hope that it will be useful, but 
// distribution is AS IS, WITHOUT ANY WARRANTY; without even the implied 
// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See 
// the Alternate Route Open Source License for more details.
//
// You should have received a copy of the Alternate Route Open Source 
// License along with this program; if not, write to the Washington 
// State Department of Transportation, Bridge and Structures Office, 
// P.O. Box  47340, Olympia, WA 98503, USA or e-mail 
// Bridge_Support@wsdot.wa.gov
///////////////////////////////////////////////////////////////////////

// BridgeAgentImp.cpp : Implementation of CBridgeAgentImp
#include "stdafx.h"
#include "BridgeAgent.h"
#include "BridgeAgentImp.h"
#include "BridgeHelpers.h"
#include <PGSuperException.h>
#include "DeckEdgeBuilder.h"

#include <PsgLib\LibraryManager.h>
#include <PsgLib\GirderLibraryEntry.h>
#include <PsgLib\ConnectionLibraryEntry.h>
#include <PsgLib\UnitServer.h>

#include <PgsExt\BridgeDescription2.h>
#include <PgsExt\DeckDescription2.h>
#include <PgsExt\PierData2.h>
#include <PgsExt\SpanData2.h>
#include <PgsExt\PrecastSegmentData.h>
#include <PgsExt\TemporarySupportData.h>
#include <PgsExt\ClosureJointData.h>
#include <PgsExt\GirderModelFactory.h>
#include <PgsExt\PoiMap.h>
#include <PgsExt\StabilityAnalysisPoint.h>
#include <PgsExt\AnalysisResult.h>

#include <PgsExt\DevelopmentLength.h>

#include <PgsExt\ReportPointOfInterest.h>
#include <PsgLib\ShearData.h>
#include <PgsExt\LongitudinalRebarData.h>
#include <PgsExt\PointLoadData.h>
#include <PgsExt\DistributedLoadData.h>
#include <PgsExt\MomentLoadData.h>
#include <PgsExt\StatusItem.h>
#include <PgsExt\GirderLabel.h>

#include <MathEx.h>
#include <Math\MathUtils.h>
#include <Math\PiecewiseFunction.h>
#include <System\Flags.h>
#include <Materials/Materials.h>

#include <IFace\DrawBridgeSettings.h>
#include <EAF\EAFDisplayUnits.h>
#include <IFace\ShearCapacity.h>
#include <IFace\GirderHandling.h>
#include <IFace\GirderHandlingSpecCriteria.h>
#include <IFace\StatusCenter.h>
#include <IFace\BeamFactory.h>
#include <IFace\EditByUI.h>
#include <IFace\MomentCapacity.h>
#include <IFace\AgeAdjustedMaterial.h>
#include <IFace\DocumentType.h>
#include <IFace\Allowables.h>

#include <PgsExt\DesignConfigUtil.h>

#include <algorithm>
#include <cctype>
#include <numeric>
#include <afxext.h>

#include <boost\foreach.hpp> // for BOOST_REVERSE_FOREACH

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#if defined _DEBUG || defined _BETA_VERSION
//#define CHECK_POI_CONVERSIONS // if this is defined the POI conversion methods are checked. Note, this can significantly reduce performance
#endif

#define CLEAR_ALL       0
#define COGO_MODEL      1
#define BRIDGE          2
#define GIRDER          3
#define LOADS           4

// this agent is "read only" to the external users. however, we do have data that must be changed
// we cast away constness during validation
#define VALIDATE(x) {if ( !(const_cast<CBridgeAgentImp*>(this)->Validate((x))) ) THROW_SHUTDOWN(_T("Fatal Error in Bridge Agent"),XREASON_AGENTVALIDATIONFAILURE,true);}
#define INVALIDATE(x) Invalidate((x))

#define VALIDATE_POINTS_OF_INTEREST(_girder_key_) (const_cast<CBridgeAgentImp*>(this)->ValidatePointsOfInterest(_girder_key_))

#define LEFT_DECK_EDGE_LAYOUT_LINE_ID  -500
#define RIGHT_DECK_EDGE_LAYOUT_LINE_ID -501

#define DECK_REBAR_OFFSET 0.0015 // distance from the deck rebar cutoff point to the adjacent POI that is offset just a little so we capture jumps

inline SectionBias GetSectionBias(const pgsPointOfInterest& poi)
{
   return (poi.HasAttribute(POI_SECTCHANGE_LEFTFACE) || poi.HasAttribute(POI_CASTING_BOUNDARY_END) ? sbLeft : sbRight);
}

//-----------------------------------------------------------------------------
CollectionIndexType LimitStateToShearIndex(pgsTypes::LimitState limitState)
{
   ATLASSERT(IsStrengthLimitState(limitState));
   CollectionIndexType idx;

   switch (limitState)
   {
   case pgsTypes::StrengthI:                         idx = 0;       break;
   case pgsTypes::StrengthII:                        idx = 1;       break;
   case pgsTypes::StrengthI_Inventory:               idx = 2;       break;
   case pgsTypes::StrengthI_Operating:               idx = 3;       break;
   case pgsTypes::StrengthI_LegalRoutine:            idx = 4;       break;
   case pgsTypes::StrengthI_LegalSpecial:            idx = 5;       break;
   case pgsTypes::StrengthI_LegalEmergency:          idx = 6;       break;
   case pgsTypes::StrengthII_PermitRoutine:          idx = 7;       break;
   case pgsTypes::StrengthII_PermitSpecial:          idx = 8;       break;
   default:
      ATLASSERT(false); // is there a new limit state type?
      idx = 0;
      break;
   }

   return idx;
}

class PoiNotInSpan
{
public:
   PoiNotInSpan(const CBridgeAgentImp* pBridgeAgent,const CSpanKey& spanKey) :
      m_pBridgeAgent(pBridgeAgent),m_SpanKey(spanKey)
      {
         m_Lspan = spanKey.spanIndex == ALL_SPANS ? -1 : m_pBridgeAgent->GetSpanLength(spanKey);
      };

   bool operator()(const pgsPointOfInterest& poi) const
   {
      if ( m_SpanKey.spanIndex == ALL_SPANS )
      {
         // poi has a POI_SPAN attribute and we are matching all spans, so keep it
         return false;
      }

      CSpanKey spanKey;
      Float64 Xspan;
      m_pBridgeAgent->ConvertPoiToSpanPoint(poi,&spanKey,&Xspan);

      if ( m_SpanKey.spanIndex == spanKey.spanIndex && IsEqual(Xspan,m_Lspan) )
      {
         // if poi is at the end of the span, the poi is in the target span
         // otherwise it is the first poi in the next span
         return poi.HasAttribute(POI_SPAN | POI_10L) ? false : true;
      }

      if ( poi.HasAttribute(POI_SPAN | POI_0L) && m_SpanKey.spanIndex == spanKey.spanIndex+1 )
      {
         // poi has start of span attribute and it was found to be in the previous span
         // if it is right at the end of the previous span, then it is actually the first poi
         // in the target span
         Float64 LprevSpan = m_pBridgeAgent->GetSpanLength(spanKey);
         if ( IsEqual(Xspan,LprevSpan) )
         {
            // poi is in the target span
            return false;
         }
      }

      return (spanKey.spanIndex != m_SpanKey.spanIndex ? true /* poi is NOT in the target span*/ : false /* poi is in the target span*/);
   };

private:
   const CBridgeAgentImp* m_pBridgeAgent;
   CSpanKey m_SpanKey; // target span
   Float64 m_Lspan;
};

//function to translate project loads to bridge loads

inline IUserDefinedLoads::UserDefinedLoadCase Project2BridgeLoads(UserLoads::LoadCase plc)
{
#if defined _DEBUG
   IUserDefinedLoads::UserDefinedLoadCase ulc;
   if (plc==UserLoads::DC)
   {
      ulc = IUserDefinedLoads::userDC;
   }
   else if (plc==UserLoads::DW)
   {
      ulc = IUserDefinedLoads::userDW;
   }
   else if (plc==UserLoads::LL_IM)
   {
      ulc = IUserDefinedLoads::userLL_IM;
   }
   else
   {
      ATLASSERT(false);
      ulc = IUserDefinedLoads::userDC;
   }
   ATLASSERT(ulc == (IUserDefinedLoads::UserDefinedLoadCase)plc);
#endif
   return (IUserDefinedLoads::UserDefinedLoadCase)plc;
}

// Function to choose confinement bars from primary and additional
static void ChooseConfinementBars(Float64 requiredZoneLength, 
                                  Float64 primSpc, Float64 primZonL, WBFL::Materials::Rebar::Size primSize,
                                  Float64 addlSpc, Float64 addlZonL, WBFL::Materials::Rebar::Size addlSize,
                                  WBFL::Materials::Rebar::Size* pSize, Float64* pProvidedZoneLength, Float64* pSpacing)
{
   // Start assuming the worst
   *pSize = WBFL::Materials::Rebar::Size::bsNone;
   *pProvidedZoneLength = 0.0;
   *pSpacing = 0.0;

   // methods must have bars and non-zero spacing just to be in the running
   bool is_prim = primSize != WBFL::Materials::Rebar::Size::bsNone && 0.0 < primSpc;
   bool is_addl = addlSize != WBFL::Materials::Rebar::Size::bsNone && 0.0 < addlSpc;

   // Both must meet required zone length to qualify for a run-off
   if (is_prim && is_addl && IsLT(requiredZoneLength,primZonL) && IsLT(requiredZoneLength,addlZonL))
   {
      // both meet zone length req. choose smallest spacing
      if (primSpc < addlSpc)
      {
         *pSize = primSize;
         *pProvidedZoneLength = primZonL;
         *pSpacing = primSpc;
      }
      else
      {
         *pSize = addlSize;
         *pProvidedZoneLength = addlZonL;
         *pSpacing = addlSpc;
      }
   }
   else if (is_prim && IsLT(requiredZoneLength,primZonL))
   {
      *pSize = primSize;
      *pProvidedZoneLength = primZonL;
      *pSpacing = primSpc;
   }
   else if (is_addl && IsLT(requiredZoneLength,addlZonL))
   {
      *pSize = addlSize;
      *pProvidedZoneLength = addlZonL;
      *pSpacing = addlSpc;
   }
   else if (is_addl)
   {
      *pSize = addlSize;
      *pProvidedZoneLength = addlZonL;
      *pSpacing = addlSpc;
   }
   else if (is_prim)
   {
      *pSize = primSize;
      *pProvidedZoneLength = primZonL;
      *pSpacing = primSpc;
   }
}

std::array<Float64, 4> ResolveFractionalDistance(const std::array<Float64, 4>& X, Float64 L)
{
   std::array<Float64, 4> result;
   for (int i = 0; i < 4; i++)
   {
      if (X[i] < 0)
      {
         ATLASSERT(-1.0 <= X[i] && X[i] <= 0.0);
         result[i] = -X[i] * L;
      }
      else
      {
         result[i] = X[i];
      }
   }

   return result;
}

/////////////////////////////////////////////////////////
// Utilities for Dealing with strand array conversions
void IndexArray2ConfigStrandFillVec(IIndexArray* pArray, ConfigStrandFillVector& rVec)
{
   rVec.clear();
   if (pArray!=nullptr)
   {
      CollectionIndexType cnt;
      pArray->get_Count(&cnt);
      rVec.reserve(cnt);

      CComPtr<IEnumIndexArray> enum_array;
      pArray->get__EnumElements(&enum_array);
      StrandIndexType value;
      while ( enum_array->Next(1,&value,nullptr) != S_FALSE )
      {
         rVec.push_back(value);
      }
   }
}

bool AreStrandsInConfigFillVec(const ConfigStrandFillVector& rHarpedFillArray)
{
   ConfigStrandFillConstIterator it =    rHarpedFillArray.begin();
   ConfigStrandFillConstIterator itend = rHarpedFillArray.end();
   while(it != itend)
   {
      if(0 < *it)
      {
         return true;
      }

      it++;
   }

   return false;
}

StrandIndexType CountStrandsInConfigFillVec(const ConfigStrandFillVector& rHarpedFillArray)
{
   StrandIndexType cnt(0);

   ConfigStrandFillConstIterator it    = rHarpedFillArray.begin();
   ConfigStrandFillConstIterator itend = rHarpedFillArray.end();
   while(it != itend)
   {
      cnt += *it;
      it++;
   }

   return cnt;
}


// Wrapper class to turn a ConfigStrandFillVector into a IIndexArray
// THIS IS A VERY MINIMAL WRAPPER USED TO PASS STRAND DATA INTO THE WBFL
//   -Read only
//   -Does not reference count
//   -Does not clone
//   -Does not support many functions of IIndexArray
class CIndexArrayWrapper : public IIndexArray
{
   // we are wrapping this container
   const ConfigStrandFillVector& m_Values;

   CIndexArrayWrapper(); // no default constuct
public:
   CIndexArrayWrapper(const ConfigStrandFillVector& vec):
      m_Values(vec)
   {;}

   // IUnknown
   virtual HRESULT STDMETHODCALLTYPE QueryInterface( REFIID riid, __RPC__deref_out void __RPC_FAR *__RPC_FAR *ppvObject)
   { ATLASSERT(false); return E_FAIL;}
   virtual ULONG STDMETHODCALLTYPE AddRef( void)
   { return 1;}
   virtual ULONG STDMETHODCALLTYPE Release( void)
   {return 1;}

   // IIndexArray
	STDMETHOD(Find)(/*[in]*/CollectionIndexType value, /*[out,retval]*/CollectionIndexType* fndIndex)
   {
      ATLASSERT(false);
      return E_FAIL;
   }
	STDMETHOD(ReDim)(/*[in]*/CollectionIndexType size)
   {
      ATLASSERT(false);
      return E_FAIL;
   }

	STDMETHOD(Clone)(/*[out,retval]*/IIndexArray* *clone)
   {
      ATLASSERT(false);
      return E_FAIL;
   }
	STDMETHOD(get_Count)(/*[out, retval]*/ CollectionIndexType *pVal)
   {
	   *pVal = m_Values.size();
	   return S_OK;
   }
	STDMETHOD(Clear)()
   {
      ATLASSERT(false);
      return E_FAIL;
   }
	STDMETHOD(Reserve)(/*[in]*/CollectionIndexType count)
   {
      ATLASSERT(false);
      return E_FAIL;
   }
	STDMETHOD(Insert)(/*[in]*/CollectionIndexType relPosition, /*[in]*/CollectionIndexType item)
   {
      ATLASSERT(false);
      return E_FAIL;
   }
	STDMETHOD(Remove)(/*[in]*/CollectionIndexType relPosition)
   {
      ATLASSERT(false);
      return E_FAIL;
   }
	STDMETHOD(Add)(/*[in]*/CollectionIndexType item)
   {
      ATLASSERT(false);
      return E_FAIL;
   }
	STDMETHOD(get_Item)(/*[in]*/CollectionIndexType relPosition, /*[out, retval]*/ CollectionIndexType *pVal)
   {
      try
      {
         *pVal = m_Values[relPosition];
      }
      catch(...)
      {
         ATLASSERT(false);
         return E_INVALIDARG;
      }
	   return S_OK;
   }
	STDMETHOD(put_Item)(/*[in]*/CollectionIndexType relPosition, /*[in]*/ CollectionIndexType newVal)
   {
      ATLASSERT(false);
      return E_FAIL;
   }
	STDMETHOD(get__NewEnum)(struct IUnknown ** )
   {
      ATLASSERT(false);
      return E_FAIL;
   }
	STDMETHOD(get__EnumElements)(struct IEnumIndexArray ** )
   {
      ATLASSERT(false);
      return E_FAIL;
   }
   STDMETHOD(Assign)(/*[in]*/CollectionIndexType numElements, /*[in]*/CollectionIndexType value)
   {
      ATLASSERT(false);
      return E_FAIL;
   }
};

/////////////////////////////////////
// For some methods, we need to change the strand configuration on the bridge model to that configuration
// defined in GDRCONFIG. When the method ends, we need to put the configuration back the way it was
// before entering the method. This class provides an exception safe way to accomplish this.
class CStrandConfigSwapper
{
public:
   CStrandConfigSwapper(const CPrecastSegmentData* pSegment, IPrecastGirder* pGirder, const GDRCONFIG* pConfig) :
      m_pSegment(pSegment), m_pGirder(pGirder), m_pConfig(pConfig)
   {
      if (m_pConfig)
      {
         // cache the current straight strand and debonding information
         CComPtr<IStrandModel> strandModel;
         m_pGirder->get_StrandModel(&strandModel);
         CComQIPtr<IStrandGridModel> strandGridModel(strandModel);
         strandGridModel->get_StrandFill(Straight, &m_StrandFill);

         strandGridModel->ClearStraightStrandDebonding();

         CIndexArrayWrapper fill(pConfig->PrestressConfig.GetStrandFill(pgsTypes::Straight));
         strandGridModel->putref_StrandFill(Straight, &fill);

         // set the straight strand and debonding information per the configuration
         for (const auto& debondConfig : pConfig->PrestressConfig.Debond[pgsTypes::Straight])
         {
            GridIndexType gridIdx;
            strandGridModel->StrandIndexToGridIndex(Straight, debondConfig.strandIdx, &gridIdx);
            strandGridModel->DebondStraightStrandByGridIndex(gridIdx, debondConfig.DebondLength[pgsTypes::metStart], debondConfig.DebondLength[pgsTypes::metEnd]);
         }
      }
   }
   ~CStrandConfigSwapper()
   {
      if (m_pConfig)
      {
         // restore the original straight strand information
         CComPtr<IStrandModel> strandModel;
         m_pGirder->get_StrandModel(&strandModel);

         CComQIPtr<IStrandGridModel> strandGridModel(strandModel);
         strandGridModel->putref_StrandFill(Straight, m_StrandFill);

         strandGridModel->ClearStraightStrandDebonding();

         const std::vector<CDebondData>& vDebond = m_pSegment->Strands.GetDebonding(pgsTypes::Straight);
         for (const auto& debond_data : vDebond)
         {
            // debond data index is in same order as grid fill
            strandGridModel->DebondStraightStrandByGridIndex(debond_data.strandTypeGridIdx, debond_data.Length[pgsTypes::metStart], debond_data.Length[pgsTypes::metEnd]);
         }
      }
   }

private:
   const CPrecastSegmentData* m_pSegment;
   IPrecastGirder* m_pGirder;
   const GDRCONFIG* m_pConfig;
   CComPtr<IIndexArray> m_StrandFill;
};

///////////////////////////////////////////////////////////
// Exception-safe class for blocking infinite recursion
class SimpleMutex
{
public:

   SimpleMutex(Uint16& flag, Uint16 value):
   m_MutexValue(flag)
   {
      flag = value;
   }

   ~SimpleMutex()
   {
      m_MutexValue = m_Default;
   }

   static const Uint16 m_Default; // mutex is not blocking if set to Default

private:
   Uint16& m_MutexValue;
};

const Uint16 SimpleMutex::m_Default=666; // evil number to search for

static Uint16 st_MutexValue = SimpleMutex::m_Default; // store m_level

// functions to get sin and cos of slope (y/x) angles
inline Float64 CosSlope(Float64 slope)
{
   return 1.0 / sqrt(1 + slope*slope);
}

inline Float64 SinSlope(Float64 slope)
{
   Float64 s = slope/sqrt(1 + slope*slope);
   return s;
}

// There is a special case during design where the inital adjustable strand type is straight, but the designer
// wants to do a harped design. For this case, we need to swap out the istrandmover and harping boundaries,
// so the precast girder can deal with vertical adjustment correctly. 
class CStrandMoverSwapper
{
public:
   CStrandMoverSwapper(const CSegmentKey& segmentKey, Float64 Hg, const PRESTRESSCONFIG& rconfig,
      const CBridgeAgentImp* pBridgeAgent, IStrandGridModel* strandGridModel, IBridgeDescription* pIBridgeDesc):
   m_StrandModel(strandGridModel)
   {
   // Save in constructor and restore in destructor - stand mover and adjustment shift values
   if (rconfig.AdjustableStrandType == pgsTypes::asHarped)
   {
      const CBridgeDescription2* pBridgeDesc = pIBridgeDesc->GetBridgeDescription();
      const CGirderGroupData* pGroup = pBridgeDesc->GetGirderGroup(segmentKey.groupIndex);
      const CSplicedGirderData* pGirder = pGroup->GetGirder(segmentKey.girderIndex);
      const CPrecastSegmentData* pSegment = pGirder->GetSegment(segmentKey.segmentIndex);
      pgsTypes::AdjustableStrandType adjType = pSegment->Strands.GetAdjustableStrandType();
      if (adjType == pgsTypes::asStraight)
      {
         // mover will be reset later
         strandGridModel->get_StrandMover(sgtEnd,      etStart,&m_StartStrandMover);
         strandGridModel->get_StrandMover(sgtEnd,      etEnd,  &m_EndStrandMover);
         strandGridModel->get_StrandMover(sgtHarpPoint,etStart,&m_Hp1StrandMover);
         strandGridModel->get_StrandMover(sgtHarpPoint,etEnd,  &m_Hp2StrandMover);

         CComPtr<IStrandMover> temp_strandmover;
         pBridgeAgent->CreateStrandMover(pGirder->GetGirderName(), Hg, pgsTypes::asHarped, &temp_strandmover);

         strandGridModel->putref_StrandMover(sgtEnd,      etStart,temp_strandmover);
         strandGridModel->putref_StrandMover(sgtEnd,      etEnd,  temp_strandmover);
         strandGridModel->putref_StrandMover(sgtHarpPoint,etStart,temp_strandmover);
         strandGridModel->putref_StrandMover(sgtHarpPoint,etEnd,  temp_strandmover);
      }
   }

   // save and restore precast girders shift values, before/after geting point locations
   for ( int i = 0; i < 2; i++ )
   {
      pgsTypes::MemberEndType endType = (pgsTypes::MemberEndType)i;
      strandGridModel->get_HarpedStrandAdjustmentEnd((EndType)endType,&m_EndShift[endType]);
      strandGridModel->get_HarpedStrandAdjustmentHP((EndType)endType,&m_HpShift[endType]);

      strandGridModel->put_HarpedStrandAdjustmentEnd((EndType)endType,rconfig.EndOffset[endType]);
      strandGridModel->put_HarpedStrandAdjustmentHP((EndType)endType,rconfig.HpOffset[endType]);
   }
}

~CStrandMoverSwapper()
{
   // Restore girder back to its original state
   if ( m_StartStrandMover )
   {
      m_StrandModel->putref_StrandMover(sgtEnd,      etStart,m_StartStrandMover);
   }

   if ( m_EndStrandMover )
   {
      m_StrandModel->putref_StrandMover(sgtEnd,      etEnd,  m_EndStrandMover);
   }

   if ( m_Hp1StrandMover )
   {
      m_StrandModel->putref_StrandMover(sgtHarpPoint,etStart,m_Hp1StrandMover);
   }

   if ( m_Hp2StrandMover )
   {
      m_StrandModel->putref_StrandMover(sgtHarpPoint,etEnd,  m_Hp2StrandMover);
   }

   m_StrandModel->put_HarpedStrandAdjustmentEnd(etStart,m_EndShift[pgsTypes::metStart]);
   m_StrandModel->put_HarpedStrandAdjustmentEnd(etEnd,  m_EndShift[pgsTypes::metEnd]);
   m_StrandModel->put_HarpedStrandAdjustmentHP(etStart, m_HpShift[pgsTypes::metStart]);
   m_StrandModel->put_HarpedStrandAdjustmentHP(etEnd,   m_HpShift[pgsTypes::metEnd]);
}

private:
   std::array<Float64, 2> m_EndShift, m_HpShift; // array index is pgsTypes::MemberEndType
   CComPtr<IStrandMover> m_StartStrandMover;
   CComPtr<IStrandMover> m_Hp1StrandMover;
   CComPtr<IStrandMover> m_Hp2StrandMover;
   CComPtr<IStrandMover> m_EndStrandMover;
   IStrandGridModel* m_StrandModel;
};

PierType GetPierType(const CPierData2* pPierData)
{
   if ( pPierData->IsBoundaryPier() )
   {
      switch( pPierData->GetBoundaryConditionType() )
      {
      case pgsTypes::bctHinge:
      case pgsTypes::bctRoller:
         return ptExpansion;

      case pgsTypes::bctContinuousAfterDeck:
      case pgsTypes::bctContinuousBeforeDeck:
         return ptContinuous;

      case pgsTypes::bctIntegralAfterDeck:
      case pgsTypes::bctIntegralBeforeDeck:
         return ptIntegral;

      case pgsTypes::bctIntegralAfterDeckHingeBack:
      case pgsTypes::bctIntegralBeforeDeckHingeBack:
      case pgsTypes::bctIntegralAfterDeckHingeAhead:
      case pgsTypes::bctIntegralBeforeDeckHingeAhead:
         return ptIntegral;
      }

      ATLASSERT(false); // should never get here
      return ptIntegral;
   }
   else
   {
      switch ( pPierData->GetSegmentConnectionType() )
      {
      case pgsTypes::psctContinousClosureJoint:
      case pgsTypes::psctContinuousSegment:
         return ptContinuous;

      case pgsTypes::psctIntegralClosureJoint:
      case pgsTypes::psctIntegralSegment:
         return ptIntegral;
      }

      ATLASSERT(false); // should never get here
      return ptIntegral;
   }
}


/////////////////////////////////////////////////////////////////////////////
// CBridgeAgentImp
void CBridgeAgentImp::InvalidateSectionProperties(pgsTypes::SectionPropertyType sectPropType)
{
   SectPropContainer* pOldSectProps = m_pSectProps[sectPropType].release();
   m_pSectProps[sectPropType] = std::make_unique<SectPropContainer>();

#if defined _USE_MULTITHREADING
   m_ThreadManager.CreateThread(CBridgeAgentImp::DeleteSectionProperties,(LPVOID)(pOldSectProps));
#else
   CBridgeAgentImp::DeleteSectionProperties((LPVOID)(pOldSectProps));
#endif
}

void CBridgeAgentImp::InvalidatePoiLocationCache()
{
   PoiLocationCache* pOldCache = m_pPoiLocationCache.release();
   m_pPoiLocationCache = std::make_unique<PoiLocationCache>();
#if defined _USE_MULTITHREADING
   m_ThreadManager.CreateThread(CBridgeAgentImp::DeletePoiLocationCache, (LPVOID)(pOldCache));
#else
   CBridgeAgentImp::DeletePoiLocationCache((LPVOID)(pOldCache)));
#endif
}

UINT CBridgeAgentImp::DeletePoiLocationCache(LPVOID pParam)
{
   WATCH(_T("Begin: DeletePoiLocationCache"));
   PoiLocationCache* pCache = (std::set<PoiLocation>*)(pParam);
   pCache->clear();
   delete pCache;
   WATCH(_T("End: DeletePoiLocationCache"));
   return 0;
}

UINT CBridgeAgentImp::DeleteSectionProperties(LPVOID pParam)
{
   WATCH(_T("Begin: DeleteSectionProperties"));
   
   SectPropContainer* pSectionProperties = (SectPropContainer*)pParam;
   pSectionProperties->clear();
   delete pSectionProperties;

   WATCH(_T("End: DeleteSectionProperties"));

   return 0;
}

pgsPoiMgr* CBridgeAgentImp::CreatePoiManager()
{
   auto pPoiMgr = std::make_unique<pgsPoiMgr>();
   return pPoiMgr.release();
}

void CBridgeAgentImp::InvalidatePointsOfInterest()
{
   pgsPoiMgr* pOldPoiMgr = m_pPoiMgr.release();
   m_pPoiMgr.reset(CreatePoiManager());

#if defined _USE_MULTITHREADING
   m_ThreadManager.CreateThread(CBridgeAgentImp::DeletePoiManager,(LPVOID)(pOldPoiMgr));
#else
   CBridgeAgentImp::DeletePoiManager((LPVOID)(pOldPoiMgr));
#endif
}

UINT CBridgeAgentImp::DeletePoiManager(LPVOID pParam)
{
   WATCH(_T("Begin: Delete Poi Manager"));
   pgsPoiMgr* pPoiMgr = (pgsPoiMgr*)pParam;
   delete pPoiMgr;
   WATCH(_T("End: Delete Poi Manager"));
   return 0;
}

pgsTypes::SectionPropertyType CBridgeAgentImp::GetSectionPropertiesType() const
{
   pgsTypes::SectionPropertyType spType = (GetSectionPropertiesMode() == pgsTypes::spmGross ? pgsTypes::sptGross : pgsTypes::sptTransformed);
   return spType;
}

HRESULT CBridgeAgentImp::FinalConstruct()
{
   m_pPoiMgr.reset(CreatePoiManager());

   HRESULT hr = m_BridgeGeometryTool.CoCreateInstance(CLSID_BridgeGeometryTool);
   if ( FAILED(hr) )
   {
      return hr;
   }

   hr = m_CogoEngine.CoCreateInstance(CLSID_CogoEngine);
   if ( FAILED(hr) )
   {
      return hr;
   }

   for ( int i = 0; i < pgsTypes::sptSectionPropertyTypeCount; i++ )
   {
      pgsTypes::SectionPropertyType spType = (pgsTypes::SectionPropertyType)(i);
      m_pSectProps[spType] = std::make_unique<SectPropContainer>();
   }

   m_pPoiLocationCache = std::make_unique<PoiLocationCache>();

   return S_OK;
}

void CBridgeAgentImp::FinalRelease()
{
   m_BridgeGeometryTool.Release();
   m_CogoEngine.Release();
}

void CBridgeAgentImp::Invalidate( Uint16 level )
{
//   LOG(_T("Invalidating"));

   if ( level <= BRIDGE )
   {
//      LOG(_T("Invalidating Bridge Model"));

      m_CogoModel.Release();
      m_Bridge.Release();
      m_CompoundCurveKeys.clear();
      m_VertCurveKeys.clear();


      // Must be valided at least past COGO_MODEL
      if ( COGO_MODEL < level )
      {
         level = COGO_MODEL;
      }

      m_AsymmetricPrestressing = Unknown;

      m_ConcreteManager.Reset();

      m_GirderTopChordElevationFunctions.clear();
      
      // If bridge is invalid, so are points of interest
      m_ValidatedPoi.clear();

      InvalidatePointsOfInterest();
      InvalidatePoiLocationCache();

      CollectionIndexType size = sizeof(m_CriticalSectionState) / sizeof(std::set<CGirderKey>);
      for (CollectionIndexType idx = 0; idx < size; idx++)
      {
         m_CriticalSectionState[idx].clear();
      }

      // there are usually a lot of a lot of cached section properties
      // don't make the user wait on deleting them. use a worker thread 
      for ( int i = 0; i < pgsTypes::sptSectionPropertyTypeCount; i++ )
      {
         pgsTypes::SectionPropertyType spType = (pgsTypes::SectionPropertyType)(i);
         InvalidateSectionProperties(spType);
      }

      InvalidateUserLoads();

      InvalidateDeckParameters();

      // clear the cached shapes
      m_DeckShapes.clear();
      m_LeftBarrierShapes.clear();
      m_RightBarrierShapes.clear();

      m_LeftSlabEdgeOffset.clear();
      m_RightSlabEdgeOffset.clear();

      // cached sheardata
      InvalidateStirrupData();

      m_LiftingStabilityModels.clear();
      m_LiftingStabilityProblems.clear();

      m_HaulingStabilityModels.clear();
      m_HaulingStabilityProblems.clear();

      // remove our items from the status center
      GET_IFACE(IEAFStatusCenter,pStatusCenter);
      pStatusCenter->RemoveByStatusGroupID(m_StatusGroupID);
   }

   m_Level = level;
   if ( m_Level != 0 )
   {
      m_Level -= 1;
   }

//   LOG(_T("Invalidate complete - BridgeAgent at level ") << m_Level );
}

Uint16 CBridgeAgentImp::Validate( Uint16 level )
{
//   LOG(_T("Validating"));

   if (st_MutexValue != SimpleMutex::m_Default)
   {
      // mutex is blocking recursion
//      LOG(_T("Mutex is blocking recursion at level")<<st_MutexValue);
      ATLASSERT(level<=st_MutexValue); // this is bad. A call down the stack is requesting a higher level Validation
   }
   else
   {
      // use SimpleMutex class to block recursion
      SimpleMutex mutex(st_MutexValue, level);

      if ( m_Level < level )
      {
         VALIDATE_TO_LEVEL( COGO_MODEL,   BuildCogoModel );
         VALIDATE_TO_LEVEL( BRIDGE,       BuildBridgeModel );
         VALIDATE_AND_CHECK_TO_LEVEL( GIRDER,       BuildGirders,    ValidateGirders );
      }

  
      if (GIRDER <= level)
      {
         ValidateUserLoads();
      }

//      LOG(_T("Validation complete - BridgeAgent at level ") << m_Level );
   }

      return m_Level;
}

void CBridgeAgentImp::ValidatePointsOfInterest(const CGirderKey& girderKey)
{
   // Bridge model, up to and including girders, must be valid before we can layout the poi
   VALIDATE(GIRDER);

   GET_IFACE(IBridgeDescription,pIBridgeDesc);
   const CBridgeDescription2* pBridgeDesc = pIBridgeDesc->GetBridgeDescription();

   // Create a collection of girder keys for the girders who's POI need to be validated
   std::vector<CGirderKey> girderKeyList;

   GroupIndexType firstGrpIdx;
   GroupIndexType lastGrpIdx;
   if ( girderKey.groupIndex == ALL_GROUPS )
   {
      // validate all groups
      firstGrpIdx = 0;
      lastGrpIdx  = pBridgeDesc->GetGirderGroupCount()-1;
   }
   else
   {
      firstGrpIdx = girderKey.groupIndex;
      lastGrpIdx  = firstGrpIdx;
   }

   for ( GroupIndexType grpIdx = firstGrpIdx; grpIdx <= lastGrpIdx; grpIdx++ )
   {
      const CGirderGroupData* pGroup = pBridgeDesc->GetGirderGroup(grpIdx);

      GirderIndexType firstGdrIdx;
      GirderIndexType lastGdrIdx;
      if ( girderKey.girderIndex == ALL_GIRDERS )
      {
         firstGdrIdx = 0;
         lastGdrIdx = pGroup->GetGirderCount() - 1;
      }
      else
      {
         firstGdrIdx = girderKey.girderIndex;
         lastGdrIdx  = firstGdrIdx;
      }

      GirderIndexType nGirdersThisGroup = pGroup->GetGirderCount();
      if ( nGirdersThisGroup <= lastGdrIdx )
      {
         lastGdrIdx = nGirdersThisGroup-1;
      }

      for ( GirderIndexType gdrIdx = firstGdrIdx; gdrIdx <= lastGdrIdx; gdrIdx++ )
      {
         CGirderKey key(grpIdx,gdrIdx);
         girderKeyList.push_back(key);
      } // girder loop
   } // group loop

   
   // Validate the POI
   std::vector<CGirderKey>::iterator keyIter(girderKeyList.begin());
   std::vector<CGirderKey>::iterator keyIterEnd(girderKeyList.end());
   for ( ; keyIter != keyIterEnd; keyIter++ )
   {
      CGirderKey& key = *keyIter;
      std::set<CGirderKey>::iterator found( m_ValidatedPoi.find( key ) );
      if ( found == m_ValidatedPoi.end() )
      {
         LayoutPointsOfInterest( key );
         m_ValidatedPoi.insert(key);
      }
   }
}

void CBridgeAgentImp::InvalidateUserLoads()
{
   m_bUserLoadsValidated = false;

   // remove our items from the status center
   GET_IFACE(IEAFStatusCenter,pStatusCenter);
   pStatusCenter->RemoveByStatusGroupID(m_LoadStatusGroupID);
}

void CBridgeAgentImp::ValidateUserLoads()
{
   if (!m_bUserLoadsValidated)
   {
      // first make sure our data is wiped
      m_PointLoads.clear();
      m_DistributedLoads.clear();
      m_MomentLoads.clear();

      ValidatePointLoads();
      ValidateDistributedLoads();
      ValidateMomentLoads();

      m_bUserLoadsValidated = true;
   }
}

void CBridgeAgentImp::ValidatePointLoads()
{
   SpanIndexType nSpans = GetSpanCount();

   GET_IFACE_NOCHECK(IEAFStatusCenter, pStatusCenter);
   GET_IFACE(IUserDefinedLoadData, pLoadData );
   GET_IFACE(IBridgeDescription, pIBridgeDesc);

   const CBridgeDescription2* pBridgeDesc = pIBridgeDesc->GetBridgeDescription();

   CollectionIndexType nLoads = pLoadData->GetPointLoadCount();
   for(CollectionIndexType loadIdx = 0; loadIdx < nLoads; loadIdx++)
   {
      const CPointLoadData* pPointLoad = pLoadData->GetPointLoad(loadIdx);

      // need to loop over all spans if that is what is selected - use a vector to store span numbers
      std::vector<SpanIndexType> spans;
      if (pPointLoad->m_SpanKey.spanIndex == ALL_SPANS)
      {
         for (SpanIndexType spanIdx = 0; spanIdx < nSpans; spanIdx++)
         {
            spans.push_back(spanIdx);
         }
      }
      else
      {
         if(nSpans <= pPointLoad->m_SpanKey.spanIndex)
         {
            CString strMsg;
            strMsg.Format(_T("Span %s for point load is out of range. Max span number is %d. This load will be ignored."), LABEL_SPAN(pPointLoad->m_SpanKey.spanIndex),nSpans);
            std::unique_ptr<pgsPointLoadStatusItem> pStatusItem = std::make_unique<pgsPointLoadStatusItem>(pPointLoad->m_ID,m_LoadStatusGroupID,m_scidPointLoadWarning,strMsg,pPointLoad->m_SpanKey);
            pStatusCenter->Add(pStatusItem.release());
            continue; // break out of this cycle
         }
         else
         {
            spans.push_back(pPointLoad->m_SpanKey.spanIndex);
         }
      }

      std::vector<SpanIndexType>::iterator spanIter(spans.begin());
      std::vector<SpanIndexType>::iterator spanIterEnd(spans.end());
      for ( ; spanIter != spanIterEnd; spanIter++ )
      {
         SpanIndexType span = *spanIter;

         GirderIndexType nGirders = GetGirderCountBySpan(span);

         std::vector<GirderIndexType> girders;
         if (pPointLoad->m_SpanKey.girderIndex == ALL_GIRDERS)
         {
            for (GirderIndexType i = 0; i < nGirders; i++)
            {
               girders.push_back(i);
            }
         }
         else
         {
            if(nGirders <= pPointLoad->m_SpanKey.girderIndex)
            {
               CString strMsg;
               strMsg.Format(_T("Girder %s for point load is out of range. Max girder number is %s. This load will be ignored."), LABEL_GIRDER(pPointLoad->m_SpanKey.girderIndex), LABEL_GIRDER(nGirders-1));
               std::unique_ptr<pgsPointLoadStatusItem> pStatusItem = std::make_unique<pgsPointLoadStatusItem>(pPointLoad->m_ID,m_LoadStatusGroupID,m_scidPointLoadWarning,strMsg,pPointLoad->m_SpanKey);
               pStatusCenter->Add(pStatusItem.release());
               continue;
            }
            else
            {
               girders.push_back(pPointLoad->m_SpanKey.girderIndex);
            }
         }

         std::vector<GirderIndexType>::iterator gdrIter(girders.begin());
         std::vector<GirderIndexType>::iterator gdrIterEnd(girders.end());
         for ( ; gdrIter != gdrIterEnd; gdrIter++ )
         {
            GirderIndexType girder = *gdrIter;

            CSpanKey thisSpanKey(span,girder);

            UserPointLoad upl;
            upl.m_bLoadOnStartCantilever = pPointLoad->m_bLoadOnCantilever[pgsTypes::metStart];
            upl.m_bLoadOnEndCantilever   = pPointLoad->m_bLoadOnCantilever[pgsTypes::metEnd];

            upl.m_LoadCase = Project2BridgeLoads(pPointLoad->m_LoadCase);
            upl.m_Description = pPointLoad->m_Description;

            CString strSpan;
            if (pPointLoad->m_SpanKey.spanIndex == ALL_SPANS)
            {
               strSpan.Format(_T("%s"), _T("All Spans"));
            }
            else
            {
               if (pPointLoad->m_bLoadOnCantilever[pgsTypes::metStart])
               {
                  strSpan.Format(_T("Span %s Start Cantilever"), LABEL_SPAN(pPointLoad->m_SpanKey.spanIndex));
               }
               else if (pPointLoad->m_bLoadOnCantilever[pgsTypes::metEnd])
               {
                  strSpan.Format(_T("Span %s End Cantilever"), LABEL_SPAN(pPointLoad->m_SpanKey.spanIndex));
               }
               else
               {
                  strSpan.Format(_T("Span %s"), LABEL_SPAN(pPointLoad->m_SpanKey.spanIndex));
               }
            }

            CString strGirder;
            if (pPointLoad->m_SpanKey.girderIndex == ALL_GIRDERS)
            {
               strGirder.Format(_T("%s"), _T("All Girders"));
            }
            else
            {
               strGirder.Format(_T("Girder %s"), LABEL_GIRDER(pPointLoad->m_SpanKey.girderIndex));
            }

            CString strLocation;
            if (pPointLoad->m_Fractional)
            {
               strLocation.Format(_T("%s"), FormatPercentage(pPointLoad->m_Location));
            }
            else
            {
               GET_IFACE(IEAFDisplayUnits, pDisplayUnits);
               strLocation.Format(_T("%s"), FormatDimension(pPointLoad->m_Location, pDisplayUnits->GetSpanLengthUnit()));
            }

            CString strLabel;
            strLabel.Format(_T("%s, %s, %s"), strSpan, strGirder, strLocation);

            // only a light warning for zero loads - don't bail out
            if (IsZero(pPointLoad->m_Magnitude))
            {

               CString strMsg;
               strMsg.Format(_T("Magnitude of point load is zero - %s"),strLabel);
               std::unique_ptr<pgsPointLoadStatusItem> pStatusItem = std::make_unique<pgsPointLoadStatusItem>(pPointLoad->m_ID,m_LoadStatusGroupID,m_scidPointLoadWarning,strMsg,thisSpanKey);
               pStatusCenter->Add(pStatusItem.release());
            }

            upl.m_Magnitude = pPointLoad->m_Magnitude;

            Float64 start_cantilever_length = GetCantileverLength(thisSpanKey,pgsTypes::metStart);
            Float64 end_cantilever_length = GetCantileverLength(thisSpanKey,pgsTypes::metEnd);
            Float64 span_length = GetSpanLength(thisSpanKey);

            if ( upl.m_bLoadOnStartCantilever && IsZero(start_cantilever_length))
            {
               CString strMsg;
               strMsg.Format(_T("Load is located on span cantilever, however span is not cantilevered. This load will be ignored. - %s"), strLabel);
               std::unique_ptr<pgsPointLoadStatusItem> pStatusItem = std::make_unique<pgsPointLoadStatusItem>(pPointLoad->m_ID,m_LoadStatusGroupID,m_scidPointLoadWarning,strMsg,thisSpanKey);
               pStatusCenter->Add(pStatusItem.release());
               continue;
            }

            if ( upl.m_bLoadOnEndCantilever && IsZero(end_cantilever_length))
            {
               CString strMsg;
               strMsg.Format(_T("Load is located on span cantilever, however span is not cantilevered. This load will be ignored. - %s"),strLabel);
               std::unique_ptr<pgsPointLoadStatusItem> pStatusItem = std::make_unique<pgsPointLoadStatusItem>(pPointLoad->m_ID,m_LoadStatusGroupID,m_scidPointLoadWarning,strMsg,thisSpanKey);
               pStatusCenter->Add(pStatusItem.release());
               continue;
            }

            if (pPointLoad->m_Fractional)
            {
               if( ::InRange(0.0,pPointLoad->m_Location,1.0) )
               {
                  if ( upl.m_bLoadOnStartCantilever )
                  {
                     upl.m_Location = pPointLoad->m_Location * start_cantilever_length;
                  }
                  else if ( upl.m_bLoadOnEndCantilever )
                  {
                     upl.m_Location = pPointLoad->m_Location * end_cantilever_length;
                  }
                  else
                  {
                     upl.m_Location = pPointLoad->m_Location * span_length;
                  }
               }
               else
               {
                  CString strMsg;
                  strMsg.Format(_T("Fractional location value for point load is out of range. Value must range from 0.0 to 1.0. This load will be ignored. - %s"),strLabel);
                  std::unique_ptr<pgsPointLoadStatusItem> pStatusItem = std::make_unique<pgsPointLoadStatusItem>(pPointLoad->m_ID,m_LoadStatusGroupID,m_scidPointLoadWarning,strMsg,thisSpanKey);
                  pStatusCenter->Add(pStatusItem.release());
                  continue;
               }
            }
            else
            {
               if ( upl.m_bLoadOnStartCantilever )
               {
                  if ( ::InRange(0.0,pPointLoad->m_Location,start_cantilever_length) )
                  {
                     upl.m_Location = pPointLoad->m_Location;
                  }
                  else
                  {
                     CString strMsg;
                     strMsg.Format(_T("Location value for point load is out of range. Value must range from 0.0 to start cantilever length. This load will be ignored. - %s"),strLabel);
                     std::unique_ptr<pgsPointLoadStatusItem> pStatusItem = std::make_unique<pgsPointLoadStatusItem>(pPointLoad->m_ID,m_LoadStatusGroupID,m_scidPointLoadWarning,strMsg,thisSpanKey);
                     pStatusCenter->Add(pStatusItem.release());
                     continue;
                  }
               }
               else if ( upl.m_bLoadOnEndCantilever )
               {
                  if ( ::InRange(0.0,pPointLoad->m_Location,end_cantilever_length) )
                  {
                     upl.m_Location = pPointLoad->m_Location;
                  }
                  else
                  {
                     CString strMsg;
                     strMsg.Format(_T("Location value for point load is out of range. Value must range from 0.0 to end cantilever length. This load will be ignored. - %s"),strLabel);
                     std::unique_ptr<pgsPointLoadStatusItem> pStatusItem = std::make_unique<pgsPointLoadStatusItem>(pPointLoad->m_ID,m_LoadStatusGroupID,m_scidPointLoadWarning,strMsg,thisSpanKey);
                     pStatusCenter->Add(pStatusItem.release());
                     continue;
                  }
               }
               else
               {
                  if ( ::InRange(0.0,pPointLoad->m_Location,span_length) )
                  {
                     upl.m_Location = pPointLoad->m_Location;
                  }
                  else
                  {
                     CString strMsg;
                     strMsg.Format(_T("Location value for point load is out of range. Value must range from 0.0 to span length. This load will be ignored. - %s"),strLabel);
                     std::unique_ptr<pgsPointLoadStatusItem> pStatusItem = std::make_unique<pgsPointLoadStatusItem>(pPointLoad->m_ID,m_LoadStatusGroupID,m_scidPointLoadWarning,strMsg,thisSpanKey);
                     pStatusCenter->Add(pStatusItem.release());
                     continue;
                  }
               }
            }

            // add a point of interest at this load location in every interval
            CSegmentKey segmentKey;
            Float64 Xs;
            ConvertSpanPointToSegmentCoordiante(thisSpanKey,upl.m_Location,&segmentKey,&Xs);

            Float64 segLength = GetSegmentLength(segmentKey);
            Xs = ::ForceIntoRange(0.0,Xs,segLength);

            pgsPointOfInterest poi(segmentKey,Xs,POI_CONCLOAD);
            VERIFY(m_pPoiMgr->AddPointOfInterest( poi ) != INVALID_ID);

            // put load into our collection
            IntervalIndexType intervalIdx;
            if ( pPointLoad->m_LoadCase == UserLoads::LL_IM )
            {
               intervalIdx = m_IntervalManager.GetLiveLoadInterval();
            }
            else
            {
               intervalIdx = m_IntervalManager.GetUserLoadInterval(thisSpanKey,pPointLoad->m_LoadCase,pPointLoad->m_ID);
            }
            ATLASSERT(intervalIdx != INVALID_INDEX);

            CUserLoadKey key(thisSpanKey,intervalIdx);
            std::map<CUserLoadKey,std::vector<UserPointLoad>>::iterator found(m_PointLoads.find(key));
            if ( found == m_PointLoads.end() )
            {
               std::vector<UserPointLoad> pointLoads;
               pointLoads.push_back(upl);
               m_PointLoads.insert(std::make_pair(key,pointLoads));
            }
            else
            {
               std::vector<UserPointLoad>& pointLoads = found->second;
               pointLoads.push_back(upl);
            }
         }
      }
   }
}

void CBridgeAgentImp::ValidateDistributedLoads()
{
   SpanIndexType nSpans = GetSpanCount();

   GET_IFACE_NOCHECK(IEAFStatusCenter,pStatusCenter);
   GET_IFACE( IUserDefinedLoadData, pUdl );

   CollectionIndexType nLoads = pUdl->GetDistributedLoadCount();
   for(CollectionIndexType loadIdx = 0; loadIdx < nLoads; loadIdx++)
   {
      const CDistributedLoadData* pDistLoad = pUdl->GetDistributedLoad(loadIdx);

      // need to loop over all spans if that is what is selected - user a vector to store span numbers
      std::vector<SpanIndexType> spans;
      if (pDistLoad->m_SpanKey.spanIndex == ALL_SPANS)
      {
         for (SpanIndexType i = 0; i < nSpans; i++)
         {
            spans.push_back(i);
         }
      }
      else
      {
         if(nSpans <= pDistLoad->m_SpanKey.spanIndex)
         {
            CString strMsg;
            strMsg.Format(_T("Span %s for Distributed load is out of range. Max span number is %d. This load will be ignored."), LABEL_SPAN(pDistLoad->m_SpanKey.spanIndex),nSpans);
            std::unique_ptr<pgsDistributedLoadStatusItem> pStatusItem = std::make_unique<pgsDistributedLoadStatusItem>(pDistLoad->m_ID,m_LoadStatusGroupID,m_scidDistributedLoadWarning,strMsg,pDistLoad->m_SpanKey);
            pStatusCenter->Add(pStatusItem.release());
            continue; // break out of this cycle
         }
         else
         {
            spans.push_back(pDistLoad->m_SpanKey.spanIndex);
         }
      }

      std::vector<SpanIndexType>::iterator spanIter(spans.begin());
      std::vector<SpanIndexType>::iterator spanIterEnd(spans.end());
      for (; spanIter != spanIterEnd; spanIter++)
      {
         SpanIndexType span = *spanIter;

         GirderIndexType nGirders = GetGirderCountBySpan(span);

         std::vector<GirderIndexType> girders;
         if (pDistLoad->m_SpanKey.girderIndex == ALL_GIRDERS)
         {
            for (GirderIndexType i = 0; i < nGirders; i++)
            {
               girders.push_back(i);
            }
         }
         else
         {
            if(nGirders <= pDistLoad->m_SpanKey.girderIndex)
            {
               CString strMsg;
               strMsg.Format(_T("Girder %s for Distributed load is out of range. Max girder number is %s. This load will be ignored."), LABEL_GIRDER(pDistLoad->m_SpanKey.girderIndex), LABEL_GIRDER(nGirders-1));
               std::unique_ptr<pgsDistributedLoadStatusItem> pStatusItem = std::make_unique<pgsDistributedLoadStatusItem>(pDistLoad->m_ID,m_LoadStatusGroupID,m_scidDistributedLoadWarning,strMsg,pDistLoad->m_SpanKey);
               pStatusCenter->Add(pStatusItem.release());
               continue;
            }
            else
            {
               girders.push_back(pDistLoad->m_SpanKey.girderIndex);
            }
         }

         std::vector<GirderIndexType>::iterator girderIter(girders.begin());
         std::vector<GirderIndexType>::iterator girderIterEnd(girders.end());
         for ( ; girderIter != girderIterEnd; girderIter++)
         {
            GirderIndexType girder = *girderIter;

            CSpanKey thisSpanKey(span,girder);

            Float64 span_length = GetSpanLength(span,girder); // span length measured along CL girder

            UserDistributedLoad upl;
            upl.m_LoadCase = Project2BridgeLoads(pDistLoad->m_LoadCase);
            upl.m_Description = pDistLoad->m_Description;

            CString strSpan;
            if (pDistLoad->m_SpanKey.spanIndex == ALL_SPANS)
            {
               strSpan.Format(_T("%s"), _T("All Spans"));
            }
            else
            {
               strSpan.Format(_T("Span %s"), LABEL_SPAN(pDistLoad->m_SpanKey.spanIndex));
            }

            CString strGirder;
            if (pDistLoad->m_SpanKey.girderIndex == ALL_GIRDERS)
            {
               strGirder.Format(_T("%s"), _T("All Girders"));
            }
            else
            {
               strGirder.Format(_T("Girder %s"), LABEL_GIRDER(pDistLoad->m_SpanKey.girderIndex));
            }

            CString strLocation;
            if (pDistLoad->m_Type == UserLoads::Uniform)
            {
               strLocation.Format(_T("%s"), _T("Entire Span"));
            }
            else
            {
               if (pDistLoad->m_Fractional)
               {
                  strLocation.Format(_T("%s - %s"), FormatPercentage(pDistLoad->m_StartLocation, false), FormatPercentage(pDistLoad->m_EndLocation));
               }
               else
               {
                  GET_IFACE(IEAFDisplayUnits, pDisplayUnits);
                  strLocation.Format(_T("%s - %s"), FormatDimension(pDistLoad->m_StartLocation, pDisplayUnits->GetSpanLengthUnit(), false), FormatDimension(pDistLoad->m_EndLocation, pDisplayUnits->GetSpanLengthUnit()));
               }
            }

            CString strLabel;
            strLabel.Format(_T("%s, %s, %s"), strSpan, strGirder, strLocation);

            if (pDistLoad->m_Type == UserLoads::Uniform)
            {
               if (IsZero(pDistLoad->m_WStart) && IsZero(pDistLoad->m_WEnd))
               {
                  CString strMsg;
                  strMsg.Format(_T("Magnitude of Distributed load is zero - %s"),strLabel);
                  std::unique_ptr<pgsDistributedLoadStatusItem> pStatusItem = std::make_unique<pgsDistributedLoadStatusItem>(pDistLoad->m_ID,m_LoadStatusGroupID,m_scidDistributedLoadWarning,strMsg,thisSpanKey);
                  pStatusCenter->Add(pStatusItem.release());
               }

               // uniform load
               upl.m_WStart = pDistLoad->m_WStart;
               upl.m_WEnd   = pDistLoad->m_WStart;

               upl.m_StartLocation = 0.0;
               upl.m_EndLocation   = span_length;
            }
            else
            {
               // only a light warning for zero loads - don't bail out
               if (IsZero(pDistLoad->m_WStart) && IsZero(pDistLoad->m_WEnd))
               {
                  CString strMsg;
                  strMsg.Format(_T("Magnitude of Distributed load is zero - %s"), strLabel);
                  std::unique_ptr<pgsDistributedLoadStatusItem> pStatusItem = std::make_unique<pgsDistributedLoadStatusItem>(pDistLoad->m_ID,m_LoadStatusGroupID,m_scidDistributedLoadWarning,strMsg,thisSpanKey);
                  pStatusCenter->Add(pStatusItem.release());
               }

               upl.m_WStart = pDistLoad->m_WStart;
               upl.m_WEnd   = pDistLoad->m_WEnd;

               // location
               if( pDistLoad->m_EndLocation <= pDistLoad->m_StartLocation )
               {
                  CString strMsg;
                  strMsg.Format(_T("Start location of distributed load is greater than end location. This load will be ignored. - %s"),strLabel);
                  std::unique_ptr<pgsDistributedLoadStatusItem> pStatusItem = std::make_unique<pgsDistributedLoadStatusItem>(pDistLoad->m_ID,m_LoadStatusGroupID,103,strMsg,thisSpanKey);
                  pStatusCenter->Add(pStatusItem.release());
                  continue;
               }

               if (pDistLoad->m_Fractional)
               {
                  if( (0.0 <= pDistLoad->m_StartLocation && pDistLoad->m_StartLocation <= 1.0) &&
                      (0.0 <= pDistLoad->m_EndLocation   && pDistLoad->m_EndLocation   <= 1.0) )
                  {
                     upl.m_StartLocation = pDistLoad->m_StartLocation * span_length;
                     upl.m_EndLocation   = pDistLoad->m_EndLocation * span_length;
                  }
                  else
                  {
                     CString strMsg;
                     strMsg.Format(_T("Fractional location value for Distributed load is out of range. Value must range from 0.0 to 1.0. This load will be ignored. - %s"),strLabel);
                     std::unique_ptr<pgsDistributedLoadStatusItem> pStatusItem = std::make_unique<pgsDistributedLoadStatusItem>(pDistLoad->m_ID,m_LoadStatusGroupID,m_scidDistributedLoadWarning,strMsg,thisSpanKey);
                     pStatusCenter->Add(pStatusItem.release());
                     continue;
                  }
               }
               else
               {
                  if( InRange(0.0,pDistLoad->m_StartLocation,span_length) &&
                      InRange(0.0,pDistLoad->m_EndLocation,span_length))
                  {
                     upl.m_StartLocation = pDistLoad->m_StartLocation;

                     // fudge a bit if user entered a slightly high value
                     if (pDistLoad->m_EndLocation < span_length)
                     {
                        upl.m_EndLocation   = pDistLoad->m_EndLocation;
                     }
                     else
                     {
                        upl.m_EndLocation   = span_length;
                     }

                  }
                  else
                  {
                     CString strMsg;
                     strMsg.Format(_T("Location value for Distributed load is out of range. Value must range from 0.0 to span length. This load will be ignored. - %s"),strLabel);
                     std::unique_ptr<pgsDistributedLoadStatusItem> pStatusItem = std::make_unique<pgsDistributedLoadStatusItem>(loadIdx,m_LoadStatusGroupID,m_scidDistributedLoadWarning,strMsg,thisSpanKey);
                     pStatusCenter->Add(pStatusItem.release());
                     continue;
                  }
               }
            }

            // add point of interests at start and end of this load
            CSegmentKey segmentKey;
            Float64 Xs;
            ConvertSpanPointToSegmentCoordiante(thisSpanKey,upl.m_StartLocation,&segmentKey,&Xs);

            Float64 segLength = GetSegmentLength(segmentKey);
            Xs = ::ForceIntoRange(0.0,Xs,segLength);

            pgsPointOfInterest poiStart(segmentKey,Xs);
            VERIFY(m_pPoiMgr->AddPointOfInterest(poiStart) != INVALID_ID);

            ConvertSpanPointToSegmentCoordiante(thisSpanKey,upl.m_EndLocation,&segmentKey,&Xs);

            segLength = GetSegmentLength(segmentKey);
            Xs = ::ForceIntoRange(0.0,Xs,segLength);

            pgsPointOfInterest poiEnd(segmentKey,Xs);
            VERIFY(m_pPoiMgr->AddPointOfInterest(poiEnd) != INVALID_ID);

            IntervalIndexType intervalIdx;
            if ( pDistLoad->m_LoadCase == UserLoads::LL_IM )
            {
               intervalIdx = m_IntervalManager.GetLiveLoadInterval();
            }
            else
            {
               intervalIdx = m_IntervalManager.GetUserLoadInterval(thisSpanKey,pDistLoad->m_LoadCase,pDistLoad->m_ID);
            }
            ATLASSERT(intervalIdx != INVALID_INDEX);

            CUserLoadKey key(thisSpanKey,intervalIdx);
            std::map<CUserLoadKey,std::vector<UserDistributedLoad>>::iterator found(m_DistributedLoads.find(key));
            if ( found == m_DistributedLoads.end() )
            {
               std::vector<UserDistributedLoad> distributedLoads;
               distributedLoads.push_back(upl);
               m_DistributedLoads.insert(std::make_pair(key,distributedLoads));
            }
            else
            {
               std::vector<UserDistributedLoad>& distributedLoads = found->second;
               distributedLoads.push_back(upl);
            }
         }
      }
   }
}

void CBridgeAgentImp::ValidateMomentLoads()
{
   SpanIndexType nSpans = GetSpanCount();

   GET_IFACE_NOCHECK(IEAFStatusCenter, pStatusCenter);
   GET_IFACE(IUserDefinedLoadData, pLoadData );
   GET_IFACE(IBridgeDescription, pIBridgeDesc);

   const CBridgeDescription2* pBridgeDesc = pIBridgeDesc->GetBridgeDescription();

   CollectionIndexType nLoads = pLoadData->GetMomentLoadCount();
   for(CollectionIndexType loadIdx = 0; loadIdx < nLoads; loadIdx++)
   {
      const CMomentLoadData* pMomentLoad = pLoadData->GetMomentLoad(loadIdx);

      // need to loop over all spans if that is what is selected - user a vector to store span numbers
      std::vector<SpanIndexType> spans;
      if (pMomentLoad->m_SpanKey.spanIndex == ALL_SPANS)
      {
         for (SpanIndexType spanIdx = 0; spanIdx < nSpans; spanIdx++)
         {
            spans.push_back(spanIdx);
         }
      }
      else
      {
         if(nSpans <= pMomentLoad->m_SpanKey.spanIndex)
         {
            CString strMsg;
            strMsg.Format(_T("Span %s for moment load is out of range. Max span number is %d. This load will be ignored."), LABEL_SPAN(pMomentLoad->m_SpanKey.spanIndex),nSpans);
            std::unique_ptr<pgsMomentLoadStatusItem> pStatusItem = std::make_unique<pgsMomentLoadStatusItem>(pMomentLoad->m_ID, m_LoadStatusGroupID, m_scidMomentLoadWarning, strMsg, pMomentLoad->m_SpanKey);
            pStatusCenter->Add(pStatusItem.release());
            continue; // break out of this cycle
         }
         else
         {
            spans.push_back(pMomentLoad->m_SpanKey.spanIndex);
         }
      }

      std::vector<SpanIndexType>::iterator spanIter(spans.begin());
      std::vector<SpanIndexType>::iterator spanIterEnd(spans.end());
      for ( ; spanIter != spanIterEnd; spanIter++ )
      {
         SpanIndexType span = *spanIter;

         GirderIndexType nGirders = GetGirderCountBySpan(span);

         std::vector<GirderIndexType> girders;
         if (pMomentLoad->m_SpanKey.girderIndex == ALL_GIRDERS)
         {
            for (GirderIndexType i = 0; i < nGirders; i++)
            {
               girders.push_back(i);
            }
         }
         else
         {
            if(nGirders <= pMomentLoad->m_SpanKey.girderIndex)
            {
               CString strMsg;
               strMsg.Format(_T("Girder %s for moment load is out of range. Max girder number is %s. This load will be ignored."), LABEL_GIRDER(pMomentLoad->m_SpanKey.girderIndex), LABEL_GIRDER(nGirders-1));
               std::unique_ptr<pgsMomentLoadStatusItem> pStatusItem = std::make_unique<pgsMomentLoadStatusItem>(pMomentLoad->m_ID,m_LoadStatusGroupID,m_scidMomentLoadWarning,strMsg,pMomentLoad->m_SpanKey);
               pStatusCenter->Add(pStatusItem.release());
               continue;
            }
            else
            {
               girders.push_back(pMomentLoad->m_SpanKey.girderIndex);
            }
         }

         CString strSpan;
         if (pMomentLoad->m_SpanKey.spanIndex == ALL_SPANS)
         {
            strSpan.Format(_T("%s"), _T("All Spans"));
         }
         else
         {
            strSpan.Format(_T("Span %s"), LABEL_SPAN(pMomentLoad->m_SpanKey.spanIndex));
         }

         CString strGirder;
         if (pMomentLoad->m_SpanKey.girderIndex == ALL_GIRDERS)
         {
            strGirder.Format(_T("%s"), _T("All Girders"));
         }
         else
         {
            strGirder.Format(_T("Girder %s"), LABEL_GIRDER(pMomentLoad->m_SpanKey.girderIndex));
         }

         CString strLocation;
         if (pMomentLoad->m_Fractional)
         {
            strLocation.Format(_T("%s"), FormatPercentage(pMomentLoad->m_Location));
         }
         else
         {
            GET_IFACE(IEAFDisplayUnits, pDisplayUnits);
            strLocation.Format(_T("%s"), FormatDimension(pMomentLoad->m_Location, pDisplayUnits->GetSpanLengthUnit()));
         }

         CString strLabel;
         strLabel.Format(_T("%s, %s, %s"), strSpan, strGirder, strLocation);

         std::vector<GirderIndexType>::iterator gdrIter(girders.begin());
         std::vector<GirderIndexType>::iterator gdrIterEnd(girders.end());
         for ( ; gdrIter != gdrIterEnd; gdrIter++ )
         {
            GirderIndexType girder = *gdrIter;

            CSpanKey thisSpanKey(span,girder);

            UserPointLoad upl;
            upl.m_LoadCase = Project2BridgeLoads(pMomentLoad->m_LoadCase);
            upl.m_Description = pMomentLoad->m_Description;

            // only a light warning for zero loads - don't bail out
            if (IsZero(pMomentLoad->m_Magnitude))
            {
               CString strMsg;
               strMsg.Format(_T("Magnitude of moment load is zero - %s"),strLabel);
               std::unique_ptr<pgsMomentLoadStatusItem> pStatusItem = std::make_unique<pgsMomentLoadStatusItem>(pMomentLoad->m_ID,m_LoadStatusGroupID,m_scidMomentLoadWarning,strMsg,thisSpanKey);
               pStatusCenter->Add(pStatusItem.release());
            }

            upl.m_Magnitude = pMomentLoad->m_Magnitude;

            Float64 span_length = GetSpanLength(span,girder); // span length measured along CL girder

            if (pMomentLoad->m_Fractional)
            {
               if(0.0 <= pMomentLoad->m_Location && pMomentLoad->m_Location <= 1.0)
               {
                  upl.m_Location = pMomentLoad->m_Location * span_length;
               }
               else
               {
                  CString strMsg;
                  strMsg.Format(_T("Fractional location value for moment load is out of range. Value must range from 0.0 to 1.0. This load will be ignored. - %s"),strLabel);
                  std::unique_ptr<pgsMomentLoadStatusItem> pStatusItem = std::make_unique<pgsMomentLoadStatusItem>(pMomentLoad->m_ID,m_LoadStatusGroupID,m_scidMomentLoadWarning,strMsg,thisSpanKey);
                  pStatusCenter->Add(pStatusItem.release());
                  continue;
               }
            }
            else
            {
               if(0.0 <= pMomentLoad->m_Location && pMomentLoad->m_Location <= span_length)
               {
                  upl.m_Location = pMomentLoad->m_Location;
               }
               else
               {
                  CString strMsg;
                  strMsg.Format(_T("Location value for moment load is out of range. Value must range from 0.0 to span length. This load will be ignored. - %s"),strLabel);
                  std::unique_ptr<pgsMomentLoadStatusItem> pStatusItem = std::make_unique<pgsMomentLoadStatusItem>(pMomentLoad->m_ID,m_LoadStatusGroupID,m_scidMomentLoadWarning,strMsg,thisSpanKey);
                  pStatusCenter->Add(pStatusItem.release());
                  continue;
               }
            }

            // add a point of interest at this load location in every interval
            CSegmentKey segmentKey;
            Float64 Xs;
            ConvertSpanPointToSegmentCoordiante(thisSpanKey,upl.m_Location,&segmentKey,&Xs);

            // The moment loads don't work well when they are at the CL pier of the FEM models
            // Move the loads so they are at the CL Brg of the segments.
            // Concentrated moments are only for PGSuper, not PGSplice, so segments = spans
            Float64 startEndDist, endEndDist;
            GetSegmentEndDistance(segmentKey, &startEndDist, &endEndDist);
            Float64 segLength = GetSegmentLength(segmentKey);
            Xs = ::ForceIntoRange(startEndDist,Xs,segLength-endEndDist);
            ConvertSegmentCoordinateToSpanPoint(segmentKey, Xs, &thisSpanKey, &upl.m_Location);

            pgsPointOfInterest poi(segmentKey,Xs,POI_CONCLOAD);
            VERIFY(m_pPoiMgr->AddPointOfInterest(poi) != INVALID_ID);

            // put load into our collection
            IntervalIndexType intervalIdx;
            if ( pMomentLoad->m_LoadCase == UserLoads::LL_IM )
            {
               intervalIdx = m_IntervalManager.GetLiveLoadInterval();
            }
            else
            {
               intervalIdx = m_IntervalManager.GetUserLoadInterval(thisSpanKey,pMomentLoad->m_LoadCase,pMomentLoad->m_ID);
            }
            ATLASSERT(intervalIdx != INVALID_INDEX);

            CUserLoadKey key(thisSpanKey,intervalIdx);
            std::map<CUserLoadKey,std::vector<UserMomentLoad>>::iterator found(m_MomentLoads.find(key));
            if ( found == m_MomentLoads.end() )
            {
               std::vector<UserMomentLoad> momentLoads;
               momentLoads.push_back(upl);
               m_MomentLoads.insert(std::make_pair(key,momentLoads));
            }
            else
            {
               std::vector<UserMomentLoad>& momentLoads = found->second;
               momentLoads.push_back(upl);
            }
         }
      }
   }
}

void CBridgeAgentImp::ValidateSegmentOrientation(const CSegmentKey& segmentKey) const
{
   VALIDATE(GIRDER);

   // Orientation was cached by geometry model builder
   Float64 orientation = 0.0;
   auto found = m_GirderOrientationCollection.find(segmentKey);
   if (found != m_GirderOrientationCollection.end())
   {
      orientation = found->second.m_Orientation;
   }
   else
   {
      ATLASSERT(0); // should never happen
   }

   // Store orientation in model
   CComPtr<ISuperstructureMember> ssmbr;
   GetSuperstructureMember(segmentKey,&ssmbr);

   CComPtr<ISuperstructureMemberSegment> segment;
   ssmbr->get_Segment(segmentKey.segmentIndex,&segment);

   segment->put_Orientation(orientation);
}

std::pair<Float64,Float64> CBridgeAgentImp::ComputeReasonableSurfaceStationRange(const CBridgeDescription2* pBridgeDesc, const AlignmentData2& alignmentData, IAlignment* pAlignment)
{
   // Want a reasonable start and end station where we can put our model and retain some numerical accuracy
   Float64 bridge_length = pBridgeDesc->GetLength();
   const CPierData2* pPier = pBridgeDesc->GetPier(0);
   Float64 startStation = pPier->GetStation();
   startStation -= bridge_length;

   // end station
   pPier = pBridgeDesc->GetPier(pBridgeDesc->GetPierCount() - 1);
   Float64 endStation = pPier->GetStation();
   endStation += bridge_length;

   IndexType nPathElements;
   pAlignment->get_Count(&nPathElements);
   if (0 < nPathElements)
   {
      CComPtr<IPathElement> element;
      pAlignment->get_Item(0, &element);
      CComPtr<IPoint2d> pntStart;
      element->GetStartPoint(&pntStart);
      CComPtr<IStation> objStation;
      Float64 offset;
      pAlignment->StationAndOffset(pntStart, &objStation, &offset);

      Float64 station;
      pAlignment->ConvertToNormalizedStation(CComVariant(objStation), &station);
      startStation = Min(startStation, station);

      element.Release();
      objStation.Release();
      pAlignment->get_Item(nPathElements - 1, &element);
      CComPtr<IPoint2d> pntEnd;
      element->GetEndPoint(&pntEnd);
      pAlignment->StationAndOffset(pntEnd, &objStation, &offset);
      pAlignment->ConvertToNormalizedStation(CComVariant(objStation), &station);
      endStation = Max(endStation, station);
   }

   CComPtr<IProfile> pProfile;
   if (SUCCEEDED(pAlignment->GetProfile(CBridgeGeometryModelBuilder::ProfileID, &pProfile)))
   {
      IndexType nProfileElements;
      pProfile->get_ProfileElementCount(&nProfileElements);
      if (0 < nProfileElements)
      {
         // get start station of first profile element
         CComPtr<IProfileElement> element;
         pProfile->get_Item(0, &element);
         CComPtr<IProfilePoint> pntStart;
         element->GetStartPoint(&pntStart);
         CComPtr<IStation> objStation;
         pntStart->get_Station(&objStation);
         Float64 station;
         pAlignment->ConvertToNormalizedStation(CComVariant(objStation), &station);
         startStation = Min(startStation, station);

         // get end station of last profile element
         element.Release();
         objStation.Release();
         pProfile->get_Item(nProfileElements - 1, &element);
         CComPtr<IProfilePoint> pntEnd;
         element->GetEndPoint(&pntEnd);
         pntEnd->get_Station(&objStation);
         pAlignment->ConvertToNormalizedStation(CComVariant(objStation), &station);
         endStation = Max(endStation, station);
      }
   }

   if (!IsZero(alignmentData.RefStation) || !IsZero(alignmentData.xRefPoint) || !IsZero(alignmentData.yRefPoint))
   {
      // we'll ignore the ref point at 0+00 (N 0, E 0)
      // this is the default and it probably means the user didn't input the values
      startStation = Min(startStation, alignmentData.RefStation);
      endStation   = Max(endStation, alignmentData.RefStation);
   }

   //if (profileData.VertCurves.size() == 0)
   //{
   //   Float64 L = 100;
   //   startStation = Min(startStation, profileData.Station + L);
   //   endStation   = Max(endStation, profileData.Station + L);
   //}

   return std::make_pair(startStation, endStation);
}


bool CBridgeAgentImp::BuildCogoModel()
{
#pragma Reminder("TODO - Break this into 3 methods for clarity, BuildAlignment,BuildProfile,BuildSurface")
   ATLASSERT(m_CogoModel == nullptr);
   m_CogoModel.Release();
   m_CogoModel.CoCreateInstance(CLSID_CogoModel);

   GET_IFACE( IRoadwayData, pIAlignment );
   if ( pIAlignment == nullptr )
   {
      return false;
   }

   const AlignmentData2& alignment_data   = pIAlignment->GetAlignmentData2();
   const ProfileData2&   profile_data     = pIAlignment->GetProfileData2();
   const RoadwaySectionData& section_data = pIAlignment->GetRoadwaySectionData();


   m_CogoModel->StoreAlignment(CBridgeGeometryModelBuilder::AlignmentID); // create the main alignment in the cogo model
   m_CogoModel->StoreProfile(CBridgeGeometryModelBuilder::ProfileID);
   m_CogoModel->AttachProfileToAlignment(CBridgeGeometryModelBuilder::ProfileID, CBridgeGeometryModelBuilder::AlignmentID);

   // Setup the alignment
   if ( alignment_data.CompoundCurves.size() == 0 )
   {
      // straight alignment
      CogoObjectID id1 = 20000;
      CogoObjectID id2 = 20001;
      m_CogoModel->StorePoint(id1,0,0); // start at point 0,0

      CComQIPtr<ILocate> locate(m_CogoModel);
      locate->ByDistDir(id2,id1,100.00,CComVariant(alignment_data.Direction),0.00);

      m_CogoModel->StorePathSegment(0, id1, id2);
      m_CogoModel->AddPathElementToAlignmentByID(CBridgeGeometryModelBuilder::AlignmentID, petPathSegment, 0);
      m_CogoModel->SetAlignmentReferenceStation(CBridgeGeometryModelBuilder::AlignmentID,CComVariant(0.00));
   }
   else
   {
      // there are horizontal curves
      CComQIPtr<ILocate2> locate(m_CogoEngine);
      CComQIPtr<IIntersect2> intersect(m_CogoEngine);

      // start the alignment at coordinate (0,0)... 
      CComPtr<IPoint2d> pbt; // point on back tangent
      pbt.CoCreateInstance(CLSID_Point2d);
      pbt->Move(0,0);



      Float64 back_tangent = alignment_data.Direction;

      Float64 prev_curve_ST_station; // station of the Spiral-to-Tangent point of the previous curve
                                    // station of the last point on the curve and will be
                                    // compared with the station at the start of the next curve
                                    // to confirm the next curve doesn't start before the previous one ends


      // The station at this first point is the PI station of the first curve less 1.5*Tangent.
      // This is somewhat arbitrary but will ensure that we are starting on the back tangent
      const auto& first_curve_data = *(alignment_data.CompoundCurves.begin());

      if ( IsZero(first_curve_data.Radius) )
      {
         prev_curve_ST_station = first_curve_data.PIStation - 100;
      }
      else
      {
         ATLASSERT(MIN_CURVE_RADIUS <= first_curve_data.Radius);
         Float64 delta;
         if (first_curve_data.bFwdTangent)
         {
            delta = first_curve_data.FwdTangent - back_tangent;
            while (delta < 0)
            {
               delta += PI_OVER_2;
            }

            while (M_PI <= delta)
            {
               delta -= M_PI;
            }

            ATLASSERT(0 <= delta && delta < M_PI);
         }
         else
         {
            delta = first_curve_data.FwdTangent;
         }
         Float64 T = first_curve_data.Radius*tan(fabs(delta)/ 2);
         ATLASSERT(0 <= T);
         prev_curve_ST_station = first_curve_data.PIStation - 1.5*T;
      }

      CogoObjectID curveID = 1;
      CogoObjectID pointID = 0;
      IndexType curveIdx = 0;
      IndexType realCurveIdx = 0;

      auto begin = std::cbegin(alignment_data.CompoundCurves);
      auto iter = begin;
      auto end = std::cend(alignment_data.CompoundCurves);
      for ( ; iter != end; iter++, curveID++, curveIdx++ )
      {
         const auto& curve_data = *iter;

         Float64 pi_station = curve_data.PIStation;

         Float64 T = 0;
         if ( IsZero(curve_data.Radius) )
         {
            // this is just a PI point (no curve)
            // create a line
            if ( iter == begin )
            {
               // if first curve, add a point on the back tangent
               m_CogoModel->StorePointEx(pointID, pbt);
               m_CogoModel->AddPathElementToAlignmentByID(CBridgeGeometryModelBuilder::AlignmentID, petPoint, pointID);
               pointID++;
            }

            // locate the PI
            CComPtr<IPoint2d> pi;
            Float64 distance = pi_station - prev_curve_ST_station; // if zero, then the pi is at the end of the previous curve... skip it
            Float64 tolerance = WBFL::Units::ConvertToSysUnits(0.009, WBFL::Units::Measure::Feet); // input accuracy is 0.01 ft
            if (!IsZero(distance,tolerance))
            {
               locate->ByDistDir(pbt, distance, CComVariant(back_tangent), 0.00, &pi);
               
               if (pi->SameLocation(pbt) == S_FALSE )
               {
                  // add the PI
                  m_CogoModel->StorePointEx(pointID, pi);
                  m_CogoModel->AddPathElementToAlignmentByID(CBridgeGeometryModelBuilder::AlignmentID, petPoint, pointID);
                  pointID++;
               }
            }

            Float64 fwd_tangent = curve_data.FwdTangent;
            if ( !curve_data.bFwdTangent )
            {
               // FwdTangent data member is the curve delta
               // compute the forward tangent direction by adding delta to the back tangent
               fwd_tangent += back_tangent;
            }

            if ( iter == std::prev(end) )
            {
               // this is the last point so add one more to model the last line segment
               CComQIPtr<ILocate2> locate(m_CogoEngine);
               CComPtr<IPoint2d> pnt;
               locate->ByDistDir(pi,100.00,CComVariant(fwd_tangent),0.00,&pnt);
               m_CogoModel->StorePointEx(pointID,pnt);
               m_CogoModel->AddPathElementToAlignmentByID(CBridgeGeometryModelBuilder::AlignmentID, petPoint, pointID);
               pointID++;
            }

            pbt = pi;
            back_tangent = fwd_tangent;
            prev_curve_ST_station = pi_station;
         }
         else
         {
            // a real curve
            ATLASSERT(MIN_CURVE_RADIUS <= curve_data.Radius);

            // locate the PI
            CComPtr<IPoint2d> pi;
            locate->ByDistDir(pbt, pi_station - prev_curve_ST_station, CComVariant( back_tangent ),0.00,&pi);

            Float64 fwd_tangent = curve_data.FwdTangent;
            if ( !curve_data.bFwdTangent )
            {
               // FwdTangent data member is the curve delta
               // compute the forward tangent direction by adding delta to the back tangent
               fwd_tangent += back_tangent;
            }

            // locate a point on the forward tangent.... at which distance? it doesn't matter... use
            // the curve radius for simplicity
            CComPtr<IPoint2d> pft; // point on forward tangent
            locate->ByDistDir(pi, curve_data.Radius, CComVariant( fwd_tangent ), 0.00, &pft );

            if ( IsZero(fabs(back_tangent - fwd_tangent)) || IsEqual(fabs(back_tangent - fwd_tangent),M_PI) )
            {
               std::_tostringstream os;
               os << _T("The central angle of horizontal curve ") << curveID << _T(" is 0 or 180 degrees. Horizontal curve was modeled as a single point at the PI location.");
               std::_tstring strMsg = os.str();
               std::unique_ptr<pgsAlignmentDescriptionStatusItem> pStatusItem = std::make_unique<pgsAlignmentDescriptionStatusItem>(m_StatusGroupID,m_scidAlignmentError,0,strMsg.c_str());
               GET_IFACE(IEAFStatusCenter,pStatusCenter);
               pStatusCenter->Add(pStatusItem.release());
               
               m_CogoModel->StorePointEx(pointID, pi);
               m_CogoModel->AddPathElementToAlignmentByID(CBridgeGeometryModelBuilder::AlignmentID, petPoint, pointID);
               pointID++;

               back_tangent = fwd_tangent;
               prev_curve_ST_station = pi_station;

               if ( curveIdx == 0 )
               {
                  // this is the first curve so set the reference station at the PI
                  m_CogoModel->SetAlignmentReferenceStation(CBridgeGeometryModelBuilder::AlignmentID,CComVariant(pi_station));
               }

               continue; // GO TO NEXT HORIZONTAL CURVE

               //strMsg += std::_tstring(_T("\nSee Status Center for Details"));
               //THROW_UNWIND(strMsg.c_str(),-1);
            }

            IDType pbtID = pointID++;
            IDType piID = pointID++;
            IDType pftID = pointID++;
            m_CogoModel->StorePointEx(pbtID, pbt);
            m_CogoModel->StorePointEx(piID, pi);
            m_CogoModel->StorePointEx(pftID, pft);
            m_CogoModel->StoreCompoundCurve(curveID, pbtID, piID, pftID, curve_data.Radius, curve_data.EntrySpiral, TransitionCurveType::Clothoid, curve_data.ExitSpiral, TransitionCurveType::Clothoid);
            m_CogoModel->AddPathElementToAlignmentByID(CBridgeGeometryModelBuilder::AlignmentID, petCompoundCurve, curveID);
            m_CompoundCurveKeys.insert(std::make_pair(realCurveIdx++,std::make_pair(curveIdx,curveID)));

            // Make sure this curve and the previous curve don't overlap
            CComPtr<ICompoundCurve> hc;
            m_CogoModel->CreateCompoundCurveByIndex(curveIdx, &hc);
            hc->get_BkTangentLength(&T);
            if ( 0 < curveIdx )
            {
               // tangent to spiral station
               Float64 TS_station = pi_station - T;

               if ( TS_station < prev_curve_ST_station )
               {
                  // this curve starts before the previous curve ends
                  if ( IsEqual(TS_station,prev_curve_ST_station, WBFL::Units::ConvertToSysUnits(0.01,WBFL::Units::Measure::Feet) ) )
                  {
                     // these 2 stations are within a 0.01 ft of each other... tweak this curve so it
                     // starts where the previous curve ends
                     CComPtr<ICompoundCurve> prev_curve, this_curve;
                     m_CogoModel->CreateCompoundCurveByIndex(curveIdx - 1, &prev_curve);

                     CComPtr<IPoint2d> pntST;
                     prev_curve->get_ST(&pntST);

                     CComPtr<IPoint2d> pntTS;
                     hc->get_TS(&pntTS);

                     Float64 stX,stY,tsX,tsY;
                     pntST->Location(&stX,&stY);
                     pntTS->Location(&tsX,&tsY);

                     CComQIPtr<IPathElement> element(hc);
                     element->Offset(stX - tsX, stY - tsY);
         
#if defined _DEBUG
                     pntTS.Release();
                     hc->get_TS(&pntTS);
                     pntTS->Location(&tsX,&tsY);
                     ATLASSERT(IsEqual(tsX,stX) && IsEqual(tsY,stY));
#endif
                     std::_tostringstream os;
                     os << _T("Horizontal curve ") << (curveIdx+1) << _T(" begins before curve ") << (curveIdx) << _T(" ends. Curve ") << (curveIdx+1) << _T(" has been adjusted.");
                     std::_tstring strMsg = os.str();
                     
                     std::unique_ptr<pgsAlignmentDescriptionStatusItem> pStatusItem = std::make_unique<pgsAlignmentDescriptionStatusItem>(m_StatusGroupID,m_scidAlignmentWarning,0,strMsg.c_str());
                     GET_IFACE(IEAFStatusCenter,pStatusCenter);
                     pStatusCenter->Add(pStatusItem.release());

                     strMsg += std::_tstring(_T("\nSee Status Center for Details"));
                  }
                  else
                  {
                     std::_tostringstream os;
                     os << _T("Horizontal curve ") << (curveIdx+1) << _T(" begins before curve ") << (curveIdx) << _T(" ends. Correct the curve data before proceeding");
                     std::_tstring strMsg = os.str();
                     
                     std::unique_ptr<pgsAlignmentDescriptionStatusItem> pStatusItem = std::make_unique<pgsAlignmentDescriptionStatusItem>(m_StatusGroupID,m_scidAlignmentError,0,strMsg.c_str());
                     GET_IFACE(IEAFStatusCenter,pStatusCenter);
                     pStatusCenter->Add(pStatusItem.release());

                     strMsg += std::_tstring(_T("\nSee Status Center for Details"));
                  }
               }
            }

            // determine the station of the ST point because this point will serve
            // as the next point on back tangent
            Float64 L;
            HRESULT hr = hc->get_TotalLength(&L);
            if ( FAILED(hr) )
            {
               std::_tostringstream os;
               os << _T("An error occurred while modeling horizontal curve ") << curveID << _T(".");
               os << std::endl;
               os << _T("The horizontal curve was ignored.");

               std::_tstring strMsg = os.str();
               std::unique_ptr<pgsAlignmentDescriptionStatusItem> pStatusItem = std::make_unique<pgsAlignmentDescriptionStatusItem>(m_StatusGroupID,m_scidAlignmentError,0,strMsg.c_str());
               GET_IFACE(IEAFStatusCenter,pStatusCenter);
               pStatusCenter->Add(pStatusItem.release());

               continue;
            }

            back_tangent = fwd_tangent;
            pbt.Release();
            hc->get_ST(&pbt);
            prev_curve_ST_station = pi_station - T + L;
         }

         if ( curveIdx == 0 )
         {
            // this is the first curve so set the reference station at the TS 
            if ( IsZero(curve_data.Radius) )
            {
               m_CogoModel->SetAlignmentReferenceStation(CBridgeGeometryModelBuilder::AlignmentID, CComVariant(pi_station - 100) );
            }
            else
            {
               m_CogoModel->SetAlignmentReferenceStation( CBridgeGeometryModelBuilder::AlignmentID, CComVariant(pi_station - T) );
            }
         }
      }
   }


   // Setup the profile
   if ( profile_data.VertCurves.size() == 0 )
   {
      CComPtr<IProfilePoint> ppStart, ppEnd;
      ppStart.CoCreateInstance(CLSID_ProfilePoint);
      ppEnd.CoCreateInstance(CLSID_ProfilePoint);

      ppStart->put_Station(CComVariant(profile_data.Station));
      ppStart->put_Elevation(profile_data.Elevation);

      Float64 L = 100;
      ppEnd->put_Station(CComVariant(profile_data.Station + L));
      ppEnd->put_Elevation( profile_data.Elevation + profile_data.Grade*L );

      IDType id1 = 20000;
      IDType id2 = 20001;
      m_CogoModel->StoreProfilePointEx(id1, ppStart);
      m_CogoModel->StoreProfilePointEx(id2, ppEnd);
      m_CogoModel->StoreProfileSegment(0, id1, id2);
      m_CogoModel->AddProfileElementByID(CBridgeGeometryModelBuilder::ProfileID, ProfileElementType::peProfileSegment, 0);
   }
   else
   {
      // there are vertical curves
      Float64 pbg_station   = profile_data.Station;
      Float64 pbg_elevation = profile_data.Elevation;
      Float64 entry_grade   = profile_data.Grade;

      Float64 prev_EVC = pbg_station;
      
      CogoObjectID curveID = 1;
      CogoObjectID pointID = 0;
      IndexType curveIdx = 0;
      IndexType realCurveIdx = 0;

      auto iter = std::cbegin(profile_data.VertCurves);
      auto end = std::cend(profile_data.VertCurves);
      for ( ; iter != end; iter++, curveIdx++ , curveID++)
      {
         const auto& curve_data = *iter;

         Float64 L1 = curve_data.L1;
         Float64 L2 = curve_data.L2;

         // if L2 is zero, interpret that as a symmetrical vertical curve with L1
         // being the full curve length.
         // Cut L1 in half and assign half to L2
         if ( IsZero(L2) )
         {
            L1 /= 2;
            L2 = L1;
         }

         CComPtr<IProfilePoint> pbg; // point on back grade
         pbg.CoCreateInstance(CLSID_ProfilePoint);

         if( curveID == 1 && IsEqual(pbg_station,curve_data.PVIStation) )
         {
            // it is a common input _T("mistake") to start with the PVI of the first curve...
            // project the beginning point back
            pbg_station   = pbg_station - 2*L1;
            pbg_elevation = pbg_elevation - 2*L1*entry_grade;
            pbg->put_Station(CComVariant(pbg_station));
            pbg->put_Elevation(pbg_elevation);

            prev_EVC = pbg_station;
         }
         else
         {
            pbg->put_Station(CComVariant(pbg_station));
            pbg->put_Elevation(pbg_elevation);
         }

         // locate the PVI
         Float64 pvi_station   = curve_data.PVIStation;
         Float64 pvi_elevation = pbg_elevation + entry_grade*(pvi_station - pbg_station);

         CComPtr<IProfilePoint> pvi;
         pvi.CoCreateInstance(CLSID_ProfilePoint);
         pvi->put_Station(CComVariant(pvi_station));
         pvi->put_Elevation(pvi_elevation);

         if ( IsZero(L1) && IsZero(L2) )
         {
            // zero length vertical curve.... this is OK as it creates
            // a profile point. It isn't common so warn the user
            std::_tostringstream os;
            os << _T("Vertical curve ") << curveID << _T(" is a zero length curve.");
            std::_tstring strMsg = os.str();

            std::unique_ptr<pgsAlignmentDescriptionStatusItem> pStatusItem = std::make_unique<pgsAlignmentDescriptionStatusItem>(m_StatusGroupID,m_scidAlignmentWarning,1,strMsg.c_str());
            GET_IFACE(IEAFStatusCenter,pStatusCenter);
            pStatusCenter->Add(pStatusItem.release());
         }

         // add a vertical curve
         Float64 pfg_station = pvi_station + (iter == end-1 ? 100 : L2);
         Float64 pfg_elevation = pvi_elevation + curve_data.ExitGrade*(iter == end-1 ? 100 : L2);

         CComPtr<IProfilePoint> pfg; // point on forward grade
         pfg.CoCreateInstance(CLSID_ProfilePoint);
         pfg->put_Station(CComVariant(pfg_station));
         pfg->put_Elevation(pfg_elevation);

         Float64 BVC = pvi_station - L1;
         Float64 EVC = pvi_station + L2;
         Float64 tolerance = WBFL::Units::ConvertToSysUnits(0.006,WBFL::Units::Measure::Feet); // sometimes users enter the BVC as the start point
                                                                           // and the numbers work out such that it differs by 0.01ft
                                                                           // select a tolerance so that this isn't a problem
         if( IsLT(BVC,prev_EVC,tolerance) || IsLT(pvi_station,prev_EVC,tolerance) || IsLT(EVC,prev_EVC,tolerance) )
         {
            // some part of this curve is before the end of the previous curve
            std::_tostringstream os;

            if ( curveID == 1 )
            {
               os << _T("Vertical Curve ") << curveID << _T(" begins before the profile reference point.");
            }
            else
            {
               os << _T("Vertical curve ") << curveID << _T(" begins before curve ") << (curveID-1) << _T(" ends.");
            }

            std::_tstring strMsg = os.str();

            std::unique_ptr<pgsAlignmentDescriptionStatusItem> pStatusItem = std::make_unique<pgsAlignmentDescriptionStatusItem>(m_StatusGroupID,m_scidAlignmentError,1,strMsg.c_str());
            GET_IFACE(IEAFStatusCenter,pStatusCenter);
            pStatusCenter->Add(pStatusItem.release());

            strMsg += std::_tstring(_T("\nSee Status Center for Details"));
//            THROW_UNWIND(strMsg.c_str(),-1);
         }

         IDType pbgID = pointID++;
         IDType pviID = pointID++;
         IDType pfgID = pointID++;
         m_CogoModel->StoreProfilePointEx(pbgID, pbg);
         m_CogoModel->StoreProfilePointEx(pviID, pvi);
         m_CogoModel->StoreProfilePointEx(pfgID, pfg);
         m_CogoModel->StoreVerticalCurve(curveID, pbgID, pviID, pfgID, L1, L2); // store the vertical curve in the COGO model
         m_CogoModel->AddProfileElementByID(CBridgeGeometryModelBuilder::ProfileID, ProfileElementType::peVertCurve, curveID); // add the vertical curve to the profile definition

         m_VertCurveKeys.insert(std::make_pair(realCurveIdx++,std::make_pair(curveIdx,curveID)));

#pragma Reminder("UPDATE - this test should go somewhere else")
         // NOTE: The following check for grades required that the stations making up the vertical curve
         // are normalized. This might not be the case in the future.
         //
         // We should use the actual vertical curve in the real profile, not create one on the fly here
         CComPtr<IVerticalCurve> vc;
         m_CogoModel->CreateVerticalCurveByID(curveID,&vc);

         Float64 g1,g2;
         vc->get_EntryGrade(&g1);
         vc->get_ExitGrade(&g2);

         if ( IsEqual(g1,g2) )
         {
            // entry and exit grades are the same
            std::_tostringstream os;
            os << _T("Entry and exit grades are the same on curve ") << curveID;
            std::_tstring strMsg = os.str();

            std::unique_ptr<pgsAlignmentDescriptionStatusItem> pStatusItem = std::make_unique<pgsAlignmentDescriptionStatusItem>(m_StatusGroupID,m_scidAlignmentWarning,1,strMsg.c_str());
            GET_IFACE(IEAFStatusCenter,pStatusCenter);
            pStatusCenter->Add(pStatusItem.release());
         }

         pbg_station   = pvi_station;
         pbg_elevation = pvi_elevation;
         entry_grade   = curve_data.ExitGrade;

         prev_EVC = EVC;
      }
   }

   // Create the roadway surface model. Make it much wider than the bridge so
   // none of the points fall off the surface.


   // NOTE: total width of roadway surface is arbitrary... just make sure it is wider than the bridge
   Float64 width = 1e9;

   // Before we start building the roadway surface, determine a reasonable station range in which to layout the surface
   GET_IFACE(IBridgeDescription, pIBridgeDesc);
   const CBridgeDescription2* pBridgeDesc = pIBridgeDesc->GetBridgeDescription();
   CComPtr<IAlignment> alignment;
   m_CogoModel->CreateAlignmentByID(CBridgeGeometryModelBuilder::AlignmentID, &alignment);
   Float64 startStation, endStation;
   std::tie(startStation,endStation) = ComputeReasonableSurfaceStationRange(pBridgeDesc, alignment_data, alignment);

   if (section_data.RoadwaySectionTemplates.empty())
   {
      // If no section templates are defined, we have a flat level roadway with crown at center
      IndexType templateIdx = 0;

      m_CogoModel->StoreSurface(CBridgeGeometryModelBuilder::SurfaceID, 2, 1, 1); // surface with 2 segments, alignment and profile at ridge point index 1
      m_CogoModel->AttachSurfaceToProfile(CBridgeGeometryModelBuilder::SurfaceID, CBridgeGeometryModelBuilder::ProfileID);

      m_CogoModel->AddSurfaceTemplate(CBridgeGeometryModelBuilder::SurfaceID, CComVariant(startStation));
      m_CogoModel->UpdateSurfaceTemplateSegmentByID(CBridgeGeometryModelBuilder::SurfaceID, 0, templateIdx++, width / 2, 0.0, tsHorizontal); // left template segment
      m_CogoModel->UpdateSurfaceTemplateSegmentByID(CBridgeGeometryModelBuilder::SurfaceID, 0, templateIdx++, width / 2, 0.0, tsHorizontal); // right template segment

      templateIdx = 0;
      m_CogoModel->AddSurfaceTemplate(CBridgeGeometryModelBuilder::SurfaceID, CComVariant(endStation));
      m_CogoModel->UpdateSurfaceTemplateSegmentByID(CBridgeGeometryModelBuilder::SurfaceID, 0, templateIdx++, width / 2, 0.0, tsHorizontal); // left template segment
      m_CogoModel->UpdateSurfaceTemplateSegmentByID(CBridgeGeometryModelBuilder::SurfaceID, 0, templateIdx++, width / 2, 0.0, tsHorizontal); // right template segment
   }
   else
   {
      // we have user defined templates. use input data
      m_CogoModel->StoreSurface(CBridgeGeometryModelBuilder::SurfaceID, section_data.NumberOfSegmentsPerSection, section_data.AlignmentPointIdx, section_data.ProfileGradePointIdx);
      m_CogoModel->AttachSurfaceToProfile(CBridgeGeometryModelBuilder::SurfaceID, CBridgeGeometryModelBuilder::ProfileID);

      IndexType templateIdx = 0;
      auto begin = section_data.RoadwaySectionTemplates.begin();
      auto iter = begin;
      auto end = section_data.RoadwaySectionTemplates.end();
      auto last = std::prev(end);
      for (; iter != end; iter++)
      {
         const auto& super(*iter);

         if (section_data.RoadwaySectionTemplates.size() == 1)
         {
            m_CogoModel->AddSurfaceTemplate(CBridgeGeometryModelBuilder::SurfaceID, CComVariant(Min(super.Station,startStation)));
         }
         else
         {
            m_CogoModel->AddSurfaceTemplate(CBridgeGeometryModelBuilder::SurfaceID, CComVariant(super.Station));
         }

         IndexType surfaceTemplateSegmentIdx = 0;

         // left infinite segment
         m_CogoModel->UpdateSurfaceTemplateSegmentByID(CBridgeGeometryModelBuilder::SurfaceID,templateIdx, surfaceTemplateSegmentIdx++,width, (section_data.slopeMeasure == RoadwaySectionData::RelativeToAlignmentPoint ? -1 : 1)* super.LeftSlope, tsHorizontal);

         // interior segments
         IndexType ridgePointIdx = 1;
         for (const auto& segment : super.SegmentDataVec)
         {
            Float64 sign = section_data.slopeMeasure == RoadwaySectionData::RelativeToAlignmentPoint ? (ridgePointIdx < section_data.AlignmentPointIdx ? -1 : 1) : 1;
            m_CogoModel->UpdateSurfaceTemplateSegmentByID(CBridgeGeometryModelBuilder::SurfaceID, templateIdx, surfaceTemplateSegmentIdx++, segment.Length, sign* segment.Slope, tsHorizontal);
            ridgePointIdx++;
         }

         // right infinite segment
         m_CogoModel->UpdateSurfaceTemplateSegmentByID(CBridgeGeometryModelBuilder::SurfaceID, templateIdx, surfaceTemplateSegmentIdx++, width, super.RightSlope, tsHorizontal);

         // Deal with bounding stations. We need to make sure our template collection spans the required boundaries
         if (section_data.RoadwaySectionTemplates.size() == 1)
         {
            m_CogoModel->CopySurfaceTemplateByID(CBridgeGeometryModelBuilder::SurfaceID, templateIdx++, CComVariant(endStation));
         }
         else if (iter == begin)
         {
            // the first user defined template has been created above.
            // if the stationing range begins before the first user template,
            // move the user template to the start of the stationing range
            if (startStation < super.Station)
            {
               m_CogoModel->CopySurfaceTemplateByID(CBridgeGeometryModelBuilder::SurfaceID, templateIdx++, CComVariant(startStation));
            }
         }
         else if (iter == last)
         {
            // the last user defined template has been created above.
            // if the stationing range ends after the last user template,
            // move the user template to the end of the stationing rage
            if (super.Station < endStation)
            {
               m_CogoModel->CopySurfaceTemplateByID(CBridgeGeometryModelBuilder::SurfaceID, templateIdx++, CComVariant(endStation));
            }
         }

         templateIdx++;
      }
   }
   
   return true;
}

bool CBridgeAgentImp::BuildBridgeGeometryModel()
{
   WATCH(_T("Building Bridge Geometry Model"));

   CComPtr<IBridgeGeometry> bridgeGeometry;
   m_Bridge->get_BridgeGeometry(&bridgeGeometry);

   // Create the alignment that will be used for the bridge
   CComPtr<IAlignment> alignment;
   m_CogoModel->CreateAlignmentByID(CBridgeGeometryModelBuilder::AlignmentID,&alignment);

   // Move the alignment such that the intersection of the alignment and the pier line of the first pier
   // is at coordinate (0,0). The purpose of doing this is to keep the bridge model in a local coordinate
   // system.

   // 1) Get station of first pier line
   GET_IFACE(IBridgeDescription, pIBridgeDesc);
   const CBridgeDescription2* pBridgeDesc = pIBridgeDesc->GetBridgeDescription();
   Float64 station = pBridgeDesc->GetPier(0)->GetStation();

   // 2) Create a point at the intersection of the alignment and the first pier line
   CComPtr<IPoint2d> objRefPoint1;
   alignment->LocatePoint(CComVariant(station), omtAlongDirection, 0.00, CComVariant(0.00), &objRefPoint1);

   // 3) create a point at the origin of the coordinate system.
   CComPtr<IPoint2d> objRefPoint2;
   objRefPoint2.CoCreateInstance(CLSID_Point2d);
   objRefPoint2->Move(0, 0);

   // 4) measure the distance and direction between the point on alignment and the desired origin
   CComQIPtr<IMeasure2> measure(m_CogoEngine);
   Float64 distance;
   CComPtr<IDirection> objDirection;
   measure->Inverse(objRefPoint1, objRefPoint2, &distance, &objDirection);

   // 5) move the alignment such that the intersection of the alignment and the first pier line is at the origin
   alignment->Move(distance, CComVariant(objDirection));

   // NOTE: THE BRIDGE AND ALIGNMENT ARE NOW IN THE LOCAL COORDINATE SYSTEM

   // 6) determine the location of the actual alignment reference point in the local coordinate system
   GET_IFACE(IRoadwayData, pIAlignment);
   const AlignmentData2& alignment_data = pIAlignment->GetAlignmentData2();
   CComPtr<IPoint2d> objRefPoint;
   alignment->LocatePoint(CComVariant(alignment_data.RefStation), omtAlongDirection, 0.00, CComVariant(0.00), &objRefPoint);
   Float64 dx, dy;
   objRefPoint->Location(&dx, &dy);
   m_DeltaX = alignment_data.xRefPoint - dx;
   m_DeltaY = alignment_data.yRefPoint - dy;

   // associated alignment with the bridge geometry
   bridgeGeometry->putref_Alignment(CBridgeGeometryModelBuilder::AlignmentID,alignment);
   bridgeGeometry->put_BridgeAlignmentID(CBridgeGeometryModelBuilder::AlignmentID);
   bridgeGeometry->put_ProfileID(CBridgeGeometryModelBuilder::ProfileID);
   bridgeGeometry->put_SurfaceID(CBridgeGeometryModelBuilder::SurfaceID);

   CBridgeGeometryModelBuilder model_builder;
   return model_builder.BuildBridgeGeometryModel(pBridgeDesc,m_CogoModel,alignment,bridgeGeometry,m_GirderOrientationCollection);
}

bool CBridgeAgentImp::BuildBridgeModel()
{
   //////////////////////////////////////////////////////////////////////////
   // NOTE
   // The analysis intervals that we use map directly to the stages
   // in the generic bridge model. The generic bridge model stages are
   // different than the stages in the timeline manager.
   //
   // The generic bridge model supports the analysis implementation, not the
   // raw input, for this reason we use analysis intervals as the generic
   // bridge "stages".
   //////////////////////////////////////////////////////////////////////////
   GET_IFACE(IBridgeDescription, pIBridgeDesc);
   if (!pIBridgeDesc->AreGirdersCompatible(ALL_GROUPS))
   {
      GET_IFACE(IEAFStatusCenter, pStatusCenter);
      CString strMsg(_T("Girder dimensions are not compatible."));
      std::unique_ptr<pgsBridgeDescriptionStatusItem> pStatusItem = std::make_unique<pgsBridgeDescriptionStatusItem>(m_StatusGroupID, m_scidBridgeDescriptionError, pgsBridgeDescriptionStatusItem::General, strMsg);
      pStatusCenter->Add(pStatusItem.release());

      strMsg += _T("\nSee Status Center for Details");
      THROW_UNWIND(strMsg,-1);
   }
   const CBridgeDescription2* pBridgeDesc = pIBridgeDesc->GetBridgeDescription();

#pragma Reminder("somewhere I need to validate the pier geometry... girders must be on the XBeam and columns must fit")
   // Need to create bridge so we can get to the cogo model
   ATLASSERT(m_Bridge == nullptr);
   m_Bridge.Release(); // release just in case, but it should already be done
   HRESULT hr = m_Bridge.CoCreateInstance(CLSID_GenericBridge);
   ATLASSERT(SUCCEEDED(hr));

   // Create effective flange width tool (it is needed to validate some of the parameters)
   CComObject<CEffectiveFlangeWidthTool>* pTool;
   hr = CComObject<CEffectiveFlangeWidthTool>::CreateInstance(&pTool);
   pTool->Init(m_pBroker,m_StatusGroupID);
   m_EffFlangeWidthTool = pTool;
   if ( FAILED(hr) || m_EffFlangeWidthTool == nullptr )
   {
      THROW_UNWIND(_T("Custom Effective Flange Width Tool not created"),-1);
   }

   m_SectCutTool->putref_EffectiveFlangeWidthTool(m_EffFlangeWidthTool);

   // Set up the interval manager
   m_IntervalManager.BuildIntervals(pBridgeDesc->GetTimelineManager());

   BuildBridgeGeometryModel(); // creates the framing geometry for the bridge model

   WATCH(_T("Validating Bridge Model"));

   if ( !LayoutPiers(pBridgeDesc) )
   {
      return false;
   }

   if ( !LayoutGirders(pBridgeDesc) )
   {
      return false;
   }

   if ( !LayoutDeck(pBridgeDesc) )
   {
      return false;
   }

   if ( !LayoutTrafficBarriers(pBridgeDesc) )
   {
      return false;
   }

   // Layout the bridge again to complete the geometry
   // This updates the geometry for the items that were added (girder, deck, etc)
   m_Bridge->UpdateBridgeModel(GF_DECK);

   // check bridge for errors - will throw an exception if there are errors
   CheckBridge();

   return true;
}

bool CBridgeAgentImp::LayoutPiers(const CBridgeDescription2* pBridgeDesc)
{
   // Build the physical generic pier model for the generic bridge object
   // Since we aren't using this information right now, this can be deferred until
   // a later date. The CPierData2 object contains enough information to create the
   // full physical pier model.
#pragma Reminder("UPDATE - build full pier model") // also add access methods to get pier model data
   // (may be useful for 3D BrIM type models

   //PierIndexType nPiers = pBridgeDesc->GetPierCount();
   //for ( PierIndexType pierIdx = 0; pierIdx < nPiers; pierIdx++ )
   //{
   //   const CPierData2* pPierData = pBridgeDesc->GetPier(pierIdx);

   //   if ( pPierData->GetPierModelType() == pgsTypes::pmtPhysical )
   //   {
   //      //
   //      // General Pier Information
   //      //
   //      CComPtr<IBridgePier> pier;
   //      GetGenericBridgePier(pierIdx,&pier);

   //      // Pier Type (derived from boundary condition)
   //      PierType pierType = GetPierType(pPierData);
   //      pier->put_Type(pierType);

   //      // skew angle should already be set

   //      // 
   //      // set the crown slope in the plane of the pier???
   //      // set the deck elevation at the alignment???
   //      // set the crown point offset???
   //      // set the curb line offsets???

   //      //
   //      // Cross Beam
   //      //
   //      CComPtr<ILinearCrossBeam> xbeam;
   //      xbeam.CoCreateInstance(CLSID_LinearCrossBeam);

   //      Float64 H1, H2, H3, H4;
   //      Float64 X1, X2, X3, X4;
   //      pPierData->GetXBeamDimensions(pgsTypes::stLeft,&H1,&H2,&X1,&X2);
   //      pPierData->GetXBeamDimensions(pgsTypes::stRight,&H3,&H4,&X3,&X4);

   //      Float64 W1 = pPierData->GetXBeamWidth();

   //      Float64 X5, X6;
   //      pPierData->GetXBeamOverhangs(&X5,&X6);

   //      Float64 H5 = pPierData->GetDiaphragmHeight(pgsTypes::Back) + pPierData->GetDiaphragmHeight(pgsTypes::Ahead);
   //      Float64 W2 = pPierData->GetDiaphragmWidth(pgsTypes::Back) + pPierData->GetDiaphragmWidth(pgsTypes::Ahead);

   //      xbeam->put_H1(H1);
   //      xbeam->put_H2(H2);
   //      xbeam->put_H3(H3);
   //      xbeam->put_H4(H4);
   //      xbeam->put_H5(H5);

   //      xbeam->put_X1(X1);
   //      xbeam->put_X2(X2);
   //      xbeam->put_X3(X3);
   //      xbeam->put_X4(X4);

   //      xbeam->put_W1(W1);
   //      xbeam->put_W2(W2);

   //      CComQIPtr<ICrossBeam> crossBeam(xbeam);
   //      pier->putref_CrossBeam(crossBeam);
   //      
   //      //
   //      // Bearing Layout
   //      //
   //      CComPtr<IBearingLayout> bearingLayout;
   //      bearingLayout.CoCreateInstance(CLSID_BearingLayout);
   //      pier->putref_BearingLayout(bearingLayout);

   //      //
   //      // Column Layout
   //      //
   //      CComPtr<IColumnLayout> columnLayout;
   //      columnLayout.CoCreateInstance(CLSID_ColumnLayout);
   //      pier->putref_ColumnLayout(columnLayout);
   //   }
   //}

   m_Bridge->UpdateBridgeModel(BGF_PIERS);

   return true;
}

bool CBridgeAgentImp::LayoutGirders(const CBridgeDescription2* pBridgeDesc)
{
   // at this point, the girder layout lines have been constructed in the bridge geometry model.
   // in this method we will create and configure superstructure members and segments for the generic bridge model.
   // we will also create precast girder objects and assign them to the superstructure members
   CComPtr<IBridgeGeometry> geometry;
   m_Bridge->get_BridgeGeometry(&geometry);

   Float64 gross_slab_depth = pBridgeDesc->GetDeckDescription()->GrossDepth;
   pgsTypes::SupportedDeckType deckType = pBridgeDesc->GetDeckDescription()->GetDeckType();
   pgsTypes::HaunchShapeType haunchShape = pBridgeDesc->GetDeckDescription()->HaunchShape;

   GroupIndexType nGroups = pBridgeDesc->GetGirderGroupCount();
   for ( GroupIndexType grpIdx = 0; grpIdx < nGroups; grpIdx++ )
   {
      const CGirderGroupData* pGroup = pBridgeDesc->GetGirderGroup(grpIdx);

      GirderIndexType nGirders = pGroup->GetGirderCount();
      for ( GirderIndexType gdrIdx = 0; gdrIdx < nGirders; gdrIdx++ )
      {
         CGirderKey girderKey(grpIdx,gdrIdx);

         const CSplicedGirderData* pGirder = pGroup->GetGirder(gdrIdx);

         // get the girder library entry
         const GirderLibraryEntry* pGirderEntry = GetGirderLibraryEntry(girderKey);

         CComPtr<IBeamFactory> beamFactory;
         pGirderEntry->GetBeamFactory(&beamFactory);

         // create a superstructure member
         CComPtr<ISuperstructureMember> ssmbr;
         IDType leftSSMbrID, thisSSMbrID, rightSSMbrID;
         GetSuperstructureMemberIDs(grpIdx, gdrIdx, nGirders, &leftSSMbrID, &thisSSMbrID, &rightSSMbrID);
         m_Bridge->CreateSuperstructureMember(thisSSMbrID,leftSSMbrID,rightSSMbrID,&ssmbr);

         SegmentIndexType nSegments = pGirder->GetSegmentCount();

         // first layout all segments in this girder (this connects the segments
         // together so the overall girder line geometry is correct).
         for ( SegmentIndexType segIdx = 0; segIdx < nSegments; segIdx++ )
         {
            CSegmentKey segmentKey(girderKey,segIdx);

            // Let beam factory build segments as necessary to represent the beam
            CComPtr<ISuperstructureMemberSegment> segment;
            beamFactory->CreateSegment(m_pBroker,m_StatusGroupID,segmentKey,&segment);
            ssmbr->AddSegment(segment);

            // associate girder line with segment so segment has plan view geometry
            LineIDType girderLineID = ::GetGirderSegmentLineID(segmentKey);
            CComPtr<IGirderLine> girderLine;
            geometry->FindGirderLine(girderLineID,&girderLine);

            segment->putref_GirderLine(girderLine);
         }

         // WARNING: You will be tempted to combine this loop with the one above. Don't do it.
         // This loop requires all the segments to be connected together in the bridge model.
         // That is what the loop above does when the beam factory creates the girder line layout.
         for (SegmentIndexType segIdx = 0; segIdx < nSegments; segIdx++)
         {
            CComPtr<ISuperstructureMemberSegment> segment;
            ssmbr->get_Segment(segIdx, &segment);

            const CPrecastSegmentData* pSegment = pGirder->GetSegment(segIdx);
            CSegmentKey segmentKey(pSegment->GetSegmentKey());

            // Now that the segment is wired up to its girder line, configure its cross section, materials, etc.
            beamFactory->ConfigureSegment(m_pBroker, m_StatusGroupID, segmentKey, segment);

            segment->put_Precamber(pSegment->Precamber);

            // assign a precast girder model to the segment
            CComPtr<IPrecastGirder> girder;
            HRESULT hr = girder.CoCreateInstance(CLSID_PrecastGirder);
            if (FAILED(hr) || girder == nullptr)
            {
               THROW_UNWIND(_T("Precast girder object not created"), -1);
            }
            girder->Initialize(segment);
            CComPtr<ITendonCollection> tendons;
            if (CreateTendons(pSegment, segment, &tendons))
            {
               girder->putref_Tendons(tendons);
            }
            CComQIPtr<IItemData> item_data(segment);
            item_data->AddItemData(CComBSTR(_T("Precast Girder")), girder);

            // ALSO SEE LayoutSsmHaunchesAdimInput() for additional configuration steps
         } // segment loop

         // add a tendon collection to the superstructure member... spliced girders know how to use it
         CComQIPtr<IItemData> ssmbrItemData(ssmbr);
         CComPtr<ITendonCollection> tendons;
         if (CreateTendons(pBridgeDesc, girderKey, ssmbr, &tendons))
         {
            ssmbrItemData->AddItemData(CComBSTR(_T("Tendons")), tendons);
         }
      } // girder loop

      // now that all the girders are layed out, we can layout the rebar
      for ( GirderIndexType gdrIdx = 0; gdrIdx < nGirders; gdrIdx++ )
      {
         CGirderKey girderKey(grpIdx,gdrIdx);

         const CSplicedGirderData* pGirder = pGroup->GetGirder(gdrIdx);

         SegmentIndexType nSegments = pGirder->GetSegmentCount();
         for ( SegmentIndexType segIdx = 0; segIdx < nSegments; segIdx++ )
         {
            CSegmentKey segmentKey(girderKey.groupIndex,girderKey.girderIndex,segIdx);

            LayoutSegmentRebar(segmentKey);

            if ( segIdx != nSegments-1 )
            {
               LayoutClosureJointRebar(segmentKey);
            }
         } // segment loop
      } // girder loop
   } // group loop
   return true;
}

void CBridgeAgentImp::ResolveStrandRowElevations(const CSegmentKey& segmentKey,const CStrandRow& strandRow,const std::array<Float64,4>& Xhp,std::array<Float64,4>& Y) const
{
   // Xhp is measured from the left end of the girder

   CComPtr<ISuperstructureMemberSegment> segment;
   GetSegment(segmentKey, &segment);

   for (int i = 0; i < 4; i++)
   {
      Y[i] = strandRow.m_Y[i];

      if (strandRow.m_Face[i] == pgsTypes::TopFace)
      {
         // measured down from top of girder... this is negative in Girder Section Coordinates
         Y[i] *= -1;
      }
      else
      {
         // adjust to be measured from top of girder
         CComPtr<IShape> shape;
         segment->get_GirderShape(Xhp[i], sbLeft, cstGirder, &shape);

         // bounding boxes of the section (height of section is height of bounding box)
         CComPtr<IRect2d> box;
         shape->get_BoundingBox(&box);

         Float64 Hg;
         box->get_Height(&Hg);

         Y[i] -= Hg;
      }
   }
}

void CBridgeAgentImp::CreateStrandModel(IPrecastGirder* girder,ISuperstructureMemberSegment* segment,const CPrecastSegmentData* pSegment, const GirderLibraryEntry* pGirderEntry) const
{
   // this is a factory method that creates and configures prestressing strand models for the generic bridge model
   const auto& segmentKey(pSegment->GetSegmentKey());

   Float64 Lg;
   girder->get_GirderLength(&Lg);

   if (pSegment->Strands.GetStrandDefinitionType() == pgsTypes::sdtDirectStrandInput)
   {
      // direct strand input defines each strand individually,
      // for this we use a strand point model
      CComPtr<IStrandPointModel> strandPointModel;
      strandPointModel.CoCreateInstance(CLSID_StrandPointModel);

      girder->putref_StrandModel(strandPointModel);

      // layout the harping points
      std::array<Float64, 4> Xhp;
      ResolveHarpPointLocations(pSegment, nullptr, Xhp);

      strandPointModel->put_EndHarpingPointReference(hprEndOfGirder);
      strandPointModel->put_EndHarpingPointMeasure(hpmAbsoluteDistance);
      strandPointModel->SetEndHarpingPoints(Xhp[ZoneBreakType::Start], Lg - Xhp[ZoneBreakType::End]);

      strandPointModel->put_HarpingPointReference(hprEndOfGirder);
      strandPointModel->put_HarpingPointMeasure(hpmAbsoluteDistance);
      strandPointModel->SetHarpingPoints(Xhp[ZoneBreakType::LeftBreak], Lg - Xhp[ZoneBreakType::RightBreak]);

      // harping points are explicitly defined so there isn't a minimum
      strandPointModel->put_UseMinHarpPointDistance(VARIANT_FALSE);
      strandPointModel->put_MinHarpPointDistance(0.0);
   }
   else
   {
      // all other strand input methods use a grid-based model with the assumption of 
      // strand symmetry about a vertical axis (center of girder or center of web(eg asymmetric deck bulb tee girders))
      CComPtr<IStrandGridModel> strandGridModel;
      strandGridModel.CoCreateInstance(CLSID_StrandGridModel);

      girder->putref_StrandModel(strandGridModel);

      // layout the harping points (assuming this is not a sdtDirectRowInput...
      // ... sdtDirectRowInput harp point information modifies these settings below)
      strandGridModel->put_AllowOddNumberOfHarpedStrands(pGirderEntry->OddNumberOfHarpedStrands() ? VARIANT_TRUE : VARIANT_FALSE);
      strandGridModel->put_UseDifferentHarpedGridsAtEnds(pGirderEntry->IsDifferentHarpedGridAtEndsUsed() ? VARIANT_TRUE : VARIANT_FALSE);

      strandGridModel->put_UseMinHarpPointDistance(pGirderEntry->IsMinHarpingPointLocationUsed() ? VARIANT_TRUE : VARIANT_FALSE);
      strandGridModel->put_MinHarpPointDistance(pGirderEntry->GetMinHarpingPointLocation());

      GirderLibraryEntry::MeasurementLocation hpref = pGirderEntry->GetHarpingPointReference();
      GirderLibraryEntry::MeasurementType hpmeasure = pGirderEntry->GetHarpingPointMeasure();
      Float64 hpLoc = pGirderEntry->GetHarpingPointLocation();

      strandGridModel->put_HarpingPointReference(HarpPointReference(hpref));
      strandGridModel->put_HarpingPointMeasure(HarpPointMeasure(hpmeasure));
      strandGridModel->SetHarpingPoints(hpLoc, hpLoc);

      // For this strand definition type, the end harp points are always located at the end faces of the girder
      strandGridModel->put_EndHarpingPointReference(hprEndOfGirder);
      strandGridModel->put_EndHarpingPointMeasure(hpmFractionOfGirderLength);
      strandGridModel->SetEndHarpingPoints(0.0, 0.0);

      // Get height of girder section... going to needed this for
      // creating strand movers and filling up strand patterns...
      // since we are in an initialization/validation phase, we cannot
      // get the height from the IShapeProperties interface
      Float64 XsStart = 0.0;
      Float64 XsEnd;
      segment->get_Length(&XsEnd);

      Float64 XsHp1Loc, XsHp2Loc;
      strandGridModel->GetHarpingPointLocations(&XsHp1Loc, &XsHp2Loc);

      CComPtr<IShape> startShape, hp1Shape, hp2Shape, endShape;
      segment->get_GirderShape(XsStart, sbRight, cstGirder, &startShape);
      segment->get_GirderShape(XsHp1Loc, sbLeft, cstGirder, &hp1Shape);
      segment->get_GirderShape(XsHp2Loc, sbLeft, cstGirder, &hp2Shape);
      segment->get_GirderShape(XsEnd, sbLeft, cstGirder, &endShape);

      // bounding boxes of the section (height of section is height of bounding box)
      CComPtr<IRect2d> bbStart, bbHP1, bbHP2, bbEnd;
      startShape->get_BoundingBox(&bbStart);
      hp1Shape->get_BoundingBox(&bbHP1);
      hp2Shape->get_BoundingBox(&bbHP2);
      endShape->get_BoundingBox(&bbEnd);

      Float64 HgStart, HgHP1, HgHP2, HgEnd;
      bbStart->get_Height(&HgStart);
      bbHP1->get_Height(&HgHP1);
      bbHP2->get_Height(&HgHP2);
      bbEnd->get_Height(&HgEnd);


      // Create the strand movers
      // one at each location harped strand can be moved/adjusted based on the height
      // of the segment at those locations
      pgsTypes::AdjustableStrandType adjType = pSegment->Strands.GetAdjustableStrandType();

      CComPtr<IStrandMover> startStrandMover, hp1StrandMover, hp2StrandMover, endStrandMover;
      CreateStrandMover(pGirderEntry->GetName().c_str(), HgStart, adjType, &startStrandMover);
      CreateStrandMover(pGirderEntry->GetName().c_str(), HgHP1, adjType, &hp1StrandMover);
      CreateStrandMover(pGirderEntry->GetName().c_str(), HgHP2, adjType, &hp2StrandMover);
      CreateStrandMover(pGirderEntry->GetName().c_str(), HgEnd, adjType, &endStrandMover);
      ATLASSERT(startStrandMover != nullptr);
      ATLASSERT(hp1StrandMover != nullptr);
      ATLASSERT(hp2StrandMover != nullptr);
      ATLASSERT(endStrandMover != nullptr);

      strandGridModel->SetStrandMovers(startStrandMover, hp1StrandMover, hp2StrandMover, endStrandMover);

      // Fill up strand patterns
      std::array<CComPtr<IStrandGrid>,2> strGrd, harpGrdEnd, harpGrdHP, tempGrd;
      strandGridModel->get_StraightStrandGrid(etStart, &strGrd[etStart]);
      strandGridModel->get_HarpedStrandGridEnd(etStart, &harpGrdEnd[etStart]);
      strandGridModel->get_HarpedStrandGridHP(etStart, &harpGrdHP[etStart]);
      strandGridModel->get_TemporaryStrandGrid(etStart, &tempGrd[etStart]);

      strandGridModel->get_StraightStrandGrid(etEnd, &strGrd[etEnd]);
      strandGridModel->get_HarpedStrandGridEnd(etEnd, &harpGrdEnd[etEnd]);
      strandGridModel->get_HarpedStrandGridHP(etEnd, &harpGrdHP[etEnd]);
      strandGridModel->get_TemporaryStrandGrid(etEnd, &tempGrd[etEnd]);

      if (pSegment->Strands.GetStrandDefinitionType() == pgsTypes::sdtDirectRowInput)
      {
         // Not using the strand grid in the library... create the strand grid based on user input
         std::array<Float64, 4> Z;
         ResolveHarpPointLocations(pSegment, nullptr, Z);

         const auto strandRows = pSegment->Strands.GetStrandRows();
         for( const auto& strandRow : strandRows)
         {
            GridIndexType nGridPoints = strandRow.m_nStrands / 2; // strand grid is only half the full grid (just the grid on the positive X side)
            Float64 Xi = strandRow.m_Z / 2; // distance from CL Girder to first strand
            ATLASSERT(IsOdd(strandRow.m_nStrands) ? IsZero(Xi) : !IsZero(Xi));
            if (IsOdd(strandRow.m_nStrands))
            {
               nGridPoints++;
            }

            std::array<Float64,4> Y;
            ResolveStrandRowElevations(segmentKey, strandRow, Z, Y);

            for (GridIndexType gridPointIdx = 0; gridPointIdx < nGridPoints; gridPointIdx++)
            {
               Float64 X = Xi + gridPointIdx*strandRow.m_Spacing;

               CComPtr<IPoint2d> pntStart;
               pntStart.CoCreateInstance(CLSID_Point2d);
               pntStart->Move(X, Y[ZoneBreakType::Start]);

               CComPtr<IPoint2d> pntLeftHP;
               pntLeftHP.CoCreateInstance(CLSID_Point2d);
               pntLeftHP->Move(X, Y[ZoneBreakType::LeftBreak]);

               CComPtr<IPoint2d> pntRightHP;
               pntRightHP.CoCreateInstance(CLSID_Point2d);
               pntRightHP->Move(X, Y[ZoneBreakType::RightBreak]);

               CComPtr<IPoint2d> pntEnd;
               pntEnd.CoCreateInstance(CLSID_Point2d);
               pntEnd->Move(X, Y[ZoneBreakType::End]);

               switch (strandRow.m_StrandType)
               {
               case pgsTypes::Straight:
                  strGrd[etStart]->AddGridPoint(pntStart);
                  strGrd[etEnd]->AddGridPoint(pntEnd);
                  break;

               case pgsTypes::Harped:
                  strandGridModel->SetEndHarpingPoints(Z[ZoneBreakType::Start], Lg - Z[ZoneBreakType::End]);
                  strandGridModel->SetHarpingPoints(Z[ZoneBreakType::LeftBreak], Lg - Z[ZoneBreakType::RightBreak]);
                  strandGridModel->put_HarpingPointMeasure(hpmAbsoluteDistance);
                  strandGridModel->put_HarpingPointReference(hprEndOfGirder);
                  strandGridModel->put_EndHarpingPointMeasure(hpmAbsoluteDistance);
                  strandGridModel->put_EndHarpingPointReference(hprEndOfGirder);
                  strandGridModel->put_AllowOddNumberOfHarpedStrands(VARIANT_FALSE);

                  harpGrdEnd[etStart]->AddGridPoint(pntStart);
                  harpGrdEnd[etEnd]->AddGridPoint(pntEnd);

                  harpGrdHP[etStart]->AddGridPoint(pntLeftHP);
                  harpGrdHP[etEnd]->AddGridPoint(pntRightHP);

                  break;

               case pgsTypes::Temporary:
                  tempGrd[etStart]->AddGridPoint(pntStart);
                  tempGrd[etEnd]->AddGridPoint(pntEnd);
                  break;

               default:
                  ATLASSERT(false); // should never get here
               }
            }
         }
      }
      else
      {
         // not user defined
         pGirderEntry->ConfigureStraightStrandGrid(HgStart, HgEnd, strGrd[etStart], strGrd[etEnd]);
         pGirderEntry->ConfigureHarpedStrandGrids(HgStart, HgHP1, HgHP2, HgEnd, harpGrdEnd[etStart], harpGrdHP[etStart], harpGrdHP[etEnd], harpGrdEnd[etEnd]);
         pGirderEntry->ConfigureTemporaryStrandGrid(HgStart, HgEnd, tempGrd[etStart], tempGrd[etEnd]);
      }
   }

   // Create strand material
   CComPtr<IStrandModel> strandModel;
   girder->get_StrandModel(&strandModel);

   IntervalIndexType stressStrandIntervalIdx = m_IntervalManager.GetStressStrandInterval(segmentKey);

   const auto* pStrand = pSegment->Strands.GetStrandMaterial(pgsTypes::Straight);
   CComPtr<IPrestressingStrand> straightStrandMaterial;
   straightStrandMaterial.CoCreateInstance(CLSID_PrestressingStrand);
   straightStrandMaterial->put_Name(CComBSTR(pStrand->GetName().c_str()));
   straightStrandMaterial->put_Grade((StrandGrade)pStrand->GetGrade());
   straightStrandMaterial->put_Type((StrandMaterialType)pStrand->GetType());
   straightStrandMaterial->put_Size((StrandSize)pStrand->GetSize());
   straightStrandMaterial->put_InstallationStage(stressStrandIntervalIdx);
   strandModel->putref_StrandMaterial(Straight, straightStrandMaterial);

   pStrand = pSegment->Strands.GetStrandMaterial(pgsTypes::Harped);
   CComPtr<IPrestressingStrand> harpedStrandMaterial;
   harpedStrandMaterial.CoCreateInstance(CLSID_PrestressingStrand);
   harpedStrandMaterial->put_Name(CComBSTR(pStrand->GetName().c_str()));
   harpedStrandMaterial->put_Grade((StrandGrade)pStrand->GetGrade());
   harpedStrandMaterial->put_Type((StrandMaterialType)pStrand->GetType());
   harpedStrandMaterial->put_Size((StrandSize)pStrand->GetSize());
   harpedStrandMaterial->put_InstallationStage(stressStrandIntervalIdx);
   strandModel->putref_StrandMaterial(Harped, harpedStrandMaterial);

   stressStrandIntervalIdx = GetTemporaryStrandStressingInterval(segmentKey);
   auto tsRemovalIntervalIdx = m_IntervalManager.GetTemporaryStrandRemovalInterval(segmentKey);
   pStrand = pSegment->Strands.GetStrandMaterial(pgsTypes::Temporary);
   CComPtr<IPrestressingStrand> temporaryStrandMaterial;
   temporaryStrandMaterial.CoCreateInstance(CLSID_PrestressingStrand);
   temporaryStrandMaterial->put_Name(CComBSTR(pStrand->GetName().c_str()));
   temporaryStrandMaterial->put_Grade((StrandGrade)pStrand->GetGrade());
   temporaryStrandMaterial->put_Type((StrandMaterialType)pStrand->GetType());
   temporaryStrandMaterial->put_Size((StrandSize)pStrand->GetSize());
   temporaryStrandMaterial->put_InstallationStage(stressStrandIntervalIdx);
   temporaryStrandMaterial->put_RemovalStage(tsRemovalIntervalIdx);
   strandModel->putref_StrandMaterial(Temporary, temporaryStrandMaterial);
}

void CBridgeAgentImp::GetHaunchDepth4ADimInput(const CPrecastSegmentData* pSegment, CComPtr<IDblArray>& pHaunchDepths)
{
   // Haunch depths were input using "A" and assumed excess camber. This is only supported in PGSuper models
#if defined _DEBUG
   GET_IFACE(IDocumentType,pDocType);
   ATLASSERT(pDocType->IsPGSuperDocument());
#endif

   // The generic bridge model wants haunch depths at the end of each segment
   const CSegmentKey& segmentKey = pSegment->GetSegmentKey();
   const CDeckDescription2* pDeck = pSegment->GetGirder()->GetGirderGroup()->GetBridgeDescription()->GetDeckDescription();
   Float64 tDeck;
   if (pDeck->GetDeckType() == pgsTypes::sdtCompositeSIP)
   {
      tDeck = pDeck->GrossDepth + pDeck->PanelDepth;
   }
   else
   {
      tDeck = pDeck->GrossDepth;
   }

   PoiList vPoi;
   GetPointsOfInterest(segmentKey,POI_0L | POI_5L | POI_10L | POI_ERECTED_SEGMENT,&vPoi);
   ATLASSERT(vPoi.size() == 3);
   std::array<Float64,2> haunch_at_support;
   haunch_at_support[pgsTypes::metStart] = GetTopSlabToTopGirderChordDistance(vPoi.front()) - tDeck;
   haunch_at_support[pgsTypes::metEnd]   = GetTopSlabToTopGirderChordDistance(vPoi.back()) - tDeck;
   Float64 haunchNoCamber = GetTopSlabToTopGirderChordDistance(vPoi[1]) - tDeck;

   haunch_at_support[pgsTypes::metStart] = IsZero(haunch_at_support[pgsTypes::metStart]) ? 0 : haunch_at_support[pgsTypes::metStart];
   haunch_at_support[pgsTypes::metEnd]   = IsZero(haunch_at_support[pgsTypes::metEnd])   ? 0 : haunch_at_support[pgsTypes::metEnd];
   haunchNoCamber = IsZero(haunchNoCamber) ? 0 : haunchNoCamber;

   std::array<const CPierData2*,2> pPier;
   std::array<const CTemporarySupportData*,2> pTS;
   pSegment->GetSupport(pgsTypes::metStart,&pPier[pgsTypes::metStart],&pTS[pgsTypes::metStart]);
   pSegment->GetSupport(pgsTypes::metEnd,&pPier[pgsTypes::metEnd],&pTS[pgsTypes::metEnd]);

   std::array<const CSpanData2*,2> pSpan;
   pSpan[pgsTypes::metStart] = pSegment->GetSpan(pgsTypes::metStart);
   pSpan[pgsTypes::metEnd] = pSegment->GetSpan(pgsTypes::metEnd);

   GET_IFACE(ISpecification,pSpec);
   bool bIsAssumedExcessCamber = pSpec->IsAssumedExcessCamberForSectProps();

   Float64 mid_haunch;
   if (bIsAssumedExcessCamber)
   {
      // A pgsuper model, and user defined assumed excess camber. Use this as our haunch geometry to view
      Float64 camber = pSpan[pgsTypes::metStart]->GetAssumedExcessCamber(segmentKey.girderIndex);

      mid_haunch = haunchNoCamber - camber;
   }
   else
   {
      // A pgsuper model, but user did not define excess camber. Use the Fillet value since no other data
      Float64 fillet = GetFillet();
      mid_haunch = fillet;
   }

   // At this point we have haunch values at supports and at mid-span. Now extend them out to the ends of the segment
   Float64 segment_start_end_dist,segment_end_end_dist;
   segment_start_end_dist = GetSegmentStartEndDistance(segmentKey);
   segment_end_end_dist   = GetSegmentEndEndDistance(segmentKey);
   Float64 span_length = GetSegmentSpanLength(segmentKey);

   // There is a linear part of the variation, and potentially a parabolic part
   Float64 lin_start_haunch,lin_end_haunch;
   if (IsEqual(haunch_at_support[pgsTypes::metStart],haunch_at_support[pgsTypes::metEnd]))
   {
      lin_start_haunch = haunch_at_support[pgsTypes::metStart];
      lin_end_haunch =  haunch_at_support[pgsTypes::metEnd];
   }
   else
   {
      lin_start_haunch = ::LinInterp(-segment_start_end_dist,haunch_at_support[pgsTypes::metStart],haunch_at_support[pgsTypes::metEnd],span_length);
      lin_end_haunch = ::LinInterp(span_length + segment_end_end_dist,haunch_at_support[pgsTypes::metStart],haunch_at_support[pgsTypes::metEnd],span_length);
   }

   // Now we can determine the three hunch depths that define our parabola
   Float64 startHaunch,midHaunch,endHaunch;

   // Parabolic part
   Float64 lin_mid_haunch = (lin_start_haunch + lin_end_haunch) / 2.0;
   Float64 bulge = mid_haunch - lin_mid_haunch;
   if (IsZero(bulge))
   {
      // No parabola, just need linear part
      startHaunch = lin_start_haunch;
      endHaunch = lin_end_haunch;
   }
   else
   {
      auto parabola(GenerateParabola(0.0,span_length,bulge));
      Float64 par_start_haunch = parabola.Evaluate(-segment_start_end_dist);
      Float64 par_end_haunch =   parabola.Evaluate(span_length + segment_end_end_dist);

      startHaunch = lin_start_haunch + par_start_haunch;
      endHaunch = lin_end_haunch + par_end_haunch;
   }

   midHaunch = mid_haunch;

   // Put into return array
   pHaunchDepths->Add(startHaunch);
   pHaunchDepths->Add(midHaunch);
   pHaunchDepths->Add(endHaunch);

   // if these fire, something is really messed up... one likely cause is 
   // the slab depth is equal to the "A" dimension so build-up doesn't fit
   // at actual ends of the segment.. this is not really a bug, but rather bad input
   ATLASSERT(0 <= startHaunch && startHaunch < 1e9);
   ATLASSERT(midHaunch < 1e9);
   ATLASSERT(0 <= endHaunch && endHaunch < 1e9);

   if (midHaunch < 0)
   {
      GET_IFACE(IEAFStatusCenter,pStatusCenter);
      GET_IFACE(ISpecification,pSpec);
      bool bIsParabolic = pSpec->IsAssumedExcessCamberInputEnabled();

      CString msg;
      if (bIsParabolic)
      {
         msg.Format(_T("The assumed excess camber for span %s, girder %s is larger than the haunch depth at mid span. The girder will intrude into the bottom of the slab. For analysis purposes, the haunch depth will be assumed to be zero."),LABEL_SPAN(segmentKey.groupIndex),LABEL_GIRDER(segmentKey.girderIndex));
      }
      else
      {
         msg.Format(_T("The girder top chord for span %s, girder %s intrudes into the bottom of the slab at mid-span."),LABEL_SPAN(segmentKey.groupIndex),LABEL_GIRDER(segmentKey.girderIndex));
      }
      std::unique_ptr<pgsBridgeDescriptionStatusItem> pStatusItem = std::make_unique<pgsBridgeDescriptionStatusItem>(m_StatusGroupID,m_scidBridgeDescriptionWarning,pgsBridgeDescriptionStatusItem::Deck,msg);
      pStatusCenter->Add(pStatusItem.release());
   }
}

void CBridgeAgentImp::GetHaunchDepth4BySpanInput(const CPrecastSegmentData* pSegment,const CBridgeDescription2* pBridgeDesc,CComPtr<IDblArray>& pHaunchDepths)
{
   // Haunch is direct input across spans. Need to convert to per-segment layout
   CSegmentKey segmentKey = pSegment->GetSegmentKey();
   GirderIndexType gdrIdx = segmentKey.girderIndex;

   if (pBridgeDesc->GetHaunchInputDistributionType() == pgsTypes::hidUniform)
   {
      // Special, trivial case. Haunch is uniform across span. Just use haunch depth of first span on segment
      const CSpanData2* pSpan = pSegment->GetSpan(pgsTypes::metStart);
      std::vector<Float64> spanHaunches = pSpan->GetDirectHaunchDepths(gdrIdx);
      ATLASSERT(spanHaunches.size() == 1);

      pHaunchDepths->Add(spanHaunches.front());
   }
   else
   {
      pgsTypes::HaunchInputDistributionType haunchInputDistributionType = pBridgeDesc->GetHaunchInputDistributionType();

      // The parabolic case needs special treatment in the case of pgsuper-type models where a segment lies entirely 
      // within a span.
      SpanIndexType startSpanIdx = pSegment->GetSpan(pgsTypes::metStart)->GetIndex();
      SpanIndexType endSpanIdx = pSegment->GetSpan(pgsTypes::metEnd)->GetIndex();

      if (haunchInputDistributionType != pgsTypes::hidParabolic)
      {
         // For all cases Except for parabolic when segment lies within a single span:
         // Use linear interpolation of piecewise linear span locations to determine haunch values across segments
         // Values at span locations can be outside of the bounds of segments - extrapolate those values
         WBFL::Math::PiecewiseFunction pwLinearFunction;
         pwLinearFunction.SetOutOfRangeBehavior(WBFL::Math::PiecewiseFunction::orbExtrapolate);

         Float64 segmentLength = GetSegmentLength(segmentKey);

         // Build layout along segments. Use GirderLineCoord's as basis
         for (SpanIndexType spanIdx = startSpanIdx; spanIdx <= endSpanIdx; spanIdx++)
         {
            CSpanKey spanKey(spanIdx,gdrIdx);
            // Need location of XSpan below in "Span Coordinates". This starts at bearing location in first span
            Float64 spanLength = GetSpanLength(spanKey); // this is cl pier to cl pier

            const CSpanData2* pSpan = pBridgeDesc->GetSpan(spanIdx);
            std::vector<Float64> spanHaunches = pSpan->GetDirectHaunchDepths(gdrIdx);

            std::size_t numHaunches = spanHaunches.size();
            std::size_t currLoc = 0;
            for (auto haunch : spanHaunches)
            {
               Float64 Xspan = spanLength * (Float64)currLoc / (Float64)(numHaunches - 1);
               pgsPointOfInterest spanPoi = ConvertSpanPointToPoi(spanKey,Xspan);
               Float64 Xgirderline = ConvertPoiToGirderlineCoordinate(spanPoi);
               pwLinearFunction.AddPoint(Xgirderline,haunch);
               currLoc++;
            }
         }

         // Create haunch depths along segment at same distribution as for spans. Don't try to match jumps 
         int numSegmentLocs = (int)haunchInputDistributionType;
         for (int iSegmentLoc = 0; iSegmentLoc < numSegmentLocs; iSegmentLoc++)
         {
            Float64 XSegment = segmentLength * (Float64)iSegmentLoc / (Float64)(numSegmentLocs - 1);
            Float64 Xgl = ConvertSegmentCoordinateToGirderlineCoordinate(segmentKey,XSegment);
            Float64 haunch = pwLinearFunction.Evaluate(Xgl);

            pHaunchDepths->Add(haunch);
         }
      }
      else if (haunchInputDistributionType == pgsTypes::hidParabolic && startSpanIdx != endSpanIdx)
      {
         // For parabolic when segment lies within multiple spans:
         // Use linear interpolation of piecewise linear span locations to determine haunch values across segments
         // Place haunch depths at along span to attempt to capture odd jump
         const IndexType numSpanSegs = 45; // after some experimentation, these values seem to work well
         const IndexType numSegSegs = numSpanSegs / 3;

         WBFL::Math::PiecewiseFunction pwLinearFunction;
         pwLinearFunction.SetOutOfRangeBehavior(WBFL::Math::PiecewiseFunction::orbExtrapolate);

         Float64 segmentLength = GetSegmentLength(segmentKey);

         // Build layout along spans. Use GirderLineCoord's as basis
         for (SpanIndexType spanIdx = startSpanIdx; spanIdx <= endSpanIdx; spanIdx++)
         {
            CSpanKey spanKey(spanIdx,gdrIdx);
            // Need location of XSpan below in "Span Coordinates". This starts at bearing location in first span
            Float64 spanLength = GetSpanLength(spanKey); // this is cl pier to cl pier

            const CSpanData2* pSpan = pBridgeDesc->GetSpan(spanIdx);
            std::vector<Float64> spanHaunches = pSpan->GetDirectHaunchDepths(gdrIdx);

            for (IndexType iseg = 0; iseg <= numSpanSegs; iseg++)
            {
               Float64 xSpan = spanLength * (Float64)iseg / (Float64)(numSpanSegs - 1);
               pgsPointOfInterest spanPoi = ConvertSpanPointToPoi(spanKey,xSpan);
               Float64 Xgirderline = ConvertPoiToGirderlineCoordinate(spanPoi);

               Float64 haunch = ::ComputeHaunchDepthAlongSegment(xSpan,spanLength,spanHaunches);

               pwLinearFunction.AddPoint(Xgirderline,haunch);
            }
         }

         // Create haunch depths along segment. Use less resolution than above for performance
         for (IndexType iseg = 0; iseg < numSegSegs; iseg++)
         {
            Float64 XSegment = segmentLength * (Float64)iseg / (Float64)(numSegSegs - 1);
            Float64 Xgl = ConvertSegmentCoordinateToGirderlineCoordinate(segmentKey,XSegment);

            Float64 haunch = pwLinearFunction.Evaluate(Xgl);
            pHaunchDepths->Add(haunch);
         }
      }
      else
      {
         // Parabolic distribution  where a segment lies entirely within a span
         ATLASSERT(startSpanIdx == endSpanIdx);

         SpanIndexType spanIdx = startSpanIdx;
         CSpanKey spanKey(spanIdx,gdrIdx);
         const CSpanData2* pSpan = pBridgeDesc->GetSpan(spanIdx);

         std::vector<Float64> spanHaunches = pSpan->GetDirectHaunchDepths(gdrIdx);
         std::size_t numHaunches = spanHaunches.size();
         ATLASSERT(numHaunches == 3);

         // Span length below starts at bearing location in first span
         Float64 spanLength = GetSpanLength(spanKey); // this is cl pier to cl pier

         Float64 segmentLength = GetSegmentLength(segmentKey);

         // Create haunch depths along segment at same distribution as for spans.
         std::size_t numSegmentLocs = numHaunches;
         for (int iSegmentLoc = 0; iSegmentLoc < numHaunches; iSegmentLoc++)
         {
            Float64 XSegment = segmentLength * (Float64)iSegmentLoc / (Float64)(numSegmentLocs - 1);

            // Get distance along span of segment location
            CSpanKey newSpanKey;
            Float64 xSpan;
            ConvertSegmentCoordinateToSpanPoint(segmentKey,XSegment,&newSpanKey,&xSpan);

            // use generic bridge helper function to determine haunch values along span
#pragma Reminder("This could be optimized by turning function below into a tool class and pre-multiplying many of the values")
            Float64 haunch = ::ComputeHaunchDepthAlongSegment(xSpan,spanLength,spanHaunches);

            pHaunchDepths->Add(haunch);
         }
      }
   }
}

bool CBridgeAgentImp::LayoutDeck(const CBridgeDescription2* pBridgeDesc)
{
   const CDeckDescription2* pDeck = pBridgeDesc->GetDeckDescription();
   pgsTypes::SupportedDeckType deckType = pDeck->GetDeckType();

   CGirderKey girderKey(0,0);
   IntervalIndexType compositeIntervalIdx = GetLastCompositeInterval();
   IntervalIndexType overlayIntervalIdx = m_IntervalManager.GetOverlayInterval();
   IntervalIndexType liveLoadIntervalIdx = m_IntervalManager.GetLiveLoadInterval();

   // put the wearing surface into the generic bridge model
   if ( pDeck->WearingSurface == pgsTypes::wstSacrificialDepth || 
        pDeck->WearingSurface == pgsTypes::wstFutureOverlay ||
        (pDeck->WearingSurface == pgsTypes::wstOverlay && liveLoadIntervalIdx < overlayIntervalIdx) // when live load comes before the overlay, the overlay is treated as a "future" overlay
      )
   {
      m_Bridge->put_SacrificialDepth(pDeck->SacrificialDepth);
      m_Bridge->put_SacrificialDepthStage(compositeIntervalIdx);
   }
   else
   {
      m_Bridge->put_SacrificialDepth(0);
      m_Bridge->put_SacrificialDepthStage(INVALID_INDEX);
   }

   if ( pDeck->WearingSurface == pgsTypes::wstOverlay || pDeck->WearingSurface == pgsTypes::wstFutureOverlay )
   {
      if ( pDeck->bInputAsDepthAndDensity )
      {
         m_Bridge->put_WearingSurfaceDepth(pDeck->OverlayDepth);
         m_Bridge->put_WearingSurfaceDensity(pDeck->OverlayDensity);
      }
      else
      {
         // depth not explicitly input... estimate based on 140 pcf material
         Float64 density = WBFL::Units::ConvertToSysUnits(140.0,WBFL::Units::Measure::LbfPerFeet3);
         m_Bridge->put_WearingSurfaceDensity(density);
         Float64 g = WBFL::Units::System::GetGravitationalAcceleration();
         Float64 depth = (pDeck->OverlayWeight/g) / density;
         m_Bridge->put_WearingSurfaceDepth(depth);
      }

      m_Bridge->put_WearingSurfaceStage(overlayIntervalIdx);
   }
   else
   {
      m_Bridge->put_WearingSurfaceDepth(0);
      m_Bridge->put_WearingSurfaceDensity(0);
      m_Bridge->put_WearingSurfaceStage(INVALID_INDEX);
   }

   CComPtr<IBridgeDeck> deck;

   if ( IsAdjustableWidthDeck(deckType) )
   {
      if ( pDeck->DeckEdgePoints.size() == 1 )
      {
         LayoutSimpleDeck(pBridgeDesc,&deck);
      }
      else
      {
         LayoutFullDeck(pBridgeDesc,&deck);
      }
   }
   else
   {
      LayoutOverlayDeck(pBridgeDesc,&deck);
   }

   if ( deck )
   {
      LayoutDeckRebar(pDeck,deck);

      // put the deck in the bridge model before creating the deck material
      // for time-step analysis we need age adjusted concrete and it depends on 
      // deck geometry parameters (V/S). The bridge model needs the deck to compute
      // these parameters.
      m_Bridge->putref_Deck(deck);

      if (!AssignDeckMaterial(pBridgeDesc, deck))
         return false;
   }


   return true;
}

bool CBridgeAgentImp::AssignDeckMaterial(const CBridgeDescription2* pBridgeDesc, IBridgeDeck* pDeck)
{
   GET_IFACE(ILossParameters, pLossParams);
   bool bTimeStepAnalysis = (pLossParams->GetLossMethod() == pgsTypes::TIME_STEP ? true : false);

   CComQIPtr<ICastSlab> castSlab(pDeck);
   CComQIPtr<IPrecastSlab> precastSlab(pDeck);
   CComQIPtr<IOverlaySlab> overlaySlab(pDeck);

   const auto* pTimelineMgr = pBridgeDesc->GetTimelineManager();
   EventIndexType castDeckEventIdx = pTimelineMgr->GetCastDeckEventIndex();
   ATLASSERT(castDeckEventIdx != INVALID_INDEX);
   const auto* pTimelineEvent = pTimelineMgr->GetEventByIndex(castDeckEventIdx);
   ATLASSERT(pTimelineEvent && pTimelineEvent->GetCastDeckActivity().IsEnabled());
   const auto& castDeckActivity = pTimelineEvent->GetCastDeckActivity();
   const auto& regions = castDeckActivity.GetCastingRegions();
   IndexType nRegions = castDeckActivity.GetCastingRegionCount();
#if defined _DEBUG
   if (overlaySlab)
   {
      ATLASSERT(nRegions == 1); // there can only be one region for overlay slabs (casting regions not available for this type)
   }
#endif
   for (IndexType regionIdx = 0; regionIdx < nRegions; regionIdx++)
   {
      const auto& region(regions[regionIdx]);

      CComPtr<IMaterial> deck_material;
      if (bTimeStepAnalysis)
      {
         GET_IFACE(IMaterials, pMaterials);
         CComPtr<IAgeAdjustedMaterial> age_adjusted_material;
         HRESULT hr = age_adjusted_material.CoCreateInstance(CLSID_AgeAdjustedMaterial);
         ATLASSERT(SUCCEEDED(hr));

         age_adjusted_material->InitDeck(regionIdx,pMaterials);

         age_adjusted_material.QueryInterface(&deck_material);
      }
      else
      {
         deck_material.CoCreateInstance(CLSID_Material);
         IntervalIndexType nIntervals = m_IntervalManager.GetIntervalCount();
         for (IntervalIndexType intervalIdx = 0; intervalIdx < nIntervals; intervalIdx++)
         {
            Float64 E = GetDeckEc(regionIdx,intervalIdx);
            Float64 D = GetDeckWeightDensity(regionIdx,intervalIdx);

            deck_material->put_E(intervalIdx, E);
            deck_material->put_Density(intervalIdx, D);
         }
      }

      if (castSlab)
      {
         CComPtr<ICastingRegions> regions;
         castSlab->get_CastingRegions(&regions);
         CComPtr<ICastingRegion> region;
         regions->get_Item(regionIdx, &region);
         region->putref_Material(deck_material);
      }
      else if (precastSlab)
      {
         CComPtr<ICastingRegions> regions;
         precastSlab->get_CastingRegions(&regions);
         CComPtr<ICastingRegion> region;
         regions->get_Item(regionIdx, &region);
         region->putref_Material(deck_material);
      }
      else
      {
         overlaySlab->putref_Material(deck_material);
      }
   }

   return true;
}

void CBridgeAgentImp::NoDeckEdgePoint(GroupIndexType grpIdx,SegmentIndexType segIdx,pgsTypes::MemberEndType end,DirectionType side,IPoint2d** ppPoint) const
{
   GET_IFACE(IBridgeDescription,pIBridgeDesc);
   const CBridgeDescription2* pBridgeDesc = pIBridgeDesc->GetBridgeDescription();
   const CGirderGroupData* pGroup = pBridgeDesc->GetGirderGroup(grpIdx);

   GirderIndexType gdrIdx;
   if ( side == qcbLeft )
   {
      gdrIdx = 0;
   }
   else
   {
      gdrIdx = pGroup->GetGirderCount()-1;
   }

   CSegmentKey segmentKey(grpIdx,gdrIdx,segIdx);

   Float64 location;
   if ( end == pgsTypes::metStart )
   {
      location = 0.0;
   }
   else
   {
      location = GetSegmentLength(segmentKey);
   }

   CComPtr<IGirderSection> girder_section;
   pgsPointOfInterest poi = GetPointOfInterest(segmentKey, location); // want to get a real poi
   HRESULT hr = GetGirderSection(poi, &girder_section);
   ATLASSERT(SUCCEEDED(hr));
   if (FAILED(hr))
   {
      return;
   }

   Float64 wLeft, wRight;
   girder_section->get_TopWidth(&wLeft, &wRight);

   Float64 offset = (side == qcbLeft ? wLeft : -wRight); // offset from girder line to edge of girder

   CComPtr<ISuperstructureMember> ssmbr;
   hr = m_Bridge->get_SuperstructureMember(::GetSuperstructureMemberID(grpIdx,gdrIdx),&ssmbr);
   ATLASSERT(SUCCEEDED(hr));

   CComPtr<ISuperstructureMemberSegment> segment;
   hr = ssmbr->get_Segment(segmentKey.segmentIndex,&segment);
   ATLASSERT(SUCCEEDED(hr));

   CComPtr<IGirderLine> girderLine;
   hr = segment->get_GirderLine(&girderLine);
   ATLASSERT(SUCCEEDED(hr));

   CComPtr<IPoint2d> point_on_girder;
   hr = girderLine->get_PierPoint(end == pgsTypes::metStart ? etStart : etEnd,&point_on_girder);
   ATLASSERT(SUCCEEDED(hr));

   CComPtr<IDirection> girder_direction;
   girderLine->get_Direction(&girder_direction); // bearing of girder

   CComPtr<IDirection> normal;
   girder_direction->Increment(CComVariant(PI_OVER_2),&normal);// rotate 90 to make a normal to the girder

   CComQIPtr<ILocate2> locate(m_CogoEngine);
   CComPtr<IPoint2d> point_on_edge;
   hr = locate->ByDistDir(point_on_girder,offset,CComVariant(normal),0.00,&point_on_edge);
   ATLASSERT(SUCCEEDED(hr));

   (*ppPoint) = point_on_edge;
   (*ppPoint)->AddRef();
}

bool CBridgeAgentImp::LayoutOverlayDeck(const CBridgeDescription2* pBridgeDesc,IBridgeDeck** ppDeck)
{
   // There isn't an explicit deck in this case, so layout of the slab must be done
   // based on the girder geometry. Update the bridge model now so that the girder geometry is correct
   //m_Bridge->UpdateBridgeModel(GF_GIRDERS);

   CComPtr<IBridgeGeometry> bridgeGeometry;
   m_Bridge->get_BridgeGeometry(&bridgeGeometry);

   CogoObjectID alignmentID;
   bridgeGeometry->get_BridgeAlignmentID(&alignmentID);

   HRESULT hr = S_OK;
   const CDeckDescription2* pDeck = pBridgeDesc->GetDeckDescription();
   pgsTypes::SupportedDeckType deckType = pDeck->GetDeckType();

   if ( deckType == pgsTypes::sdtNone )
   {
      (*ppDeck) = nullptr;
      return true;
   }

   ATLASSERT( deckType == pgsTypes::sdtCompositeOverlay || deckType == pgsTypes::sdtNonstructuralOverlay);

   // create path objects that represent the deck edges
   CComPtr<IPath> left_path, right_path;
   CreateOverlayDeckEdgePaths(pBridgeDesc,&left_path,&right_path);

   // store the deck edge paths as layout lines in the bridge geometry model
   CComPtr<ISimpleLayoutLineFactory> layoutLineFactory;
   layoutLineFactory.CoCreateInstance(CLSID_SimpleLayoutLineFactory);
   layoutLineFactory->AddPath(LEFT_DECK_EDGE_LAYOUT_LINE_ID,left_path);
   layoutLineFactory->AddPath(RIGHT_DECK_EDGE_LAYOUT_LINE_ID,right_path);
   bridgeGeometry->CreateLayoutLines(layoutLineFactory);

   // create the deck boundary
   CComPtr<ISimpleDeckBoundaryFactory> deckBoundaryFactory;
   deckBoundaryFactory.CoCreateInstance(CLSID_SimpleDeckBoundaryFactory);
   deckBoundaryFactory->put_TransverseEdgeID( etStart, GetPierLineID(0) );
   deckBoundaryFactory->put_TransverseEdgeType(etStart, setPier);
   deckBoundaryFactory->put_TransverseEdgeID( etEnd, GetPierLineID(pBridgeDesc->GetPierCount()-1) ); 
   deckBoundaryFactory->put_TransverseEdgeType(etEnd, setPier);
   deckBoundaryFactory->put_EdgeID(stLeft, LEFT_DECK_EDGE_LAYOUT_LINE_ID); 
   deckBoundaryFactory->put_EdgeID(stRight, RIGHT_DECK_EDGE_LAYOUT_LINE_ID);

   bridgeGeometry->CreateDeckBoundary(deckBoundaryFactory); 

   // get the deck boundary
   CComPtr<IDeckBoundary> deckBoundary;
   bridgeGeometry->get_DeckBoundary(&deckBoundary);

   // create the specific deck type
   CComPtr<IOverlaySlab> slab;
   slab.CoCreateInstance(CLSID_OverlaySlab);

   slab->put_GrossDepth(pDeck->GrossDepth);

   slab.QueryInterface(ppDeck);

   (*ppDeck)->put_Composite( deckType == pgsTypes::sdtCompositeOverlay ? VARIANT_TRUE : VARIANT_FALSE );
   (*ppDeck)->putref_DeckBoundary(deckBoundary);


   return true;
}

bool CBridgeAgentImp::LayoutSimpleDeck(const CBridgeDescription2* pBridgeDesc,IBridgeDeck** ppDeck)
{
   const CDeckDescription2* pDeck = pBridgeDesc->GetDeckDescription();
   pgsTypes::SupportedDeckType deckType = pDeck->GetDeckType();

   ATLASSERT( deckType == pgsTypes::sdtCompositeSIP || deckType == pgsTypes::sdtCompositeCIP );
   ATLASSERT( pDeck->DeckEdgePoints.size() == 1 );

   Float64 alignment_offset = pBridgeDesc->GetAlignmentOffset();

   // this is a simple deck edge that parallels the alignment
   CDeckPoint deckPoint = *(pDeck->DeckEdgePoints.begin());

   Float64 left_offset;
   Float64 right_offset;

   if ( deckPoint.MeasurementType == pgsTypes::omtAlignment )
   {
      // deck edge is measured from the alignment
      left_offset  =  deckPoint.LeftEdge;
      right_offset = -deckPoint.RightEdge;
   }
   else
   {
      // deck edge is measured from the CL bridge. compute the offsets from the alignment
      left_offset  = -alignment_offset + deckPoint.LeftEdge;
      right_offset = -alignment_offset - deckPoint.RightEdge;
   }

   //
   // Create slab model in new BridgeGeometry sub-system
   //
   CComPtr<IBridgeGeometry> bridgeGeometry;
   m_Bridge->get_BridgeGeometry(&bridgeGeometry);

   PierIndexType nPiers = pBridgeDesc->GetPierCount();

   CogoObjectID alignmentID;
   bridgeGeometry->get_BridgeAlignmentID(&alignmentID);

   // Create slab edge paths
   CComPtr<IAlignmentOffsetLayoutLineFactory> factory;
   factory.CoCreateInstance(CLSID_AlignmentOffsetLayoutLineFactory);
   factory->put_AlignmentID(alignmentID);
   factory->put_LayoutLineID(LEFT_DECK_EDGE_LAYOUT_LINE_ID); // left edge
   factory->put_Offset(left_offset);
   bridgeGeometry->CreateLayoutLines(factory);

   factory->put_LayoutLineID(RIGHT_DECK_EDGE_LAYOUT_LINE_ID); // right edge
   factory->put_Offset(right_offset);
   bridgeGeometry->CreateLayoutLines(factory);

   CComPtr<ISimpleDeckBoundaryFactory> deckBoundaryFactory;
   deckBoundaryFactory.CoCreateInstance(CLSID_SimpleDeckBoundaryFactory);
   deckBoundaryFactory->put_TransverseEdgeID( etStart, GetPierLineID(0) );
   deckBoundaryFactory->put_TransverseEdgeType(etStart, setPier);
   deckBoundaryFactory->put_TransverseEdgeID( etEnd, GetPierLineID(nPiers-1) ); 
   deckBoundaryFactory->put_TransverseEdgeType(etEnd, setPier);
   deckBoundaryFactory->put_EdgeID(stLeft,LEFT_DECK_EDGE_LAYOUT_LINE_ID); 
   deckBoundaryFactory->put_EdgeID(stRight,RIGHT_DECK_EDGE_LAYOUT_LINE_ID);

//   // this is a fake slab break just for testing and an example on how to model it
//   // when we actually use it
//   factory->put_Offset(left_offset-0.5);
//   factory->put_LayoutLineID(-1001); // left edge
//   bridgeGeometry->CreateLayoutLines(factory);
//   factory->put_LayoutLineID(-2001); // right edge
//   factory->put_Offset(right_offset+0.5);
//   bridgeGeometry->CreateLayoutLines(factory);
//   deckBoundaryFactory->put_BreakEdge(etStart,stLeft,VARIANT_TRUE);
//   deckBoundaryFactory->put_BreakEdge(etEnd,  stLeft, VARIANT_TRUE);
//   deckBoundaryFactory->put_BreakEdge(etStart,stRight,VARIANT_TRUE);
//   deckBoundaryFactory->put_BreakEdge(etEnd,  stRight,VARIANT_TRUE);
//   deckBoundaryFactory->put_EdgeBreakID(stLeft,-1001);
//   deckBoundaryFactory->put_EdgeBreakID(stRight,-2001);

   bridgeGeometry->CreateDeckBoundary(deckBoundaryFactory); 

   CComPtr<IDeckBoundary> deckBoundary;
   bridgeGeometry->get_DeckBoundary(&deckBoundary);

   if ( deckType == pgsTypes::sdtCompositeCIP )
   {
      LayoutCompositeCIPDeck(pBridgeDesc,deckBoundary,ppDeck);
   }
   else if ( deckType == pgsTypes::sdtCompositeSIP )
   {
      LayoutCompositeSIPDeck(pBridgeDesc,deckBoundary,ppDeck);
   }
   else
   {
      ATLASSERT(false); // shouldn't get here
   }

   return true;
}

bool CBridgeAgentImp::LayoutFullDeck(const CBridgeDescription2* pBridgeDesc,IBridgeDeck** ppDeck)
{
   const CDeckDescription2* pDeck = pBridgeDesc->GetDeckDescription();
   pgsTypes::SupportedDeckType deckType = pDeck->GetDeckType();

   ATLASSERT( deckType == pgsTypes::sdtCompositeSIP || deckType == pgsTypes::sdtCompositeCIP );
   ATLASSERT( 1 < pDeck->DeckEdgePoints.size() );

   // the deck edge is described by a series of points. the transitions
   // between the points can be parallel to alignment, linear or spline. 
   // for spline transitions a cubic spline will be used. 
   // for parallel transitions, a parallel alignment sub-path will be used.
   CComPtr<IAlignment> alignment;
   m_Bridge->get_Alignment(&alignment);

   CComPtr<IBridgeGeometry> geometry;
   m_Bridge->get_BridgeGeometry(&geometry);

   // create the path objects for the edge of deck
   CComPtr<IPath> left_path, right_path;
   CDeckEdgeBuilder deck_edge_builder;
   deck_edge_builder.BuildDeckEdges(pBridgeDesc,m_CogoEngine,alignment,&left_path,&right_path);

   // store the deck edge paths as layout lines in the bridge geometry model
   CComPtr<ISimpleLayoutLineFactory> layoutLineFactory;
   layoutLineFactory.CoCreateInstance(CLSID_SimpleLayoutLineFactory);
   layoutLineFactory->AddPath(LEFT_DECK_EDGE_LAYOUT_LINE_ID,left_path);
   layoutLineFactory->AddPath(RIGHT_DECK_EDGE_LAYOUT_LINE_ID,right_path);
   geometry->CreateLayoutLines(layoutLineFactory);

   // create the bridge deck boundary
   CComPtr<ISimpleDeckBoundaryFactory> deckBoundaryFactory;
   deckBoundaryFactory.CoCreateInstance(CLSID_SimpleDeckBoundaryFactory);
   deckBoundaryFactory->put_TransverseEdgeID(etStart,::GetPierLineID(0));
   deckBoundaryFactory->put_TransverseEdgeType(etStart,setPier);
   deckBoundaryFactory->put_TransverseEdgeID(etEnd,::GetPierLineID(pBridgeDesc->GetPierCount()-1));
   deckBoundaryFactory->put_TransverseEdgeType(etEnd,setPier);
   deckBoundaryFactory->put_EdgeID(stLeft,LEFT_DECK_EDGE_LAYOUT_LINE_ID);
   deckBoundaryFactory->put_EdgeID(stRight,RIGHT_DECK_EDGE_LAYOUT_LINE_ID);
   geometry->CreateDeckBoundary(deckBoundaryFactory);

   // get the deck boundary
   CComPtr<IDeckBoundary> deckBoundary;
   geometry->get_DeckBoundary(&deckBoundary);

   if ( deckType == pgsTypes::sdtCompositeCIP )
   {
      LayoutCompositeCIPDeck(pBridgeDesc,deckBoundary,ppDeck);
   }
   else if ( deckType == pgsTypes::sdtCompositeSIP )
   {
      LayoutCompositeSIPDeck(pBridgeDesc,deckBoundary,ppDeck);
   }
   else
   {
      ATLASSERT(false); // shouldn't get here
   }

   return true;
}

bool CBridgeAgentImp::LayoutCompositeCIPDeck(const CBridgeDescription2* pBridgeDesc,IDeckBoundary* pBoundary,IBridgeDeck** ppDeck)
{
   const CDeckDescription2* pDeck = pBridgeDesc->GetDeckDescription();

   CComPtr<ICastSlab> slab;
   slab.CoCreateInstance(CLSID_CastSlab);

   slab->put_GrossDepth(pDeck->GrossDepth);
   slab->SetOverhang(pDeck->OverhangEdgeDepth[pgsTypes::stLeft], (DeckOverhangTaper)pDeck->OverhangTaper[pgsTypes::stLeft], pDeck->OverhangEdgeDepth[pgsTypes::stRight], (DeckOverhangTaper)pDeck->OverhangTaper[pgsTypes::stRight]);

   CComPtr<ICastingRegions> castingRegions;
   slab->get_CastingRegions(&castingRegions);
   if (!LayoutDeckCastingRegions(pBridgeDesc, castingRegions))
   {
      return false;
   }

   slab.QueryInterface(ppDeck);

   (*ppDeck)->put_Composite( VARIANT_TRUE );
   (*ppDeck)->putref_DeckBoundary(pBoundary);

   return true;
}

bool CBridgeAgentImp::LayoutCompositeSIPDeck(const CBridgeDescription2* pBridgeDesc,IDeckBoundary* pBoundary,IBridgeDeck** ppDeck)
{
   const CDeckDescription2* pDeck = pBridgeDesc->GetDeckDescription();

   CComPtr<IPrecastSlab> slab;
   slab.CoCreateInstance(CLSID_PrecastSlab);

   slab->put_PanelDepth(pDeck->PanelDepth);
   slab->put_CastDepth(pDeck->GrossDepth); // interpreted as cast depth
   slab->SetOverhang(pDeck->OverhangEdgeDepth[pgsTypes::stLeft], (DeckOverhangTaper)pDeck->OverhangTaper[pgsTypes::stLeft], pDeck->OverhangEdgeDepth[pgsTypes::stRight], (DeckOverhangTaper)pDeck->OverhangTaper[pgsTypes::stRight]);

   CComPtr<ICastingRegions> castingRegions;
   slab->get_CastingRegions(&castingRegions);
   if (!LayoutDeckCastingRegions(pBridgeDesc, castingRegions))
   {
      return false;
   }

   slab.QueryInterface(ppDeck);

   (*ppDeck)->put_Composite( VARIANT_TRUE );
   (*ppDeck)->putref_DeckBoundary(pBoundary);

   return true;
}

bool CBridgeAgentImp::LayoutDeckCastingRegions(const CBridgeDescription2* pBridgeDesc, ICastingRegions* pCastingRegions)
{
   EventIndexType castDeckEventIdx = pBridgeDesc->GetTimelineManager()->GetCastDeckEventIndex();
   ATLASSERT(castDeckEventIdx != INVALID_INDEX);
   const CTimelineEvent* pEvent = pBridgeDesc->GetTimelineManager()->GetEventByIndex(castDeckEventIdx);
   ATLASSERT(pEvent && pEvent->GetCastDeckActivity().IsEnabled());
   const CCastDeckActivity& castDeckActivity = pEvent->GetCastDeckActivity();

   pCastingRegions->put_Boundary((CastingRegionBoundary)castDeckActivity.GetDeckCastingRegionBoundary());

   const auto& vRegions = castDeckActivity.GetCastingRegions();
   IndexType nRegions = vRegions.size();
   for (IndexType regionIdx = 0; regionIdx < nRegions; regionIdx++)
   {
      const auto& region = vRegions[regionIdx];
      PierIndexType startPierIdx, endPierIdx;
      Float64 Xstart, Xend;
      IndexType sequenceIdx;
      CCastingRegion::RegionType type;
      GetDeckCastingRegionLimits(regionIdx, &startPierIdx, &Xstart, &endPierIdx, &Xend, &type, &sequenceIdx, nullptr);

      PierIDType startPierID = ::GetPierLineID(startPierIdx);
      PierIDType endPierID = ::GetPierLineID(endPierIdx);
      
      CComPtr<ICastingRegion> objRegion;
      pCastingRegions->CreateRegion(startPierID, Xstart, endPierID, Xend, nullptr/*material will be assigned later*/, &objRegion);
   }

   return true;
}

bool CBridgeAgentImp::LayoutTrafficBarriers(const CBridgeDescription2* pBridgeDesc)
{
   CComPtr<ISidewalkBarrier> lb;
   const CRailingSystem* pLeftRailingSystem  = pBridgeDesc->GetLeftRailingSystem();
   LayoutTrafficBarrier(pBridgeDesc,pLeftRailingSystem,pgsTypes::tboLeft,&lb);
   m_Bridge->putref_LeftBarrier(lb);

   CComPtr<ISidewalkBarrier> rb;
   const CRailingSystem* pRightRailingSystem = pBridgeDesc->GetRightRailingSystem();
   LayoutTrafficBarrier(pBridgeDesc,pRightRailingSystem,pgsTypes::tboRight,&rb);
   m_Bridge->putref_RightBarrier(rb);

   CComPtr<IPath> leftPath, rightPath;
   if (IsNonstructuralDeck(pBridgeDesc->GetDeckDescription()->GetDeckType()) )
   {
      CreateOverlayDeckEdgePaths(pBridgeDesc,&leftPath,&rightPath);
   }
   else
   {
      CComPtr<IBridgeDeck> deck;
      m_Bridge->get_Deck(&deck);

      CComPtr<IDeckBoundary> deckBoundary;
      deck->get_DeckBoundary(&deckBoundary);

      deckBoundary->get_EdgePath(stLeft,VARIANT_TRUE,&leftPath);
      deckBoundary->get_EdgePath(stRight,VARIANT_TRUE,&rightPath);
   }
   lb->put_Path(leftPath);
   rb->put_Path(rightPath);

   return true;
}

void ComputeBarrierShapeToeLocations(IShape* pShape, Float64* leftToe, Float64* rightToe)
{
   // barrier toe is at X=0.0 of shape. Clip a very shallow rect at this elevation and use the width
   // of the clipped shape as the toe bounds.
   CComPtr<IRect2d> rect;
   rect.CoCreateInstance(CLSID_Rect2d);
   rect->SetBounds(-1.0e06, 1.0e06, 0.0, 1.0e-04);

   CComPtr<IShape> clip_shape;
   pShape->ClipIn(rect, &clip_shape);
   if (clip_shape)
   {
      CComPtr<IRect2d> bbox;
      clip_shape->get_BoundingBox(&bbox);
      bbox->get_Left(leftToe);
      bbox->get_Right(rightToe);
   }
   else
   {
      *leftToe = 0.0;
      *rightToe = 0.0;
   }
}

void CBridgeAgentImp::CreateBarrierObject(IBarrier** pBarrier, const TrafficBarrierEntry*  pBarrierEntry, pgsTypes::TrafficBarrierOrientation orientation)
{
   CComPtr<IPolyShape> polyshape;
   pBarrierEntry->CreatePolyShape(orientation,&polyshape);

   CComQIPtr<IShape> pShape(polyshape);

   // box containing barrier
   CComPtr<IRect2d> bbox;
   pShape->get_BoundingBox(&bbox);

   Float64 rightEdge, leftEdge;
   bbox->get_Right(&rightEdge);
   bbox->get_Left(&leftEdge);

   // Distance from the barrier curb to the exterior face of barrier for purposes of determining
   // roadway width
   Float64 curbOffset = pBarrierEntry->GetCurbOffset();

   // Toe locations of barrier
   Float64 leftToe, rightToe;
   ComputeBarrierShapeToeLocations(pShape, &leftToe, &rightToe);

   // Dimensions of barrier depend on orientation
   Float64 extToeWid, intToeWid;
   if (orientation == pgsTypes::tboLeft )
   {
      intToeWid = rightEdge - rightToe;
      extToeWid = -(leftEdge - leftToe);
   }
   else
   {
      extToeWid = rightEdge - rightToe;
      intToeWid = -(leftEdge - leftToe);
   }

   // We have all data. Create barrier and initialize
   CComPtr<IGenericBarrier> barrier;
   barrier.CoCreateInstance(CLSID_GenericBarrier);

   barrier->Init(pShape, curbOffset, intToeWid, extToeWid);

   barrier.QueryInterface(pBarrier);

   CComPtr<IMaterial> material;
   (*pBarrier)->get_Material(&material);

   IntervalIndexType installRailingSystemIntervalIdx = m_IntervalManager.GetInstallRailingSystemInterval();
   IntervalIndexType nIntervals = m_IntervalManager.GetIntervalCount();
   for ( IntervalIndexType intervalIdx = 0; intervalIdx < nIntervals; intervalIdx++ )
   {
      Float64 E(0), D(0);
      if ( installRailingSystemIntervalIdx < intervalIdx )
      {
         E = GetRailingSystemEc(orientation,intervalIdx);
         D = GetRailingSystemWeightDensity(orientation,intervalIdx);
      }

      material->put_E(intervalIdx,E);
      material->put_Density(intervalIdx,D);
   }
}

bool CBridgeAgentImp::LayoutTrafficBarrier(const CBridgeDescription2* pBridgeDesc,const CRailingSystem* pRailingSystem,pgsTypes::TrafficBarrierOrientation orientation,ISidewalkBarrier** ppBarrier)
{
   // Railing system object
   CComPtr<ISidewalkBarrier> railing_system;
   railing_system.CoCreateInstance(CLSID_SidewalkBarrier);

   GET_IFACE(ILibrary,pLib);
   const TrafficBarrierEntry*  pExtRailingEntry = pLib->GetTrafficBarrierEntry( pRailingSystem->strExteriorRailing.c_str() );

   // Exterior Barrier
   CComPtr<IBarrier> extBarrier;
   CreateBarrierObject(&extBarrier, pExtRailingEntry, orientation);

   railing_system->put_IsExteriorStructurallyContinuous(pExtRailingEntry->IsBarrierStructurallyContinuous() ? VARIANT_TRUE : VARIANT_FALSE);

   SidewalkPositionType swPosition = pRailingSystem->bBarriersOnTopOfSidewalk ? swpBeneathBarriers : swpBetweenBarriers;

   int barrierType = 1;
   Float64 h1,h2,w;
   CComPtr<IBarrier> intBarrier;
   if ( pRailingSystem->bUseSidewalk )
   {
      // get the sidewalk dimensions
      barrierType = 2;
      h1 = pRailingSystem->LeftDepth;
      h2 = pRailingSystem->RightDepth;
      w  = pRailingSystem->Width;

      railing_system->put_IsSidewalkStructurallyContinuous(pRailingSystem->bSidewalkStructurallyContinuous ? VARIANT_TRUE : VARIANT_FALSE);

      if ( pRailingSystem->bUseInteriorRailing )
      {
         // there is an interior railing as well
         barrierType = 3;
         const TrafficBarrierEntry* pIntRailingEntry = pLib->GetTrafficBarrierEntry( pRailingSystem->strInteriorRailing.c_str() );

         CreateBarrierObject(&intBarrier, pIntRailingEntry, orientation);

         railing_system->put_IsInteriorStructurallyContinuous(pIntRailingEntry->IsBarrierStructurallyContinuous() ? VARIANT_TRUE : VARIANT_FALSE);
      }
   }

   switch(barrierType)
   {
   case 1:
      railing_system->put_Barrier1(extBarrier,(TrafficBarrierOrientation)orientation);
      break;

   case 2:
      railing_system->put_Barrier2(extBarrier,h1,h2,w,(TrafficBarrierOrientation)orientation, swPosition);
      break;

   case 3:
      railing_system->put_Barrier3(extBarrier,h1,h2,w,(TrafficBarrierOrientation)orientation, swPosition, intBarrier);
      break;

   default:
      ATLASSERT(FALSE); // should never get here
   }


   (*ppBarrier) = railing_system;
   (*ppBarrier)->AddRef();

   return true;
}

bool CBridgeAgentImp::BuildGirders()
{
   GET_IFACE(IBridgeDescription,pIBridgeDesc);
   const CBridgeDescription2* pBridgeDesc = pIBridgeDesc->GetBridgeDescription();
   pgsTypes::HaunchInputDepthType haunchInputDepthType = pBridgeDesc->GetHaunchInputDepthType();

   // Dependencies are complicated here. "A" dim input needs poi layout to determine haunch depths, and so prestressing needs haunch depths
   // Direct haunch depth does not need pois, so call order is reversed below
   if (haunchInputDepthType == pgsTypes::hidACamber)
   {
      UpdatePrestressing(ALL_GROUPS,ALL_GIRDERS,ALL_SEGMENTS);
      return LayoutSsmHaunches();
   }
   else
   {
      LayoutSsmHaunches();
      UpdatePrestressing(ALL_GROUPS,ALL_GIRDERS,ALL_SEGMENTS);
      return true;
   }
}

bool CBridgeAgentImp::LayoutSsmHaunches()
{
   // need to do final layout after POI's have been built
   GET_IFACE(IBridgeDescription,pIBridgeDesc);
   const CBridgeDescription2* pBridgeDesc = pIBridgeDesc->GetBridgeDescription();

   pgsTypes::SupportedDeckType deckType = pBridgeDesc->GetDeckDescription()->GetDeckType();
   pgsTypes::HaunchShapeType haunchShape = pBridgeDesc->GetDeckDescription()->HaunchShape;
   pgsTypes::HaunchInputDepthType haunchInputDepthType = pBridgeDesc->GetHaunchInputDepthType();
   pgsTypes::HaunchLayoutType haunchLayoutType = pBridgeDesc->GetHaunchLayoutType();

   GroupIndexType nGroups = pBridgeDesc->GetGirderGroupCount();
   for (GroupIndexType grpIdx = 0; grpIdx < nGroups; grpIdx++)
   {
      const CGirderGroupData* pGroup = pBridgeDesc->GetGirderGroup(grpIdx);

      GirderIndexType nGirders = pGroup->GetGirderCount();
      for (GirderIndexType gdrIdx = 0; gdrIdx < nGirders; gdrIdx++)
      {
         CGirderKey girderKey(grpIdx,gdrIdx);
         const CSplicedGirderData* pGirder = pGroup->GetGirder(gdrIdx);

         CComPtr<ISuperstructureMember> ssmbr;
         IDType ssmbrID = ::GetSuperstructureMemberID(girderKey.groupIndex,girderKey.girderIndex);
         m_Bridge->get_SuperstructureMember(ssmbrID,&ssmbr);

         SegmentIndexType nSegments = pGirder->GetSegmentCount();
         for (SegmentIndexType segIdx = 0; segIdx < nSegments; segIdx++)
         {
            const CPrecastSegmentData* pSegment = pGirder->GetSegment(segIdx);

            CComPtr<ISuperstructureMemberSegment> segment;
            ssmbr->get_Segment(segIdx, &segment);

            Float64 fillet = 0;
            CComPtr<IDblArray> pHaunchDepths;
            pHaunchDepths.CoCreateInstance(CLSID_DblArray);
            if ( deckType != pgsTypes::sdtNone )
            {
               if (haunchInputDepthType == pgsTypes::hidACamber)
               {
                  // Haunch depths were input using "A" and assumed excess camber. This is only supported in PGSuper models
                  GetHaunchDepth4ADimInput(pSegment,pHaunchDepths);
               }
               else
               {
                  // Haunch depths were input directly. i.e., hidHaunchDirectly or hidHaunchPlusSlabDirectly. Note that the UI subtracts the deck
                  // depth for the case of hidHaunchPlusSlabDirectly, so haunch depth values can be used without modification for this case.

                  if (haunchLayoutType == pgsTypes::hltAlongSegments)
                  {
                     // Simple case - input is direct to segments
                     std::vector<Float64> haunches = pGirder->GetDirectHaunchDepths(segIdx);
                     for (auto haunch : haunches)
                     {
                        pHaunchDepths->Add(haunch);
                     }
                  }
                  else if (haunchLayoutType == pgsTypes::hltAlongSpans)
                  {
                     // Loads are laid out along spans - need to do some work to map to segment
                     GetHaunchDepth4BySpanInput(pSegment, pBridgeDesc, pHaunchDepths);
                  }
               }

               fillet = GetFillet();
               segment->put_FilletShape((FilletShape)haunchShape);
            }
            else
            {
               pHaunchDepths->Add(0.0); // constant haunch of zero
            }

            segment->SetHaunchDepth(pHaunchDepths);

            // fillet in model is only used to draw
            segment->put_Fillet(fillet);
         }
      }
   }

   return true;
}

void CBridgeAgentImp::ValidateGirders()
{
   GET_IFACE(IBridgeDescription,pIBridgeDesc);
   GET_IFACE_NOCHECK(IEAFStatusCenter, pStatusCenter);

   const CBridgeDescription2* pBridgeDesc = pIBridgeDesc->GetBridgeDescription();
   GroupIndexType nGroups = pBridgeDesc->GetGirderGroupCount();
   for ( GroupIndexType grpIdx = 0; grpIdx < nGroups; grpIdx++ )
   {
      const CGirderGroupData* pGroup = pBridgeDesc->GetGirderGroup(grpIdx);

      GirderIndexType nGirders = pGroup->GetGirderCount();
      for ( GirderIndexType gdrIdx = 0; gdrIdx < nGirders; gdrIdx++ )
      {
         const CSplicedGirderData* pGirder = pGroup->GetGirder(gdrIdx);
         SegmentIndexType nSegments = pGirder->GetSegmentCount();
         for ( SegmentIndexType segIdx = 0; segIdx < nSegments; segIdx++ )
         {
            CSegmentKey segmentKey(grpIdx,gdrIdx,segIdx);
            CComPtr<IPrecastGirder> girder;
            GetGirder(segmentKey, &girder);

            // Check location of temporary strands... usually in the top half of the girder
            CComPtr<IStrandModel> strandModel;
            girder->get_StrandModel(&strandModel);

            const GirderLibraryEntry* pGirderEntry = GetGirderLibraryEntry(segmentKey);
            Float64 h_start = pGirderEntry->GetBeamHeight(pgsTypes::metStart);
            Float64 h_end = pGirderEntry->GetBeamHeight(pgsTypes::metEnd);

            CComPtr<IPoint2dCollection> strandPoints;
            strandModel->GetStrandPositions(Temporary, 0.0, &strandPoints);

            CComPtr<IEnumPoint2d> enumPoints;
            strandPoints->get__Enum(&enumPoints);
            CComPtr<IPoint2d> point;
            while (enumPoints->Next(1, &point, nullptr) != S_FALSE)
            {
               Float64 Y;
               point->get_Y(&Y);

               if (Y < -h_start / 2 || Y < -h_end / 2)
               {
                  CString strMsg;
                  strMsg.Format(_T("%s: Temporary strands are not in the top half of the girder"), SEGMENT_LABEL(CSegmentKey(grpIdx, gdrIdx, segIdx)));
                  std::unique_ptr<pgsInformationalStatusItem> pStatusItem = std::make_unique<pgsInformationalStatusItem>(m_StatusGroupID, m_scidInformationalWarning, strMsg);
                  pStatusCenter->Add(pStatusItem.release());
                  break;
               }

               point.Release();
            }


            // check strand drape...
            // can't use POIs at ends of girders because we can model harped strands that are straight along the top
            // then deflect downwards (this could happen with cantilevered beams)
            PoiList vPoi;
            GetPointsOfInterest(segmentKey, POI_HARPINGPOINT, &vPoi);
            if (0 < vPoi.size())
            {
               pgsPointOfInterest poiStart = vPoi.front();
               pgsPointOfInterest poiEnd;
               if (vPoi.size() == 1)
               {
                  // there is only one harp point. if we use the same poi to get the start and
                  // end strand slopes, they will be equal. This will be interpreted as an
                  // upside down drape
                  // Use the POI on either side of the harp point poi
                  poiEnd = GetNextPointOfInterest(poiStart.GetID()); // get next poi first (order is important here)
                  poiStart = GetPrevPointOfInterest(poiStart.GetID());
               }
               else
               {
                  poiEnd = vPoi.back();
               }

               // Check strand slope 
               Float64 start_slope = GetMaxStrandSlope(poiStart);
               Float64 end_slope = GetMaxStrandSlope(poiEnd);

               if ((start_slope != Float64_Max && 0.0 < start_slope) || (end_slope != Float64_Max && end_slope < 0.0))
               {
                  std::_tstring msg = std::_tstring(SEGMENT_LABEL(segmentKey)) + _T(": Strand drape is upside down");
                  std::unique_ptr<pgsGirderDescriptionStatusItem> pStatusItem = std::make_unique<pgsGirderDescriptionStatusItem>(segmentKey, 0, m_StatusGroupID, m_scidGirderDescriptionWarning, msg.c_str());
                  pStatusCenter->Add(pStatusItem.release());
               }
            }

            const CPrecastSegmentData* pSegment = pGirder->GetSegment(segIdx);
            Float64 framing_length = GetSegmentFramingLength(segmentKey);
            if ( !pSegment->AreSegmentVariationsValid(framing_length) )
            {
               std::_tstring msg = std::_tstring(SEGMENT_LABEL(segmentKey)) + _T(": Segment variation dimensions are invalid.");
               std::unique_ptr<pgsGirderDescriptionStatusItem> pStatusItem = std::make_unique<pgsGirderDescriptionStatusItem>(segmentKey,0,m_StatusGroupID,m_scidGirderDescriptionError,msg.c_str());
               pStatusCenter->Add(pStatusItem.release());

               //strMsg += _T("See Status Center for Details");
               //THROW_UNWIND(os.str().c_str(),XREASON_INVALID_SEGMENT_VARIATION);
            }

            // Warn if girder has both debonded and harped strands
            if (pSegment->Strands.GetAdjustableStrandType() != pgsTypes::asStraight &&
               pSegment->Strands.GetStrandCount(pgsTypes::Harped) > 0 &&
               GetNumDebondedStrands(segmentKey, pgsTypes::Straight, pgsTypes::dbetEither) > 0)
            {
               std::_tstring msg = std::_tstring(SEGMENT_LABEL(segmentKey)) + _T(": Has a mix of Harped and Debonded strands. Specification checks for debond constructability may be innacurate.");
               std::unique_ptr<pgsGirderDescriptionStatusItem> pStatusItem = std::make_unique<pgsGirderDescriptionStatusItem>(segmentKey,1,m_StatusGroupID,m_scidGirderDescriptionWarning,msg.c_str());
               pStatusCenter->Add(pStatusItem.release());
            }

            // validate connection geometry (segment end must be at or into continuous diaphragms)
            std::array<Float64, 2> brg_offset, end_distance;
            GetSegmentBearingOffset(segmentKey, &brg_offset[pgsTypes::metStart], &brg_offset[pgsTypes::metEnd]);
            GetSegmentEndDistance(segmentKey, &end_distance[pgsTypes::metStart], &end_distance[pgsTypes::metEnd]);
            for (int i = 0; i < 2; i++)
            {
               pgsTypes::MemberEndType endType = (pgsTypes::MemberEndType)i;
               pgsTypes::PierFaceType pierFace = (endType == pgsTypes::metStart ? pgsTypes::Ahead : pgsTypes::Back);
               const CPierData2* pPier;
               const CTemporarySupportData* pTS;
               pSegment->GetSupport(endType, &pPier, &pTS);

               if (pPier && (pPier->IsInteriorPier() || IsContinuousBoundaryCondition(pierFace,pPier->GetBoundaryConditionType())))
               {
                  PierIndexType pierIdx = pPier->GetIndex();
                  Float64 diaphragm_width, diaphragm_height;
                  GetPierDiaphragmSize(pierIdx, pierFace, &diaphragm_width, &diaphragm_height);

                  //           CL Brg        CL Pier      CL Brg
                  //             |         :   |   :        |
                  // ------------|-----+   :   |   :   +----|---------------
                  //             |     |   :   |   :   |    |
                  //             |     |   :   |   :   |    |
                  // ------------|-----+   :   |   :   +----|---------------
                  //             |     |   :   |   :
                  //             |     |   :   |   :<--Face of diaphragm
                  //             |     |   :   |   :
                  //             |     |<----->------- CLpier_to_end_of_segment - MUST BE <= diaphragm_width OTHERWISE THE SEGMENT ISN'T CONNECTED TO THE DIAPHRAGM
                  //             |     |   :<->------- diaphragm_width (per side)
                  //             |<--->|-------------- end_distance
                  //             |<----------->------- brg_offset

                  Float64 CLpier_to_end_of_segment = brg_offset[endType] - end_distance[endType];
                  if (diaphragm_width < CLpier_to_end_of_segment)
                  {
                     CString strMsg;
                     strMsg.Format(_T("%s end of %s does not engage continuity diaphragm at Pier %s.\r\nPrecast elements must engage pier diaphragms to make the continuity connection. There is a gap between the end of this element and the diaphragm. Update the connection geometry and the diaphragm dimensions."), endType == pgsTypes::metStart ? _T("Start") : _T("End"), SEGMENT_LABEL(segmentKey), LABEL_PIER(pierIdx));
                     std::unique_ptr<pgsConnectionGeometryStatusItem> pStatusItem = std::make_unique<pgsConnectionGeometryStatusItem>(m_StatusGroupID, m_scidConnectionGeometryWarning, pierIdx, strMsg);
                     pStatusCenter->Add(pStatusItem.release());
                  }
               }
            }
         } // segment loop

         // Determine if bearings fit over current girder at pier face
         PierIndexType startPierIdx, endPierIdx;
         startPierIdx = pGroup->GetPierIndex(pgsTypes::metStart);
         endPierIdx = pGroup->GetPierIndex(pgsTypes::metEnd);
         for (PierIndexType pierIdx = startPierIdx; pierIdx <= endPierIdx; pierIdx++)
         {
            bool doAhead = pierIdx != endPierIdx;
            bool doBack = pierIdx != startPierIdx;

            if (doAhead)
            {
               pgsTypes::PierFaceType face = pgsTypes::Ahead;
               const CBearingData2* pBearingData = pIBridgeDesc->GetBearingData(pierIdx, face, gdrIdx);
               if (pBearingData == nullptr)
               {
                  ATLASSERT(0);
                  continue;
               }

               Float64 bearingWidth = pBearingData->Width + (pBearingData->BearingCount - 1) * pBearingData->Spacing;

               SegmentIndexType segIdx = 0;
               CSegmentKey segmentKey(grpIdx,gdrIdx,segIdx);
               PoiList vPoi;
               GetPointsOfInterest(segmentKey, POI_0L | POI_ERECTED_SEGMENT, &vPoi);
               ATLASSERT(vPoi.size() == 1);

               Float64 botWidth = this->GetBottomWidth(vPoi.front());

               if (IsLT(botWidth,bearingWidth))
               {
                  const CPierData2* pPier = pIBridgeDesc->GetPier(pierIdx);
                  CString strMsg;
                  strMsg.Format(_T("The bearings on the ahead side of %s for Girder %s, are wider than the bottom of the girder."),LABEL_PIER_EX(pPier->IsAbutment(),pierIdx),LABEL_GIRDER(segmentKey.girderIndex));
                  std::unique_ptr<pgsBridgeDescriptionStatusItem> pStatusItem = std::make_unique<pgsBridgeDescriptionStatusItem>(m_StatusGroupID,m_scidBridgeDescriptionWarning,pgsBridgeDescriptionStatusItem::Bearings,strMsg);
                  pStatusCenter->Add(pStatusItem.release());
               }
            }

            if (doBack)
            {
               pgsTypes::PierFaceType face = pgsTypes::Back;
               const CBearingData2* pBearingData = pIBridgeDesc->GetBearingData(pierIdx, face, gdrIdx);
               if (pBearingData == nullptr)
               {
                  ATLASSERT(false);
                  continue;
               }

               Float64 bearingWidth = pBearingData->Width + (pBearingData->BearingCount - 1) * pBearingData->Spacing;

               // end of the last segment in this group
               SegmentIndexType segIdx = nSegments-1;
               CSegmentKey segmentKey(grpIdx,gdrIdx,segIdx);
               PoiList vPoi;
               GetPointsOfInterest(segmentKey, POI_10L | POI_ERECTED_SEGMENT,&vPoi);
               ATLASSERT(vPoi.size() == 1);

               Float64 botWidth = this->GetBottomWidth(vPoi.front());

               if (IsLT(botWidth,bearingWidth))
               {
                  const CPierData2* pPier = pIBridgeDesc->GetPier(pierIdx);
                  CString strMsg;
                  strMsg.Format(_T("The bearings on the back side of %s for Girder %s, are wider than the bottom of the girder."),LABEL_PIER_EX(pPier->IsAbutment(),pierIdx),LABEL_GIRDER(segmentKey.girderIndex));
                  std::unique_ptr<pgsBridgeDescriptionStatusItem> pStatusItem = std::make_unique<pgsBridgeDescriptionStatusItem>(m_StatusGroupID,m_scidBridgeDescriptionWarning,pgsBridgeDescriptionStatusItem::Bearings,strMsg);
                  pStatusCenter->Add(pStatusItem.release());
               }
            }

            // There is a problem modeling boundary conditions at cantilever piers
            // The LBAM does not support changing boundary conditions so we can't model a "continuous" beam
            // which is the girder cantilevered over a support, and then change it to integral. For
            // this reason, only hinge and roller boundary conditions are supported at cantilever piers.
            //
            // Historical note - this check was once done in BridgeDescription2.cpp after the bridge model was loaded,
            // but the check for cantilever wasn't made. This resulted in boundary conditions always being force to
            // hinge. See Mantis 1319. There isn't enough information in the ProjectAgent to determine if a segment is
            // cantilevered so the check was moved to here. Calling ModelCantilevers from the ProjectAgent at load time
            // results in undefined behavior since the bridge model is not yet fully loaded from disk.
            // Instead of forcing the boundary condition to change, the model is put into an error state and the user can
            // decide how to adjust the model.
            const CPierData2* pPier = pBridgeDesc->GetPier(pierIdx);
            if (pPier->IsAbutment() && IsContinuousBoundaryCondition(pPier->GetBoundaryConditionType()))
            {
               CSegmentKey segmentKey(grpIdx, gdrIdx, 0);
               if (pPier->GetIndex() != 0)
               {
                  segmentKey.segmentIndex = pGirder->GetSegmentCount() - 1;
               }
               bool bStartCantilever, bEndCantilever;
               ModelCantilevers(segmentKey, &bStartCantilever, &bEndCantilever);
               bool bCantilever = (segmentKey.segmentIndex == 0 ? bStartCantilever : bEndCantilever);
               if (bCantilever)
               {
                  CString strMsg;
                  strMsg.Format(_T("The boundary condition at %s must be Hinge or Roller."), LABEL_PIER_EX(pPier->IsAbutment(), pierIdx));
                  std::unique_ptr<pgsBridgeDescriptionStatusItem> pStatusItem = std::make_unique<pgsBridgeDescriptionStatusItem>(m_StatusGroupID, m_scidBridgeDescriptionError, pgsBridgeDescriptionStatusItem::Framing, strMsg);
                  pStatusCenter->Add(pStatusItem.release());
               }
            }

         } // pier loop
      } // girder loop
   } // group loop
}

void CBridgeAgentImp::UpdatePrestressing(GroupIndexType groupIdx,GirderIndexType girderIdx,SegmentIndexType segmentIdx)
{
   GET_IFACE(IBridgeDescription,pIBridgeDesc);
   const CBridgeDescription2* pBridgeDesc = pIBridgeDesc->GetBridgeDescription();

   GroupIndexType firstGroupIdx,lastGroupIdx;
   if ( groupIdx == ALL_GROUPS )
   {
      firstGroupIdx = 0;
      lastGroupIdx = pBridgeDesc->GetGirderGroupCount()-1;
   }
   else
   {
      firstGroupIdx = groupIdx;
      lastGroupIdx = firstGroupIdx;
   }

   // must create at the strands models first
   for (GroupIndexType grpIdx = firstGroupIdx; grpIdx <= lastGroupIdx; grpIdx++)
   {
      const CGirderGroupData* pGroup = pBridgeDesc->GetGirderGroup(grpIdx);

      GirderIndexType firstGirderIdx, lastGirderIdx;
      if (girderIdx == ALL_GIRDERS)
      {
         firstGirderIdx = 0;
         lastGirderIdx = pGroup->GetGirderCount() - 1;
      }
      else
      {
         firstGirderIdx = girderIdx;
         lastGirderIdx = firstGirderIdx;
      }

      for (GirderIndexType gdrIdx = firstGirderIdx; gdrIdx <= lastGirderIdx; gdrIdx++)
      {
         Float64 segmentOffset = 0;

         const CSplicedGirderData* pGirder = pGroup->GetGirder(gdrIdx);
         SegmentIndexType firstSegmentIdx, lastSegmentIdx;
         if (segmentIdx == ALL_SEGMENTS)
         {
            firstSegmentIdx = 0;
            lastSegmentIdx = pGirder->GetSegmentCount() - 1;
         }
         else
         {
            firstSegmentIdx = segmentIdx;
            lastSegmentIdx = firstSegmentIdx;
         }

         CGirderKey girderKey = pGirder->GetGirderKey();
         const GirderLibraryEntry* pGirderEntry = GetGirderLibraryEntry(girderKey);

         for (SegmentIndexType segIdx = firstSegmentIdx; segIdx <= lastSegmentIdx; segIdx++)
         {
            CSegmentKey segmentKey(grpIdx, gdrIdx, segIdx);
            const CPrecastSegmentData* pSegment = pGirder->GetSegment(segIdx);

            CComPtr<ISuperstructureMemberSegment> segment;
            ::GetSegment(m_Bridge, segmentKey, &segment);

            CComQIPtr<IItemData> itemdata(segment);
            CComPtr<IUnknown> punk;
            itemdata->GetItemData(CComBSTR("Precast Girder"), &punk);
            CComQIPtr<IPrecastGirder> girder(punk);

            CreateStrandModel(girder, segment, pSegment, pGirderEntry);
         } // segment loop
      } // girder loop
   } // group loop

   for ( GroupIndexType grpIdx = firstGroupIdx; grpIdx <= lastGroupIdx; grpIdx++ )
   {
      const CGirderGroupData* pGroup = pBridgeDesc->GetGirderGroup(grpIdx);

      GirderIndexType firstGirderIdx, lastGirderIdx;
      if ( girderIdx == ALL_GIRDERS )
      {
         firstGirderIdx = 0;
         lastGirderIdx = pGroup->GetGirderCount()-1;
      }
      else
      {
         firstGirderIdx = girderIdx;
         lastGirderIdx = firstGirderIdx;
      }

      for ( GirderIndexType gdrIdx = firstGirderIdx; gdrIdx <= lastGirderIdx; gdrIdx++ )
      {
         Float64 segmentOffset = 0;

         const CSplicedGirderData* pGirder = pGroup->GetGirder(gdrIdx);
         SegmentIndexType firstSegmentIdx, lastSegmentIdx;
         if ( segmentIdx == ALL_SEGMENTS )
         {
            firstSegmentIdx = 0;
            lastSegmentIdx = pGirder->GetSegmentCount()-1;
         }
         else
         {
            firstSegmentIdx = segmentIdx;
            lastSegmentIdx = firstSegmentIdx;
         }

         for ( SegmentIndexType segIdx = firstSegmentIdx; segIdx <= lastSegmentIdx; segIdx++ )
         {
            CSegmentKey segmentKey(grpIdx,gdrIdx,segIdx);
            const CPrecastSegmentData* pSegment = pGirder->GetSegment(segIdx);

            CComPtr<IPrecastGirder> girder;
            GetGirder(segmentKey, &girder);

            CComPtr<IStrandModel> strandModel;
            girder->get_StrandModel(&strandModel);

            CComQIPtr<IStrandGridModel> strandGridModel(strandModel);

            strandModel->put_StraightStrandProfileType(FollowGirder); // straight strands always follow the bottom of the girder
            ATLASSERT(IsZero(pSegment->Precamber) ? true : pSegment->Strands.GetTemporaryStrandUsage() != pgsTypes::ttsPretensioned); // UI forces TTS to be post-tensioned if there is precamber
            strandModel->put_TemporaryStrandProfileType(pSegment->Strands.GetTemporaryStrandUsage() == pgsTypes::ttsPretensioned ? Linear : FollowGirder); // PT TTS follow girder (shielding can be curved)

            // Inititalize a strand filler for each girder
            const GirderLibraryEntry* pGirderEntry = GetGirderLibraryEntry(segmentKey);
            InitializeStrandFiller(pGirderEntry, segmentKey);

            if (strandGridModel)
            {
                strandGridModel->ClearStraightStrandDebonding();

               // Fill strands
               pgsTypes::StrandDefinitionType strandDefinitionType = pSegment->Strands.GetStrandDefinitionType();
               if (strandDefinitionType == pgsTypes::sdtTotal ||
                  strandDefinitionType == pgsTypes::sdtStraightHarped ||
                  strandDefinitionType == pgsTypes::sdtDirectRowInput)
               {
                  // Continuous fill
                  CContinuousStrandFiller* pfiller = GetContinuousStrandFiller(segmentKey);

                  HRESULT hr;
                  hr = pfiller->SetStraightContinuousFill(strandGridModel, pSegment->Strands.GetStrandCount(pgsTypes::Straight));
                  ATLASSERT(SUCCEEDED(hr));
                  hr = pfiller->SetHarpedContinuousFill(strandGridModel, pSegment->Strands.GetStrandCount(pgsTypes::Harped));
                  ATLASSERT(SUCCEEDED(hr));
                  hr = pfiller->SetTemporaryContinuousFill(strandGridModel, pSegment->Strands.GetStrandCount(pgsTypes::Temporary));
                  ATLASSERT(SUCCEEDED(hr));
               }
               else if (strandDefinitionType == pgsTypes::sdtDirectSelection)
               {
                  // Direct fill
                  CDirectStrandFiller* pfiller = GetDirectStrandFiller(segmentKey);

                  HRESULT hr;
                  hr = pfiller->SetStraightDirectStrandFill(strandGridModel, pSegment->Strands.GetDirectStrandFillStraight());
                  ATLASSERT(SUCCEEDED(hr));
                  hr = pfiller->SetHarpedDirectStrandFill(strandGridModel, pSegment->Strands.GetDirectStrandFillHarped());
                  ATLASSERT(SUCCEEDED(hr));
                  hr = pfiller->SetTemporaryDirectStrandFill(strandGridModel, pSegment->Strands.GetDirectStrandFillTemporary());
                  ATLASSERT(SUCCEEDED(hr));
               }
               else
               {
                  ATLASSERT(false); // is there a new fill type?
               }

               if (strandDefinitionType != pgsTypes::sdtDirectRowInput)
               {
                  // Apply harped strand pattern offsets.
                  // Get fill array for harped and convert to ConfigStrandFillVector
                  CComPtr<IIndexArray> hFillArray;
                  strandGridModel->get_StrandFill(Harped, &hFillArray);
                  ConfigStrandFillVector hFillVec;
                  IndexArray2ConfigStrandFillVec(hFillArray, hFillVec);

                  Float64 adjustment(0.0);
                  if (pSegment->Strands.GetAdjustableStrandType() == pgsTypes::asHarped)
                  {
                     if (pGirderEntry->IsVerticalAdjustmentAllowedEnd())
                     {
                        adjustment = this->ComputeAbsoluteHarpedOffsetEnd(segmentKey, pgsTypes::metStart, hFillVec, pSegment->Strands.GetHarpStrandOffsetMeasurementAtEnd(), pSegment->Strands.GetHarpStrandOffsetAtEnd(pgsTypes::metStart));
                        strandGridModel->put_HarpedStrandAdjustmentEnd(etStart, adjustment);

                        adjustment = this->ComputeAbsoluteHarpedOffsetEnd(segmentKey, pgsTypes::metEnd, hFillVec, pSegment->Strands.GetHarpStrandOffsetMeasurementAtEnd(), pSegment->Strands.GetHarpStrandOffsetAtEnd(pgsTypes::metEnd));
                        strandGridModel->put_HarpedStrandAdjustmentEnd(etEnd, adjustment);
                     }

                     if (pGirderEntry->IsVerticalAdjustmentAllowedHP() && pSegment->Strands.GetAdjustableStrandType() == pgsTypes::asHarped)
                     {
                        adjustment = this->ComputeAbsoluteHarpedOffsetHp(segmentKey, pgsTypes::metStart, hFillVec,
                           pSegment->Strands.GetHarpStrandOffsetMeasurementAtHarpPoint(), pSegment->Strands.GetHarpStrandOffsetAtHarpPoint(pgsTypes::metStart));

                        strandGridModel->put_HarpedStrandAdjustmentHP(etStart, adjustment);

                        adjustment = this->ComputeAbsoluteHarpedOffsetHp(segmentKey, pgsTypes::metEnd, hFillVec,
                           pSegment->Strands.GetHarpStrandOffsetMeasurementAtHarpPoint(), pSegment->Strands.GetHarpStrandOffsetAtHarpPoint(pgsTypes::metEnd));

                        strandGridModel->put_HarpedStrandAdjustmentHP(etEnd, adjustment);
                     }
                  }
                  else
                  {
                     // Adjustable strands are straight
                     if (pGirderEntry->IsVerticalAdjustmentAllowedStraight())
                     {
                        // Use same adjustment at harping points if harped strands are forced to straight

                        adjustment = ComputeAbsoluteHarpedOffsetEnd(segmentKey, pgsTypes::metStart, hFillVec, pSegment->Strands.GetHarpStrandOffsetMeasurementAtEnd(), pSegment->Strands.GetHarpStrandOffsetAtEnd(pgsTypes::metStart));
                        strandGridModel->put_HarpedStrandAdjustmentEnd(etStart, adjustment);
                        strandGridModel->put_HarpedStrandAdjustmentHP(etStart, adjustment);

                        adjustment = ComputeAbsoluteHarpedOffsetEnd(segmentKey, pgsTypes::metEnd, hFillVec, pSegment->Strands.GetHarpStrandOffsetMeasurementAtEnd(), pSegment->Strands.GetHarpStrandOffsetAtEnd(pgsTypes::metEnd));
                        strandGridModel->put_HarpedStrandAdjustmentEnd(etEnd, adjustment);
                        strandGridModel->put_HarpedStrandAdjustmentHP(etEnd, adjustment);
                     }
                  }
               }

                // Apply debonding
               ApplyDebonding(pSegment, strandGridModel);
            }
            else
            {
               CComQIPtr<IStrandPointModel> strandPointModel(strandModel);
               ATLASSERT(strandPointModel);
               ATLASSERT(pSegment->Strands.GetStrandDefinitionType() == pgsTypes::sdtDirectStrandInput);

               Float64 Lg = GetSegmentLength(segmentKey);

               CComPtr<ISuperstructureMemberSegment> segment;
               GetSegment(segmentKey, &segment);

               std::array<Float64, 4> Z;
               ResolveHarpPointLocations(pSegment, nullptr, Z);

               const auto& strandRows = pSegment->Strands.GetStrandRows();
               for (const auto& strandRow : strandRows)
               {
                  std::array<Float64, 4> Y;
                  ResolveStrandRowElevations(segmentKey, strandRow, Z, Y);

                  if (strandRow.m_StrandType == pgsTypes::Straight)
                  {
                     strandPointModel->AddStraightStrand(strandRow.m_Z,Y[ZoneBreakType::Start],Y[ZoneBreakType::End], strandRow.m_bIsExtendedStrand[etStart] ? VARIANT_TRUE : VARIANT_FALSE, strandRow.m_bIsExtendedStrand[etEnd] ? VARIANT_TRUE : VARIANT_FALSE, strandRow.m_bIsDebonded[etStart] ? strandRow.m_DebondLength[etStart] : 0, strandRow.m_bIsDebonded[etEnd] ? strandRow.m_DebondLength[etEnd] : 0);
                  }
                  else if (strandRow.m_StrandType == pgsTypes::Harped)
                  {
                     strandPointModel->AddHarpedStrand(strandRow.m_Z, Y[ZoneBreakType::Start], Y[ZoneBreakType::LeftBreak], Y[ZoneBreakType::RightBreak], Y[ZoneBreakType::End]);

                  }
                  else if (strandRow.m_StrandType == pgsTypes::Temporary)
                  {
                     strandPointModel->AddTemporaryStrand(strandRow.m_Z, Y[ZoneBreakType::Start], Y[ZoneBreakType::End]);
                  }
                  else
                  {
                     ATLASSERT(false); // should never get here
                  }
               }
            }

            // lay out POIs based on this prestressing
            LayoutPrestressTransferAndDebondPoi(segmentKey,segmentOffset); 

            segmentOffset += GetSegmentLayoutLength(segmentKey);

         } // segment loop
      } // girder loop
   } // group loop
}

bool CBridgeAgentImp::AreGirderTopFlangesRoughened(const CSegmentKey& segmentKey) const
{
   GET_IFACE(IShear,pShear);
	const CShearData2* pShearData = pShear->GetSegmentShearData(segmentKey);
   return pShearData->bIsRoughenedSurface;
}

void CBridgeAgentImp::GetClosureJointSize(const CClosureKey& closureKey,Float64* pLeft,Float64* pRight) const
{
   GroupIndexType      grpIdx     = closureKey.groupIndex;
   GirderIndexType     gdrIdx     = closureKey.girderIndex;
   CollectionIndexType closureIdx = closureKey.segmentIndex;

   GET_IFACE(IBridgeDescription,pIBridgeDesc);
   const CBridgeDescription2* pBridgeDesc = pIBridgeDesc->GetBridgeDescription();
   const CGirderGroupData* pGroup = pBridgeDesc->GetGirderGroup(grpIdx);
   const CSplicedGirderData* pGirder = pGroup->GetGirder(gdrIdx);
   
   if ( pGirder->GetClosureJointCount() <= closureIdx )
   {
      ATLASSERT(false); // shouldn't get here
      *pLeft = 0;
      *pRight = 0;
      return;
   }

   const CClosureJointData* pClosureJoint = pGirder->GetClosureJoint(closureIdx);
   
   const CPrecastSegmentData* pLeftSegment = pClosureJoint->GetLeftSegment();
   SegmentIndexType leftSegIdx = pLeftSegment->GetIndex();
   
   const CPrecastSegmentData* pRightSegment = pClosureJoint->GetRightSegment();
   SegmentIndexType rightSegIdx = pRightSegment->GetIndex();

   CSegmentKey leftSegmentKey(grpIdx,gdrIdx,leftSegIdx);
   CSegmentKey rightSegmentKey(grpIdx,gdrIdx,rightSegIdx);

   Float64 leftSegStartEndDist, leftSegEndEndDist;
   GetSegmentEndDistance(leftSegmentKey,&leftSegStartEndDist,&leftSegEndEndDist);

   Float64 rightSegStartEndDist, rightSegEndEndDist;
   GetSegmentEndDistance(rightSegmentKey,&rightSegStartEndDist,&rightSegEndEndDist);

   Float64 leftSegStartBrgOffset, leftSegEndBrgOffset;
   GetSegmentBearingOffset(leftSegmentKey,&leftSegStartBrgOffset,&leftSegEndBrgOffset);

   Float64 rightSegStartBrgOffset, rightSegEndBrgOffset;
   GetSegmentBearingOffset(rightSegmentKey,&rightSegStartBrgOffset,&rightSegEndBrgOffset);

   *pLeft  = leftSegEndBrgOffset    - leftSegEndEndDist;
   *pRight = rightSegStartBrgOffset - rightSegStartEndDist;
}

Float64 CBridgeAgentImp::GetClosureJointLength(const CClosureKey& closureKey) const
{
   Float64 left, right;
   GetClosureJointSize(closureKey,&left,&right);
   return left+right;
}

void CBridgeAgentImp::GetAngleBetweenSegments(const CClosureKey& closureKey,IAngle** ppAngle) const
{
   CSegmentKey backSegmentKey(closureKey);
   CSegmentKey aheadSegmentKey(closureKey);
   aheadSegmentKey.segmentIndex++;

   CComPtr<IDirection> backBearing, aheadBearing;
   GetSegmentDirection(backSegmentKey,&backBearing);
   GetSegmentDirection(aheadSegmentKey,&aheadBearing);

   backBearing->AngleBetween(aheadBearing,ppAngle);
}

void CBridgeAgentImp::LayoutPointsOfInterest(const CGirderKey& girderKey)
{
   ASSERT_GIRDER_KEY(girderKey);

   SegmentIndexType nSegments = GetSegmentCount(girderKey);
   Float64 segment_offset = 0; // offset from start of the girder to the end of the previous segment

   for ( SegmentIndexType segIdx = 0; segIdx < nSegments; segIdx++ )
   {
      CSegmentKey segmentKey(girderKey,segIdx);

      LayoutRegularPoi(segmentKey,10,segment_offset); // 10th points in each segment.
      LayoutSpecialPoi(segmentKey,segment_offset);

      Float64 segment_layout_length = GetSegmentLayoutLength(segmentKey);
      segment_offset += segment_layout_length;
   }

   LayoutPoiForSlabCastingRegions(girderKey);
   LayoutPoiForSlabBarCutoffs(girderKey);

   LayoutPoiForTendons(girderKey);

   // Must do this last. Several of the span POIs are non-mergable having them in the POI manager
   // before the other POIs are created causes certain POI to not merge into other POIs properly.
   // (POI_FACEOFSUPPORT would merge into the poi before the start of a span. with POI_FACEOFSUPPORT
   // stored before the start of the span poi, the start of the span POI can merge into the FOS and
   // we get what we want)
   SpanIndexType startSpanIdx, endSpanIdx;
   GetGirderGroupSpans(girderKey.groupIndex,&startSpanIdx,&endSpanIdx);
   for ( SpanIndexType spanIdx = startSpanIdx; spanIdx <= endSpanIdx; spanIdx++ )
   {
      CSpanKey spanKey(spanIdx,girderKey.girderIndex);
      LayoutSpanPoi(spanKey,10);
      LayoutPoiForIntermediateDiaphragmLoads(spanKey);
   }
}

void CBridgeAgentImp::LayoutSpanPoi(const CSpanKey& spanKey,Uint16 nPnts)
{
   Float64 span_length = GetSpanLength(spanKey);
   const Float64 toler = +1.0e-6;

   for ( Uint16 i = 0; i <= nPnts; i++ )
   {
      Float64 Xspan = span_length * ((Float64)i / (Float64)nPnts); // distance from CL Brg

      pgsPointOfInterest poi = ConvertSpanPointToPoi(spanKey,Xspan);
      if ( poi.GetID() != INVALID_ID)
      {
         // we found an existing POI at the same location
         // clear it's ID and attributes, but keep the location (segment key, etc) the same
         poi.SetID(INVALID_ID);
         poi.ClearAttributes();
      }

      Uint16 tenthPoint = 0;

      // Add a special attribute flag if poi is at a tenth point
      Float64 val = Float64(i)/Float64(nPnts)+toler;
      Float64 modv = fmod(val, 0.1);
      if (IsZero(modv,2*toler) || modv==0.1)
      {
         tenthPoint = Uint16(10.*Float64(i)/Float64(nPnts) + 1);
      }

      poi.MakeTenthPoint(POI_SPAN,tenthPoint);

      VERIFY(m_pPoiMgr->AddPointOfInterest(poi) != INVALID_ID);
   }
}

void CBridgeAgentImp::LayoutRegularPoi(const CSegmentKey& segmentKey,Uint16 nPnts,Float64 segmentOffset)
{
   // This method creates POIs at n-th points for segment spans lengths at release and for the erected segment
   ASSERT_SEGMENT_KEY(segmentKey);

   GET_IFACE(IBridgeDescription,pIBridgeDesc);

   const Float64 toler = +1.0e-6;

   Float64 segment_length  = GetSegmentLength(segmentKey); // end to end length
   Float64 span_length     = GetSegmentSpanLength(segmentKey); // cl brg to cl brg length
   Float64 left_brg_offset = GetSegmentStartBearingOffset(segmentKey);
   Float64 left_end_size   = GetSegmentStartEndDistance(segmentKey);

   pgsPointOfInterest poiStartFace(segmentKey,0.0,POI_START_FACE);
   pgsPointOfInterest poiEndFace(segmentKey,segment_length,POI_END_FACE);
   VERIFY(m_pPoiMgr->AddPointOfInterest(poiStartFace) != INVALID_ID);
   VERIFY(m_pPoiMgr->AddPointOfInterest(poiEndFace) != INVALID_ID);

   Float64 left_release_point, right_release_point;
   GetSegmentReleaseSupportLocations(segmentKey,&left_release_point,&right_release_point);

   Float64 release_span_length = segment_length - left_release_point - right_release_point;

   Float64 left_storage_point, right_storage_point;
   GetSegmentStorageSupportLocations(segmentKey,&left_storage_point,&right_storage_point);

   Float64 storage_span_length = segment_length - left_storage_point - right_storage_point;

   GroupIndexType nGroups     = GetGirderGroupCount();
   SegmentIndexType nSegments = GetSegmentCount(segmentKey);

   // distance from CL Support to start end of girder
   Float64 start_offset = left_brg_offset - left_end_size;

   CSegmentKey firstSegmentKey(segmentKey);
   firstSegmentKey.segmentIndex = 0;
   Float64 first_segment_start_offset = GetSegmentStartBearingOffset(firstSegmentKey) - GetSegmentStartEndDistance(firstSegmentKey);

   for ( Uint16 i = 0; i <= nPnts; i++ )
   {
#if defined _REDUCE_POI
      // cut down on the number of POI.
      // Will only have POI at 0.0, 0.3, 0.5, 0.7 and 1.0L
      // This makes the time-step analysis go faster
      if ( i == 1 || i == 2 || i == 4 || i == 6 || i == 8 || i == 9 )
      {
         continue;
      }
#endif

      Float64 casting_yard_dist = release_span_length * ((Float64)i / (Float64)nPnts); // distance from CL Brg
      Float64 bridge_site_dist  = span_length * ((Float64)i / (Float64)nPnts); // distance from CL Brg
      Float64 storage_dist      = storage_span_length * ((Float64)i / (Float64)nPnts); // distance from left storage point

      PoiAttributeType attribute = 0;

      Uint16 tenthPoint = 0;

      // Add a special attribute flag if poi is at a tenth point
      Float64 val = Float64(i)/Float64(nPnts)+toler;
      Float64 modv = fmod(val, 0.1);
      if (IsZero(modv,2*toler) || modv==0.1)
      {
         tenthPoint = Uint16(10.*Float64(i)/Float64(nPnts) + 1);
      }

      // create casting yard POI
      Float64 Xs  = left_release_point + casting_yard_dist; // distance from left face of segment
      Float64 Xsp = start_offset + Xs; // distance from CLSupport - CLSegment intersection point
      Float64 Xgp = segmentOffset + Xsp; // distance from CLSupport - CLGirder intersection point
      Float64 Xg  = Xgp - first_segment_start_offset;  // distance from left face of first segment
      pgsPointOfInterest cyPoi(segmentKey,Xs,Xsp,Xg,Xgp,attribute | POI_RELEASED_SEGMENT);
      cyPoi.MakeTenthPoint(POI_RELEASED_SEGMENT,tenthPoint);
      VERIFY(m_pPoiMgr->AddPointOfInterest(cyPoi) != INVALID_ID);

      Xs  = left_end_size + bridge_site_dist;
      Xsp = start_offset + Xs;
      Xgp = segmentOffset + Xsp;
      Xg  = Xgp - first_segment_start_offset;
      pgsPointOfInterest bsPoi(segmentKey,Xs,Xsp,Xg,Xgp,attribute | POI_ERECTED_SEGMENT);
      bsPoi.MakeTenthPoint(POI_ERECTED_SEGMENT,tenthPoint);

      // If this is the very first or very last erected segment 10th point in the bridge, these
      // are key CL Bearing points. Mark them with the POI_ABUTMENT attribute so they can be
      // easily found when searching for piers
      if ( (segmentKey.groupIndex == 0         && segmentKey.segmentIndex == 0           && bsPoi.IsTenthPoint(POI_ERECTED_SEGMENT) == 1) ||
           (segmentKey.groupIndex == nGroups-1 && segmentKey.segmentIndex == nSegments-1 && bsPoi.IsTenthPoint(POI_ERECTED_SEGMENT) == 11) )
      {
         bsPoi.SetNonReferencedAttributes(bsPoi.GetNonReferencedAttributes() | POI_ABUTMENT);
      }
      VERIFY(m_pPoiMgr->AddPointOfInterest(bsPoi) != INVALID_ID);

      Xs  = left_storage_point + storage_dist;
      Xsp = start_offset + Xs;
      Xgp = segmentOffset + Xsp;
      Xg  = Xgp - first_segment_start_offset;
      pgsPointOfInterest stPoi(segmentKey,Xs,Xsp,Xg,Xgp,attribute | POI_STORAGE_SEGMENT);
      stPoi.MakeTenthPoint(POI_STORAGE_SEGMENT,tenthPoint);
      VERIFY(m_pPoiMgr->AddPointOfInterest(stPoi) != INVALID_ID);

      // if this is the last poi on the segment, and there is a closure joint on the right end
      // of the segment, then add a closure POI
      if ( i == nPnts )
      {
         const CPrecastSegmentData* pSegment = pIBridgeDesc->GetPrecastSegmentData(segmentKey);
         const CClosureJointData*   pClosure = pSegment->GetClosureJoint(pgsTypes::metEnd);
         if ( pClosure != nullptr )
         {
            Float64 closure_left, closure_right;
            GetClosureJointSize(pClosure->GetClosureKey(),&closure_left,&closure_right);

            Float64 Xs  = segment_length + closure_left;
            Float64 Xsp = start_offset + Xs;
            Float64 Xgp = segmentOffset + Xsp;
            Float64 Xg  = Xgp - first_segment_start_offset;
            pgsPointOfInterest cpPOI(segmentKey,Xs,Xsp,Xg,Xgp,POI_CLOSURE);

            // if the segment ends on a permanent pier, add the POI_BOUNDARY_PIER attribute
            const CPierData2* pPier;
            const CTemporarySupportData* pTS;
            pSegment->GetSupport(pgsTypes::metEnd,&pPier,&pTS);
            if ( pPier )
            {
               cpPOI.SetNonReferencedAttributes(cpPOI.GetNonReferencedAttributes() | POI_BOUNDARY_PIER);
            }
            VERIFY(m_pPoiMgr->AddPointOfInterest(cpPOI) != INVALID_ID);
         }
      }
   }
}

void CBridgeAgentImp::LayoutSpecialPoi(const CSegmentKey& segmentKey,Float64 segmentOffset)
{
   ASSERT_SEGMENT_KEY(segmentKey);

   LayoutEndSizePoi(segmentKey,segmentOffset);
   LayoutHarpingPointPoi(segmentKey,segmentOffset);
   //LayoutPrestressTransferAndDebondPoi(segmentKey,segmentOffset); // this is done when the prestressing is updated
   LayoutPoiForPrecastDiaphragmLoads(segmentKey,segmentOffset);
   LayoutPoiForShear(segmentKey,segmentOffset);
   LayoutPoiForSegmentBarCutoffs(segmentKey,segmentOffset);

   LayoutPoiForHandling(segmentKey);     // lifting and hauling
   LayoutPoiForSectionChanges(segmentKey);
   LayoutPoiForPiers(segmentKey);
   LayoutPoiForTemporarySupports(segmentKey);
}

void CBridgeAgentImp::ModelCantilevers(const CSegmentKey& segmentKey, bool* pbLeftCantilever,bool* pbRightCantilever) const
{
   Float64 start_offset = GetSegmentStartEndDistance(segmentKey);
   Float64 end_offset = GetSegmentEndEndDistance(segmentKey);
   ModelCantilevers(segmentKey, start_offset, end_offset, pbLeftCantilever, pbRightCantilever);
}

void CBridgeAgentImp::ModelCantilevers(const CSegmentKey& segmentKey, Float64 leftSupportDistance, Float64 rightSupportDistance, bool* pbLeftCantilever, bool* pbRightCantilever) const
{
   // This method determines if the overhangs at the ends of a segment are modeled as cantilevers
   ASSERT_SEGMENT_KEY(segmentKey);

   *pbLeftCantilever = false;
   *pbRightCantilever = false;

   // Overhangs are modeled as cantilevers if they are longer than the height of the segment at the CL Bearing
   Float64 segment_length = GetSegmentLength(segmentKey);

   // this method gets called from LayoutEndSizePoi during POI validation... if we call this->GetPointsOfInterest() we get
   // recursion and stack overflow.... since we don't know the validation state of the POIs, we will just have to create
   // POIs on the fly, even though this is not the most efficient way to call GetHeight()
   pgsPointOfInterest poiStartBrg(segmentKey, leftSupportDistance);
   pgsPointOfInterest poiEndBrg(segmentKey, segment_length - rightSupportDistance);

   Float64 segment_height_start = GetHeight(poiStartBrg);
   Float64 segment_height_end = GetHeight(poiEndBrg);

   // the cantilevers at the ends of the segment are modeled as flexural members
   // if the cantilever length exceeds the height of the girder. From LRFD 5.5.1.2.1, B-Regions
   // are beyond one member depth on either side of the discontinuity in geoemtry or force.
   // In this case, the discontinuity in force is the bearing reaction
   *pbLeftCantilever = (::IsLT(segment_height_start, leftSupportDistance) ? true : false);
   *pbRightCantilever = (::IsLT(segment_height_end, rightSupportDistance) ? true : false);
}

void CBridgeAgentImp::LayoutEndSizePoi(const CSegmentKey& segmentKey,Float64 segmentOffset)
{
   GET_IFACE(IBridgeDescription,pIBridgeDesc);
   const CBridgeDescription2* pBridgeDesc = pIBridgeDesc->GetBridgeDescription();
   const CGirderGroupData* pGroup = pBridgeDesc->GetGirderGroup(segmentKey.groupIndex);
   GroupIndexType nGroups = pBridgeDesc->GetGirderGroupCount();
   const CSplicedGirderData* pGirder = pGroup->GetGirder(segmentKey.girderIndex);
   SegmentIndexType nSegments = pGirder->GetSegmentCount();

   Float64 left_end_dist   = GetSegmentStartEndDistance(segmentKey);
   Float64 left_brg_offset = GetSegmentStartBearingOffset(segmentKey);
   Float64 right_end_dist  = GetSegmentEndEndDistance(segmentKey);
   Float64 segment_length  = GetSegmentLength(segmentKey);
   Float64 span_length     = GetSegmentSpanLength(segmentKey); // cl brg to cl brg length

   Float64 start_offset = left_brg_offset - left_end_dist;

   CSegmentKey firstSegmentKey(segmentKey);
   firstSegmentKey.segmentIndex = 0;
   Float64 first_segment_start_offset = GetSegmentStartBearingOffset(firstSegmentKey) - GetSegmentStartEndDistance(firstSegmentKey);

   bool bStartCantilever, bEndCantilever;
   ModelCantilevers(segmentKey,&bStartCantilever,&bEndCantilever);
   if ( bStartCantilever )
   {
      // model 5 poi per cantilever, except the poi spacing can't exceed 
      // the 10th point spacing
      Float64 max_poi_spacing = span_length/10.0;
      IndexType nPoi = 5; // puts poi at quarter points on cantilever, including a poi at start and end
      Float64 poi_spacing = left_end_dist/(nPoi-1);
      if ( max_poi_spacing < poi_spacing )
      {
         nPoi = IndexType(left_end_dist/max_poi_spacing);
         poi_spacing = left_end_dist/(nPoi-1);
      }

      Float64 Xs = 0;
      for ( IndexType poiIdx = 0; poiIdx < nPoi; poiIdx++ )
      {
         Float64 Xsp = Xs + start_offset;
         Float64 Xgp = segmentOffset + Xsp;
         Float64 Xg = Xgp - first_segment_start_offset;
         pgsPointOfInterest poi(segmentKey, Xs, Xsp, Xg, Xgp,POI_SPAN | POI_CANTILEVER);
         poi.SetReferencedAttributes(POI_ERECTED_SEGMENT | POI_CANTILEVER);
         ATLASSERT(poi.GetReferencedAttributes(POI_SPAN) == (POI_SPAN | POI_CANTILEVER));
         ATLASSERT(poi.GetReferencedAttributes(POI_ERECTED_SEGMENT) == (POI_ERECTED_SEGMENT | POI_CANTILEVER));
         VERIFY(m_pPoiMgr->AddPointOfInterest(poi) != INVALID_ID);
         Xs += poi_spacing;
      }
   }
   else if ( segmentKey.segmentIndex == 0 && 0 < left_end_dist )
   {
      Float64 Xs = left_end_dist;
      Float64 Xsp = Xs + start_offset;
      Float64 Xgp = segmentOffset + Xsp;
      Float64 Xg = Xgp - first_segment_start_offset;
      pgsPointOfInterest poi(segmentKey, Xs, Xsp, Xg, Xgp, POI_SPAN | POI_CANTILEVER);
      poi.SetReferencedAttributes(POI_ERECTED_SEGMENT | POI_CANTILEVER);
      ATLASSERT(poi.GetReferencedAttributes(POI_SPAN) == (POI_SPAN | POI_CANTILEVER));
      ATLASSERT(poi.GetReferencedAttributes(POI_ERECTED_SEGMENT) == (POI_ERECTED_SEGMENT | POI_CANTILEVER));
      VERIFY(m_pPoiMgr->AddPointOfInterest(poi) != INVALID_ID);
   }

   if ( bEndCantilever )
   {
      // model 5 poi per cantilever, except the poi spacing can't exceed 
      // the 10th point spacing
      Float64 max_poi_spacing = span_length/10.0;
      IndexType nPoi = 5; // puts poi at quarter points on cantilever, including a poi at start and end
      Float64 poi_spacing = right_end_dist/(nPoi-1);
      if ( max_poi_spacing < poi_spacing )
      {
         nPoi = IndexType(right_end_dist/max_poi_spacing);
         poi_spacing = right_end_dist/(nPoi-1);
      }

      Float64 Xs = segment_length - right_end_dist;
      for ( IndexType poiIdx = 0; poiIdx < nPoi; poiIdx++ )
      {
         Float64 Xsp = Xs + start_offset;
         Float64 Xgp = segmentOffset + Xsp;
         Float64 Xg = Xgp - first_segment_start_offset;
         pgsPointOfInterest poi(segmentKey, Xs, Xsp, Xg, Xgp,POI_SPAN | POI_CANTILEVER);
         poi.SetReferencedAttributes(POI_ERECTED_SEGMENT | POI_CANTILEVER);
         ATLASSERT(poi.GetReferencedAttributes(POI_SPAN) == (POI_SPAN | POI_CANTILEVER));
         ATLASSERT(poi.GetReferencedAttributes(POI_ERECTED_SEGMENT) == (POI_ERECTED_SEGMENT | POI_CANTILEVER));
         VERIFY(m_pPoiMgr->AddPointOfInterest(poi) != INVALID_ID);
         Xs += poi_spacing;
      }
   }
   else if ( segmentKey.segmentIndex == nSegments-1 && 0 < right_end_dist )
   {
      Float64 Xs = segment_length - right_end_dist;
      Float64 Xsp = Xs + start_offset;
      Float64 Xgp = segmentOffset + Xsp;
      Float64 Xg = Xgp - first_segment_start_offset;
      pgsPointOfInterest poi(segmentKey, Xs, Xsp, Xg, Xgp, POI_SPAN | POI_CANTILEVER);
      poi.SetReferencedAttributes(POI_ERECTED_SEGMENT | POI_CANTILEVER);
      ATLASSERT(poi.GetReferencedAttributes(POI_SPAN) == (POI_SPAN | POI_CANTILEVER));
      ATLASSERT(poi.GetReferencedAttributes(POI_ERECTED_SEGMENT) == (POI_ERECTED_SEGMENT | POI_CANTILEVER));
      VERIFY(m_pPoiMgr->AddPointOfInterest(poi) != INVALID_ID);
   }

   // Add a POI at the start and end of every segment, except at the start of the first segment in the first group
   // and the end of the last segment in the last group.
   //
   // POIs are needed at this location because of the way the Anaysis Agent builds the LBAM models. At intermediate piers
   // and closure joints, the "span length" is extended to the end of the segment rather than the CL Bearing.
   if ( !((segmentKey.segmentIndex == 0) && (segmentKey.groupIndex == 0)) )
   {
      Float64 Xs  = 0;
      Float64 Xsp = Xs + start_offset;
      Float64 Xgp = segmentOffset + Xsp;
      Float64 Xg  = Xgp - first_segment_start_offset;
      pgsPointOfInterest poi(segmentKey,Xs,Xsp,Xg,Xgp);
      VERIFY(m_pPoiMgr->AddPointOfInterest(poi) != INVALID_ID);
   }

   if ( !((segmentKey.segmentIndex == nSegments-1) && (segmentKey.groupIndex == nGroups-1)) )
   {
      Float64 Xs  = segment_length;
      Float64 Xsp = Xs + start_offset;
      Float64 Xgp = segmentOffset + Xsp;
      Float64 Xg  = Xgp - first_segment_start_offset;
      pgsPointOfInterest poi(segmentKey,Xs,Xsp,Xg,Xgp);
      VERIFY(m_pPoiMgr->AddPointOfInterest(poi) != INVALID_ID);
   }
}

void CBridgeAgentImp::LayoutHarpingPointPoi(const CSegmentKey& segmentKey,Float64 segmentOffset)
{
   IndexType maxHarped = GetNumHarpPoints(segmentKey);

   // if there can't be any harped strands, then there is no need to use the harping point attribute
   if ( maxHarped == 0 )
   {
      return; 
   }

   Float64 left_end_dist = GetSegmentStartEndDistance(segmentKey);
   Float64 left_brg_offset = GetSegmentStartBearingOffset(segmentKey);
   Float64 segment_length = GetSegmentLength(segmentKey);
   Float64 start_offset = left_brg_offset - left_end_dist;

   CSegmentKey firstSegmentKey(segmentKey);
   firstSegmentKey.segmentIndex = 0;
   Float64 first_segment_start_offset = GetSegmentStartBearingOffset(firstSegmentKey) - GetSegmentStartEndDistance(firstSegmentKey);

   Float64 hp1, hp2;
   GetHarpingPointLocations( segmentKey, &hp1, &hp2 );

   Float64 Xs  = hp1;
   Float64 Xsp = Xs + start_offset;
   Float64 Xgp = segmentOffset + Xsp;
   Float64 Xg  = Xgp - first_segment_start_offset;
   pgsPointOfInterest poiHP1(segmentKey,Xs,Xsp,Xg,Xgp,POI_HARPINGPOINT);

   Xs  = hp2;
   Xsp = Xs + start_offset;
   Xgp = segmentOffset + Xsp;
   Xg = Xgp - first_segment_start_offset;
   pgsPointOfInterest poiHP2(segmentKey,Xs,Xsp,Xg,Xgp,POI_HARPINGPOINT);


   GET_IFACE(IBridgeDescription,pIBridgeDesc);
   const CTimelineManager* pTimelineMgr = pIBridgeDesc->GetTimelineManager();

   CComPtr<IPrecastGirder> girder;
   GetGirder(segmentKey, &girder);

   Float64 left_end, right_end, length;
   girder->get_LeftEndDistance(&left_end);
   girder->get_RightEndDistance(&right_end);
   girder->get_GirderLength(&length);
   StrandIndexType nHarped = GetStrandCount(segmentKey, pgsTypes::Harped);
   if ( 0 < nHarped && (hp1 <= left_end || (length-right_end) <= hp2 ))
   {
      // harp points are outside of the support location
      GET_IFACE(IEAFStatusCenter,pStatusCenter);
      std::_tostringstream os;
      os << _T("The harping points for ") << SEGMENT_LABEL(segmentKey)
         << _T(" are located outside of the bearings. You can fix this by increasing the segment length, or")
         << _T(" by changing the harping point location in the girder library entry.")<<std::endl;

      std::unique_ptr<pgsBridgeDescriptionStatusItem> pStatusItem = std::make_unique<pgsBridgeDescriptionStatusItem>(m_StatusGroupID,m_scidBridgeDescriptionError,pgsBridgeDescriptionStatusItem::General,os.str().c_str());
      pStatusCenter->Add(pStatusItem.release());
   }

   VERIFY(m_pPoiMgr->AddPointOfInterest(poiHP1) != INVALID_ID);
   VERIFY(m_pPoiMgr->AddPointOfInterest(poiHP2) != INVALID_ID);

   // add POI on either side of the harping point. Because the vertical component of prestress, Vp, is zero
   // on one side of the harp point and Vp on the other side there is a jump in shear capacity. Add these
   // poi to pick up the jump.
   poiHP1.Offset( 0.0015);
   poiHP2.Offset(-0.0015);

   poiHP1.SetNonReferencedAttributes(0);
   poiHP2.SetNonReferencedAttributes(0);
   
   VERIFY(m_pPoiMgr->AddPointOfInterest(poiHP1) != INVALID_ID);
   VERIFY(m_pPoiMgr->AddPointOfInterest(poiHP2) != INVALID_ID);
}

void CBridgeAgentImp::LayoutPrestressTransferAndDebondPoi(const CSegmentKey& segmentKey,Float64 segmentOffset)
{
   PoiAttributeType attrib_debond = POI_DEBOND;
   PoiAttributeType attrib_xfer   = POI_PSXFER;

   GET_IFACE(IBridgeDescription,pIBridgeDesc);
   const CTimelineManager* pTimelineMgr = pIBridgeDesc->GetTimelineManager();

   SegmentIDType segID = pIBridgeDesc->GetSegmentID(segmentKey);

   // remove any current ps-xfer and debond pois
   PoiList vPoi;
   m_pPoiMgr->GetPointsOfInterest(segmentKey,POI_DEBOND | POI_PSXFER,POIMGR_OR,&vPoi);
   for ( const pgsPointOfInterest& poi : vPoi)
   {
      m_pPoiMgr->RemovePointOfInterest(poi);
   }

#if defined _DEBUG
   // after removal, get the same pois... the list should be empty
   vPoi.clear();
   m_pPoiMgr->GetPointsOfInterest(segmentKey,POI_DEBOND | POI_PSXFER,POIMGR_OR,&vPoi);
   ATLASSERT(vPoi.size() == 0);
#endif

   // Add POIs at the prestress transfer length from the ends of the girder
   // since straight and harped strands can have different diameters they 
   // can have different transfer points, that's why we loop over both strand types
   Float64 left_end_dist = GetSegmentStartEndDistance(segmentKey);
   Float64 left_brg_offset = GetSegmentStartBearingOffset(segmentKey);
   Float64 segment_length = GetSegmentLength(segmentKey);
   Float64 start_offset = left_brg_offset - left_end_dist;

   CSegmentKey firstSegmentKey(segmentKey);
   firstSegmentKey.segmentIndex = 0;
   Float64 first_segment_start_offset = GetSegmentStartBearingOffset(firstSegmentKey) - GetSegmentStartEndDistance(firstSegmentKey);

   GET_IFACE(IPretensionForce,pPrestress);
   for (int i = 0; i < 2; i++)
   {
      pgsTypes::StrandType strandType = (pgsTypes::StrandType)i;
      Float64 xfer_length = pPrestress->GetTransferLength(segmentKey, strandType, pgsTypes::tltMinimum);
      // use minimum transfer length for POI_PSXFER sinces this is the critical location for stress calculations

      Float64 d1 = xfer_length;
      Float64 d2 = segment_length - xfer_length;

      Float64 Xs = d1;
      Float64 Xsp = Xs + start_offset;
      Float64 Xgp = segmentOffset + Xsp;
      Float64 Xg = Xgp - first_segment_start_offset;
      pgsPointOfInterest poiXfer1(segmentKey, Xs, Xsp, Xg, Xgp, attrib_xfer);
      VERIFY(m_pPoiMgr->AddPointOfInterest(poiXfer1) != INVALID_ID);

      Xs = d2;
      Xsp = Xs + start_offset;
      Xgp = segmentOffset + Xsp;
      Xg = Xgp - first_segment_start_offset;
      pgsPointOfInterest poiXfer2(segmentKey, Xs, Xsp, Xg, Xgp, attrib_xfer);
      VERIFY(m_pPoiMgr->AddPointOfInterest(poiXfer2) != INVALID_ID);
   }

   ////////////////////////////////////////////////////////////////
   // debonded strands
   ////////////////////////////////////////////////////////////////

   GET_IFACE(ISegmentData,pSegmentData);
   const CStrandData* pStrands = pSegmentData->GetStrandData(segmentKey);

   for ( Uint16 i = 0; i < 3; i++ )
   {
      pgsTypes::StrandType strandType = (pgsTypes::StrandType)i;

      Float64 xfer_length = pPrestress->GetTransferLength(segmentKey, strandType, pgsTypes::tltMinimum);

      const std::vector<CDebondData>& vDebond(pStrands->GetDebonding(strandType));
      std::vector<CDebondData>::const_iterator iter(vDebond.begin());
      std::vector<CDebondData>::const_iterator end(vDebond.end());
      for ( ; iter != end; iter++ )
      {
         const CDebondData& debond_info = *iter;

         Float64 d1 = debond_info.Length[pgsTypes::metStart];
         Float64 d2 = d1 + xfer_length;

         // only add POI if debond and transfer point are on the girder
         if ( d1 < segment_length && d2 < segment_length )
         {
            ATLASSERT(0 <= debond_info.Length[pgsTypes::metStart]);// this should not happen, but if it does it would be nice to know about it because there is a bug somewhere
            if (!IsZero(debond_info.Length[pgsTypes::metStart]))
            {
               Float64 Xs = d1;
               Float64 Xsp = Xs + start_offset;
               Float64 Xgp = segmentOffset + Xsp;
               Float64 Xg = Xgp - first_segment_start_offset;
               pgsPointOfInterest poiDBD(segmentKey, Xs, Xsp, Xg, Xgp, attrib_debond);
               VERIFY(m_pPoiMgr->AddPointOfInterest(poiDBD) != INVALID_ID);

               poiDBD.SetDistFromStart(d1 - 0.001);
               VERIFY(m_pPoiMgr->AddPointOfInterest(poiDBD) != INVALID_ID);
            }

            Float64 Xs  = d2;
            Float64 Xsp = Xs + start_offset;
            Float64 Xgp = segmentOffset + Xsp;
            Float64 Xg  = Xgp - first_segment_start_offset;
            pgsPointOfInterest poiXFR(segmentKey,Xs,Xsp,Xg,Xgp,attrib_xfer);
            VERIFY(m_pPoiMgr->AddPointOfInterest(poiXFR) != INVALID_ID);
         }

         d1 = segment_length - debond_info.Length[pgsTypes::metEnd];
         d2 = d1 - xfer_length;
         // only add POI if debond and transfer point are on the girder
         if ( 0 < d1 && 0 < d2 )
         {
            ATLASSERT(0 <= debond_info.Length[pgsTypes::metStart]); // this should not happen, but if it does it would be nice to know about it because there is a bug somewhere
            if (!IsZero(debond_info.Length[pgsTypes::metStart]))
            {
               Float64 Xs = d1;
               Float64 Xsp = Xs + start_offset;
               Float64 Xgp = segmentOffset + Xsp;
               Float64 Xg = Xgp - first_segment_start_offset;
               pgsPointOfInterest poiDBD(segmentKey, Xs, Xsp, Xg, Xgp, attrib_debond);
               VERIFY(m_pPoiMgr->AddPointOfInterest(poiDBD) != INVALID_ID);

               poiDBD.SetDistFromStart(d1 + 0.001);
               VERIFY(m_pPoiMgr->AddPointOfInterest(poiDBD) != INVALID_ID);
            }

            Float64 Xs  = d2;
            Float64 Xsp = Xs + start_offset;
            Float64 Xgp = segmentOffset + Xsp;
            Float64 Xg  = Xgp - first_segment_start_offset;
            pgsPointOfInterest poiXFR(segmentKey,Xs,Xsp,Xg,Xgp,attrib_xfer);
            VERIFY(m_pPoiMgr->AddPointOfInterest(poiXFR) != INVALID_ID);
         }
      }
   }
}

void CBridgeAgentImp::LayoutPoiForPrecastDiaphragmLoads(const CSegmentKey& segmentKey,Float64 segmentOffset)
{
   // we want to capture "jumps" due to diaphragm loads in the graphical displays
   Float64 left_end_dist = GetSegmentStartEndDistance(segmentKey);
   Float64 left_brg_offset = GetSegmentStartBearingOffset(segmentKey);
   Float64 start_offset = left_brg_offset - left_end_dist;

   CSegmentKey firstSegmentKey(segmentKey);
   firstSegmentKey.segmentIndex = 0;
   Float64 first_segment_start_offset = GetSegmentStartBearingOffset(firstSegmentKey) - GetSegmentStartEndDistance(firstSegmentKey);

   // layout for diaphragms that are built in the casting yard
   std::vector<IntermedateDiaphragm> pcDiaphragms( GetPrecastDiaphragms(segmentKey) );
   std::vector<IntermedateDiaphragm>::iterator iter(pcDiaphragms.begin());
   std::vector<IntermedateDiaphragm>::iterator end(pcDiaphragms.end());
   for ( ; iter != end; iter++ )
   {
      IntermedateDiaphragm& diaphragm = *iter;

      Float64 Xs  = diaphragm.Location; // location in POI coordinates
      Float64 Xsp = start_offset  + Xs; // location in segment path coordinates
      Float64 Xgp = segmentOffset + Xsp;  // location in girder path coordinates
      Float64 Xg  = Xgp - first_segment_start_offset;   // location in girder coordinates
      pgsPointOfInterest poi( segmentKey, Xs, Xsp, Xg, Xgp, POI_DIAPHRAGM);
      VERIFY(m_pPoiMgr->AddPointOfInterest(poi) != INVALID_ID);
   }
}

void CBridgeAgentImp::LayoutPoiForIntermediateDiaphragmLoads(const CSpanKey& spanKey)
{
   // we want to capture "jumps" due to diaphragm loads in the graphical displays
   // get loads for bridge site 
   std::vector<IntermedateDiaphragm> cipDiaphragms( GetCastInPlaceDiaphragms(spanKey,true/*location only*/) );
   std::vector<IntermedateDiaphragm>::iterator iter(cipDiaphragms.begin());
   std::vector<IntermedateDiaphragm>::iterator end(cipDiaphragms.end());
   for ( ; iter != end; iter++ )
   {
      IntermedateDiaphragm& diaphragm = *iter;

      Float64 Xspan = diaphragm.Location;

      pgsPointOfInterest poi = ConvertSpanPointToPoi(spanKey,Xspan);
      poi.SetID(INVALID_ID);
      poi.ClearAttributes();
      poi.SetNonReferencedAttributes(POI_DIAPHRAGM);

      VERIFY(m_pPoiMgr->AddPointOfInterest(poi) != INVALID_ID);
   }
}

void CBridgeAgentImp::LayoutPoiForShear(const CSegmentKey& segmentKey,Float64 segmentOffset)
{
   // Layout POI at H, 1.5H, 2.5H, and FaceOfSupport from CL-Brg for piers that occur at the
   // ends of a segment (See LayoutPoiForPier for shear POIs that occur near
   // intermediate supports for segments that span over a pier)

   Float64 start_end_dist   = GetSegmentStartEndDistance(segmentKey);
   Float64 end_end_dist     = GetSegmentEndEndDistance(segmentKey);
   Float64 start_brg_offset = GetSegmentStartBearingOffset(segmentKey);
   Float64 end_brg_offset   = GetSegmentEndBearingOffset(segmentKey);
   Float64 start_offset     = start_brg_offset - start_end_dist;
   Float64 segment_length   = GetSegmentLength(segmentKey);

   CSegmentKey firstSegmentKey(segmentKey);
   firstSegmentKey.segmentIndex = 0;
   Float64 first_segment_start_offset = GetSegmentStartBearingOffset(firstSegmentKey) - GetSegmentStartEndDistance(firstSegmentKey);

   GET_IFACE(IBridgeDescription,pIBridgeDesc);
   const CPrecastSegmentData* pSegment = pIBridgeDesc->GetPrecastSegmentData(segmentKey);
   const CPierData2* pPier;
   const CTemporarySupportData* pTS;
   pSegment->GetSupport(pgsTypes::metStart,&pPier,&pTS);

   if ( pPier )
   {
      // this is a pier at the start of this segment
      PierIndexType pierIdx = pPier->GetIndex();
      Float64 XsCLPier;
      GetPierLocation(pierIdx,segmentKey,&XsCLPier); // location of CL pier in segment coordinates
      Float64 XsCLBrg = XsCLPier + start_brg_offset; // location of CL brg in segment coordinates
      Float64 Hg = GetHeight(pgsPointOfInterest(segmentKey,XsCLBrg));

      Float64 right_support_width; // support width on right side of CL Pier
      if (pPier->IsInteriorPier() || ::IsContinuousBoundaryConditionAheadSide(pPier->GetBoundaryConditionType()))
      {
         // if the pier is continuous, the face of support is the face of the diaphragm
         Float64 diaphragm_height;
         GetPierDiaphragmSize(pierIdx, pgsTypes::Ahead, &right_support_width, &diaphragm_height);

         right_support_width -= start_brg_offset;
         if (right_support_width < 0)
         {
            // negative means the FOS is not on the girder (which is weird)
            right_support_width = 0;
         }
      }
      else
      {
         // NOTE: Assuming that the support is symmetric about the CL Bearing
         // Distance from CL Brg to face of support is taken to be support_width/2
         Float64 support_width = GetSegmentStartSupportWidth(segmentKey); // this is based on the bearing size
         right_support_width = support_width / 2;
      }

      // If "H" from the end of the girder is at the point of bearing
      // make sure there isn't any "noise" in the data
      if ( IsEqual(Hg,start_end_dist) )
      {
         Hg = start_end_dist;
      }

      Float64 Xs, Xsp, Xg, Xgp;

      // POI between FOS and 1.5H for purposes of computing critical section
      Xs  = start_end_dist + /*right_support_width +*/ 0.75*Hg; // support width was not used in Version 2.x
      Xsp = Xs + start_offset;
      Xgp = segmentOffset + Xsp;
      Xg  = Xgp - first_segment_start_offset;
      pgsPointOfInterest poi_075h( segmentKey, Xs, Xsp, Xg, Xgp);
      VERIFY(m_pPoiMgr->AddPointOfInterest(poi_075h) != INVALID_ID);

      Xs  = start_end_dist + right_support_width + Hg;
      Xsp = Xs + start_offset;
      Xgp = segmentOffset + Xsp;
      Xg  = Xgp - first_segment_start_offset;
      pgsPointOfInterest poi_h( segmentKey, Xs, Xsp, Xg, Xgp, POI_H);
      VERIFY(m_pPoiMgr->AddPointOfInterest(poi_h) != INVALID_ID);

      Xs  = start_end_dist + right_support_width + 1.5*Hg;
      Xsp = Xs + start_offset;
      Xgp = segmentOffset + Xsp;
      Xg  = Xgp - first_segment_start_offset;
      pgsPointOfInterest poi_15h( segmentKey, Xs, Xsp, Xg, Xgp, POI_15H);
      VERIFY(m_pPoiMgr->AddPointOfInterest(poi_15h) != INVALID_ID);

      Xs = start_end_dist + right_support_width;
      Xsp = Xs + start_offset;
      Xgp = segmentOffset + Xsp;
      Xg = Xgp - first_segment_start_offset;
      pgsPointOfInterest poi_fos(segmentKey, Xs, Xsp, Xg, Xgp, POI_FACEOFSUPPORT);
      VERIFY(m_pPoiMgr->AddPointOfInterest(poi_fos) != INVALID_ID);
   }

   pSegment->GetSupport(pgsTypes::metEnd,&pPier,&pTS);
   if ( pPier )
   {
      // this is a pier at the end of this segment
      PierIndexType pierIdx = pPier->GetIndex();
      Float64 XsCLPier;
      GetPierLocation(pierIdx,segmentKey,&XsCLPier); // CL pier in segment coordinates
      Float64 XsCLBrg = XsCLPier - end_brg_offset; // CL brg in segment coordinates
      ATLASSERT( ::IsLE(XsCLBrg,segment_length) );

      Float64 Hg = GetHeight(pgsPointOfInterest(segmentKey,XsCLBrg));

      Float64 left_support_width;
      if (pPier->IsInteriorPier() || ::IsContinuousBoundaryConditionBackSide(pPier->GetBoundaryConditionType()))
      {
         // if the pier is continuous, the face of support is the face of the diaphragm
         Float64 diaphragm_height;
         GetPierDiaphragmSize(pierIdx, pgsTypes::Back, &left_support_width, &diaphragm_height);

         left_support_width -= end_brg_offset;
         if (left_support_width < 0)
         {
            // negative means the FOS is not on the girder (which is weird)
            left_support_width = 0;
         }
      }
      else
      {
         Float64 support_width = GetSegmentEndSupportWidth(segmentKey);
         left_support_width = support_width / 2; // support width on left side of CL Pier
      }


      // If "H" from the end of the girder is at the point of bearing
      // make sure there isn't any "noise" in the data
      if ( IsEqual(Hg,end_end_dist) )
      {
         Hg = end_end_dist;
      }

      Float64 Xs, Xsp, Xg, Xgp;
      // add a POI at 0.75H for purposes of computing critical section
      Xs  = segment_length - (end_end_dist + /*left_support_width +*/ 0.75*Hg); // support width was not used in Version 2.x
      Xsp = Xs + start_offset;
      Xgp = Xsp + segmentOffset;
      Xg  = Xgp - first_segment_start_offset;
      pgsPointOfInterest poi_075h( segmentKey, Xs, Xsp, Xg, Xgp);
      VERIFY(m_pPoiMgr->AddPointOfInterest(poi_075h) != INVALID_ID);

      Xs  = segment_length - (end_end_dist + left_support_width + Hg);
      Xsp = Xs + start_offset;
      Xgp = Xsp + segmentOffset;
      Xg  = Xgp - first_segment_start_offset;
      pgsPointOfInterest poi_h( segmentKey, Xs, Xsp, Xg, Xgp, POI_H);
      VERIFY(m_pPoiMgr->AddPointOfInterest(poi_h) != INVALID_ID);

      Xs  = segment_length - (end_end_dist + left_support_width + 1.5*Hg);
      Xsp = Xs + start_offset;
      Xgp = Xsp + segmentOffset;
      Xg  = Xgp - first_segment_start_offset;
      pgsPointOfInterest poi_15h( segmentKey, Xs, Xsp, Xg, Xgp, POI_15H);
      VERIFY(m_pPoiMgr->AddPointOfInterest(poi_15h) != INVALID_ID);

      Xs  = segment_length - (end_end_dist + left_support_width);
      Xsp = Xs + start_offset;
      Xgp = Xsp + segmentOffset;
      Xg  = Xgp - first_segment_start_offset;
      pgsPointOfInterest poi_fos( segmentKey, Xs, Xsp, Xg, Xgp, POI_FACEOFSUPPORT);
      VERIFY(m_pPoiMgr->AddPointOfInterest(poi_fos) != INVALID_ID);
   }


   // POI's at stirrup zone boundaries
   Float64 end_support_loc = segment_length - end_end_dist;
   Float64 midLen = segment_length/2.0;

   ZoneIndexType nZones = GetPrimaryZoneCount(segmentKey);
   for (ZoneIndexType zoneIdx = 1; zoneIdx < nZones; zoneIdx++) // note that count starts at one
   {
      Float64 zStart, zEnd;
      GetPrimaryZoneBounds(segmentKey, zoneIdx, &zStart, &zEnd);

      // Nudge poi toward mid-span as this is where smaller Av/s will typically lie
      zStart += (zStart < midLen ? 0.001 : -0.001);

      if (start_end_dist < zStart && zStart < end_support_loc)
      {
         Float64 Xs, Xsp, Xg, Xgp;
         Xs  = zStart;
         Xsp = Xs + start_offset;
         Xgp = Xsp + segmentOffset;
         Xg  = Xgp - first_segment_start_offset;

         pgsPointOfInterest poi(segmentKey, Xs, Xsp, Xg, Xgp, POI_STIRRUP_ZONE);
         VERIFY(m_pPoiMgr->AddPointOfInterest(poi) != INVALID_ID);
      }
   }
}

void CBridgeAgentImp::LayoutPoiForSlabBarCutoffs(const CGirderKey& girderKey)
{
   GET_IFACE(IBridgeDescription,pIBridgeDesc);
   const CBridgeDescription2* pBridgeDesc = pIBridgeDesc->GetBridgeDescription();
   const CDeckRebarData& rebarData = pBridgeDesc->GetDeckDescription()->DeckRebarData;

   CComPtr<IGeomUtil2d> geomUtil;
   geomUtil.CoCreateInstance(CLSID_GeomUtil);

   PierIndexType startPierIdx, endPierIdx;
   GetGirderGroupPiers(girderKey.groupIndex,&startPierIdx,&endPierIdx);
   for ( PierIndexType pierIdx = startPierIdx; pierIdx <= endPierIdx; pierIdx++ )
   {
      std::vector<CDeckRebarData::NegMomentRebarData> vSupplementalRebarData(rebarData.GetSupplementalReinforcement(pierIdx));
      for( const auto& nmRebarData : vSupplementalRebarData)
      {
         CComPtr<IPierLine> pierLine;
         GetPierLine(pierIdx,&pierLine);

         CComPtr<ILine2d> centerlinePier;
         pierLine->get_Centerline(&centerlinePier);

         CComPtr<IAngle> objSkewAngle;
         pierLine->get_Skew(&objSkewAngle);
         Float64 skewAngle;
         objSkewAngle->get_Value(&skewAngle);

         if ( pierIdx != endPierIdx )
         {
            // on ahead side of pier... do this for all pier except that last one in this group
            // the ahead side doesn't exist if this is the last group or it will be handled
            // when the next group is processed

            Float64 offset = nmRebarData.RightCutoff*cos(skewAngle);

            CComPtr<ILine2d> pAheadLine;
            geomUtil->CreateParallelLine(centerlinePier,offset,&pAheadLine);

            SpanIndexType spanIdx = (SpanIndexType)pierIdx;
            CSpanKey spanKey(spanIdx,girderKey.girderIndex);
            Float64 Xspan = nmRebarData.RightCutoff;

            // this is the poi measuring the right cutoff along the CL girder... this
            // we don't actually want to do this. we want to measure bar cutoff
            // in the direction of the alignment at the pier.
            // This poi is near the one we want so it makes finding the actual location quicker
            pgsPointOfInterest poi = ConvertSpanPointToPoi(spanKey,Xspan);

            Float64 Xpoi;
            SegmentIndexType segIdx;
            VERIFY(GirderLineIntersect(girderKey,pAheadLine,poi.GetSegmentKey().segmentIndex,&segIdx,&Xpoi));
            poi.SetSegmentKey(CSegmentKey(girderKey,segIdx));
            poi.SetDistFromStart(Xpoi);
            poi.SetID(INVALID_ID);
            poi.ClearAttributes();
            poi.SetNonReferencedAttributes(POI_DECKBARCUTOFF);
            VERIFY(m_pPoiMgr->AddPointOfInterest(poi) != INVALID_ID);

            // put a POI just after the bar cutoff so we capture jumps in capacity
            poi.ClearAttributes();
            poi.SetDistFromStart(poi.GetDistFromStart()+DECK_REBAR_OFFSET);
            VERIFY(m_pPoiMgr->AddPointOfInterest(poi) != INVALID_ID);
         }

         if ( pierIdx != startPierIdx )
         {
            // on back side of pier... do this for all pier except for first one in this group
            // the back side doesn't exist if this is the first group or it was handled
            // when the previous group was processed

            Float64 offset = nmRebarData.LeftCutoff*cos(skewAngle);

            CComPtr<ILine2d> pBackLine;
            geomUtil->CreateParallelLine(centerlinePier,-offset,&pBackLine);

            SpanIndexType spanIdx = SpanIndexType(pierIdx-1);
            CSpanKey spanKey(spanIdx,girderKey.girderIndex);
            Float64 spanLength = GetSpanLength(spanKey);
            Float64 Xspan = spanLength - nmRebarData.LeftCutoff;

            pgsPointOfInterest poi = ConvertSpanPointToPoi(spanKey,Xspan);
            Float64 Xpoi;
            SegmentIndexType segIdx;
            VERIFY(GirderLineIntersect(girderKey,pBackLine,poi.GetSegmentKey().segmentIndex,&segIdx,&Xpoi));
            poi.SetSegmentKey(CSegmentKey(girderKey,segIdx));
            poi.SetDistFromStart(Xpoi);

            poi.SetID(INVALID_ID);
            poi.ClearAttributes();
            poi.SetNonReferencedAttributes(POI_DECKBARCUTOFF);
            VERIFY(m_pPoiMgr->AddPointOfInterest(poi) != INVALID_ID);

            // put a POI just before the bar cutoff so we capture jumps in capacity
            poi.ClearAttributes();
            poi.SetDistFromStart(poi.GetDistFromStart()-DECK_REBAR_OFFSET);
            VERIFY(m_pPoiMgr->AddPointOfInterest(poi) != INVALID_ID);
         }
      }
   }
}

void CBridgeAgentImp::LayoutPoiForSlabCastingRegions(const CGirderKey& girderKey)
{
   ASSERT_GIRDER_KEY(girderKey);

   GET_IFACE(IBridgeDescription, pIBridgeDesc);
   EventIndexType castDeckEventIdx = pIBridgeDesc->GetCastDeckEventIndex();
   if (castDeckEventIdx == INVALID_INDEX)
   {
      // no deck, no deck casting boundaries
      ATLASSERT(pIBridgeDesc->GetDeckDescription()->GetDeckType() == pgsTypes::sdtNone);
      return;
   }

   const CTimelineEvent* pEvent = pIBridgeDesc->GetEventByIndex(castDeckEventIdx);
   const CCastDeckActivity& castDeckActivity = pEvent->GetCastDeckActivity();
   ATLASSERT(castDeckActivity.IsEnabled());

   // create a geometry utility object... we'll need it for geometric calculations
   CComPtr<IGeomUtil2d> geomUtil;
   geomUtil.CoCreateInstance(CLSID_GeomUtil);

   GroupIndexType nGroups = GetGirderGroupCount();

   SpanIndexType startSpanIdx, endSpanIdx;
   GetGirderGroupSpans(girderKey.groupIndex, &startSpanIdx, &endSpanIdx);
   
   PierIndexType startPierIdx, endPierIdx;
   GetGirderGroupPiers(girderKey.groupIndex, &startPierIdx, &endPierIdx);

   // loop over all the casting regions
   const auto& vRegions = castDeckActivity.GetCastingRegions();
   IndexType nRegions = vRegions.size();
   for (IndexType regionIdx = 0; regionIdx < nRegions; regionIdx++)
   {
      const auto& region = vRegions[regionIdx];

      if ((region.m_Type == CCastingRegion::Span && (region.m_Index < startSpanIdx || endSpanIdx < region.m_Index)) ||
         (region.m_Type == CCastingRegion::Pier && (region.m_Index < startPierIdx || endPierIdx < region.m_Index)))
      {
         // region is not in this group... skip it and try next region
         continue;
      }

      // get the location of the region limits
      std::array<PierIndexType, 2> pierIdx; // pier the region is keyed to
      std::array<Float64, 2> Xb; // location of the region boundary in bridge coordinates
      IndexType sequenceIdx;
      CCastingRegion::RegionType type;
      GetDeckCastingRegionLimits(regionIdx, &pierIdx[pgsTypes::metStart], &Xb[pgsTypes::metStart], &pierIdx[pgsTypes::metEnd], &Xb[pgsTypes::metEnd], &type, &sequenceIdx, nullptr);

      std::array<PoiAttributeType, 2> attrib{ POI_CASTING_BOUNDARY_START, POI_CASTING_BOUNDARY_END};

      // search for left and right face boundary POI
      for (int i = 0; i < 2; i++)
      {
         pgsTypes::MemberEndType endType = (pgsTypes::MemberEndType)i;

         // get the reference line of the pier
         CComPtr<IPierLine> pierLine;
         GetPierLine(pierIdx[endType], &pierLine);

         // get the centerline of the pier, we'll call it the deck casting boundary line
         // however its location will get moved to position it at the actual boundary
         CComPtr<ILine2d> boundary_line;
         pierLine->get_Centerline(&boundary_line);

         CComPtr<IStation> objStation;
         pierLine->get_Station(&objStation);

         CComPtr<IPoint2d> alignment_point;
         if (IsZero(Xb[endType]))
         {
            // pier line is the boundary line
            pierLine->get_AlignmentPoint(&alignment_point);
         }
         else
         {
            // boundary line is offset from the pier line
            // get the location of the boundary line
            objStation->Offset(Xb[endType]);

            CComPtr<IAlignment> alignment;
            m_Bridge->get_Alignment(&alignment);

            alignment->LocatePoint(CComVariant(objStation), OffsetMeasureType::omtNormal, 0.0, CComVariant(0), &alignment_point);
         }

         // orient the boundary line
         CComPtr<IPoint2d> pnt;
         CComPtr<IVector2d> vDir;
         boundary_line->GetExplicit(&pnt, &vDir); // these parameters are for parallel pier

         if (castDeckActivity.GetDeckCastingRegionBoundary() == pgsTypes::dcrbNormalToAlignment)
         {
            // we want the boundary line to be normal to the alignment
            CComPtr<IAlignment> alignment;
            m_Bridge->get_Alignment(&alignment);

            CComPtr<IDirection> normal;
            alignment->GetNormal(CComVariant(objStation), &normal);

            Float64 value;
            normal->get_Value(&value);

            vDir->put_Direction(value);
         }

         // move and orient the boundary line
         boundary_line->SetExplicit(alignment_point, vDir);

         // for each segment in the girder line, see if the segment centerline
         // intesects the boundary line. If it does, we've found the boundary
         // poi location.
         SegmentIndexType nSegments = GetSegmentCount(girderKey);
         for (SegmentIndexType segIdx = 0; segIdx < nSegments; segIdx++)
         {
            CSegmentKey segmentKey(girderKey, segIdx);
            
            // get the centerline of the segment
            CComPtr<IGirderLine> segment_line;
            GetGirderLine(segmentKey, &segment_line);
            
            // model segment centerline as a line segment between the ends of the segment
            CComPtr<ILineSegment2d> seg_centerline;
            seg_centerline.CoCreateInstance(CLSID_LineSegment2d);
            
            CComPtr<IPoint2d> pntStart, pntEnd;
            if (segIdx == 0)
            {
               // use the point where the segment centerline projected
               // intersects its support line
               segment_line->get_PierPoint(etStart, &pntStart);
            }
            else
            {
               // segment, use the actual segment end
               segment_line->get_EndPoint(etStart, &pntStart);
            }

            if (segIdx == nSegments - 1)
            {
               segment_line->get_PierPoint(etEnd, &pntEnd);
            }
            else
            {
               segment_line->get_EndPoint(etEnd, &pntEnd);
            }
            seg_centerline->ThroughPoints(pntStart, pntEnd);

            // intersect the segment line with the boundary line
            CComPtr<IPoint2d> pntIntersect;
            geomUtil->IntersectLineWithLineSegment(boundary_line, seg_centerline, &pntIntersect);
            if (pntIntersect != nullptr)
            {
               // the intersection was found
               // make sure we have the real segment end point so Xpoi is in segment coordinates
               pntStart.Release();
               segment_line->get_EndPoint(etStart, &pntStart);

               // Compute distace from start to intersection point
               // distance is always a positive value since it is just a magnitude
               // Use the inverse method so we get the direction from start to intersectin point
               // as well
               CComQIPtr<IMeasure2> measure(m_CogoEngine);
               Float64 Xpoi;
               CComPtr<IDirection> dir;
               measure->Inverse(pntStart, pntIntersect, &Xpoi, &dir);

               // get the direction of the segment
               CComPtr<IDirection> seg_direction;
               GetSegmentDirection(segmentKey, &seg_direction);

               // if the directions are not equal, intersection point is before start so change
               // the sign of Xpoi
               if (seg_direction->IsEqual(dir) == S_FALSE)
               {
                  Xpoi *= -1;
               }

               // If this is the first segment, move deck casting boundary to the start of the segment
               if (girderKey.groupIndex == 0 && segIdx == 0 && Xpoi < 0)
               {
                  Xpoi = 0;
               }

               // If this is the last segment, move the deck casting boundary to the end of the segment
               Float64 Ls = GetSegmentLength(segmentKey);
               if (girderKey.groupIndex == nGroups-1 && segIdx == nSegments-1 && Ls < Xpoi)
               {
                  Xpoi = Ls;
               }

               // for deck casting regions that are exactly at segment ends, take out any noise in the numbers
               Xpoi = IsZero(Xpoi) ? 0.0 : Xpoi;
               Xpoi = IsEqual(Xpoi, Ls) ? Ls : Xpoi;

               pgsPointOfInterest poi(segmentKey, Xpoi, attrib[endType]);
               VERIFY(m_pPoiMgr->AddPointOfInterest(poi) != INVALID_ID);
               break; // we found the POI, so no need to continue search through the segments
            }
         } // next segment
      } // next end
   } // next region
}

void CBridgeAgentImp::LayoutPoiForSegmentBarCutoffs(const CSegmentKey& segmentKey,Float64 segmentOffset)
{
   CComPtr<IPrecastGirder> girder;
   GetGirder(segmentKey,&girder);

   Float64 segment_length = GetSegmentLength(segmentKey);
   Float64 left_brg_loc  = GetSegmentStartEndDistance(segmentKey);
   Float64 right_brg_loc = segment_length - GetSegmentEndEndDistance(segmentKey);

   // TRICKY: Move bearing locations slightly so bar cutoffs directly over supports get picked up and tagged correctly
   left_brg_loc  -= 1.0e-06;
   right_brg_loc += 1.0e-06;

   Float64 fc = GetSegmentFc28(segmentKey);
   pgsTypes::ConcreteType concType = GetSegmentConcreteType(segmentKey);
   bool hasFct = DoesSegmentConcreteHaveAggSplittingStrength(segmentKey);
   Float64 Fct = hasFct ? GetSegmentConcreteAggSplittingStrength(segmentKey) : 0.0;

   PoiAttributeType cut_attribute = POI_BARCUTOFF;
   PoiAttributeType dev_attribute = POI_BARDEVELOP;

   CComPtr<IRebarLayout> rebar_layout;
   girder->get_RebarLayout(&rebar_layout);

   CollectionIndexType nRebarLayoutItems;
   rebar_layout->get_Count(&nRebarLayoutItems);
   for (CollectionIndexType rebarLayoutItemIdx = 0; rebarLayoutItemIdx < nRebarLayoutItems; rebarLayoutItemIdx++)
   {
      CComPtr<IRebarLayoutItem> rebarLayoutItem;
      rebar_layout->get_Item(rebarLayoutItemIdx, &rebarLayoutItem);

      Float64 startLoc, barLength;
      rebarLayoutItem->get_Start(&startLoc);
      rebarLayoutItem->get_Length(&barLength);
      Float64 endLoc = startLoc + barLength;

      if ( segment_length <= startLoc )
      {
         // NOTE: if we decide to put dev length POI in closure joint, then
         // fc used to compute closure joint below needs to be re-examined... it is currently fc for the girder

         // bar starts after the end of the segment... bar is in the closure joint..
         // NO BAR CUTOFF OR DEVELOPMENT POI IN THE CLOSURE JOINT
         // ASSUMING CLOSURE JOINT BARS ARE FULLY DEVELOPED
         continue;
      }

      if (segment_length < endLoc)
      {
         ATLASSERT(false); // probably should never happen
         endLoc = segment_length;
      }

      // Add pois at cutoffs if they are within bearing locations
      if (left_brg_loc < startLoc && startLoc < right_brg_loc)
      {
         VERIFY(m_pPoiMgr->AddPointOfInterest(pgsPointOfInterest(segmentKey, startLoc, cut_attribute)) != INVALID_ID);
      }

      if (left_brg_loc < endLoc && endLoc < right_brg_loc)
      {
         VERIFY(m_pPoiMgr->AddPointOfInterest(pgsPointOfInterest(segmentKey, endLoc, cut_attribute)) != INVALID_ID);
      }

      // we only create one pattern per layout
      CollectionIndexType nRebarPatterns;
      rebarLayoutItem->get_Count(&nRebarPatterns);
      ATLASSERT(nRebarPatterns==1);
      if (0 < nRebarPatterns)
      {
         CComPtr<IRebarPattern> rebarPattern;
         rebarLayoutItem->get_Item(0, &rebarPattern);

         CComPtr<IRebar> rebar;
         rebarPattern->get_Rebar(&rebar);

         if (rebar)
         {
            // Get development length and add poi only if dev length is shorter than 1/2 rebar length
            REBARDEVLENGTHDETAILS devDetails = GetSegmentRebarDevelopmentLengthDetails(segmentKey, rebar, concType, fc, hasFct, Fct,false/*not top bar*/, false/*not epoxy coated*/, true/*meets cover requirements*/);
            Float64 ld = devDetails.ld;
            if (ld < barLength/2.0)
            {
               startLoc += ld;
               endLoc -= ld;

               if (left_brg_loc < startLoc && startLoc < right_brg_loc)
               {
                  VERIFY(m_pPoiMgr->AddPointOfInterest(pgsPointOfInterest(segmentKey, startLoc, dev_attribute)) != INVALID_ID);
               }

               if (left_brg_loc < endLoc && endLoc < right_brg_loc)
               {
                  VERIFY(m_pPoiMgr->AddPointOfInterest(pgsPointOfInterest(segmentKey, endLoc, dev_attribute)) != INVALID_ID);
               }
            }
         }
         else
         {
            ATLASSERT(false);
         }
      }
   }
}

void CBridgeAgentImp::LayoutPoiForHandling(const CSegmentKey& segmentKey)
{
   LayoutLiftingPoi(segmentKey,10); // puts poi at 10th points
   LayoutHaulingPoi(segmentKey,10);
}

void CBridgeAgentImp::LayoutPoiForSectionChanges(const CSegmentKey& segmentKey)
{
   const GirderLibraryEntry* pGirderEntry = GetGirderLibraryEntry(segmentKey);
   CComPtr<IBeamFactory> beamFactory;
   pGirderEntry->GetBeamFactory(&beamFactory);

   beamFactory->LayoutSectionChangePointsOfInterest(m_pBroker,segmentKey,m_pPoiMgr.get());
}

void CBridgeAgentImp::LayoutPoiForPiers(const CSegmentKey& segmentKey)
{
   // puts a POI at piers that are located between the ends of a segment
   GET_IFACE(IBridgeDescription,pIBridgeDesc);
   const CBridgeDescription2* pBridgeDesc = pIBridgeDesc->GetBridgeDescription();
   const CGirderGroupData*    pGroup      = pBridgeDesc->GetGirderGroup(segmentKey.groupIndex);
   const CSplicedGirderData*  pGirder     = pGroup->GetGirder(segmentKey.girderIndex);
   const CPrecastSegmentData* pSegment    = pGirder->GetSegment(segmentKey.segmentIndex);

   const CSpanData2* pStartSpan = pSegment->GetSpan(pgsTypes::metStart);
   const CSpanData2* pEndSpan   = pSegment->GetSpan(pgsTypes::metEnd);

   // collect all the piers that are between the ends of this segment
   std::vector<const CPierData2*> piers;
   const CPierData2* pPier = pStartSpan->GetNextPier();
   while ( pPier != pEndSpan->GetNextPier() )
   {
      piers.push_back(pPier);

      pPier = pPier->GetNextSpan()->GetNextPier();
   }

   if ( 0 < piers.size() )
   {
      std::vector<const CPierData2*>::iterator iter(piers.begin());
      std::vector<const CPierData2*>::iterator iterEnd(piers.end());
      for ( ; iter != iterEnd; iter++ )
      {
         const CPierData2* pPier = *iter;
         ATLASSERT(pPier->IsInteriorPier());

         PierIndexType pierIdx = pPier->GetIndex();

         Float64 Xpoi;
         VERIFY(GetPierLocation(pierIdx,segmentKey,&Xpoi));
         pgsPointOfInterest poi(segmentKey,Xpoi,POI_INTERMEDIATE_PIER);
         VERIFY(m_pPoiMgr->AddPointOfInterest(poi) != INVALID_ID);

         // POI at h and 1.5h from cl-brg (also at 2.5h for purposes of computing critical section)
         Float64 Hg = GetHeight(poi);

         // left side of pier
         Float64 location;
         CSegmentKey thisSegmentKey(segmentKey);
         location = Xpoi - Hg;
         if ( location < 0 )
         {
            // poi falls in previous segment
            ATLASSERT(thisSegmentKey.segmentIndex != 0);
            thisSegmentKey.segmentIndex--;
            Float64 Ls  = GetSegmentLength(thisSegmentKey);
            Float64 BOl = GetSegmentEndBearingOffset(thisSegmentKey);
            Float64 EDl = GetSegmentEndEndDistance(thisSegmentKey);
            Float64 BOr = GetSegmentStartBearingOffset(segmentKey);
            Float64 EDr = GetSegmentStartEndDistance(segmentKey);
            location = Ls + (BOl - EDl) + (BOr - EDr) + location;
         }
         pgsPointOfInterest left_H(thisSegmentKey,location,POI_H);
         VERIFY(m_pPoiMgr->AddPointOfInterest(left_H) != INVALID_ID);

         thisSegmentKey = segmentKey;
         location = Xpoi - 1.5*Hg;
         if ( location < 0 )
         {
            // poi falls in previous segment
            ATLASSERT(thisSegmentKey.segmentIndex != 0);
            thisSegmentKey.segmentIndex--;
            Float64 Ls  = GetSegmentLength(thisSegmentKey);
            Float64 BOl = GetSegmentEndBearingOffset(thisSegmentKey);
            Float64 EDl = GetSegmentEndEndDistance(thisSegmentKey);
            Float64 BOr = GetSegmentStartBearingOffset(segmentKey);
            Float64 EDr = GetSegmentStartEndDistance(segmentKey);
            location = Ls + (BOl - EDl) + (BOr - EDr) + location;
         }
         pgsPointOfInterest left_15H(thisSegmentKey,location,POI_15H);
         VERIFY(m_pPoiMgr->AddPointOfInterest(left_15H) != INVALID_ID);

         thisSegmentKey = segmentKey;
         location = Xpoi - 2.5*Hg;
         if ( location < 0 )
         {
            // poi falls in previous segment
            ATLASSERT(thisSegmentKey.segmentIndex != 0);
            thisSegmentKey.segmentIndex--;
            Float64 Ls  = GetSegmentLength(thisSegmentKey);
            Float64 BOl = GetSegmentEndBearingOffset(thisSegmentKey);
            Float64 EDl = GetSegmentEndEndDistance(thisSegmentKey);
            Float64 BOr = GetSegmentStartBearingOffset(segmentKey);
            Float64 EDr = GetSegmentStartEndDistance(segmentKey);
            location = Ls + (BOl - EDl) + (BOr - EDr) + location;
         }
         pgsPointOfInterest left_25H(thisSegmentKey,location);
         VERIFY(m_pPoiMgr->AddPointOfInterest(left_25H) != INVALID_ID);

         // right side of pier
         Float64 segment_length = GetSegmentLength(segmentKey);
         thisSegmentKey = segmentKey;
         location = Xpoi + Hg;
         if ( segment_length < location )
         {
            // poi falls in next segment
            thisSegmentKey.segmentIndex++;
            Float64 BOl = GetSegmentEndBearingOffset(segmentKey);
            Float64 EDl = GetSegmentEndEndDistance(segmentKey);
            Float64 BOr = GetSegmentStartBearingOffset(thisSegmentKey);
            Float64 EDr = GetSegmentStartEndDistance(thisSegmentKey);
            Float64 dist_between_segments = (BOl - EDl) + (BOr - EDr);
            location = location - segment_length - dist_between_segments;
         }
         pgsPointOfInterest right_H(thisSegmentKey,location,POI_H);
         VERIFY(m_pPoiMgr->AddPointOfInterest(right_H) != INVALID_ID);

         thisSegmentKey = segmentKey;
         location = Xpoi + 1.5*Hg;
         if ( segment_length < location )
         {
            // poi falls in next segment
            thisSegmentKey.segmentIndex++;
            Float64 BOl = GetSegmentEndBearingOffset(segmentKey);
            Float64 EDl = GetSegmentEndEndDistance(segmentKey);
            Float64 BOr = GetSegmentStartBearingOffset(thisSegmentKey);
            Float64 EDr = GetSegmentStartEndDistance(thisSegmentKey);
            Float64 dist_between_segments = (BOl - EDl) + (BOr - EDr);
            location = location - segment_length - dist_between_segments;
         }
         pgsPointOfInterest right_15H(thisSegmentKey,location,POI_15H);
         VERIFY(m_pPoiMgr->AddPointOfInterest(right_15H) != INVALID_ID);

         thisSegmentKey = segmentKey;
         location = Xpoi + 2.5*Hg;
         if ( segment_length < location )
         {
            // poi falls in next segment
            thisSegmentKey.segmentIndex++;
            Float64 BOl = GetSegmentEndBearingOffset(segmentKey);
            Float64 EDl = GetSegmentEndEndDistance(segmentKey);
            Float64 BOr = GetSegmentStartBearingOffset(thisSegmentKey);
            Float64 EDr = GetSegmentStartEndDistance(thisSegmentKey);
            Float64 dist_between_segments = (BOl - EDl) + (BOr - EDr);
            location = location - segment_length - dist_between_segments;
         }
         pgsPointOfInterest right_25H(thisSegmentKey,location);
         VERIFY(m_pPoiMgr->AddPointOfInterest(right_25H) != INVALID_ID);

         // Add POIs for face of support
         Float64 left_support_width, right_support_width, diaphragm_height;
         GetPierDiaphragmSize(pierIdx, pgsTypes::Back, &left_support_width, &diaphragm_height);
         GetPierDiaphragmSize(pierIdx, pgsTypes::Ahead, &right_support_width, &diaphragm_height);

         // if the diaphragm has zero width, the left and right side FOS are at the same location
         // and merge into a single POI. However, it is assumed throughout the code that the
         // diaphragm has a width so there is a left and right FOS POI. To make this assumption true,
         // we provide a small offset for zero width diaphragms so there will be left and right
         // FOS POIs
         Float64 offset = (IsZero(left_support_width) && IsZero(right_support_width) ? 0.001 : 0);

         pgsPointOfInterest leftFOS(segmentKey, Xpoi - left_support_width - offset, POI_FACEOFSUPPORT);
         VERIFY(m_pPoiMgr->AddPointOfInterest(leftFOS) != INVALID_ID);

         pgsPointOfInterest rightFOS(segmentKey, Xpoi + right_support_width + offset, POI_FACEOFSUPPORT);
         VERIFY(m_pPoiMgr->AddPointOfInterest(rightFOS) != INVALID_ID);
      } // next pier
   }

   // add POI at centerline of pier between groups
   if ( pSegment->GetClosureJoint(pgsTypes::metEnd) == nullptr )
   {
      const CPierData2* pPier;
      const CTemporarySupportData* pTS;
      pSegment->GetSupport(pgsTypes::metEnd,&pPier,&pTS);
      ATLASSERT(pPier != nullptr);
      ATLASSERT(pTS == nullptr);

      if ( pPier->GetNextSpan() )
      {
         Float64 Xs; // pier is in segment coordinates
         GetPierLocation(pPier->GetIndex(),segmentKey,&Xs);
         pgsPointOfInterest poi(segmentKey,Xs,POI_BOUNDARY_PIER);
         VERIFY(m_pPoiMgr->AddPointOfInterest(poi) != INVALID_ID);
      }
   }
}

void CBridgeAgentImp::LayoutPoiForTemporarySupports(const CSegmentKey& segmentKey)
{
   // puts a POI at temporary supports that are located between the ends of a segment
   GET_IFACE(IBridgeDescription,pIBridgeDesc);
   const CBridgeDescription2* pBridgeDesc = pIBridgeDesc->GetBridgeDescription();
   const CGirderGroupData*    pGroup      = pBridgeDesc->GetGirderGroup(segmentKey.groupIndex);
   const CSplicedGirderData*  pGirder     = pGroup->GetGirder(segmentKey.girderIndex);
   const CPrecastSegmentData* pSegment    = pGirder->GetSegment(segmentKey.segmentIndex);

   const CSpanData2* pStartSpan = pSegment->GetSpan(pgsTypes::metStart);
   const CSpanData2* pEndSpan   = pSegment->GetSpan(pgsTypes::metEnd);

   std::vector<const CTemporarySupportData*> tempSupports(pStartSpan->GetTemporarySupports());
   std::vector<const CTemporarySupportData*> endTempSupports(pEndSpan->GetTemporarySupports());
   tempSupports.insert(tempSupports.begin(),endTempSupports.begin(),endTempSupports.end());

   if ( tempSupports.size() == 0 )
   {
      return; // no temporary supports
   }

   Float64 segment_start_station, segment_end_station;
   pSegment->GetStations(&segment_start_station,&segment_end_station);
   std::vector<const CTemporarySupportData*>::iterator iter(tempSupports.begin());
   std::vector<const CTemporarySupportData*>::iterator iterEnd(tempSupports.end());
   for ( ; iter != iterEnd; iter++ )
   {
      const CTemporarySupportData* pTS = *iter;
      Float64 ts_station = pTS->GetStation();
      if ( ::IsEqual(segment_start_station,ts_station) || ::IsEqual(segment_end_station,ts_station) )
      {
         continue; // temporary support is at end of segment... we are creating POIs for intermediate temporary supports
      }

      if ( ::InRange(segment_start_station,ts_station,segment_end_station) )
      {
         Float64 Xpoi;
         VERIFY(GetTemporarySupportLocation(pTS->GetIndex(),segmentKey,&Xpoi));
         pgsPointOfInterest poi(segmentKey,Xpoi,POI_INTERMEDIATE_TEMPSUPPORT);

         VERIFY(m_pPoiMgr->AddPointOfInterest(poi) != INVALID_ID);
      }
   } // next temporary support
}

void CBridgeAgentImp::LayoutPoiForTendons(const CGirderKey& girderKey)
{
   CComPtr<ISuperstructureMember> ssMbr;
   GetSuperstructureMember(girderKey, &ssMbr);

   CComQIPtr<IItemData> itemData(ssMbr);

   CComPtr<IUnknown> unk;
   itemData->GetItemData(CComBSTR(_T("Tendons")), &unk);
   if (unk)
   {
      CComQIPtr<ITendonCollection> tendons(unk);

      IndexType nDucts;
      tendons->get_Count(&nDucts);

      for (DuctIndexType ductIdx = 0; ductIdx < nDucts; ductIdx++)
      {
         CComPtr<ITendon> tendon;
         tendons->get_Item(ductIdx, &tendon);

         // start and end of tendon in girder coordinates
         CComPtr<IPoint3d> pntStart, pntEnd;
         tendon->get_Start(&pntStart);
         tendon->get_End(&pntEnd);
         Float64 Xgs, Xge;
         pntStart->get_Z(&Xgs);
         pntEnd->get_Z(&Xge);

         pgsPointOfInterest startPoi = ConvertGirderCoordinateToPoi(girderKey, Xgs);
         startPoi.SetID(INVALID_ID);
         startPoi.SetReferencedAttributes(0);
         startPoi.SetNonReferencedAttributes(POI_DUCT_START);
         PoiIDType startPoiID = m_pPoiMgr->AddPointOfInterest(startPoi);
         ATLASSERT(startPoiID != INVALID_ID);

         pgsPointOfInterest endPoi = ConvertGirderCoordinateToPoi(girderKey, Xge);
         endPoi.SetID(INVALID_ID);
         endPoi.SetReferencedAttributes(0);
         endPoi.SetNonReferencedAttributes(POI_DUCT_END);
         PoiIDType endPoiID = m_pPoiMgr->AddPointOfInterest(endPoi);
         ATLASSERT(endPoiID != INVALID_ID);

         m_pPoiMgr->AddDuctBoundary(girderKey, ductIdx, startPoiID, endPoiID);
      }
   }
}

//-----------------------------------------------------------------------------
void CBridgeAgentImp::LayoutLiftingPoi(const CSegmentKey& segmentKey,Uint16 nPnts)
{
   // lifting
   LayoutHandlingPoi(GetLiftSegmentInterval(segmentKey),segmentKey,
                     nPnts, 
                     0,
                     m_pPoiMgr.get()); 
                     
}

//-----------------------------------------------------------------------------
void CBridgeAgentImp::LayoutHaulingPoi(const CSegmentKey& segmentKey,Uint16 nPnts)
{
   // hauling
   LayoutHandlingPoi(GetHaulSegmentInterval(segmentKey),segmentKey,
                     nPnts, 
                     0,
                     m_pPoiMgr.get());
}

//-----------------------------------------------------------------------------
void CBridgeAgentImp::LayoutHandlingPoi(IntervalIndexType intervalIdx,const CSegmentKey& segmentKey,
                                        Uint16 nPnts, 
                                        PoiAttributeType attrib,
                                        pgsPoiMgr* pPoiMgr) const
{
   ATLASSERT(intervalIdx == GetLiftSegmentInterval(segmentKey) || intervalIdx == GetHaulSegmentInterval(segmentKey));
   PoiAttributeType supportAttribute, poiReference;
   Float64 leftOverhang, rightOverhang;
   if (intervalIdx == GetLiftSegmentInterval(segmentKey))
   {
      GET_IFACE(ISegmentLifting, pSegmentLifting);
      leftOverhang  = pSegmentLifting->GetLeftLiftingLoopLocation(segmentKey);
      rightOverhang = pSegmentLifting->GetRightLiftingLoopLocation(segmentKey);

      supportAttribute = POI_PICKPOINT;
      poiReference = POI_LIFT_SEGMENT;
   }
   else if (intervalIdx == GetHaulSegmentInterval(segmentKey))
   {
      GET_IFACE(ISegmentHauling, pSegmentHauling);
      leftOverhang  = pSegmentHauling->GetTrailingOverhang(segmentKey);
      rightOverhang = pSegmentHauling->GetLeadingOverhang(segmentKey);

      supportAttribute = POI_BUNKPOINT;
      poiReference = POI_HAUL_SEGMENT;
   }
   else
   {
      ATLASSERT(false); // you sent in the wrong interval index
   }

   LayoutHandlingPoi(segmentKey,nPnts,leftOverhang,rightOverhang,attrib,supportAttribute,poiReference,pPoiMgr);


#if defined _DEBUG
   // make sure there are two support POI
   PoiList vPoi;
   pPoiMgr->GetPointsOfInterest(segmentKey,poiReference | supportAttribute,POIMGR_AND,&vPoi);
   ATLASSERT(vPoi.size() == 2);
#endif
}

//-----------------------------------------------------------------------------
void CBridgeAgentImp::LayoutHandlingPoi(const CSegmentKey& segmentKey,
                                        Uint16 nPnts, 
                                        Float64 leftOverhang, 
                                        Float64 rightOverhang, 
                                        PoiAttributeType attrib, 
                                        PoiAttributeType supportAttribute,
                                        PoiAttributeType poiReference,
                                        pgsPoiMgr* pPoiMgr) const
{
   Float64 segment_length = GetSegmentLength(segmentKey);
   Float64 span_length = segment_length - leftOverhang - rightOverhang;
   ATLASSERT(0.0 < span_length); // should be checked in input

   // add poi at support locations
   VERIFY(pPoiMgr->AddPointOfInterest(pgsPointOfInterest(segmentKey, leftOverhang, attrib | poiReference | supportAttribute)) != INVALID_ID);
   VERIFY(pPoiMgr->AddPointOfInterest(pgsPointOfInterest(segmentKey, segment_length - rightOverhang, attrib | poiReference | supportAttribute)) != INVALID_ID);

   GET_IFACE(ISegmentLiftingSpecCriteria, pLiftingCriteria);
   if ( !IsEqual(pLiftingCriteria->GetLiftingCableMinInclination(),PI_OVER_2) && poiReference == POI_LIFT_SEGMENT )
   { 
      // when lifting with inclined cables, add poi's just outboard of the lift points to capture the jump in the
      // horizontal cable force moment diagram
      Float64 offset = WBFL::Units::ConvertToSysUnits(0.01, WBFL::Units::Measure::Feet);
      if (!IsZero(leftOverhang))
      {
         pgsPointOfInterest leftPoi(segmentKey, leftOverhang - offset);
         VERIFY(pPoiMgr->AddPointOfInterest(leftPoi) != INVALID_ID);
      }

      if (!IsZero(rightOverhang))
      {
         pgsPointOfInterest rightPoi(segmentKey, segment_length - rightOverhang + offset);
         VERIFY(pPoiMgr->AddPointOfInterest(rightPoi) != INVALID_ID);
      }
   }

   // add poi at ends of girder
   VERIFY(pPoiMgr->AddPointOfInterest(pgsPointOfInterest(segmentKey, 0, attrib)) != INVALID_ID);
   VERIFY(pPoiMgr->AddPointOfInterest(pgsPointOfInterest(segmentKey, segment_length, attrib)) != INVALID_ID);

   // n-th point POI between overhang support points
   const Float64 toler = +1.0e-6;
   for ( Uint16 i = 0; i < nPnts+1; i++ )
   {
      Float64 dist = leftOverhang + span_length * ((Float64)i / (Float64)nPnts);

      PoiAttributeType attribute = attrib;

      // Add a special attribute flag if poi is at a tenth point
      Uint16 tenthPoint = 0;
      Float64 val = Float64(i)/Float64(nPnts)+toler;
      Float64 modv = fmod(val, 0.1);
      if (IsZero(modv,2*toler) || modv==0.1)
      {
         tenthPoint = Uint16(10.*Float64(i)/Float64(nPnts) + 1);
      }
      
      pgsPointOfInterest poi(segmentKey,dist,attribute);
      poi.MakeTenthPoint(poiReference,tenthPoint);
      VERIFY(pPoiMgr->AddPointOfInterest(poi) != INVALID_ID);
   }

}

/////////////////////////////////////////////////////////////////////////
// IAgent
//
STDMETHODIMP CBridgeAgentImp::SetBroker(IBroker* pBroker)
{
   EAF_AGENT_SET_BROKER(pBroker);
   return S_OK;
}

STDMETHODIMP CBridgeAgentImp::RegInterfaces()
{
   CComQIPtr<IBrokerInitEx2,&IID_IBrokerInitEx2> pBrokerInit(m_pBroker);
   pBrokerInit->RegInterface( IID_IRoadway,                       this );
   pBrokerInit->RegInterface( IID_IGeometry,                      this );
   pBrokerInit->RegInterface( IID_IBridge,                        this );
   pBrokerInit->RegInterface( IID_IMaterials,                     this );
   pBrokerInit->RegInterface( IID_IStrandGeometry,                this );
   pBrokerInit->RegInterface( IID_ILongRebarGeometry,             this );
   pBrokerInit->RegInterface( IID_IStirrupGeometry,               this );
   pBrokerInit->RegInterface( IID_IPointOfInterest,               this );
   pBrokerInit->RegInterface( IID_ISectionProperties,             this );
   pBrokerInit->RegInterface( IID_IShapes,                        this );
   pBrokerInit->RegInterface( IID_IBarriers,                      this );
   pBrokerInit->RegInterface( IID_ISegmentLiftingPointsOfInterest, this );
   pBrokerInit->RegInterface( IID_ISegmentHaulingPointsOfInterest, this );
   pBrokerInit->RegInterface( IID_IUserDefinedLoads,              this );
   pBrokerInit->RegInterface( IID_ITempSupport,                   this );
   pBrokerInit->RegInterface( IID_IGirder,                        this );
   pBrokerInit->RegInterface(IID_IGirderTendonGeometry,           this);
   pBrokerInit->RegInterface(IID_ISegmentTendonGeometry,          this );
   pBrokerInit->RegInterface( IID_IIntervals,                     this );

   return S_OK;
}

STDMETHODIMP CBridgeAgentImp::Init()
{
   CREATE_LOGFILE("BridgeAgent");
   EAF_AGENT_INIT; // this macro defines pStatusCenter
   m_LoadStatusGroupID = pStatusCenter->CreateStatusGroupID();

   // Register status callbacks that we want to use
   m_scidInformationalError       = pStatusCenter->RegisterCallback(new pgsInformationalStatusCallback(eafTypes::statusError)); 
   m_scidInformationalWarning     = pStatusCenter->RegisterCallback(new pgsInformationalStatusCallback(eafTypes::statusWarning)); 
   m_scidBridgeDescriptionError   = pStatusCenter->RegisterCallback(new pgsBridgeDescriptionStatusCallback(m_pBroker,eafTypes::statusError));
   m_scidBridgeDescriptionWarning = pStatusCenter->RegisterCallback(new pgsBridgeDescriptionStatusCallback(m_pBroker,eafTypes::statusWarning));
   m_scidAlignmentWarning         = pStatusCenter->RegisterCallback(new pgsAlignmentDescriptionStatusCallback(m_pBroker,eafTypes::statusWarning));
   m_scidAlignmentError           = pStatusCenter->RegisterCallback(new pgsAlignmentDescriptionStatusCallback(m_pBroker,eafTypes::statusError));
   m_scidGirderDescriptionWarning = pStatusCenter->RegisterCallback(new pgsGirderDescriptionStatusCallback(m_pBroker,eafTypes::statusWarning));
   m_scidGirderDescriptionInform  = pStatusCenter->RegisterCallback(new pgsGirderDescriptionStatusCallback(m_pBroker,eafTypes::statusInformation));
   m_scidGirderDescriptionError   = pStatusCenter->RegisterCallback(new pgsGirderDescriptionStatusCallback(m_pBroker,eafTypes::statusError));
   m_scidPointLoadWarning         = pStatusCenter->RegisterCallback(new pgsPointLoadStatusCallback(m_pBroker,eafTypes::statusInformation));
   m_scidDistributedLoadWarning   = pStatusCenter->RegisterCallback(new pgsDistributedLoadStatusCallback(m_pBroker,eafTypes::statusInformation));
   m_scidMomentLoadWarning        = pStatusCenter->RegisterCallback(new pgsMomentLoadStatusCallback(m_pBroker,eafTypes::statusInformation));
   m_scidZeroOverlayWarning       = pStatusCenter->RegisterCallback(new pgsInformationalStatusCallback(eafTypes::statusInformation));
   m_scidConnectionGeometryWarning = pStatusCenter->RegisterCallback(new pgsConnectionGeometryStatusCallback(m_pBroker,eafTypes::statusWarning));

   m_IntervalManager.Init(m_pBroker, m_StatusGroupID);

   return AGENT_S_SECONDPASSINIT;
}

STDMETHODIMP CBridgeAgentImp::Init2()
{
   // Attach to connection points
   CComQIPtr<IBrokerInitEx2,&IID_IBrokerInitEx2> pBrokerInit(m_pBroker);
   CComPtr<IConnectionPoint> pCP;
   HRESULT hr = S_OK;

   // Connection point for the bridge description
   hr = pBrokerInit->FindConnectionPoint( IID_IBridgeDescriptionEventSink, &pCP );
   ATLASSERT( SUCCEEDED(hr) );
   hr = pCP->Advise( GetUnknown(), &m_dwBridgeDescCookie );
   ATLASSERT( SUCCEEDED(hr) );
   pCP.Release(); // Recycle the IConnectionPoint smart pointer so we can use it again.

   // Connection point for the specifications
   hr = pBrokerInit->FindConnectionPoint( IID_ISpecificationEventSink, &pCP );
   ATLASSERT( SUCCEEDED(hr) );
   hr = pCP->Advise( GetUnknown(), &m_dwSpecificationCookie );
   ATLASSERT( SUCCEEDED(hr) );
   pCP.Release(); // Recycle the IConnectionPoint smart pointer so we can use it again.

   // Connection point for the specifications
   hr = pBrokerInit->FindConnectionPoint( IID_ILossParametersEventSink, &pCP );
   ATLASSERT( SUCCEEDED(hr) );
   hr = pCP->Advise( GetUnknown(), &m_dwLossParametersCookie );
   ATLASSERT( SUCCEEDED(hr) );
   pCP.Release(); // Recycle the IConnectionPoint smart pointer so we can use it again.

   hr = m_SectCutTool.CoCreateInstance(CLSID_SectionCutTool);
   if ( FAILED(hr) || m_SectCutTool == nullptr )
   {
      THROW_UNWIND(_T("GenericBridgeTools::SectionPropertyTool not created"),-1);
   }


   m_ConcreteManager.Init(m_pBroker,m_StatusGroupID);

   return S_OK;
}

STDMETHODIMP CBridgeAgentImp::GetClassID(CLSID* pCLSID)
{
   *pCLSID = CLSID_BridgeAgent;
   return S_OK;
}

STDMETHODIMP CBridgeAgentImp::Reset()
{
   Invalidate( CLEAR_ALL );
   m_SectCutTool.Release();

   return S_OK;
}

STDMETHODIMP CBridgeAgentImp::ShutDown()
{
   //
   // Detach to connection points
   //
   CComQIPtr<IBrokerInitEx2,&IID_IBrokerInitEx2> pBrokerInit(m_pBroker);
   CComPtr<IConnectionPoint> pCP;
   HRESULT hr = S_OK;

   hr = pBrokerInit->FindConnectionPoint(IID_IBridgeDescriptionEventSink, &pCP );
   ATLASSERT( SUCCEEDED(hr) );
   hr = pCP->Unadvise( m_dwBridgeDescCookie );
   ATLASSERT( SUCCEEDED(hr) );
   pCP.Release(); // Recycle the connection point

   hr = pBrokerInit->FindConnectionPoint(IID_ISpecificationEventSink, &pCP );
   ATLASSERT( SUCCEEDED(hr) );
   hr = pCP->Unadvise( m_dwSpecificationCookie );
   ATLASSERT( SUCCEEDED(hr) );
   pCP.Release(); // Recycle the connection point

   hr = pBrokerInit->FindConnectionPoint(IID_ILossParametersEventSink, &pCP );
   ATLASSERT( SUCCEEDED(hr) );
   hr = pCP->Unadvise( m_dwLossParametersCookie );
   ATLASSERT( SUCCEEDED(hr) );
   pCP.Release(); // Recycle the connection point

   EAF_AGENT_CLEAR_INTERFACE_CACHE;
   CLOSE_LOGFILE;

   return S_OK;
}

/////////////////////////////////////////////////////////////////////////
// IRoadway
//
void CBridgeAgentImp::GetStartPoint(Float64 n,Float64* pStartStation,Float64* pStartElevation,Float64* pGrade,IPoint2d** ppPoint) const
{
   Float64 pierStation = GetPierStation(0);
   Float64 spanLength = GetSpanLength(0);
   *pStartStation = pierStation - spanLength/n;

   CComPtr<IAlignment> alignment;
   GetAlignment(&alignment);

   IndexType nHCurves = GetCurveCount();
   if ( 0 < nHCurves )
   {
      CComPtr<ICompoundCurve> hc;
      GetCurve(0,&hc);
      CComPtr<IPoint2d> pntTS;
      hc->get_TS(&pntTS);

      Float64 tsStation, offset;
      GetStationAndOffset(pgsTypes::pcLocal,pntTS,&tsStation,&offset);
      *pStartStation = Min(*pStartStation,tsStation);
   }

   CComPtr<IProfile> profile;
   alignment->GetProfile(CBridgeGeometryModelBuilder::ProfileID,&profile);
   IndexType nElements;
   profile->get_ProfileElementCount(&nElements);
   if (0 < nElements)
   {
      CComPtr<IProfileElement> profileElement;
      profile->get_Item(0, &profileElement);
      CComPtr<IProfilePoint> startPoint;
      profileElement->GetStartPoint(&startPoint);
      CComPtr<IStation> objStation;
      startPoint->get_Station(&objStation);
      Float64 station;
      alignment->ConvertToNormalizedStation(CComVariant(objStation), &station);
      *pStartStation = Min(*pStartStation, station);
   }

   CComPtr<ISurface> surface;
   profile->GetSurface(CBridgeGeometryModelBuilder::SurfaceID, &surface);
   CComPtr<IStation> objStartStation, objEndStation;
   surface->GetStationRange(&objStartStation, &objEndStation);
   Float64 station;
   alignment->ConvertToNormalizedStation(CComVariant(objStartStation), &station);
   if (station < (pierStation - spanLength / n) && IsZero(station))
   {
      // often, the roadway surface is defined by a single point at station 0+00
      // if there is only one surface definition and it starts before the bridge
      // and it is at 0+00, skip it so we don't end up with a really long alignment
      // and a really short bridge... the graphics come out bad
   }
   else
   {
      *pStartStation = Min(*pStartStation, station);
   }

   GET_IFACE(IRoadwayData, pIAlignment);
   const AlignmentData2& alignment_data = pIAlignment->GetAlignmentData2();

   Float64 refStation = alignment_data.RefStation;
   CComPtr<IPoint2d> refPoint;
   alignment->LocatePoint(CComVariant(refStation),omtNormal,0.0,CComVariant(0),&refPoint);
   Float64 x,y;
   refPoint->Location(&x,&y); // this is in local coordinates, we want it in global coordinates
   x += m_DeltaX;
   y += m_DeltaY;
   if ( !IsZero(refStation) || !IsZero(x) || !IsZero(y) )
   {
      // we'll ignore the ref point at 0+00 (N 0, E 0)
      // this is the default and it probably means the user didn't input the values
      *pStartStation = Min(*pStartStation,refStation);
   }

   GetPoint(*pStartStation,0,nullptr,pgsTypes::pcGlobal,ppPoint);
   *pStartElevation = GetElevation(*pStartStation,0);
   *pGrade = GetProfileGrade(*pStartStation);
}

void CBridgeAgentImp::GetEndPoint(Float64 n,Float64* pEndStation,Float64* pEndElevation,Float64* pGrade,IPoint2d** ppPoint) const
{
   PierIndexType nPiers = GetPierCount();
   SpanIndexType nSpans = GetSpanCount();
   Float64 pierStation = GetPierStation(nPiers-1);
   Float64 spanLength = GetSpanLength(nSpans-1);
   *pEndStation = pierStation + spanLength/n;

   CComPtr<IAlignment> alignment;
   GetAlignment(&alignment);

   IndexType nHCurves = GetCurveCount();
   if ( 0 < nHCurves )
   {
      CComPtr<ICompoundCurve> hc;
      GetCurve(nHCurves-1,&hc);
      CComPtr<IPoint2d> pntST;
      hc->get_ST(&pntST);

      Float64 stStation, offset;
      GetStationAndOffset(pgsTypes::pcLocal,pntST,&stStation,&offset);
      *pEndStation = Max(*pEndStation,stStation);
   }

   CComPtr<IProfile> profile;
   alignment->GetProfile(CBridgeGeometryModelBuilder::ProfileID, &profile);
   IndexType nElements;
   profile->get_ProfileElementCount(&nElements);
   if ( 0 < nElements )
   {
      CComPtr<IProfileElement> profileElement;
      profile->get_Item(nElements-1, &profileElement);
      CComPtr<IProfilePoint> endPoint;
      profileElement->GetEndPoint(&endPoint);
      CComPtr<IStation> objStation;
      endPoint->get_Station(&objStation);
      Float64 station;
      alignment->ConvertToNormalizedStation(CComVariant(objStation), &station);
      *pEndStation = Max(*pEndStation,station);
   }

   CComPtr<ISurface> surface;
   profile->GetSurface(CBridgeGeometryModelBuilder::SurfaceID, &surface);
   CComPtr<IStation> objStartStation, objEndStation;
   surface->GetStationRange(&objStartStation, &objEndStation);
   Float64 station;
   alignment->ConvertToNormalizedStation(CComVariant(objEndStation), &station);
   *pEndStation = Max(*pEndStation,station);

   GetPoint(*pEndStation,0,nullptr,pgsTypes::pcGlobal,ppPoint);
   *pEndElevation = GetElevation(*pEndStation,0);
   *pGrade = GetProfileGrade(*pEndStation);
}

Float64 CBridgeAgentImp::GetSlope(Float64 station,Float64 offset) const
{
   VALIDATE( COGO_MODEL );

   CComPtr<IProfile> profile;
   GetProfile(&profile);

   Float64 slope;
   profile->CrossSlope(CBridgeGeometryModelBuilder::SurfaceID,CComVariant(station),offset,&slope);

   return slope;
}

Float64 CBridgeAgentImp::GetProfileGrade(Float64 station) const
{
   VALIDATE( COGO_MODEL );

   CComPtr<IProfile> profile;
   GetProfile(&profile);

   Float64 grade;
   profile->Grade(CComVariant(station),&grade);
   return grade;
}

Float64 CBridgeAgentImp::GetElevation(Float64 station,Float64 offset) const
{
   VALIDATE( COGO_MODEL );

   CComPtr<IProfile> profile;
   GetProfile(&profile);

   Float64 elev;
   profile->Elevation(CBridgeGeometryModelBuilder::SurfaceID, CComVariant(station), offset,&elev);
   return elev;
}

void CBridgeAgentImp::GetBearing(Float64 station,IDirection** ppBearing) const
{
   VALIDATE( COGO_MODEL );

   CComPtr<IAlignment> alignment;
   GetAlignment(&alignment);

   alignment->GetBearing(CComVariant(station),ppBearing);
}

void CBridgeAgentImp::GetBearingNormal(Float64 station,IDirection** ppNormal) const
{
   VALIDATE( COGO_MODEL );

   CComPtr<IAlignment> alignment;
   GetAlignment(&alignment);

   alignment->GetNormal(CComVariant(station),ppNormal);
}

CollectionIndexType CBridgeAgentImp::GetCurveCount() const
{
   VALIDATE( COGO_MODEL );

   IndexType nCurves;
   m_CogoModel->GetCompoundCurveCountByID(CBridgeGeometryModelBuilder::AlignmentID, &nCurves);
   return nCurves;
}

void CBridgeAgentImp::GetCurve(CollectionIndexType idx, ICompoundCurve** ppCurve) const
{
   // this is a private method, not accessible through the IAlignment interface
   VALIDATE(BRIDGE);
   CComPtr<IAlignment> alignment;
   m_Bridge->get_Alignment(&alignment);

   auto found = m_CompoundCurveKeys.find(idx);
   ATLASSERT(found != std::end(m_CompoundCurveKeys));

   CComPtr<IPathElement> element;
   alignment->get_Item(found->first, &element);
   VERIFY(element.QueryInterface(ppCurve) == S_OK);
}

void CBridgeAgentImp::GetCurve(CollectionIndexType idx, pgsTypes::PlanCoordinateType pcType,ICompoundCurve** ppCurve) const
{
   CComPtr<ICompoundCurve> curve;
   GetCurve(idx, &curve);

   // It is very important to make a copy of the curve here. The curve can be manipulated outside of this method
   // which will change the original alignment. Return a copy so the copy gets changed, not the original.
   CComQIPtr<IPathElement> element(curve);
   CComPtr<IPathElement> clone;
   element->Clone(&clone);
   clone.QueryInterface(ppCurve);
   if (pcType == pgsTypes::pcGlobal)
   {
      element.Release();
      (*ppCurve)->QueryInterface(&element);
      element->Offset(m_DeltaX, m_DeltaY);
   }
}

HCURVESTATIONS CBridgeAgentImp::GetCurveStations(IndexType hcIdx) const
{
   HCURVESTATIONS stations;

   CComPtr<ICompoundCurve> hc;
   GetCurve(hcIdx, &hc);
   ATLASSERT(hc != nullptr);

   auto found = m_CompoundCurveKeys.find(hcIdx);
   ATLASSERT(found != std::end(m_CompoundCurveKeys));

   IndexType inputHcIdx = found->second.first;
   GET_IFACE(IRoadwayData, pAlignment);
   const AlignmentData2& alignment = pAlignment->GetAlignmentData2();
   const CompoundCurveData& hc_data = alignment.CompoundCurves[inputHcIdx];

   ATLASSERT(!IsZero(hc_data.Radius));

   Float64 bk_tangent_length;
   hc->get_BkTangentLength(&bk_tangent_length);

   Float64 total_length;
   hc->get_TotalLength(&total_length);

   stations.TSStation = hc_data.PIStation - bk_tangent_length;
   stations.SCStation = hc_data.PIStation - bk_tangent_length + hc_data.EntrySpiral;
   stations.PIStation = hc_data.PIStation;
   stations.CSStation = hc_data.PIStation - bk_tangent_length + total_length - hc_data.ExitSpiral;
   stations.STStation = hc_data.PIStation - bk_tangent_length + total_length;

   Float64 u;
   hc->get_LongTangent(spEntry, &u);
   stations.SPI1Station = stations.TSStation + u;

   hc->get_LongTangent(spExit, &u);
   stations.SPI2Station = stations.STStation - u;


   return stations;
}

CollectionIndexType CBridgeAgentImp::GetVertCurveCount() const
{
   VALIDATE( COGO_MODEL );

   IndexType nCurves;
   m_CogoModel->GetVerticalCurveCount(&nCurves);
   return nCurves;
}

void CBridgeAgentImp::GetVertCurve(CollectionIndexType idx,IVerticalCurve** ppCurve) const
{
   VALIDATE(BRIDGE);
   CComPtr<IAlignment> alignment;
   m_Bridge->get_Alignment(&alignment);
   CComPtr<IProfile> profile;
   alignment->GetProfile(CBridgeGeometryModelBuilder::ProfileID, &profile);

   auto found = m_VertCurveKeys.find(idx);
   ATLASSERT(found != std::end(m_VertCurveKeys));

   CComPtr<IProfileElement> element;
   profile->get_Item(found->first, &element);
   element.QueryInterface(ppCurve);
}

void CBridgeAgentImp::GetRoadwaySurface(Float64 station,IAngle* pSkewAngle,IPoint2dCollection** ppPoints) const
{
   CComPtr<IStation> objStation;
   objStation.CoCreateInstance(CLSID_Station);
   objStation->SetStation(INVALID_INDEX,station);
   CComVariant varStation(objStation);

   CComPtr<IProfile> profile;
   GetProfile(&profile);

   CComPtr<ISurface> surface;
   profile->GetSurface(CBridgeGeometryModelBuilder::SurfaceID,&surface);

   Float64 skew_angle = 0.; // pSkewAngle == nullptr means the cut is normal to the alignment
   if (pSkewAngle) pSkewAngle->get_Value(&skew_angle);

   CComPtr<IPoint2dCollection> points;
   points.CoCreateInstance(CLSID_Point2dCollection);
   if (IsZero(skew_angle))
   {
      // cut is normal to the alignment
      // using surface templates is faster but only works for normal cuts
      CComPtr<ISurfaceTemplate> surfaceTemplate;
      surface->CreateSurfaceTemplateSectionCut(varStation, VARIANT_TRUE, &surfaceTemplate);

      Float64 Xb = ConvertRouteToBridgeLineCoordinate(station);
      Float64 leftEdgeOffset  = GetLeftSlabEdgeOffset(Xb);
      Float64 rightEdgeOffset = GetRightSlabEdgeOffset(Xb);

      IndexType alignmentRidgePointIdx;
      surface->get_AlignmentPoint(&alignmentRidgePointIdx);

      SegmentIndexType nSegments;
      surfaceTemplate->get_Count(&nSegments);
      IndexType nRidgePoints = nSegments+1;
      for ( IndexType ridgePointIdx = 0; ridgePointIdx < nRidgePoints; ridgePointIdx++ )
      {
         Float64 x,y;
         profile->GetRidgePointOffsetAndElevation(CBridgeGeometryModelBuilder::SurfaceID,varStation,alignmentRidgePointIdx,ridgePointIdx,&x,&y);

         if ( x < leftEdgeOffset )
         {
            x = leftEdgeOffset;
            profile->Elevation(CBridgeGeometryModelBuilder::SurfaceID,varStation, x,&y);
         }
         else if ( rightEdgeOffset < x )
         {
            x = rightEdgeOffset;
            profile->Elevation(CBridgeGeometryModelBuilder::SurfaceID,varStation, x,&y);
         }

         CComPtr<IPoint2d> point;
         point.CoCreateInstance(CLSID_Point2d);
         point->Move(x,y);
         points->Add(point);
      }
   }
   else
   {
      CComPtr<ISurfaceProfile> surfaceProfile;
      surface->CreateSurfaceProfileSectionCut(varStation,CComVariant(pSkewAngle),VARIANT_TRUE,&surfaceProfile);

      IndexType nRidgePoints;
      surfaceProfile->get_Count(&nRidgePoints);
      for ( IndexType ridgePointIdx = 0; ridgePointIdx < nRidgePoints; ridgePointIdx++ )
      {
         CComPtr<ISurfacePoint> surfacePoint;
         surfaceProfile->get_Item(ridgePointIdx,&surfacePoint);
         Float64 x,y;
         surfacePoint->get_CutLineOffset(&x);
         surfacePoint->get_Elevation(&y);

         CComPtr<IPoint2d> point;
         point.CoCreateInstance(CLSID_Point2d);
         point->Move(x,y);
         points->Add(point);
      }
   }

   points.CopyTo(ppPoints);
}

void CBridgeAgentImp::GetPoint(Float64 station,Float64 offset,IDirection* pBearing,pgsTypes::PlanCoordinateType pcType,IPoint2d** ppPoint) const
{
   VALIDATE( COGO_MODEL );

   CComPtr<IAlignment> alignment;
   GetAlignment(&alignment);

   alignment->LocatePoint(CComVariant(station),omtAlongDirection, offset,CComVariant(pBearing),ppPoint);

   if ( pcType == pgsTypes::pcGlobal )
   {
      (*ppPoint)->Offset(m_DeltaX,m_DeltaY);
   }
}

void CBridgeAgentImp::GetStationAndOffset(pgsTypes::PlanCoordinateType pcType,IPoint2d* pPoint,Float64* pStation,Float64* pOffset) const
{
   VALIDATE( COGO_MODEL );

   CComPtr<IAlignment> alignment;
   GetAlignment(&alignment);

   CComPtr<IPoint2d> point(pPoint);
   if ( pcType == pgsTypes::pcGlobal )
   {
      // the inbound point is in global coordinates, we need to convert it to local coordinates
      // We don't want to alter the original point so make a copy
      point.Release();
      pPoint->Clone(&point);
      point->Offset(-m_DeltaX,-m_DeltaY);
      // point is now in local coordinates
   }

   CComPtr<IStation> station;
   Float64 offset;
   alignment->StationAndOffset(point,&station,&offset);

   ATLASSERT(station);
   if (station)
   {
      station->get_Value(pStation);
      *pOffset = offset;
   }
   else
   {
      *pStation = 0.;
      *pOffset = 0;
   }
}

IndexType CBridgeAgentImp::GetCrownPointIndexCount(Float64 station) const
{
   CComPtr<IProfile> profile;
   GetProfile(&profile);

   CComPtr<ISurface> surface;
   profile->GetSurface(CBridgeGeometryModelBuilder::SurfaceID,&surface);

   IndexType cnt;
   surface->GetSurfaceTemplateCount(&cnt);

   return cnt+1;
}

IndexType CBridgeAgentImp::GetAlignmentPointIndex(Float64 station) const
{
   CComPtr<IProfile> profile;
   GetProfile(&profile);

   CComPtr<ISurface> surface;
   profile->GetSurface(CBridgeGeometryModelBuilder::SurfaceID, &surface);

   IndexType cnt;
   surface->get_AlignmentPoint(&cnt);

   return cnt;
}


Float64 CBridgeAgentImp::GetAlignmentOffset(IndexType crownPointIdx, Float64 station) const
{
   CComPtr<IProfile> profile;
   GetProfile(&profile);

   CComPtr<ISurface> surface;
   profile->GetSurface(CBridgeGeometryModelBuilder::SurfaceID, &surface);

   IndexType alignmentRidgePointIdx;
   surface->get_AlignmentPoint(&alignmentRidgePointIdx);

   CComPtr<ISurfaceTemplate> surfaceTemplate;
   surface->CreateSurfaceTemplateSectionCut(CComVariant(station), VARIANT_TRUE, &surfaceTemplate);

   Float64 offset;
   surfaceTemplate->GetRidgePointOffset(alignmentRidgePointIdx,crownPointIdx,&offset);

   return offset;
}

IndexType CBridgeAgentImp::GetProfileGradeLineIndex(Float64 station) const
{
   CComPtr<IProfile> profile;
   GetProfile(&profile);

   CComPtr<ISurface> surface;
   profile->GetSurface(CBridgeGeometryModelBuilder::SurfaceID, &surface);

   IndexType pglIdx;
   surface->get_ProfileGradePoint(&pglIdx);
   return pglIdx;
}

Float64 CBridgeAgentImp::GetProfileGradeLineOffset(IndexType crownPointIdx, Float64 station) const
{
   CComPtr<IProfile> profile;
   GetProfile(&profile);

   CComPtr<ISurface> surface;
   profile->GetSurface(CBridgeGeometryModelBuilder::SurfaceID, &surface);

   IndexType pgl;
   surface->get_ProfileGradePoint(&pgl);

   CComPtr<ISurfaceTemplate> surfaceTemplate;
   surface->CreateSurfaceTemplateSectionCut(CComVariant(station), VARIANT_TRUE, &surfaceTemplate);

   Float64 offset;
   surfaceTemplate->GetRidgePointOffset(pgl, crownPointIdx, &offset);

   return offset;
}

/////////////////////////////////////////////////////////
// IGeometry
HRESULT CBridgeAgentImp::Angle(IPoint2d* from,IPoint2d* vertex,IPoint2d* to,IAngle** angle) const
{
   CComPtr<IMeasure2> measure;
   m_CogoEngine->get_Measure(&measure);
   return measure->Angle(from,vertex,to,angle);
}

HRESULT CBridgeAgentImp::Area(IPoint2dCollection* points,Float64* area) const
{
   CComPtr<IMeasure2> measure;
   m_CogoEngine->get_Measure(&measure);
   return measure->Area(points,area);
}

HRESULT CBridgeAgentImp::Distance(IPoint2d* from,IPoint2d* to,Float64* dist) const
{
   CComPtr<IMeasure2> measure;
   m_CogoEngine->get_Measure(&measure);
   return measure->Distance(from,to,dist);
}

HRESULT CBridgeAgentImp::Direction(IPoint2d* from,IPoint2d* to,IDirection** dir) const
{
   CComPtr<IMeasure2> measure;
   m_CogoEngine->get_Measure(&measure);
   return measure->Direction(from,to,dir);
}

HRESULT CBridgeAgentImp::Inverse(IPoint2d* from,IPoint2d* to,Float64* dist,IDirection** dir) const
{
   CComPtr<IMeasure2> measure;
   m_CogoEngine->get_Measure(&measure);
   return measure->Inverse(from,to,dist,dir);
}

HRESULT CBridgeAgentImp::ByDistAngle(IPoint2d* from,IPoint2d* to,Float64 dist,VARIANT varAngle,Float64 offset,IPoint2d** point) const
{
   CComPtr<ILocate2> locate;
   m_CogoEngine->get_Locate(&locate);
   return locate->ByDistAngle(from,to,dist,varAngle,offset,point);
}

HRESULT CBridgeAgentImp::ByDistDefAngle(IPoint2d* from,IPoint2d* to,Float64 dist,VARIANT varDefAngle,Float64 offset,IPoint2d** point) const
{
   CComPtr<ILocate2> locate;
   m_CogoEngine->get_Locate(&locate);
   return locate->ByDistDefAngle(from,to,dist,varDefAngle,offset,point);
}

HRESULT CBridgeAgentImp::ByDistDir(IPoint2d* from,Float64 dist,VARIANT varDir,Float64 offset,IPoint2d** point) const
{
   CComPtr<ILocate2> locate;
   m_CogoEngine->get_Locate(&locate);
   return locate->ByDistDir(from,dist,varDir,offset,point);
}

HRESULT CBridgeAgentImp::PointOnLine(IPoint2d* from,IPoint2d* to,Float64 dist,Float64 offset,IPoint2d** point) const
{
   CComPtr<ILocate2> locate;
   m_CogoEngine->get_Locate(&locate);
   return locate->PointOnLine(from,to,dist,offset,point);
}

HRESULT CBridgeAgentImp::ParallelLineByPoints(IPoint2d* from,IPoint2d* to,Float64 offset,IPoint2d** p1,IPoint2d** p2) const
{
   CComPtr<ILocate2> locate;
   m_CogoEngine->get_Locate(&locate);
   return locate->ParallelLineByPoints(from,to,offset,p1,p2);
}

HRESULT CBridgeAgentImp::ParallelLineSegment(ILineSegment2d* ls,Float64 offset,ILineSegment2d** linesegment) const
{
   CComPtr<ILocate2> locate;
   m_CogoEngine->get_Locate(&locate);
   return locate->ParallelLineSegment(ls,offset,linesegment);
}

HRESULT CBridgeAgentImp::Bearings(IPoint2d* p1,VARIANT varDir1,Float64 offset1,IPoint2d* p2,VARIANT varDir2,Float64 offset2,IPoint2d** point) const
{
   CComPtr<IIntersect2> intersect;
   m_CogoEngine->get_Intersect(&intersect);
   return intersect->Bearings(p1,varDir1,offset1,p2,varDir2,offset2,point);
}

HRESULT CBridgeAgentImp::BearingCircle(IPoint2d* p1,VARIANT varDir,Float64 offset,IPoint2d* center,Float64 radius,IPoint2d* nearest,IPoint2d** point) const
{
   CComPtr<IIntersect2> intersect;
   m_CogoEngine->get_Intersect(&intersect);
   return intersect->BearingCircle(p1,varDir,offset,center,radius,nearest,point);
}

HRESULT CBridgeAgentImp::Circles(IPoint2d* p1,Float64 r1,IPoint2d* p2,Float64 r2,IPoint2d* nearest,IPoint2d** point) const
{
   CComPtr<IIntersect2> intersect;
   m_CogoEngine->get_Intersect(&intersect);
   return intersect->Circles(p1,r1,p2,r2,nearest,point);
}

HRESULT CBridgeAgentImp::LineByPointsCircle(IPoint2d* p1,IPoint2d* p2,Float64 offset,IPoint2d* center,Float64 radius,IPoint2d* nearest,IPoint2d** point) const
{
   CComPtr<IIntersect2> intersect;
   m_CogoEngine->get_Intersect(&intersect);
   return intersect->LineByPointsCircle(p1,p2,offset,center,radius,nearest,point);
}

HRESULT CBridgeAgentImp::LinesByPoints(IPoint2d* p11,IPoint2d* p12,Float64 offset1,IPoint2d* p21,IPoint2d* p22,Float64 offset2,IPoint2d** point) const
{
   CComPtr<IIntersect2> intersect;
   m_CogoEngine->get_Intersect(&intersect);
   return intersect->LinesByPoints(p11,p12,offset1,p21,p22,offset2,point);
}

HRESULT CBridgeAgentImp::Lines(ILineSegment2d* l1,Float64 offset1,ILineSegment2d* l2,Float64 offset2,IPoint2d** point) const
{
   CComPtr<IIntersect2> intersect;
   m_CogoEngine->get_Intersect(&intersect);
   return intersect->Lines(l1,offset1,l2,offset2,point);
}

HRESULT CBridgeAgentImp::LineSegmentCircle(ILineSegment2d* pSeg,Float64 offset,IPoint2d* center,Float64 radius,IPoint2d* nearest, IPoint2d** point) const
{
   CComPtr<IIntersect2> intersect;
   m_CogoEngine->get_Intersect(&intersect);
   return intersect->LineSegmentCircle(pSeg,offset,center,radius,nearest,point);
}

HRESULT CBridgeAgentImp::PointOnLineByPoints(IPoint2d* pnt,IPoint2d* start,IPoint2d* end,Float64 offset,IPoint2d** point) const
{
   CComPtr<IProject2> project;
   m_CogoEngine->get_Project(&project);
   return project->PointOnLineByPoints(pnt,start,end,offset,point);
}

HRESULT CBridgeAgentImp::PointOnLineSegment(IPoint2d* from,ILineSegment2d* seg,Float64 offset,IPoint2d** point) const
{
   CComPtr<IProject2> project;
   m_CogoEngine->get_Project(&project);
   return project->PointOnLineSegment(from,seg,offset,point);
}

HRESULT CBridgeAgentImp::Arc(IPoint2d* from, IPoint2d* vertex, IPoint2d* to,CollectionIndexType nParts,IPoint2dCollection** points) const
{
   CComPtr<IDivide2> divide;
   m_CogoEngine->get_Divide(&divide);
   return divide->Arc(from,vertex,to,nParts,points);
}

HRESULT CBridgeAgentImp::BetweenPoints(IPoint2d* from, IPoint2d* to,CollectionIndexType nParts,IPoint2dCollection** points) const
{
   CComPtr<IDivide2> divide;
   m_CogoEngine->get_Divide(&divide);
   return divide->BetweenPoints(from,to,nParts,points);
}

HRESULT CBridgeAgentImp::LineSegment(ILineSegment2d* seg,CollectionIndexType nParts,IPoint2dCollection** points) const
{
   CComPtr<IDivide2> divide;
   m_CogoEngine->get_Divide(&divide);
   return divide->LineSegment(seg,nParts,points);
}

HRESULT CBridgeAgentImp::CompoundCurve(ICompoundCurve* curve, CollectionIndexType nParts, IPoint2dCollection** points) const
{
   CComPtr<IDivide2> divide;
   m_CogoEngine->get_Divide(&divide);
   return divide->CompoundCurve(curve,nParts,points);
}

HRESULT CBridgeAgentImp::Path(IPath* pPath,CollectionIndexType nParts,Float64 start,Float64 end,IPoint2dCollection** points) const
{
   CComPtr<IDivide2> divide;
   m_CogoEngine->get_Divide(&divide);
   return divide->Path(pPath,nParts,start,end,points);
}

HRESULT CBridgeAgentImp::External(IPoint2d* center1, Float64 radius1,IPoint2d* center2,Float64 radius2,TangentSignType sign, IPoint2d** t1,IPoint2d** t2) const
{
   CComPtr<ITangent2> tangent;
   m_CogoEngine->get_Tangent(&tangent);
   return tangent->External(center1,radius1,center2,radius2,sign,t1,t2);
}

HRESULT CBridgeAgentImp::Cross(IPoint2d* center1, Float64 radius1,IPoint2d* center2, Float64 radius2, TangentSignType sign, IPoint2d** t1,IPoint2d** t2) const
{
   CComPtr<ITangent2> tangent;
   m_CogoEngine->get_Tangent(&tangent);
   return tangent->Cross(center1,radius1,center2,radius2,sign,t1,t2);
}

HRESULT CBridgeAgentImp::Point(IPoint2d* center, Float64 radius,IPoint2d* point, TangentSignType sign, IPoint2d** tangentPoint) const
{
   CComPtr<ITangent2> tangent;
   m_CogoEngine->get_Tangent(&tangent);
   return tangent->Point(center,radius,point,sign,tangentPoint);
}

/////////////////////////////////////////////////////////////////////////
// IBridge
//
#include <MFCTools\AutoRegistry.h>
#include <EAF\EAFApp.h>
bool CBridgeAgentImp::IsAsymmetricGirder(const CGirderKey& girderKey) const
{
   CSegmentKey segmentKey(girderKey, 0);
   PoiList vPoi;
   GetPointsOfInterest(segmentKey, POI_5L | POI_RELEASED_SEGMENT, &vPoi);
   ATLASSERT(vPoi.size() == 1);
   const auto& poi(vPoi.front());

   CComPtr<IGirderSection> girder_section;
   HRESULT hr = GetGirderSection(poi, &girder_section);
   ATLASSERT(SUCCEEDED(hr));
   if (FAILED(hr))
   {
      return false;
   }

   CComQIPtr<IAsymmetricSection> asymmetricSection(girder_section);
   if (asymmetricSection == nullptr)
   {
      return false;
   }
   return true;
}

bool CBridgeAgentImp::HasAsymmetricGirders() const
{
   // Asymmetric effects are only taken into account for girders that implement the IAsymmetricSection interface

   CSegmentKey segmentKey(0, 0, 0);
   PoiList vPoi;
   GetPointsOfInterest(segmentKey, POI_5L | POI_RELEASED_SEGMENT, &vPoi);
   ATLASSERT(vPoi.size() == 1);
   const auto& poi(vPoi.front());

   CComPtr<IGirderSection> girder_section;
   HRESULT hr = GetGirderSection(poi, &girder_section);
   ATLASSERT(SUCCEEDED(hr));
   if (FAILED(hr))
   {
      return false;
   }

   CComQIPtr<IAsymmetricSection> asymmetricSection(girder_section);
   if (asymmetricSection == nullptr )
   {
      return false;
   }

   BOOL bIgnoreBiaxial;
   asymmetricSection->IgnoreBiaxialBending(&bIgnoreBiaxial);

   // Super secret registry setting....
   // If you want to experiment with unaxial vs biaxial bending stresses and asymmetric section related lateral deflections
   // add the IgnoreBiaxialBending setting to the registry. Set a value of "Yes" to force uniaxial bending
   CEAFApp* pApp = EAFGetApp();
   CAutoRegistry autoReg(_T("PGSuper"));
   CString strIgnoreBiaxialBending = pApp->GetProfileString(_T("Settings"), _T("IgnoreBiaxialBending"), _T("Unknown"));
   strIgnoreBiaxialBending.MakeUpper();
   if (strIgnoreBiaxialBending == _T("YES"))
   {
      bIgnoreBiaxial = true;
   }
   else if (strIgnoreBiaxialBending == _T("NO"))
   {
      bIgnoreBiaxial = false;
   }
   else
   {
      ATLASSERT(strIgnoreBiaxialBending == _T("UNKNOWN"));
   }

   if (bIgnoreBiaxial)
   {
      return false;
   }
   else
   {
      IntervalIndexType releaseIntervalIdx = GetPrestressReleaseInterval(segmentKey);
      pgsTypes::SectionPropertyType sectPropType = GetSectionPropertiesType();
      Float64 Ixy = GetIxy_Private(sectPropType,releaseIntervalIdx, poi); // must use private version or there will be recursion with this method
      if (IsZero(Ixy))
      {
         return false;
      }
      return true;
   }
}

bool CBridgeAgentImp::HasAsymmetricPrestressing() const
{
   if (m_AsymmetricPrestressing == Unknown)
   {
      // presence of asymmetric prestressing hasn't been determined yet.
      // Figure it out and cache the result
      GroupIndexType nGroups = GetGirderGroupCount();
      for (GroupIndexType grpIdx = 0; grpIdx < nGroups; grpIdx++)
      {
         GirderIndexType nGirders = GetGirderCount(grpIdx);
         for (GirderIndexType gdrIdx = 0; gdrIdx < nGirders; gdrIdx++)
         {
            SegmentIndexType nSegments = GetSegmentCount(grpIdx, gdrIdx);
            for (SegmentIndexType segIdx = 0; segIdx < nSegments; segIdx++)
            {
               CSegmentKey segmentKey(grpIdx, gdrIdx, segIdx);

               PoiList vPoi;
               GetPointsOfInterest(segmentKey, POI_5L | POI_RELEASED_SEGMENT, &vPoi);
               ATLASSERT(vPoi.size() == 1);
               const pgsPointOfInterest& poi = vPoi.front();

               IntervalIndexType releaseIntervalIdx = GetPrestressReleaseInterval(segmentKey);
               auto cg = GetStrandCG(releaseIntervalIdx, poi, true /*include temp strands*/);
               if (!IsZero(cg.X()))
               {
                  // we found one case of asymmetry so return
                  m_AsymmetricPrestressing = Yes;
                  return true;
               }
            }
         }
      }
      m_AsymmetricPrestressing = No;
   }

   return (m_AsymmetricPrestressing == Yes ? true : false);
}

bool CBridgeAgentImp::HasTiltedGirders() const
{
   // if girders are asymmetric and/or if girders are installed tilted, return true, else false
   GET_IFACE(IBridgeDescription, pIBridgeDesc);
   const CBridgeDescription2* pBridgeDesc = pIBridgeDesc->GetBridgeDescription();
   pgsTypes::GirderOrientationType orientationType = pBridgeDesc->GetGirderOrientation();

   return orientationType == pgsTypes::Plumb ? false : true;
}

Float64 CBridgeAgentImp::GetLength() const
{
   GET_IFACE(IBridgeDescription,pIBridgeDesc);
   const CBridgeDescription2* pBridgeDesc = pIBridgeDesc->GetBridgeDescription();
   return pBridgeDesc->GetLength();
}

Float64 CBridgeAgentImp::GetSpanLength(SpanIndexType spanIdx) const
{
   GET_IFACE(IBridgeDescription,pIBridgeDesc);
   const CBridgeDescription2* pBridgeDesc = pIBridgeDesc->GetBridgeDescription();

   PierIndexType startPierIdx = spanIdx;
   PierIndexType endPierIdx   = startPierIdx+1;

   const CPierData2* pStartPier = pBridgeDesc->GetPier(startPierIdx);
   const CPierData2* pEndPier   = pBridgeDesc->GetPier(endPierIdx);

   Float64 length = pEndPier->GetStation() - pStartPier->GetStation();

   return length;
}

Float64 CBridgeAgentImp::GetGirderLayoutLength(const CGirderKey& girderKey) const
{
   ASSERT_GIRDER_KEY(girderKey);

   GET_IFACE(IBridgeDescription, pIBridgeDesc);
   const CBridgeDescription2* pBridgeDesc = pIBridgeDesc->GetBridgeDescription();
   const CGirderGroupData* pGroup = pBridgeDesc->GetGirderGroup(girderKey.groupIndex);
#if defined _DEBUG
   ATLASSERT(girderKey.girderIndex <= pGroup->GetGirderCount() - 1);
#endif
   const CSplicedGirderData* pGirder = pGroup->GetGirder(girderKey.girderIndex);
   SegmentIndexType nSegments = pGirder->GetSegmentCount();

   Float64 L = 0;
   for ( SegmentIndexType segIdx = 0; segIdx < nSegments; segIdx++ )
   {
      L += GetSegmentLayoutLength(CSegmentKey(girderKey,segIdx));
   }
   return L;
}

Float64 CBridgeAgentImp::GetGirderSpanLength(const CGirderKey& girderKey) const
{
   Float64 layout_length = GetGirderLayoutLength(girderKey);

   // layout length goes from between the back of pavement seats at the end piers
   // need to deduct for connection geometry at end piers

   Float64 startBrgOffset, endBrgOffset;
   CSegmentKey startSegmentKey(girderKey.groupIndex,girderKey.girderIndex,0);
   GetSegmentBearingOffset(startSegmentKey,&startBrgOffset,&endBrgOffset);
   layout_length -= startBrgOffset;

   SegmentIndexType nSegments = GetSegmentCount(girderKey);
   CSegmentKey endSegmentKey(girderKey.groupIndex,girderKey.girderIndex,nSegments-1);
   GetSegmentBearingOffset(endSegmentKey,&startBrgOffset,&endBrgOffset);
   layout_length -= endBrgOffset;

   return layout_length;
}

Float64 CBridgeAgentImp::GetGirderLength(const CGirderKey& girderKey) const
{
   Float64 layout_length = GetGirderLayoutLength(girderKey);

   CSegmentKey startSegmentKey(girderKey.groupIndex,girderKey.girderIndex,0);
   Float64 startBrgOffset, endBrgOffset;
   GetSegmentBearingOffset(startSegmentKey,&startBrgOffset,&endBrgOffset);

   Float64 startEndDist, endEndDist;
   GetSegmentEndDistance(startSegmentKey,&startEndDist,&endEndDist);

   Float64 offset = startEndDist - startBrgOffset;
   layout_length += offset;

   SegmentIndexType nSegments = GetSegmentCount(girderKey);
   CSegmentKey endSegmentKey(girderKey.groupIndex,girderKey.girderIndex,nSegments-1);

   GetSegmentBearingOffset(endSegmentKey,&startBrgOffset,&endBrgOffset);
   GetSegmentEndDistance(endSegmentKey,&startEndDist,&endEndDist);

   offset = endEndDist - endBrgOffset;
   layout_length += offset;

   return layout_length;
}

Float64 CBridgeAgentImp::GetAlignmentOffset() const
{
   GET_IFACE(IBridgeDescription,pIBridgeDesc);
   const CBridgeDescription2* pBridgeDesc = pIBridgeDesc->GetBridgeDescription();
   return pBridgeDesc->GetAlignmentOffset();
}

SpanIndexType CBridgeAgentImp::GetSpanCount() const
{
   GET_IFACE(IBridgeDescription,pIBridgeDesc);
   const CBridgeDescription2* pBridgeDesc = pIBridgeDesc->GetBridgeDescription();
   return pBridgeDesc->GetSpanCount();
}

PierIndexType CBridgeAgentImp::GetPierCount() const
{
   GET_IFACE(IBridgeDescription,pIBridgeDesc);
   const CBridgeDescription2* pBridgeDesc = pIBridgeDesc->GetBridgeDescription();
   return pBridgeDesc->GetPierCount();
}

SupportIndexType CBridgeAgentImp::GetTemporarySupportCount() const
{
   GET_IFACE(IBridgeDescription,pIBridgeDesc);
   const CBridgeDescription2* pBridgeDesc = pIBridgeDesc->GetBridgeDescription();
   return pBridgeDesc->GetTemporarySupportCount();
}

GroupIndexType CBridgeAgentImp::GetGirderGroupCount() const
{
   GET_IFACE(IBridgeDescription,pIBridgeDesc);
   const CBridgeDescription2* pBridgeDesc = pIBridgeDesc->GetBridgeDescription();
   return pBridgeDesc->GetGirderGroupCount();
}

GirderIndexType CBridgeAgentImp::GetGirderCount(GroupIndexType grpIdx) const
{
   ATLASSERT( grpIdx != ALL_GROUPS );
   GET_IFACE(IBridgeDescription,pIBridgeDesc);
   const CBridgeDescription2* pBridgeDesc = pIBridgeDesc->GetBridgeDescription();
   const CGirderGroupData* pGroup = pBridgeDesc->GetGirderGroup(grpIdx);
   return pGroup->GetGirderCount();
}

GirderIndexType CBridgeAgentImp::GetGirderlineCount() const
{
   GET_IFACE(IBridgeDescription,pIBridgeDesc);
   const CBridgeDescription2* pBridgeDesc = pIBridgeDesc->GetBridgeDescription();
   GirderIndexType nGirderLines = 0;
   GroupIndexType nGroups = pBridgeDesc->GetGirderGroupCount();
   for ( GroupIndexType grpIdx = 0; grpIdx < nGroups; grpIdx++ )
   {
      const CGirderGroupData* pGroup = pBridgeDesc->GetGirderGroup(grpIdx);
      nGirderLines = Max(nGirderLines,pGroup->GetGirderCount());
   }
   return nGirderLines;
}

void CBridgeAgentImp::GetGirderline(GirderIndexType gdrLineIdx, std::vector<CGirderKey>* pvGirderKeys) const
{
   GetGirderline(CGirderKey(ALL_GROUPS,gdrLineIdx),pvGirderKeys);
}

void CBridgeAgentImp::GetGirderline(GirderIndexType gdrLineIdx, GroupIndexType startGroupIdx, GroupIndexType endGroupIdx, std::vector<CGirderKey>* pvGirderKeys) const
{
   ATLASSERT(gdrLineIdx != INVALID_INDEX);
   ATLASSERT(startGroupIdx != INVALID_INDEX);
   ATLASSERT(endGroupIdx != INVALID_INDEX);
   ATLASSERT(startGroupIdx <= endGroupIdx);

   GET_IFACE(IBridgeDescription, pIBridgeDesc);
   const CBridgeDescription2* pBridgeDesc = pIBridgeDesc->GetBridgeDescription();
   pvGirderKeys->reserve(endGroupIdx - startGroupIdx + 1);
   for (GroupIndexType grpIdx = startGroupIdx; grpIdx <= endGroupIdx; grpIdx++)
   {
      GirderIndexType nGirders = pBridgeDesc->GetGirderGroup(grpIdx)->GetGirderCount();
      GirderIndexType gdrIdx = Min(gdrLineIdx, nGirders - 1);
      pvGirderKeys->emplace_back(grpIdx, gdrIdx);
   }
}

void CBridgeAgentImp::GetGirderline(const CGirderKey& girderKey, std::vector<CGirderKey>* pvGirderKeys) const
{
   ATLASSERT(girderKey.girderIndex != INVALID_INDEX);
   GroupIndexType nGroups = GetGirderGroupCount();
   GroupIndexType startGroupIdx = (girderKey.groupIndex == ALL_GROUPS ? 0 : girderKey.groupIndex);
   GroupIndexType endGroupIdx = (girderKey.groupIndex == ALL_GROUPS ? nGroups - 1 : startGroupIdx);
   GetGirderline(girderKey.girderIndex, startGroupIdx, endGroupIdx, pvGirderKeys);
}

GirderIndexType CBridgeAgentImp::GetGirderCountBySpan(SpanIndexType spanIdx) const
{
   ATLASSERT( spanIdx != ALL_SPANS );

   GET_IFACE(IBridgeDescription,pIBridgeDesc);
   const CBridgeDescription2* pBridgeDesc = pIBridgeDesc->GetBridgeDescription();
   const CSpanData2* pSpan = pBridgeDesc->GetSpan(spanIdx);
   const CGirderGroupData* pGroup = pBridgeDesc->GetGirderGroup(pSpan);
   return pGroup->GetGirderCount();
}

SegmentIndexType CBridgeAgentImp::GetSegmentCount(const CGirderKey& girderKey) const
{
   ASSERT_GIRDER_KEY(girderKey);
   GET_IFACE(IBridgeDescription,pIBridgeDesc);
   const CBridgeDescription2* pBridgeDesc = pIBridgeDesc->GetBridgeDescription();
   const CGirderGroupData* pGroup = pBridgeDesc->GetGirderGroup(girderKey.groupIndex);
   GirderIndexType ngdrs = pGroup->GetGirderCount();
   GirderIndexType idx = min(ngdrs-1, girderKey.girderIndex);
   const CSplicedGirderData* pGirder = pGroup->GetGirder(idx);
   return pGirder->GetSegmentCount();
}

SegmentIndexType CBridgeAgentImp::GetSegmentCount(GroupIndexType grpIdx,GirderIndexType gdrIdx) const
{
   return GetSegmentCount(CGirderKey(grpIdx,gdrIdx));
}

PierIndexType CBridgeAgentImp::GetGirderGroupStartPier(GroupIndexType grpIdx) const
{
   GET_IFACE(IBridgeDescription,pIBridgeDesc);
   const CBridgeDescription2* pBridgeDesc = pIBridgeDesc->GetBridgeDescription();
   const CGirderGroupData* pGroup = pBridgeDesc->GetGirderGroup(grpIdx == ALL_GROUPS ? 0 : grpIdx);
   return pGroup->GetPierIndex(pgsTypes::metStart);
}

PierIndexType CBridgeAgentImp::GetGirderGroupEndPier(GroupIndexType grpIdx) const
{
   GET_IFACE(IBridgeDescription,pIBridgeDesc);
   const CBridgeDescription2* pBridgeDesc = pIBridgeDesc->GetBridgeDescription();
   const CGirderGroupData* pGroup = pBridgeDesc->GetGirderGroup(grpIdx == ALL_GROUPS ? pBridgeDesc->GetGirderGroupCount()-1 : grpIdx);
   return pGroup->GetPierIndex(pgsTypes::metEnd);
}

void CBridgeAgentImp::GetGirderGroupPiers(GroupIndexType grpIdx,PierIndexType* pStartPierIdx,PierIndexType* pEndPierIdx) const
{
   GET_IFACE(IBridgeDescription,pIBridgeDesc);
   const CBridgeDescription2* pBridgeDesc = pIBridgeDesc->GetBridgeDescription();
   if ( grpIdx == ALL_GROUPS )
   {
      *pStartPierIdx = 0;
      *pEndPierIdx = pBridgeDesc->GetPierCount()-1;
   }
   else
   {
      const CGirderGroupData* pGroup = pBridgeDesc->GetGirderGroup(grpIdx);
      *pStartPierIdx = pGroup->GetPierIndex(pgsTypes::metStart);
      *pEndPierIdx = pGroup->GetPierIndex(pgsTypes::metEnd);
   }
}

SpanIndexType CBridgeAgentImp::GetGirderGroupStartSpan(GroupIndexType grpIdx) const
{
   return (SpanIndexType)GetGirderGroupStartPier(grpIdx);
}

SpanIndexType CBridgeAgentImp::GetGirderGroupEndSpan(GroupIndexType grpIdx) const
{
   return (SpanIndexType)(GetGirderGroupEndPier(grpIdx)-1);
}

void CBridgeAgentImp::GetGirderGroupSpans(GroupIndexType grpIdx,SpanIndexType* pStartSpanIdx,SpanIndexType* pEndSpanIdx) const
{
   PierIndexType startPierIdx, endPierIdx;
   GetGirderGroupPiers(grpIdx,&startPierIdx,&endPierIdx);

   *pStartSpanIdx = (SpanIndexType)startPierIdx;
   *pEndSpanIdx   = (SpanIndexType)(endPierIdx-1);
}

GroupIndexType CBridgeAgentImp::GetGirderGroupIndex(SpanIndexType spanIdx) const
{
   GET_IFACE(IBridgeDescription,pIBridgeDesc);
   const CBridgeDescription2* pBridgeDesc = pIBridgeDesc->GetBridgeDescription();
   const CSpanData2* pSpan = pBridgeDesc->GetSpan(spanIdx);
   const CGirderGroupData* pGroup = pBridgeDesc->GetGirderGroup(pSpan);
   return pGroup->GetIndex();
}

void CBridgeAgentImp::GetGirderGroupIndex(PierIndexType pierIdx,GroupIndexType* pBackGroupIdx,GroupIndexType* pAheadGroupIdx) const
{
   GET_IFACE(IBridgeDescription,pIBridgeDesc);
   const CBridgeDescription2* pBridgeDesc = pIBridgeDesc->GetBridgeDescription();
   const CPierData2* pPier = pBridgeDesc->GetPier(pierIdx);
   const CGirderGroupData* pPrevGroup = pPier->GetPrevGirderGroup();
   const CGirderGroupData* pNextGroup = pPier->GetNextGirderGroup();

   *pBackGroupIdx  = INVALID_INDEX;
   if ( pPrevGroup )
   {
      *pBackGroupIdx = pPrevGroup->GetIndex();
   }

   *pAheadGroupIdx = INVALID_INDEX;
   if ( pNextGroup )
   {
      *pAheadGroupIdx = pNextGroup->GetIndex();
   }
}

void CBridgeAgentImp::GetDistanceBetweenGirders(const pgsPointOfInterest& poi,Float64 *pLeft,Float64* pRight) const
{
   VALIDATE( GIRDER );

   const CSegmentKey& segmentKey = poi.GetSegmentKey();

   GET_IFACE(IBridgeDescription,pIBridgeDesc);
   const CBridgeDescription2* pBridgeDesc = pIBridgeDesc->GetBridgeDescription();
   const CGirderGroupData* pGroup = pBridgeDesc->GetGirderGroup(segmentKey.groupIndex);
   const CSplicedGirderData* pGirder = pGroup->GetGirder(segmentKey.girderIndex);
   const CPrecastSegmentData* pSegment = pGirder->GetSegment(segmentKey.segmentIndex);

   const CGirderSpacing2* pStartSpacing;
   const CGirderSpacing2* pEndSpacing;
   pSegment->GetSpacing(&pStartSpacing,&pEndSpacing);

   // girder spacing is on the right hand side of the girder

   // Get spacing on the left side of the girder at start and end
   Float64 left_start = 0;
   Float64 left_end   = 0;

   if ( 0 != segmentKey.girderIndex )
   {
      SpacingIndexType spaceIdx = segmentKey.girderIndex-1;
      left_start = pStartSpacing->GetGirderSpacing(spaceIdx);
      left_end   = pEndSpacing->GetGirderSpacing(spaceIdx);
   }

   // Get spacing on the right side of the girder at start and end
   GirderIndexType nGirders = pGroup->GetGirderCount();
   Float64 right_start = 0;
   Float64 right_end   = 0;
   if ( segmentKey.girderIndex < nGirders-1 )
   {
      SpacingIndexType spaceIdx = segmentKey.girderIndex;
      right_start = pStartSpacing->GetGirderSpacing(spaceIdx);
      right_end   = pEndSpacing->GetGirderSpacing(spaceIdx);
   }

   Float64 gdrLength = GetSegmentLength(segmentKey);

   Float64 Xpoi = poi.GetDistFromStart();
   Float64 left  = ::LinInterp( Xpoi, left_start,  left_end,  gdrLength );
   Float64 right = ::LinInterp( Xpoi, right_start, right_end, gdrLength );

   // if the spacing is a joint spacing, we have what we are after
   if ( IsJointSpacing(pBridgeDesc->GetGirderSpacingType()) )
   {
      *pLeft = left;
      *pRight = right;
      return;
   }

   // not a joint spacing so the spacing is between CL girders.... deduct the width
   // of the adjacent girders and this girder
   Float64 left_width = 0;
   Float64 width = 0;
   Float64 right_width = 0;
   if ( 0 != segmentKey.girderIndex )
   {
      pgsPointOfInterest leftPoi(poi);
      leftPoi.SetSegmentKey( CSegmentKey(segmentKey.groupIndex,segmentKey.girderIndex-1,segmentKey.segmentIndex) );
      left_width = Max(GetTopWidth(leftPoi),GetBottomWidth(leftPoi));
   }

   width = Max(GetTopWidth(poi),GetBottomWidth(poi));

   if ( segmentKey.girderIndex < nGirders-1 )
   {
      pgsPointOfInterest rightPoi(poi);
      rightPoi.SetSegmentKey( segmentKey );
      right_width = Max(GetTopWidth(rightPoi),GetBottomWidth(rightPoi));
   }

   // clear spacing is C-C spacing minus half the width of the adjacent girder minus the width of this girder
   *pLeft = left - left_width/2 - width/2;
   *pRight = right - right_width/2 - width/2;

   if ( *pLeft < 0 )
   {
      *pLeft = 0;
   }

   if ( *pRight < 0 )
   {
      *pRight = 0;
   }
}

void CBridgeAgentImp::GetBottomFlangeClearance(const pgsPointOfInterest& poi,Float64* pLeft,Float64* pRight) const
{
   VALIDATE( BRIDGE );

   const CSegmentKey& segmentKey = poi.GetSegmentKey();

   GET_IFACE(IBridgeDescription,pIBridgeDesc);
   const CBridgeDescription2* pBridgeDesc = pIBridgeDesc->GetBridgeDescription();
   const CGirderGroupData* pGroup = pBridgeDesc->GetGirderGroup(segmentKey.groupIndex);
   const CSplicedGirderData* pGirder = pGroup->GetGirder(segmentKey.girderIndex);
   const CPrecastSegmentData* pSegment = pGirder->GetSegment(segmentKey.segmentIndex);

   const CGirderSpacing2* pStartSpacing;
   const CGirderSpacing2* pEndSpacing;
   pSegment->GetSpacing(&pStartSpacing,&pEndSpacing);

   // girder spacing is on the right hand side of the girder

   // Get spacing on the left side of the girder at start and end
   Float64 left_start = 0;
   Float64 left_end   = 0;

   if ( 0 != segmentKey.girderIndex )
   {
      SpacingIndexType spaceIdx = segmentKey.girderIndex-1;
      left_start = pStartSpacing->GetGirderSpacing(spaceIdx);
      left_end   = pEndSpacing->GetGirderSpacing(spaceIdx);
   }

   // Get spacing on the right side of the girder at start and end
   GirderIndexType nGirders = pGroup->GetGirderCount();
   Float64 right_start = 0;
   Float64 right_end   = 0;
   if ( segmentKey.girderIndex < nGirders-1 )
   {
      SpacingIndexType spaceIdx = segmentKey.girderIndex;
      right_start = pStartSpacing->GetGirderSpacing(spaceIdx);
      right_end   = pEndSpacing->GetGirderSpacing(spaceIdx);
   }

   Float64 gdrLength = GetSegmentLength(segmentKey);

   Float64 Xpoi = poi.GetDistFromStart();
   Float64 left  = ::LinInterp( Xpoi, left_start,  left_end,  gdrLength );
   Float64 right = ::LinInterp( Xpoi, right_start, right_end, gdrLength );

   // if the spacing is a joint spacing, we have what we are after
   if ( IsJointSpacing(pBridgeDesc->GetGirderSpacingType()) )
   {
      *pLeft  = left;
      *pRight = right;
      return;
   }

   // not a joint spacing so the spacing is between CL girders.... deduct the width
   // of the adjacent girders and this girder
   Float64 left_width = 0;
   Float64 width = 0;
   Float64 right_width = 0;
   if ( 0 != segmentKey.girderIndex )
   {
      pgsPointOfInterest leftPoi = GetPointOfInterest(CSegmentKey(segmentKey.groupIndex, segmentKey.girderIndex - 1, segmentKey.segmentIndex), poi.GetDistFromStart());
      left_width = GetBottomWidth(leftPoi);
   }

   width = GetBottomWidth(poi);

   if ( segmentKey.girderIndex < nGirders-1 )
   {
      pgsPointOfInterest rightPoi = GetPointOfInterest(CSegmentKey(segmentKey.groupIndex, segmentKey.girderIndex + 1, segmentKey.segmentIndex), poi.GetDistFromStart());
      right_width = GetBottomWidth(rightPoi);
   }

   // clear spacing is C-C spacing minus half the width of the adjacent girder minus the width of this girder
   *pLeft  = left  - left_width/2  - width/2;
   *pRight = right - right_width/2 - width/2;
}

std::vector<Float64> CBridgeAgentImp::GetGirderSpacing(PierIndexType pierIdx,pgsTypes::PierFaceType pierFace,pgsTypes::MeasurementLocation measureLocation,pgsTypes::MeasurementType measureType) const
{
   VALIDATE( GIRDER );

   // Determine which girder group the face of pier belongs to
   GroupIndexType backGroupIdx, aheadGroupIdx;
   GetGirderGroupIndex(pierIdx,&backGroupIdx,&aheadGroupIdx);
   GroupIndexType grpIdx = (pierFace == pgsTypes::Back ? backGroupIdx : aheadGroupIdx);

   GET_IFACE(IBridgeDescription,pIBridgeDesc);
   const CGirderGroupData* pGroup = pIBridgeDesc->GetGirderGroup(grpIdx);
   GirderIndexType nGirders = pGroup->GetGirderCount();

   // we are going to need the bridge geomtry model
   CComPtr<IBridgeGeometry> bridgeGeometry;
   m_Bridge->get_BridgeGeometry(&bridgeGeometry);

   CComPtr<IAlignment> alignment;
   m_Bridge->get_Alignment(&alignment);

   CComPtr<IPoint2d> pntLeft,pntAlignment,pntBridge,pntRight;
   GetPierPoints(pierIdx,pgsTypes::pcLocal,&pntLeft,&pntAlignment,&pntBridge,&pntRight);

   CComPtr<ILine2d> measureLine; // only used if we are measuring normal to item (CLPier or CLBrg)
   if ( measureType == pgsTypes::NormalToItem )
   {
      // need the line that we are measuring along... then we will intersect the segment lines
      // with this line to compute the spacing
      if ( measureLocation == pgsTypes::AtPierLine )
      {
         // measuring along a line that is normal to the CL Pier line
         Float64 station = pIBridgeDesc->GetPier(pierIdx)->GetStation();
         CComPtr<IDirection> normal;
         alignment->GetNormal(CComVariant(station),&normal);
         Float64 dir;
         normal->get_Value(&dir);

         measureLine.CoCreateInstance(CLSID_Line2d);
         CComPtr<IVector2d> v;
         CComPtr<IPoint2d> pnt;
         measureLine->GetExplicit(&pnt,&v);

         v->put_Direction(dir);
         measureLine->SetExplicit(pntAlignment,v);
      }
      else
      {
         // measuring along a line that is normal the CL Bearing line
         // NOTE: in the general case, there can be multiple CL Bearing lines.
         // to make things manageable, we'll create a CL Bearing line by connecting the CL Bearing point
         // for the two exterior girders
         CSegmentKey leftSegmentKey = GetSegmentAtPier(pierIdx,CGirderKey(grpIdx,0));
         CSegmentKey rightSegmentKey = GetSegmentAtPier(pierIdx,CGirderKey(grpIdx,nGirders-1));

         CComPtr<IPoint2d> pntPier1,pntEnd1,pntBrg1,pntBrg2,pntEnd2,pntPier2;
         GetSegmentEndPoints(leftSegmentKey,pgsTypes::pcLocal,&pntPier1,&pntEnd1,&pntBrg1,&pntBrg2,&pntEnd2,&pntPier2);
         CComPtr<IPoint2d> p1 = (pierFace == pgsTypes::Ahead ? pntBrg1 : pntBrg2);

         pntPier1.Release();
         pntEnd1.Release();
         pntBrg1.Release();
         pntBrg2.Release();
         pntEnd2.Release();
         pntPier2.Release();
         GetSegmentEndPoints(rightSegmentKey,pgsTypes::pcLocal,&pntPier1,&pntEnd1,&pntBrg1,&pntBrg2,&pntEnd2,&pntPier2);
         CComPtr<IPoint2d> p2 = (pierFace == pgsTypes::Ahead ? pntBrg1 : pntBrg2);

         CComPtr<ILine2d> clBrgLine;
         clBrgLine.CoCreateInstance(CLSID_Line2d);
         clBrgLine->ThroughPoints(p1,p2);

         CComPtr<IPoint2d> pntBrg;
         alignment->Intersect(clBrgLine,pntAlignment,&pntBrg);

         CComPtr<IStation> station;
         Float64 offset;
         alignment->StationAndOffset(pntBrg,&station,&offset);

         CComPtr<IDirection> normal;
         alignment->GetNormal(CComVariant(station),&normal);
         Float64 dir;
         normal->get_Value(&dir);

         measureLine.CoCreateInstance(CLSID_Line2d);
         CComPtr<IPoint2d> p;
         CComPtr<IVector2d> v;
         measureLine->GetExplicit(&p,&v);

         v->put_Direction(dir);
         measureLine->SetExplicit(pntBrg,v);
      }
   }

   // loop over all girders and compute the spacing between the girders at the CL Pier
   std::vector<Float64> spaces;
   for ( GirderIndexType gdrIdx = 1; gdrIdx < nGirders; gdrIdx++ ) // start at gdrIdx 1 (spacing between gdrIdx 0 and 1)
   {
      // girder line IDs for the segments pairs of adjacent segments working left to right across the bridge cross section

      // segments that touch the pier
      std::array<CSegmentKey, 2> leftSegmentKey, rightSegmentKey;
      GetSegmentsAtPier(pierIdx, gdrIdx - 1, &leftSegmentKey[pgsTypes::Back], &leftSegmentKey[pgsTypes::Ahead]);
      GetSegmentsAtPier(pierIdx, gdrIdx, &rightSegmentKey[pgsTypes::Back], &rightSegmentKey[pgsTypes::Ahead]);

      // girder line IDs for the segments
      GirderIDType leftGdrID  = ::GetGirderSegmentLineID(leftSegmentKey[pierFace]);
      GirderIDType rightGdrID = ::GetGirderSegmentLineID(rightSegmentKey[pierFace]);

      // get the girder lines so they can be intersected with the pier line
      CComPtr<IGirderLine> leftGirderLine, rightGirderLine;
      bridgeGeometry->FindGirderLine(leftGdrID,&leftGirderLine);
      bridgeGeometry->FindGirderLine(rightGdrID,&rightGirderLine);

      CComPtr<IPoint2d> pntLeft, pntRight; // point on left and right girder
      // spacing is distance between the points

      Float64 distance = -9999;
      if ( measureType == pgsTypes::NormalToItem )
      {
         // intersect measure line with girder paths

         // get the girder paths
         CComPtr<IPath> leftPath, rightPath;
         leftGirderLine->get_Path(&leftPath);
         rightGirderLine->get_Path(&rightPath);

         // intersect each path with the normal line
         leftPath->Intersect(measureLine,pntAlignment,&pntLeft);
         rightPath->Intersect(measureLine,pntAlignment,&pntRight);
      }
      else
      {
         ATLASSERT(measureType == pgsTypes::AlongItem);
         // geometry points are already computed... just get them

         switch ( measureLocation )
         {
         case pgsTypes::AtPierLine:
            leftGirderLine->get_PierPoint(pierFace == pgsTypes::Back ? etEnd : etStart,&pntLeft);
            rightGirderLine->get_PierPoint(pierFace == pgsTypes::Back ? etEnd : etStart,&pntRight);
            break;

         case pgsTypes::AtCenterlineBearing:
            leftGirderLine->get_BearingPoint(pierFace == pgsTypes::Back ? etEnd : etStart,&pntLeft);
            rightGirderLine->get_BearingPoint(pierFace == pgsTypes::Back ? etEnd : etStart,&pntRight);
            break;

         default:
            ATLASSERT(false);
         }
      }

      pntLeft->DistanceEx(pntRight,&distance); // distance along line

      ATLASSERT( 0 < distance );
      spaces.push_back(distance);
   }

   return spaces;
}

std::vector<Float64> CBridgeAgentImp::GetGirderSpacingAtTemporarySupport(SupportIndexType tsIdx, pgsTypes::PierFaceType pierFace, pgsTypes::MeasurementLocation measureLocation, pgsTypes::MeasurementType measureType) const
{
   VALIDATE(GIRDER);

   // Determine which group the temporary support belogs to
   std::array<CSegmentKey, 2> segmentKey;
   GetSegmentsAtTemporarySupport(0, tsIdx, &segmentKey[pgsTypes::Back], &segmentKey[pgsTypes::Ahead]);
   GroupIndexType grpIdx = segmentKey[pgsTypes::Back].groupIndex;

   GET_IFACE(IBridgeDescription, pIBridgeDesc);
   const CGirderGroupData* pGroup = pIBridgeDesc->GetGirderGroup(grpIdx);
   GirderIndexType nGirders = pGroup->GetGirderCount();

   // we are going to need the bridge geomtry model
   CComPtr<IBridgeGeometry> bridgeGeometry;
   m_Bridge->get_BridgeGeometry(&bridgeGeometry);

   CComPtr<IAlignment> alignment;
   m_Bridge->get_Alignment(&alignment);

   CComPtr<IPoint2d> pntLeft, pntAlignment, pntBridge, pntRight;
   GetControlPoints(tsIdx, pgsTypes::pcLocal, &pntLeft, &pntAlignment, &pntBridge, &pntRight);

   CComPtr<ILine2d> measureLine; // only used if we are measuring normal to item (CLPier or CLBrg)
   if (measureType == pgsTypes::NormalToItem)
   {
      // need the line that we are measuring along... then we will intersect the segment lines
      // with this line to compute the spacing
      if (measureLocation == pgsTypes::AtPierLine)
      {
         // measuring along a line that is normal to the CL Temporary Support line
         Float64 station = pIBridgeDesc->GetTemporarySupport(tsIdx)->GetStation();
         CComPtr<IDirection> normal;
         alignment->GetNormal(CComVariant(station), &normal);
         Float64 dir;
         normal->get_Value(&dir);

         measureLine.CoCreateInstance(CLSID_Line2d);
         CComPtr<IVector2d> v;
         CComPtr<IPoint2d> pnt;
         measureLine->GetExplicit(&pnt, &v);

         v->put_Direction(dir);
         measureLine->SetExplicit(pntAlignment, v);
      }
      else
      {
         // measuring along a line that is normal the CL Bearing line
         // NOTE: in the general case, there can be multiple CL Bearing lines.
         // to make things managable, we'll create a CL Bearing line by connecting the CL Bearing point
         // for the two exterior girders
         CSegmentKey leftSegmentKey(segmentKey[pierFace]);
         leftSegmentKey.girderIndex = 0;
         CComPtr<IPoint2d> pntPier1, pntEnd1, pntBrg1, pntBrg2, pntEnd2, pntPier2;
         GetSegmentEndPoints(leftSegmentKey, pgsTypes::pcLocal, &pntPier1, &pntEnd1, &pntBrg1, &pntBrg2, &pntEnd2, &pntPier2);
         CComPtr<IPoint2d> p1 = (pierFace == pgsTypes::Ahead ? pntBrg1 : pntBrg2);

         pntPier1.Release();
         pntEnd1.Release();
         pntBrg1.Release();
         pntBrg2.Release();
         pntEnd2.Release();
         pntPier2.Release();
         
         CSegmentKey rightSegmentKey(segmentKey[pierFace]);
         rightSegmentKey.girderIndex = nGirders - 1;
         GetSegmentEndPoints(rightSegmentKey, pgsTypes::pcLocal, &pntPier1, &pntEnd1, &pntBrg1, &pntBrg2, &pntEnd2, &pntPier2);
         CComPtr<IPoint2d> p2 = (pierFace == pgsTypes::Ahead ? pntBrg1 : pntBrg2);

         CComPtr<ILine2d> clBrgLine;
         clBrgLine.CoCreateInstance(CLSID_Line2d);
         clBrgLine->ThroughPoints(p1, p2);

         CComPtr<IPoint2d> pntBrg;
         alignment->Intersect(clBrgLine, pntAlignment, &pntBrg);

         CComPtr<IStation> station;
         Float64 offset;
         alignment->StationAndOffset(pntBrg, &station, &offset);

         CComPtr<IDirection> normal;
         alignment->GetNormal(CComVariant(station), &normal);
         Float64 dir;
         normal->get_Value(&dir);

         measureLine.CoCreateInstance(CLSID_Line2d);
         CComPtr<IPoint2d> p;
         CComPtr<IVector2d> v;
         measureLine->GetExplicit(&p, &v);

         v->put_Direction(dir);
         measureLine->SetExplicit(pntBrg, v);
      }
   }

   // loop over all girders and compute the spacing between the girders at the CL Temp Support
   std::vector<Float64> spaces;
   for (GirderIndexType gdrIdx = 1; gdrIdx < nGirders; gdrIdx++) // start at gdrIdx 1 (spacing between gdrIdx 0 and 1)
   {
      // girder line IDs for the segments pairs of adjacent segments working left to right across the bridge cross section
      std::array<CSegmentKey, 2> segmentKey;
      GetSegmentsAtTemporarySupport(gdrIdx-1, tsIdx, &segmentKey[pgsTypes::Back], &segmentKey[pgsTypes::Ahead]);
      GirderIDType leftGdrID = ::GetGirderSegmentLineID(segmentKey[pierFace]);

      GetSegmentsAtTemporarySupport(gdrIdx, tsIdx, &segmentKey[pgsTypes::Back], &segmentKey[pgsTypes::Ahead]);
      GirderIDType rightGdrID = ::GetGirderSegmentLineID(segmentKey[pierFace]);

      // get the girder lines so they can be intersected with the pier line
      CComPtr<IGirderLine> leftGirderLine, rightGirderLine;
      bridgeGeometry->FindGirderLine(leftGdrID, &leftGirderLine);
      bridgeGeometry->FindGirderLine(rightGdrID, &rightGirderLine);

      CComPtr<IPoint2d> pntLeft, pntRight; // point on left and right girder
                                           // spacing is distance between the points

      Float64 distance = -9999;
      if (measureType == pgsTypes::NormalToItem)
      {
         // intersect measure line with girder paths

         // get the girder paths
         CComPtr<IPath> leftPath, rightPath;
         leftGirderLine->get_Path(&leftPath);
         rightGirderLine->get_Path(&rightPath);

         // intersect each path with the normal line
         leftPath->Intersect(measureLine, pntAlignment, &pntLeft);
         rightPath->Intersect(measureLine, pntAlignment, &pntRight);
      }
      else
      {
         ATLASSERT(measureType == pgsTypes::AlongItem);
         // geometry points are already computed... just get them

         switch (measureLocation)
         {
         case pgsTypes::AtPierLine:
            leftGirderLine->get_PierPoint(pierFace == pgsTypes::Back ? etEnd : etStart, &pntLeft);
            rightGirderLine->get_PierPoint(pierFace == pgsTypes::Back ? etEnd : etStart, &pntRight);
            break;

         case pgsTypes::AtCenterlineBearing:
            leftGirderLine->get_BearingPoint(pierFace == pgsTypes::Back ? etEnd : etStart, &pntLeft);
            rightGirderLine->get_BearingPoint(pierFace == pgsTypes::Back ? etEnd : etStart, &pntRight);
            break;

         default:
            ATLASSERT(false);
         }
      }

      pntLeft->DistanceEx(pntRight, &distance); // distance along line

      ATLASSERT(0 < distance);
      spaces.push_back(distance);
   }

   return spaces;
}

Float64 CBridgeAgentImp::GetGirderOffset(GirderIndexType gdrIdx,PierIndexType pierIdx,pgsTypes::PierFaceType pierFace,pgsTypes::OffsetMeasurementType offsetMeasureDatum) const
{
   VALIDATE(GIRDER);
   CComPtr<IPoint2d> pntLeft, pntAlignment, pntBridge, pntRight;
   GetPierPoints(pierIdx,pgsTypes::pcLocal,&pntLeft,&pntAlignment,&pntBridge,&pntRight);

   GroupIndexType grpIdx = GetGirderGroupAtPier(pierIdx,pierFace);
   CSegmentKey segmentKey(GetSegmentAtPier(pierIdx,CGirderKey(grpIdx,gdrIdx)));

   CComPtr<IPoint2d> pntSegment;
   bool bResult = GetSegmentPierIntersection(segmentKey,pierIdx,pgsTypes::pcLocal,&pntSegment);
   ATLASSERT(bResult == true);

   // Create a coordinate system with origin at pntAlignment/pntBridge and the x-axis
   // pointing toward the right side of the alignment and in the direction of the CL pier
   // Transform pntSegment into this coordinate system. If the X value of the point in 
   // the new coordinate system is the offset from the offset datum

   CComPtr<IDirection> dirPier;
   GetPierDirection(pierIdx,&dirPier);
   dirPier->IncrementBy(CComVariant(M_PI)); // rotation 180 so X is to the right of the alignment
   Float64 dir;
   dirPier->get_Value(&dir);

   CComPtr<ICoordinateXform2d> xform;
   xform.CoCreateInstance(CLSID_CoordinateXform2d);
   if (offsetMeasureDatum == pgsTypes::omtAlignment )
   {
      xform->put_NewOrigin(pntAlignment);
   }
   else
   {
      xform->put_NewOrigin(pntBridge);
   }

   xform->put_RotationAngle(dir);

   CComPtr<IPoint2d> pnt;
   xform->XformEx(pntSegment,xfrmOldToNew,&pnt);

   Float64 offset;
   pnt->get_X(&offset);

#if defined _DEBUG
   Float64 Y;
   pnt->get_Y(&Y);
   ATLASSERT(IsZero(Y));
#endif

   return offset;
}

std::vector<SpaceBetweenGirder> CBridgeAgentImp::GetGirderSpacing(Float64 station) const
{
   // Get the spacing between girders at the specified location. Spacing is measured normal to the alignment.
   // Identical adjacent spaces are grouped together

   // NOTE: this should be delegated to Generic Bridge Model or Bridge Geometry Model

   VALIDATE( GIRDER );
   std::vector<SpaceBetweenGirder> vSpacing;

   GET_IFACE(IBridgeDescription,pIBridgeDesc);
   const CBridgeDescription2* pBridgeDesc = pIBridgeDesc->GetBridgeDescription();
   GroupIndexType nGroups = pBridgeDesc->GetGirderGroupCount();
   const CGirderGroupData* pGroup = nullptr;
   for ( GroupIndexType grpIdx = 0; grpIdx < nGroups; grpIdx++ )
   {
      const CGirderGroupData* pThisGroup = pBridgeDesc->GetGirderGroup(grpIdx);
      Float64 startStation = pThisGroup->GetPier(pgsTypes::metStart)->GetStation();
      Float64 endStation   = pThisGroup->GetPier(pgsTypes::metEnd)->GetStation();
      if ( ::InRange(startStation,station,endStation) )
      {
         pGroup = pThisGroup;
         break;
      }
   }

   if ( pGroup == nullptr )
   {
      return vSpacing;
   }

   GroupIndexType grpIdx = pGroup->GetIndex();
   GirderIndexType nGirders = pGroup->GetGirderCount();

   if ( nGirders <= 1 )
   {
      return vSpacing;
   }

   CComPtr<IAlignment> alignment;
   GetAlignment(&alignment);

   CComPtr<IDirection> normal;
   alignment->GetNormal(CComVariant(station),&normal);
   Float64 dirNormal;
   normal->get_Value(&dirNormal);

   CComPtr<IPoint2d> pntAlignment;
   alignment->LocatePoint(CComVariant(station),omtAlongDirection,0.00,CComVariant(normal),&pntAlignment);

   CComPtr<IVector2d> v;
   v.CoCreateInstance(CLSID_Vector2d);
   v->put_Direction(dirNormal);

   CComPtr<ILine2d> line;
   line.CoCreateInstance(CLSID_Line2d);
   line->SetExplicit(pntAlignment,v);

   SpaceBetweenGirder gdrSpacing;
   gdrSpacing.firstGdrIdx = 0;
   gdrSpacing.lastGdrIdx  = 0;
   gdrSpacing.spacing     = -1;

   CComPtr<IPoint2d> pntIntersection1;
   SegmentIndexType segIdx = GetSegmentIndex(CGirderKey(grpIdx,0),line,&pntIntersection1);
   if ( segIdx == INVALID_INDEX )
   {
      return std::vector<SpaceBetweenGirder>();
   }

   for ( GirderIndexType gdrIdx = 1; gdrIdx < nGirders; gdrIdx++ )
   {
      CComPtr<IPoint2d> pntIntersection2;
      segIdx = GetSegmentIndex(CGirderKey(grpIdx,gdrIdx),line,&pntIntersection2);
      if ( segIdx == INVALID_INDEX )
      {
         return std::vector<SpaceBetweenGirder>();
      }

      Float64 space;
      pntIntersection1->DistanceEx(pntIntersection2,&space);
      gdrSpacing.lastGdrIdx++;

      if ( !IsEqual(gdrSpacing.spacing,space) )
      {
         // this is a new spacing
         gdrSpacing.spacing = space; // save it
         vSpacing.push_back(gdrSpacing);
      }
      else
      {
         // this space is the same as the previous one... change the lastGdrIdx
         vSpacing.back().lastGdrIdx = gdrSpacing.lastGdrIdx;
      }

      gdrSpacing.firstGdrIdx = gdrSpacing.lastGdrIdx;

      pntIntersection1 = pntIntersection2;
   }

   return vSpacing;
}

std::vector<SpaceBetweenGirder> CBridgeAgentImp::GetGirderSpacingAtBottomClGirder(Float64 station) const
{
   // We will be calling GetGirderSpacing, but first need to know which group we are in...
   VALIDATE(GIRDER);
   std::vector<SpaceBetweenGirder> vSpacing;

   GET_IFACE(IBridgeDescription, pIBridgeDesc);
   const CBridgeDescription2* pBridgeDesc = pIBridgeDesc->GetBridgeDescription();
   GroupIndexType nGroups = pBridgeDesc->GetGirderGroupCount();
   const CGirderGroupData* pGroup = nullptr;
   for (GroupIndexType grpIdx = 0; grpIdx < nGroups; grpIdx++)
   {
      const CGirderGroupData* pThisGroup = pBridgeDesc->GetGirderGroup(grpIdx);
      Float64 startStation = pThisGroup->GetPier(pgsTypes::metStart)->GetStation();
      Float64 endStation = pThisGroup->GetPier(pgsTypes::metEnd)->GetStation();
      if (::InRange(startStation, station, endStation))
      {
         pGroup = pThisGroup;
         break;
      }
   }

   if (pGroup == nullptr)
   {
      return vSpacing;
   }

   GroupIndexType grpIdx = pGroup->GetIndex();

   GirderIndexType ngdrs = pGroup->GetGirderCount();
   if (ngdrs < 2)
   {
      return vSpacing;
   }

   // Get the spacing at top CL girders
   std::vector<SpaceBetweenGirder> topClSpacings = GetGirderSpacing(station);
   if (topClSpacings.empty())
   {
      return vSpacing;
   }

   pgsTypes::GirderOrientationType orientationType = pBridgeDesc->GetGirderOrientation();
   if (orientationType == pgsTypes::Plumb)
   {
      return topClSpacings; // top and bottom spacing are identical for plumb girders
   }

   // build a list of girder orientation shift values for each girder
   std::vector<Float64> girderShifts;
   girderShifts.reserve(ngdrs);
   for (GirderIndexType igdr = 0; igdr < ngdrs; igdr++)
   {
      CSegmentKey segKey(grpIdx, igdr, 0); // just use segment 0 since all segments in a group are oriented and shifted the same

      girderShifts.push_back( GetWorkPointShiftOffset(segKey) );
   }

   // explode (ungroup) top spacings
   std::vector<SpaceBetweenGirder> explodedTopClSpacings;
   explodedTopClSpacings.reserve(ngdrs - 1);
   for (const auto& spacing : topClSpacings)
   {
      for (GirderIndexType idx = spacing.firstGdrIdx; idx < spacing.lastGdrIdx; idx++)
      {
         SpaceBetweenGirder newSpace;
         newSpace.firstGdrIdx = idx;
         newSpace.lastGdrIdx = idx + 1;
         newSpace.spacing = spacing.spacing;
         explodedTopClSpacings.push_back(newSpace);
      }
   }

   // Cycle over exploded spacings accounting that a change in shift will change spacing
   Float64 prev_shift = girderShifts[0];
   GirderIndexType curGdrIdx = 1;
   for (const auto& spacing : explodedTopClSpacings)
   {
      Float64 curr_shift = girderShifts[curGdrIdx];
      SpaceBetweenGirder newSpace = spacing;

      newSpace.spacing -= (prev_shift - curr_shift);

      vSpacing.push_back(newSpace);

      prev_shift = curr_shift;
      curGdrIdx++;
   }

   return vSpacing;
}

std::vector<Float64> CBridgeAgentImp::GetGirderSpacing(SpanIndexType spanIdx,Float64 Xspan) const
{
   // Get the spacing between girders at the specified location. Spacing is measured normal to the alignment.
   // Identical adjacent spaces are grouped together

   // NOTE: this should be delegated to Generic Bridge Model or Bridge Geometry Model

   VALIDATE( GIRDER );
   std::vector<Float64> vSpacing;

   GET_IFACE(IBridgeDescription,pIBridgeDesc);
   const CBridgeDescription2* pBridgeDesc = pIBridgeDesc->GetBridgeDescription();
   const CSpanData2* pSpan = pBridgeDesc->GetSpan(spanIdx);
   const CGirderGroupData* pGroup = pBridgeDesc->GetGirderGroup(pSpan);

   GroupIndexType grpIdx = pGroup->GetIndex();
   GirderIndexType nGirders = pGroup->GetGirderCount();

   if ( nGirders <= 1 )
   {
      return vSpacing;
   }

   const CPierData2* pPier = pSpan->GetPier(pgsTypes::metStart);
   Float64 station = pPier->GetStation();
   station += Xspan;

   CComPtr<IAlignment> alignment;
   GetAlignment(&alignment);

   CComPtr<IDirection> normal;
   alignment->GetNormal(CComVariant(station),&normal);
   Float64 dirNormal;
   normal->get_Value(&dirNormal);

   CComPtr<IPoint2d> pntAlignment;
   alignment->LocatePoint(CComVariant(station),omtAlongDirection,0.00,CComVariant(normal),&pntAlignment);

   CComPtr<IVector2d> v;
   v.CoCreateInstance(CLSID_Vector2d);
   v->put_Direction(dirNormal);

   CComPtr<ILine2d> line;
   line.CoCreateInstance(CLSID_Line2d);
   line->SetExplicit(pntAlignment,v);

   CComPtr<IPoint2d> pntIntersection1;
   SegmentIndexType segIdx = GetSegmentIndex(CGirderKey(grpIdx,0),line,&pntIntersection1);
   if ( segIdx == INVALID_INDEX )
   {
      return std::vector<Float64>();
   }

   for ( GirderIndexType gdrIdx = 1; gdrIdx < nGirders; gdrIdx++ )
   {
      CComPtr<IPoint2d> pntIntersection2;
      segIdx = GetSegmentIndex(CGirderKey(grpIdx,gdrIdx),line,&pntIntersection2);
      if ( segIdx == INVALID_INDEX )
      {
         return std::vector<Float64>();
      }

      Float64 space;
      pntIntersection1->DistanceEx(pntIntersection2,&space);

      vSpacing.push_back(space);

      pntIntersection1 = pntIntersection2;
   }

   return vSpacing;
}

void CBridgeAgentImp::GetSpacingAlongGirder(const CGirderKey& girderKey,Float64 Xg,Float64* leftSpacing,Float64* rightSpacing) const
{
   pgsPointOfInterest poi = ConvertGirderCoordinateToPoi(girderKey,Xg);
   GetSpacingAlongGirder(poi,leftSpacing,rightSpacing);
}

void CBridgeAgentImp::GetSpacingAlongGirder(const pgsPointOfInterest& poi,Float64* leftSpacing,Float64* rightSpacing) const
{
   const CSegmentKey& segmentKey = poi.GetSegmentKey();
   Float64 Xpoi = poi.GetDistFromStart();

   GirderIDType leftGdrID, gdrID, rightGdrID;
   ::GetAdjacentSuperstructureMemberIDs(segmentKey,&leftGdrID,&gdrID,&rightGdrID);

   m_BridgeGeometryTool->GirderSpacingBySSMbr(m_Bridge,gdrID,Xpoi,leftGdrID, leftSpacing);
   m_BridgeGeometryTool->GirderSpacingBySSMbr(m_Bridge,gdrID,Xpoi,rightGdrID,rightSpacing);
}

std::vector<std::pair<SegmentIndexType,Float64>> CBridgeAgentImp::GetSegmentLengths(const CSpanKey& spanKey) const
{
   // NOTE: this method looks like it is something that should be in WBFLBridgeGeometry
   ASSERT_SPAN_KEY(spanKey);

   std::vector<std::pair<SegmentIndexType,Float64>> seg_lengths;

   // Returns the structural span length for (spanIdx,gdrIdx) measured along the centerline of the girder
   GET_IFACE(IBridgeDescription,pIBridgeDesc);
   const CBridgeDescription2* pBridgeDesc = pIBridgeDesc->GetBridgeDescription();

   SpanIndexType nSpans = pBridgeDesc->GetSpanCount();

   // Get the group this span belongs to
   const CGirderGroupData* pGroup = pBridgeDesc->GetGirderGroup( pBridgeDesc->GetSpan(spanKey.spanIndex) );
   GroupIndexType grpIdx = pGroup->GetIndex();
   GroupIndexType nGroups = pBridgeDesc->GetGirderGroupCount();

   // Get the girder in this group
   const CSplicedGirderData* pGirder = pGroup->GetGirder(spanKey.girderIndex);

   Float64 span_length = 0;

   // Determine which segments are part of this span
   SegmentIndexType nSegments = pGirder->GetSegmentCount();
   for ( SegmentIndexType segIdx = 0; segIdx < nSegments; segIdx++ )
   {
      const CPrecastSegmentData* pSegment = pGirder->GetSegment(segIdx);
      CSegmentKey segmentKey( pSegment->GetSegmentKey() );
      
      SpanIndexType startSpanIdx = pSegment->GetSpanIndex(pgsTypes::metStart);
      SpanIndexType endSpanIdx   = pSegment->GetSpanIndex(pgsTypes::metEnd);

      if ( startSpanIdx <= spanKey.spanIndex && spanKey.spanIndex <= endSpanIdx )
      {
         // this segment starts, ends, or is completely in the span

         Float64 distance = -99999;
         if ( startSpanIdx < spanKey.spanIndex && spanKey.spanIndex == endSpanIdx )
         {
            // segment starts in a previous span but ends in this span

            // Only count the length of segment in this span
            // Intersect the girder line for this segment with the
            // pier line at the start of this span
            // We want the distance from the intersection point to the end of the segment
            //
            //             |<----Segment---->|
            //    |        |       |         |       |
            //    |--------.-----------------.-------|
            //    |   spanIdx-1    |   spanIdx       |
            //                     |
            //                     |<------->|
            //                     |  Length of segment in this span
            //                     |
            //                     +- CL Pier

            CComPtr<ISuperstructureMemberSegment> segment;
            GetSegment(segmentKey,&segment);
            CComPtr<IGirderLine> girderLine;
            segment->get_GirderLine(&girderLine);
            CComPtr<IPath> path;
            girderLine->get_Path(&path);

            PierIndexType pierIdx = (PierIndexType)spanKey.spanIndex; // index of the pier at the start of the span
            CComPtr<IPierLine> pierLine;
            GetPierLine(pierIdx,&pierLine);
            CComPtr<ILine2d> clPier;
            pierLine->get_Centerline(&clPier);

            CComPtr<IPoint2d> pntNearest;
            pierLine->get_AlignmentPoint(&pntNearest);

            CComPtr<IPoint2d> pntIntersect;
            path->Intersect(clPier,pntNearest,&pntIntersect);

            CComPtr<IPoint2d> pntSegmentEnd;
            girderLine->get_PierPoint(etEnd,&pntSegmentEnd);

            pntSegmentEnd->DistanceEx(pntIntersect,&distance); // distance from CL Pier to CL Pier/TS at right end of segment

            if ( segIdx == nSegments-1 && grpIdx == nGroups-1 && spanKey.spanIndex == nSpans-1 )
            {
               // last segment in the last group, adjust distance so that it is measured from CL-Bearing at right end of segment
               Float64 brg_offset;
               girderLine->get_BearingOffset(etEnd,&brg_offset);
               distance -= brg_offset;
            }
         }
         else if ( startSpanIdx == spanKey.spanIndex && spanKey.spanIndex < endSpanIdx )
         {
            // Segment starts in ths span but ends in a later span
            //
            // Only count the length of segment in this span
            // Intersect the girder line for this segment with the
            // pier line at the end of this span
            // We want the distance from the start of the segment to the intersection point
            //
            //             |<----Segment---->|
            //    |        |                 |       |
            //    |--------.-----------------.-------|
            //    |  spanIdx       |   spanIdx+1     |
            //                     |
            //             |<----->|
            //                 Length of segment in this span
            //                     |
            //                     +-- CL Pier

            CComPtr<ISuperstructureMemberSegment> segment;
            GetSegment(segmentKey,&segment);
            CComPtr<IGirderLine> girderLine;
            segment->get_GirderLine(&girderLine);
            CComPtr<IPath> path;
            girderLine->get_Path(&path);

            PierIndexType pierIdx = (PierIndexType)(spanKey.spanIndex+1);
            CComPtr<IPierLine> pierLine;
            GetPierLine(pierIdx,&pierLine);
            CComPtr<ILine2d> clPier;
            pierLine->get_Centerline(&clPier);

            CComPtr<IPoint2d> pntNearest;
            pierLine->get_AlignmentPoint(&pntNearest);

            CComPtr<IPoint2d> pntIntersect;
            path->Intersect(clPier,pntNearest,&pntIntersect);

            CComPtr<IPoint2d> pntSegmentStart;
            girderLine->get_PierPoint(etStart,&pntSegmentStart);

            pntSegmentStart->DistanceEx(pntIntersect,&distance); // distance from the CL Pier/TS on the left end of the segment to the CL Pier

            if ( segIdx == 0 && grpIdx == 0 && spanKey.spanIndex == 0 )
            {
               // first segment in the last group, adjust distance so that it is measured from CL-Bearing at left end of segment
               Float64 brg_offset;
               girderLine->get_BearingOffset(etStart,&brg_offset);
               distance -= brg_offset;
            }
         }
         else if ( startSpanIdx < spanKey.spanIndex && spanKey.spanIndex < endSpanIdx )
         {
            // Segments starts in a previous span and end in a later span

            // Intersect the girder line for this segment with the pier
            // lines at the start and end of the span
            //
            //             |<----------Segment--------------->|
            //    |        |       |                 |        |   |
            //    |--------.----------------------------------.---|
            //    |                |   spanIdx       |            |
            //    |                |                 |            |
            //                     |<--------------->|
            //                     |     Length of segment in this span
            //                     |                 |
            //                     |                 +--- CL Pier
            //                     +--- CL Pier

            CComPtr<ISuperstructureMemberSegment> segment;
            GetSegment(segmentKey,&segment);
            CComPtr<IGirderLine> girderLine;
            segment->get_GirderLine(&girderLine);
            CComPtr<IPath> path;
            girderLine->get_Path(&path);

            CComPtr<IPierLine> startPierLine, endPierLine;
            GetPierLine(spanKey.spanIndex,&startPierLine);
            GetPierLine(spanKey.spanIndex+1,&endPierLine);

            CComPtr<ILine2d> clStartPier, clEndPier;
            startPierLine->get_Centerline(&clStartPier);
            endPierLine->get_Centerline(&clEndPier);

            CComPtr<IPoint2d> pntNearest;
            startPierLine->get_AlignmentPoint(&pntNearest);

            CComPtr<IPoint2d> pntStartIntersect;
            path->Intersect(clStartPier,pntNearest,&pntStartIntersect);

            pntNearest.Release();
            endPierLine->get_AlignmentPoint(&pntNearest);

            CComPtr<IPoint2d> pntEndIntersect;
            path->Intersect(clEndPier,pntNearest,&pntEndIntersect);

            pntStartIntersect->DistanceEx(pntEndIntersect,&distance);
         }
         else
         {
            // segment is completely within the span
            CComPtr<IGirderLine> girderLine;
            GetGirderLine(segmentKey,&girderLine);
            girderLine->get_LayoutLength(&distance); // use the CL-Pier to CL-Pier length to account for closure joints

            if ( segIdx == 0 && grpIdx == 0 && spanKey.spanIndex == 0 )
            {
               // first segment in the first group, measure from CL-Bearing
               Float64 brg_offset;
               girderLine->get_BearingOffset(etStart,&brg_offset);
               distance -= brg_offset;
            }
            
            if ( segIdx == nSegments-1 && grpIdx == nGroups-1 && spanKey.spanIndex == nSpans-1 )
            {
               // last segment in the last group, measure from CL-Bearing
               Float64 brg_offset;
               girderLine->get_BearingOffset(etEnd,&brg_offset);
               distance -= brg_offset;
            }
         }

         ATLASSERT(0 < distance);

         seg_lengths.emplace_back(segIdx,distance);
      } // next segment

      // Once the segment starts after this span, break out of the loop
      if ( spanKey.spanIndex < startSpanIdx )
      {
         break;
      }

   } // next span

   return seg_lengths;
}

Float64 CBridgeAgentImp::GetSpanLength(SpanIndexType spanIdx,GirderIndexType gdrIdx) const
{
   return GetSpanLength(CSpanKey(spanIdx,gdrIdx));
}

Float64 CBridgeAgentImp::GetSpanLength(const CSpanKey& spanKey) const
{
   ASSERT_SPAN_KEY(spanKey);

   PierIndexType startPierIdx = (PierIndexType)spanKey.spanIndex;
   PierIndexType endPierIdx = startPierIdx + 1;
   GroupIndexType grpIdx = GetGirderGroupAtPier(startPierIdx,pgsTypes::Ahead);
   GroupIndexType nGroups = GetGirderGroupCount();
   SegmentIndexType nSegments = GetSegmentCount(grpIdx,spanKey.girderIndex);

   Float64 span_length = 0;
   std::vector<std::pair<SegmentIndexType,Float64>> seg_lengths(GetSegmentLengths(spanKey));
   std::vector<std::pair<SegmentIndexType,Float64>>::iterator iter(seg_lengths.begin());
   std::vector<std::pair<SegmentIndexType,Float64>>::iterator iterEnd(seg_lengths.end());
   for ( ; iter != iterEnd; iter++ )
   {
      span_length += (*iter).second;

      // At boundary piers, but not the first or last pier in the bridge, the segment 
      // length returned by GetSegmentLengths go to the centerline of the pier. If
      // there is a simple span boundary condition between the groups the span
      // length we want for loading is the span length to the CL Bearing, not CL Pier.
      // Adjust the segment length with the bearing offset.
      // This adjustment as already been made for the first segment in the first group
      // and the last segment in the last group

      if ( (*iter).first == 0 && grpIdx != 0 )
      {
         // this is the first segment in a group (but not the first group)
         bool bContinuousBack, bContinuousAhead;
         IsContinuousAtPier(startPierIdx,&bContinuousBack,&bContinuousAhead);
         bool bIntegralBack, bIntegralAhead;
         IsIntegralAtPier(startPierIdx,&bIntegralBack,&bIntegralAhead);
         if ( !(bContinuousAhead || bIntegralAhead) )
         {
            CSegmentKey segmentKey(grpIdx,spanKey.girderIndex,(*iter).first);
            Float64 brgOffset = GetSegmentStartBearingOffset(segmentKey);
            span_length -= brgOffset;
         }
      }

      if ( (*iter).first == nSegments-1 && grpIdx != nGroups-1 )
      {
         // this is the last segment in a group (but not the last group)
         bool bContinuousBack, bContinuousAhead;
         IsContinuousAtPier(endPierIdx,&bContinuousBack,&bContinuousAhead);
         bool bIntegralBack, bIntegralAhead;
         IsIntegralAtPier(endPierIdx,&bIntegralBack,&bIntegralAhead);
         if ( !(bContinuousBack || bIntegralBack) )
         {
            CSegmentKey segmentKey(grpIdx,spanKey.girderIndex,(*iter).first);
            Float64 brgOffset = GetSegmentEndBearingOffset(segmentKey);
            span_length -= brgOffset;
         }
      }
   }

   return span_length;
}

Float64 CBridgeAgentImp::GetFullSpanLength(const CSpanKey& spanKey) const
{
   Float64 span_length = 0;
   std::vector<std::pair<SegmentIndexType,Float64>> seg_lengths(GetSegmentLengths(spanKey));
   std::vector<std::pair<SegmentIndexType,Float64>>::iterator iter(seg_lengths.begin());
   std::vector<std::pair<SegmentIndexType,Float64>>::iterator iterEnd(seg_lengths.end());
   for ( ; iter != iterEnd; iter++ )
   {
      span_length += (*iter).second;
   }
   return span_length;
}

Float64 CBridgeAgentImp::GetGirderlineLength(GirderIndexType gdrLineIdx) const
{
   Float64 Lgl = 0;
   GroupIndexType nGroups = GetGirderGroupCount();
   for ( GroupIndexType grpIdx = 0; grpIdx < nGroups; grpIdx++ )
   {
      GirderIndexType nGirders = GetGirderCount(grpIdx);
      CGirderKey girderKey(grpIdx,Min(gdrLineIdx,nGirders-1));
      Float64 Lg = GetGirderLength(girderKey);
      Lgl += Lg;
   }
   return Lgl;
}

Float64 CBridgeAgentImp::GetCantileverLength(SpanIndexType spanIdx,GirderIndexType gdrIdx,pgsTypes::MemberEndType endType) const
{
   ATLASSERT(spanIdx != ALL_SPANS && gdrIdx != ALL_GIRDERS);

   // Since cantilevers can only happen on the first or last spans, we can easily infer the segment key
   GET_IFACE(IBridgeDescription, pIBridgeDesc);
   SpanIndexType nSpans = pIBridgeDesc->GetSpanCount();

   if (spanIdx != 0 || spanIdx != nSpans - 1)
   {
      return 0;
   }

   CSegmentKey segmentKey(0, gdrIdx, 0);
   if (0 < spanIdx || (spanIdx == nSpans-1 && endType == pgsTypes::metEnd))
   {
      GroupIndexType nGroups = pIBridgeDesc->GetGirderGroupCount();
      const CSplicedGirderData* pGirder = pIBridgeDesc->GetGirder(CGirderKey(nGroups - 1, gdrIdx));
      SegmentIndexType nSegments = pGirder->GetSegmentCount();
      segmentKey.groupIndex = nGroups - 1;
      segmentKey.segmentIndex = nSegments - 1;
   }
   bool bStartCantilever, bEndCantilever;
   ModelCantilevers(segmentKey, &bStartCantilever, &bEndCantilever);
   bool bCantilever = (endType == pgsTypes::metStart ? bStartCantilever : bEndCantilever);

   if ( !bCantilever)
   {
      return 0;
   }


   Float64 Lc = 0;
   if ( endType == pgsTypes::metStart )
   {
      Lc = GetSegmentStartEndDistance(segmentKey);
   }
   else
   {
      Lc = GetSegmentEndEndDistance(segmentKey);
   }

// RAB: Commented out this check because it causes errors in the Validate method for certain bridge types
// A specific example is the regression test file PGSplice\CantileverSplicedGirder_DeckCastingRegions.spl
//
//#if defined _DEBUG
//   Float64 LcTest;
//   if ( endType == pgsTypes::metStart )
//   {
//      PoiList vPoi;
//      GetPointsOfInterest(segmentKey, POI_START_FACE,&vPoi);
//      ATLASSERT(vPoi.size() == 1);
//      pgsPointOfInterest poiStart = vPoi.front();
//
//      vPoi.clear();
//      GetPointsOfInterest(segmentKey, POI_0L | POI_ERECTED_SEGMENT, &vPoi);
//      ATLASSERT(vPoi.size() == 1);
//      pgsPointOfInterest poiEnd = vPoi.front();
//
//      LcTest = poiEnd.GetDistFromStart() - poiStart.GetDistFromStart();
//   }
//   else
//   {
//      PoiList vPoi;
//      GetPointsOfInterest(segmentKey, POI_10L | POI_ERECTED_SEGMENT, &vPoi);
//      ATLASSERT(vPoi.size() == 1);
//      pgsPointOfInterest poiStart = vPoi.front();
//
//      vPoi.clear();
//      GetPointsOfInterest(segmentKey, POI_END_FACE,&vPoi);
//      ATLASSERT(vPoi.size() == 1);
//      pgsPointOfInterest poiEnd = vPoi.front();
//
//      LcTest = poiEnd.GetDistFromStart() - poiStart.GetDistFromStart();
//   }
//   ATLASSERT(IsEqual(Lc,LcTest));
//#endif // _DEBUG

   return Lc;
}

Float64 CBridgeAgentImp::GetCantileverLength(const CSpanKey& spanKey,pgsTypes::MemberEndType endType) const
{
   ASSERT_SPAN_KEY(spanKey);
   return GetCantileverLength(spanKey.spanIndex,spanKey.girderIndex,endType);
}

Float64 CBridgeAgentImp::GetSegmentStartEndDistance(const CSegmentKey& segmentKey) const
{
   // distance from CL Bearing to start of girder, measured along CL Girder
   CComPtr<IPrecastGirder> girder;
   GetGirder(segmentKey,&girder);
   Float64 length;
   girder->get_LeftEndDistance(&length);
   return length;
}

Float64 CBridgeAgentImp::GetSegmentEndEndDistance(const CSegmentKey& segmentKey) const
{
   // distance from CL Bearing to end of girder, measured along CL Girder
   CComPtr<IPrecastGirder> girder;
   GetGirder(segmentKey,&girder);
   Float64 length;
   girder->get_RightEndDistance(&length);
   return length;
}

Float64 CBridgeAgentImp::GetSegmentOffset(const CSegmentKey& segmentKey,Float64 station) const
{
   VALIDATE( GIRDER );
   Float64 offset;
   HRESULT hr = m_BridgeGeometryTool->GirderPathOffset(m_Bridge,::GetSuperstructureMemberID(segmentKey.groupIndex,segmentKey.girderIndex),segmentKey.segmentIndex,CComVariant(station),&offset);
   ATLASSERT( SUCCEEDED(hr) );
   return offset;
}

void CBridgeAgentImp::GetPoiLocation(const pgsPointOfInterest& poi, Float64* pStation, Float64* pOffset, IPoint2d** ppLocal, IPoint2d** ppGlobal) const
{
   VALIDATE(BRIDGE);
   PoiLocation location;
   location.ID = poi.GetID();
   auto found = m_pPoiLocationCache->find(location);
   if (found == m_pPoiLocationCache->end())
   {
      const CSegmentKey& segmentKey(poi.GetSegmentKey());
      Float64 Xpoi = poi.GetDistFromStart();

      Float64 station, offset;
      CComPtr<IPoint2d> pntLocal, pntGlobal;

      CComPtr<IPoint2d> pntPier1, pntEnd1, pntBrg1, pntBrg2, pntEnd2, pntPier2;
      GetSegmentEndPoints(segmentKey, pgsTypes::pcLocal, &pntPier1, &pntEnd1, &pntBrg1, &pntBrg2, &pntEnd2, &pntPier2); // in local coordinates

      CComPtr<ILocate2> locate;
      m_CogoEngine->get_Locate(&locate);
      HRESULT hr = locate->PointOnLine(pntEnd1, pntEnd2, Xpoi, 0.0, &pntLocal);
      ATLASSERT(SUCCEEDED(hr));

      pntLocal->Clone(&pntGlobal);
      pntGlobal->Offset(m_DeltaX, m_DeltaY);

      GetStationAndOffset(pgsTypes::pcLocal, pntLocal, &station, &offset);

      *pStation = station;
      *pOffset = offset;
      pntLocal->Clone(ppLocal);
      pntGlobal->Clone(ppGlobal);

      if (location.ID != INVALID_ID)
      {
         // only cache if the POI has a valid ID
         location.Station = station;
         location.Offset = offset;
         location.pntLocal = pntLocal;
         location.pntGlobal = pntGlobal;

         auto result = m_pPoiLocationCache->insert(location);
         ATLASSERT(result.second == true);
      }
   }
   else
   {
      const auto& poiLocation(*found);
      *pStation = poiLocation.Station;
      *pOffset = poiLocation.Offset;
      poiLocation.pntLocal->Clone(ppLocal);
      poiLocation.pntGlobal->Clone(ppGlobal);
   }
}

void CBridgeAgentImp::GetPoint(const CSegmentKey& segmentKey,Float64 Xpoi,pgsTypes::PlanCoordinateType pcType,IPoint2d** ppPoint) const
{
   VALIDATE( BRIDGE );
   CComPtr<IPoint2d> pntPier1,pntEnd1,pntBrg1,pntBrg2,pntEnd2,pntPier2;
   GetSegmentEndPoints(segmentKey,pcType,&pntPier1,&pntEnd1,&pntBrg1,&pntBrg2,&pntEnd2,&pntPier2);

   CComPtr<ILocate2> locate;
   m_CogoEngine->get_Locate(&locate);
   HRESULT hr = locate->PointOnLine(pntEnd1,pntEnd2,Xpoi,0.0,ppPoint);
   ATLASSERT( SUCCEEDED(hr) );
}

void CBridgeAgentImp::GetPoint(const pgsPointOfInterest& poi,pgsTypes::PlanCoordinateType pcType,IPoint2d** ppPoint) const
{
   Float64 station, offset;
   CComPtr<IPoint2d> pntLocal, pntGlobal;
   GetPoiLocation(poi, &station, &offset, &pntLocal, &pntGlobal);
   if (pcType == pgsTypes::pcLocal)
   {
      pntLocal->Clone(ppPoint);
   }
   else
   {
      pntGlobal->Clone(ppPoint);
   }
}

bool CBridgeAgentImp::GetSegmentPierIntersection(const CSegmentKey& segmentKey,PierIndexType pierIdx,pgsTypes::PlanCoordinateType pcType,IPoint2d** ppPoint) const
{
   VALIDATE(BRIDGE);
   CComPtr<IGirderLine> girderLine;
   GetGirderLine(segmentKey,&girderLine);

   CComPtr<IPierLine> pierLine;
   GetPierLine(pierIdx,&pierLine);

   CComPtr<IPath> path;
   girderLine->get_Path(&path);

   CComPtr<ILine2d> line;
   pierLine->get_Centerline(&line);

   CComPtr<IPoint2d> nearest;
   pierLine->get_AlignmentPoint(&nearest);

   HRESULT hr = path->IntersectEx(line,nearest,VARIANT_FALSE,VARIANT_FALSE,ppPoint);
   if ( FAILED(hr) )
   {
      return false;
   }

   if ( pcType == pgsTypes::pcGlobal )
   {
      (*ppPoint)->Offset(m_DeltaX,m_DeltaY);
   }

   return true;
}

bool CBridgeAgentImp::GetSegmentTempSupportIntersection(const CSegmentKey& segmentKey,SupportIndexType tsIdx,pgsTypes::PlanCoordinateType pcType,IPoint2d** ppPoint) const
{
   VALIDATE(BRIDGE);
   CComPtr<IGirderLine> girderLine;
   GetGirderLine(segmentKey,&girderLine);

   // recall that temporary supports are modeled with pier line objects in the bridge geometry model
   CComPtr<IPierLine> pierLine;
   GetTemporarySupportLine(tsIdx,&pierLine);

   CComPtr<IPath> path;
   girderLine->get_Path(&path);

   CComPtr<ILine2d> line;
   pierLine->get_Centerline(&line);

   CComPtr<IPoint2d> nearest;
   pierLine->get_AlignmentPoint(&nearest);

   HRESULT hr = path->IntersectEx(line,nearest,VARIANT_FALSE,VARIANT_FALSE,ppPoint);
   if ( FAILED(hr) )
   {
      return false;
   }

   if ( pcType == pgsTypes::pcGlobal )
   {
      (*ppPoint)->Offset(m_DeltaX,m_DeltaY);
   }

   return true;
}

void CBridgeAgentImp::GetStationAndOffset(const CSegmentKey& segmentKey,Float64 Xpoi,Float64* pStation,Float64* pOffset) const
{
   VALIDATE( BRIDGE );

   CComPtr<IPoint2d> point;
   GetPoint(segmentKey,Xpoi,pgsTypes::pcLocal,&point);

   GetStationAndOffset(pgsTypes::pcLocal,point,pStation,pOffset);
}

void CBridgeAgentImp::GetStationAndOffset(const pgsPointOfInterest& poi,Float64* pStation,Float64* pOffset) const
{
   CComPtr<IPoint2d> pntLocal, pntGlobal;
   GetPoiLocation(poi, pStation, pOffset, &pntLocal, &pntGlobal);
}

Float64 CBridgeAgentImp::ConvertSegmentToBridgeLineCoordinate(const CSegmentKey& segmentKey,Float64 Xs) const
{
   return ConvertPoiToBridgeLineCoordinate(pgsPointOfInterest(segmentKey,Xs));
}

bool CBridgeAgentImp::IsInteriorGirder(const CGirderKey& girderKey) const
{
   CComPtr<ISuperstructureMember> ssMbr;
   GetSuperstructureMember(girderKey,&ssMbr);

   LocationType location;
   ssMbr->get_LocationType(&location);

   return location == ltInteriorGirder ? true : false;
}

bool CBridgeAgentImp::IsExteriorGirder(const CGirderKey& girderKey) const
{
   return !IsInteriorGirder(girderKey);
}

bool CBridgeAgentImp::IsLeftExteriorGirder(const CGirderKey& girderKey) const
{
   CComPtr<ISuperstructureMember> ssMbr;
   GetSuperstructureMember(girderKey,&ssMbr);

   LocationType location;
   ssMbr->get_LocationType(&location);

   return location == ltLeftExteriorGirder ? true : false;
}

bool CBridgeAgentImp::IsRightExteriorGirder(const CGirderKey& girderKey) const
{
   CComPtr<ISuperstructureMember> ssMbr;
   GetSuperstructureMember(girderKey,&ssMbr);

   LocationType location;
   ssMbr->get_LocationType(&location);

   return location == ltRightExteriorGirder ? true : false;
}

bool CBridgeAgentImp::IsObtuseCorner(const CSpanKey& spanKey,pgsTypes::MemberEndType endType) const
{
   GET_IFACE(IBridgeDescription,pIBridgeDesc);
   const CBridgeDescription2* pBridgeDesc = pIBridgeDesc->GetBridgeDescription();
   const CSpanData2* pSpan = pBridgeDesc->GetSpan(spanKey.spanIndex);
   GirderIndexType nGirders = pSpan->GetGirderCount();

   // in general, only the exterior and first interior girders are correctable
   bool bIsLeftSideCorrectableGirder = (spanKey.girderIndex < 2 ? true : false);
   bool bIsRightSideCorrectableGirder = (nGirders-2 <= spanKey.girderIndex ? true : false);
   if ( IsNonstructuralDeck(pBridgeDesc->GetDeckDescription()->GetDeckType()) )
   {
      // There is not a composite deck so we consider this a deck system bridge.
      // Per LRFD 4.6.2.2.3c (2014) "In determining the end shear in deck system
      // bridges, the skew correction at the obtuse corner shall be applied to
      // all the beams". 
      bIsLeftSideCorrectableGirder  = true;
      bIsRightSideCorrectableGirder = true;
   }

   if ( !bIsLeftSideCorrectableGirder && !bIsRightSideCorrectableGirder )
   {
      // girder is not skew corrected so say we are not in an obtuse corner
      return false;
   }
   else
   {
      PierIndexType startPierIdx = pSpan->GetPrevPier()->GetIndex();
      PierIndexType endPierIdx   = pSpan->GetNextPier()->GetIndex();

      CComPtr<IAngle> objStartSkewAngle;
      GetPierSkew(startPierIdx,&objStartSkewAngle);
      Float64 startSkewAngle;
      objStartSkewAngle->get_Value(&startSkewAngle);

      CComPtr<IAngle> objEndSkewAngle;
      GetPierSkew(endPierIdx,&objEndSkewAngle);
      Float64 endSkewAngle;
      objEndSkewAngle->get_Value(&endSkewAngle);

      if ( IsZero(startSkewAngle) && IsZero(endSkewAngle) )
      {
         return false;
      }

      if ( ::Sign(startSkewAngle) == ::Sign(endSkewAngle) )
      {
         // Both ends are skewed the same direction
         if ( startSkewAngle < 0 )
         {
            // Both ends are skewed to the right

            //              --------------------------------------
            //             / -***------ gdrIdx = 0 ------------- /
            //            / -***------ gdrIdx = 1 ------------- /
            //           /                                     /
            //          /                                     /
            //         / ------ gdrIdx = nGirders-2-----***- /
            //        / ------ gdrIdx = nGirders-1 ----***- /
            //        --------------------------------------
            //
            // *** = Obtuse corner
            //
            if ( (endType == pgsTypes::metStart && bIsLeftSideCorrectableGirder) ||
                 (endType == pgsTypes::metEnd   && bIsRightSideCorrectableGirder )
               )
            {
               return true;
            }
         }
         else
         {
            // both ends are skewed to the left
            ATLASSERT(0 < startSkewAngle);
            ATLASSERT(0 < endSkewAngle);

            //   --------------------------------------
            //   \ ---------- gdrIdx = 0 ---------***- \
            //    \ ---------- gdrIdx = 1 ---------***- \
            //     \                                     \
            //      \                                     \
            //       \ -***-- gdrIdx = nGirders-2--------- \
            //        \ -***-- gdrIdx = nGirders-1 -------- \
            //         --------------------------------------
            //
            // *** = Obtuse corner
            //
            if ( (endType == pgsTypes::metStart && bIsRightSideCorrectableGirder) ||
                 (endType == pgsTypes::metEnd   && bIsLeftSideCorrectableGirder)
               )
            {
               return true;
            }
         }
      }
      else
      {
         // Ends are skewed in opposite directions
         //
         // Obtuse corners are the diagonally opposite corners that are closest together
         // (i.e. shortest distance)

         //   --------------------------------------------------
         //   \ ---------- gdrIdx = 0 ------------------------ /
         //    \ ---------- gdrIdx = 1 ---------------------- /
         //     \                                            /
         //      \                                          /
         //       \ ------ gdrIdx = nGirders-2------------ /
         //        \ ------ gdrIdx = nGirders-1 --------- /
         //         --------------------------------------

         if ( IsZero(startSkewAngle) )
         {
            // start of span is normal to alignment
            if ( endType == pgsTypes::metStart )
            {
               // can't have an obtuse corner for no skew
               return false;
            }

            ATLASSERT( !IsZero(endSkewAngle) );
            if ( (0 < endSkewAngle && bIsLeftSideCorrectableGirder) ||
                 (endSkewAngle < 0 && bIsRightSideCorrectableGirder) )
            {
               return true;
            }
            else
            {
               return false;
            }
         }

         if ( IsZero(endSkewAngle) )
         {
            // end of span is normal to alignment
            if ( endType == pgsTypes::metEnd )
            {
               // can't have an obtuse corner for no skew
               return false;
            }

            ATLASSERT( !IsZero(startSkewAngle) );
            if ( (0 < startSkewAngle && bIsRightSideCorrectableGirder) ||
                 (startSkewAngle < 0 && bIsLeftSideCorrectableGirder) )
            {
               return true;
            }
            else
            {
               return false;
            }
         }

         GroupIndexType grpIdx = GetGirderGroupAtPier((PierIndexType)spanKey.spanIndex,pgsTypes::Ahead);
         pgsPointOfInterest poiStartLeft  = GetPierPointOfInterest(CGirderKey(grpIdx,0),startPierIdx);
         pgsPointOfInterest poiEndLeft    = GetPierPointOfInterest(CGirderKey(grpIdx,0),endPierIdx);
         pgsPointOfInterest poiStartRight = GetPierPointOfInterest(CGirderKey(grpIdx,nGirders-1),startPierIdx);
         pgsPointOfInterest poiEndRight   = GetPierPointOfInterest(CGirderKey(grpIdx,nGirders-1),endPierIdx);

         CComPtr<IPoint2d> pntStartLeft, pntEndLeft, pntStartRight, pntEndRight;
         GetPoint(poiStartLeft,  pgsTypes::pcLocal, &pntStartLeft);
         GetPoint(poiEndLeft,    pgsTypes::pcLocal, &pntEndLeft);
         GetPoint(poiStartRight, pgsTypes::pcLocal, &pntStartRight);
         GetPoint(poiEndRight,   pgsTypes::pcLocal, &pntEndRight);

         Float64 d1,d2;
         pntStartLeft->DistanceEx(pntEndRight,&d1);
         pntStartRight->DistanceEx(pntEndLeft,&d2);

         if ( IsEqual(d1,d2) )
         {
            // if the diagonals are the same length... both corners on one side are obtuse
            if ( startSkewAngle < 0 )
            {
               // obtuse corners are on the left side
               ATLASSERT( 0 <= endSkewAngle );
               if ( bIsLeftSideCorrectableGirder )
               {
                  return true;
               }
            }
            else
            {
               // obtuse corners are on the right side
               ATLASSERT( 0 <= startSkewAngle);
               ATLASSERT( endSkewAngle < 0 );
               if ( bIsRightSideCorrectableGirder )
               {
                  return true;
               }
            }
         }
         else if ( d1 < d2 )
         {
            // shortest distance is from start,left to end,right so obtuse corners are
            // at the start,right and end,left
            if ( (endType == pgsTypes::metStart && bIsLeftSideCorrectableGirder) ||
                 (endType == pgsTypes::metEnd && bIsRightSideCorrectableGirder) )
            {
               return true;
            }
         }
         else
         {
            ATLASSERT(d2 < d1);
            // shortest distance is from the start,right to end,left so the obtuse corners are
            // at the start,left and end,right
            if ( (endType == pgsTypes::metStart && bIsRightSideCorrectableGirder) ||
                 (endType == pgsTypes::metEnd && bIsLeftSideCorrectableGirder) )
            {
               return true;
            }
         }
      }
   }

   return false;
}

void CBridgeAgentImp::GetPierDiaphragmSize(PierIndexType pierIdx,pgsTypes::PierFaceType pierFace,Float64* pW,Float64* pH) const
{
   VALIDATE( BRIDGE );
   GET_IFACE(IBridgeDescription,pIBridgeDesc);
   const CBridgeDescription2* pBridgeDesc = pIBridgeDesc->GetBridgeDescription();
   const CPierData2* pPierData = pBridgeDesc->GetPier(pierIdx);
   ATLASSERT( pPierData );

   *pH = pPierData->GetDiaphragmHeight(pierFace);
   *pW = pPierData->GetDiaphragmWidth(pierFace);
   
   if ( *pH < 0 )
   {
      *pH = ComputePierDiaphragmHeight(pierIdx,pierFace);
   }

   if ( *pW < 0 )
   {
      *pW = ComputePierDiaphragmWidth(pierIdx,pierFace);
      if ( pPierData->IsInteriorPier() )
      {
         // see note above
         *pW /= 2;
      }
   }
}

Float64 CBridgeAgentImp::GetSegmentStartBearingOffset(const CSegmentKey& segmentKey) const
{
   // returns distance from CL pier to the bearing line,
   // measured along CL girder
   CComPtr<IPrecastGirder> girder;
   GetGirder(segmentKey,&girder);
   Float64 length;
   girder->get_LeftBearingOffset(&length);
   return length;
}

Float64 CBridgeAgentImp::GetSegmentEndBearingOffset(const CSegmentKey& segmentKey) const
{
   // returns distance from CL pier to the bearing line,
   // measured along CL girder
   CComPtr<IPrecastGirder> girder;
   GetGirder(segmentKey,&girder);
   Float64 length;
   girder->get_RightBearingOffset(&length);
   return length;
}

Float64 CBridgeAgentImp::GetSegmentStartSupportWidth(const CSegmentKey& segmentKey) const
{
   // returns the support width
   // measured along the CL girder
   Float64 support_width;
   GET_IFACE(IBridgeDescription,pIBridgeDesc);
   const CBridgeDescription2* pBridgeDesc = pIBridgeDesc->GetBridgeDescription();

   if (pBridgeDesc->GetBearingType() == pgsTypes::brtBridge)
   {
      // bearing data the same bridge-wide
      return pBridgeDesc->GetBearingData()->Length;
   }
   else
   {
      const CPrecastSegmentData* pSegment = pIBridgeDesc->GetPrecastSegmentData(segmentKey);
      const CClosureJointData* pClosure = pSegment->GetClosureJoint(pgsTypes::metStart);
      if (pClosure)
      {
         if (pClosure->GetPier())
         {
            support_width = pClosure->GetPier()->GetSupportWidth(segmentKey.girderIndex, pgsTypes::Ahead);
         }
         else
         {
            ATLASSERT(0); // probably should never be called for temp supports
            support_width = 0.0;
         }
      }
      else
      {
         const CSpanData2* pSpan = pSegment->GetSpan(pgsTypes::metStart);
         support_width = pSpan->GetPrevPier()->GetSupportWidth(segmentKey.girderIndex, pgsTypes::Ahead);
      }

      return support_width;
   }
}

Float64 CBridgeAgentImp::GetSegmentEndSupportWidth(const CSegmentKey& segmentKey) const
{
   // returns the support width
   // measured along the CL girder
   Float64 support_width;
   GET_IFACE(IBridgeDescription,pIBridgeDesc);
   const CBridgeDescription2* pBridgeDesc = pIBridgeDesc->GetBridgeDescription();

   if (pBridgeDesc->GetBearingType() == pgsTypes::brtBridge)
   {
      return pBridgeDesc->GetBearingData()->Length;
   }
   else
   {
      const CPrecastSegmentData* pSegment = pIBridgeDesc->GetPrecastSegmentData(segmentKey);
      const CClosureJointData* pClosure = pSegment->GetClosureJoint(pgsTypes::metEnd);
      if (pClosure)
      {
         if (pClosure->GetPier())
         {
            support_width = pClosure->GetPier()->GetSupportWidth(segmentKey.girderIndex, pgsTypes::Back);
         }
         else
         {
            ATLASSERT(0); // probably should never be called for temp supports
            support_width = 0.0;
         }
      }
      else
      {
         const CSpanData2* pSpan = pSegment->GetSpan(pgsTypes::metEnd);
         support_width = pSpan->GetNextPier()->GetSupportWidth(segmentKey.girderIndex, pgsTypes::Back);
      }

      return support_width;
   }
}

Float64 CBridgeAgentImp::GetCLPierToCLBearingDistance(const CSegmentKey& segmentKey,pgsTypes::MemberEndType endType,pgsTypes::MeasurementType measure) const
{
   VALIDATE( BRIDGE );

   Float64 dist; // distance from CL pier to CL Bearing along the CL girder
   switch( endType )
   {
      case pgsTypes::metStart: // at start of span
         dist = GetSegmentStartBearingOffset(segmentKey);
         break;

      case pgsTypes::metEnd: // at end of span
         dist = GetSegmentEndBearingOffset(segmentKey);
         break;
   }

   if ( measure == pgsTypes::NormalToItem )
   {
      // we want dist to be measured normal to the pier
      // adjust the distance
      GET_IFACE(IBridgeDescription,pIBridgeDesc);
      const CPrecastSegmentData* pSegment = pIBridgeDesc->GetPrecastSegmentData(segmentKey);

      const CPierData2* pPier;
      const CTemporarySupportData* pTS;
      pSegment->GetSupport(endType,&pPier,&pTS);

      CComPtr<IDirection> supportDirection;

      if ( pPier )
      {
         GetPierDirection(pPier->GetIndex(),&supportDirection);
      }
      else
      {
         GetTemporarySupportDirection(pTS->GetIndex(),&supportDirection);
      }


      CComPtr<IDirection> dirSegment;
      GetSegmentBearing(segmentKey,&dirSegment);

      CComPtr<IAngle> angleBetween;
      supportDirection->AngleBetween(dirSegment,&angleBetween);

      Float64 angle;
      angleBetween->get_Value(&angle);

      dist *= sin(angle);
   }


   return dist;
}

Float64 CBridgeAgentImp::GetCLPierToSegmentEndDistance(const CSegmentKey& segmentKey,pgsTypes::MemberEndType endType,pgsTypes::MeasurementType measure) const
{
   VALIDATE( BRIDGE );
   Float64 distCLPierToCLBearingAlongGirder = GetCLPierToCLBearingDistance(segmentKey,endType,pgsTypes::AlongItem);
   Float64 endDist;

   switch ( endType )
   {
   case pgsTypes::metStart: // at start of span
      endDist = GetSegmentStartEndDistance(segmentKey);
      break;

   case pgsTypes::metEnd: // at end of span
      endDist = GetSegmentEndEndDistance(segmentKey);
      break;
   }

   Float64 distCLPierToEndGirderAlongGirder = distCLPierToCLBearingAlongGirder - endDist;

   if ( measure == pgsTypes::NormalToItem )
   {
      // we want dist to be measured normal to the pier
      // adjust the distance
      GET_IFACE(IBridgeDescription,pIBridgeDesc);
      const CPrecastSegmentData* pSegment = pIBridgeDesc->GetPrecastSegmentData(segmentKey);

      const CPierData2* pPier;
      const CTemporarySupportData* pTS;
      pSegment->GetSupport(endType,&pPier,&pTS);

      CComPtr<IDirection> supportDirection;

      if ( pPier )
      {
         GetPierDirection(pPier->GetIndex(),&supportDirection);
      }
      else
      {
         GetTemporarySupportDirection(pTS->GetIndex(),&supportDirection);
      }


      CComPtr<IDirection> dirSegment;
      GetSegmentBearing(segmentKey,&dirSegment);

      CComPtr<IAngle> angleBetween;
      supportDirection->AngleBetween(dirSegment,&angleBetween);

      Float64 angle;
      angleBetween->get_Value(&angle);

      distCLPierToEndGirderAlongGirder *= sin(angle);
   }

   return distCLPierToEndGirderAlongGirder;
}

void CBridgeAgentImp::GetSegmentBearing(const CSegmentKey& segmentKey,IDirection** ppBearing) const
{
   VALIDATE( GIRDER );
   CComPtr<IGirderLine> girderLine;
   GetGirderLine(segmentKey,&girderLine);
   girderLine->get_Direction(ppBearing);
}

void CBridgeAgentImp::GetSegmentNormal(const CSegmentKey& segmentKey, IDirection** ppNormal) const
{
   GetSegmentBearing(segmentKey,ppNormal);
   (*ppNormal)->IncrementBy(CComVariant(PI_OVER_2));
}

void CBridgeAgentImp::GetSegmentAngle(const CSegmentKey& segmentKey,pgsTypes::MemberEndType endType,IAngle** ppAngle) const
{
   CComPtr<IDirection> gdrDir;
   GetSegmentBearing(segmentKey,&gdrDir);

   GET_IFACE(IBridgeDescription,pIBridgeDesc);
   const CPrecastSegmentData* pSegment = pIBridgeDesc->GetPrecastSegmentData(segmentKey);

   const CPierData2* pPier;
   const CTemporarySupportData* pTS;
   pSegment->GetSupport(endType,&pPier,&pTS);

   CComPtr<IDirection> supportDirection;

   if ( pPier )
   {
      GetPierDirection(pPier->GetIndex(),&supportDirection);
   }
   else
   {
      GetTemporarySupportDirection(pTS->GetIndex(),&supportDirection);
   }

   supportDirection->AngleBetween(gdrDir,ppAngle);
}

void CBridgeAgentImp::GetSegmentSkewAngle(const CSegmentKey& segmentKey,pgsTypes::MemberEndType endType,IAngle** ppAngle) const
{
   GetSegmentAngle(segmentKey,endType,ppAngle);
   Float64 v;
   (*ppAngle)->get_Value(&v);
   v = M_PI - v;
   (*ppAngle)->put_Value(v);
}

CSegmentKey CBridgeAgentImp::GetSegmentAtPier(PierIndexType pierIdx,const CGirderKey& girderKey) const
{
   ATLASSERT(girderKey.girderIndex != ALL_GIRDERS);

   CSegmentKey segmentKey;

   // Gets the girder segment that touches the pier 
   // When two segments touch a pier, the segment will be in the girder group defined by the girderKey
   // If both girders are in the same group, the left segment is returned
   GET_IFACE(IBridgeDescription, pIBridgeDesc);
   const CBridgeDescription2* pBridgeDesc = pIBridgeDesc->GetBridgeDescription();

   std::vector<CGirderKey> vGirderKeys;
   GetGirderline(girderKey, &vGirderKeys);
   for(const auto& thisGirderKey : vGirderKeys)
   {
      const CGirderGroupData* pGroup = pBridgeDesc->GetGirderGroup(thisGirderKey.groupIndex);
      const CSplicedGirderData* pGirder = pGroup->GetGirder(thisGirderKey.girderIndex);

      const CPierData2* pPierData = pBridgeDesc->GetPier(pierIdx);
      Float64 pierStation = pPierData->GetStation();

      SegmentIndexType nSegments = pGirder->GetSegmentCount();
      for ( SegmentIndexType segIdx = 0; segIdx < nSegments; segIdx++ )
      {
         const CPrecastSegmentData* pSegment = pGirder->GetSegment(segIdx);
         Float64 startStation,endStation;
         pSegment->GetStations(&startStation,&endStation);

         if ( ::InRange(startStation,pierStation,endStation) )
         {
            segmentKey.groupIndex = thisGirderKey.groupIndex;
            segmentKey.girderIndex = thisGirderKey.girderIndex;
            segmentKey.segmentIndex = segIdx;
            return segmentKey;
         }
      } // next segment
   } // next group

   ATLASSERT(false); // should never get here
   return segmentKey;
}

void CBridgeAgentImp::GetSegmentsAtPier(PierIndexType pierIdx, GirderIndexType gdrIdx, CSegmentKey* pBackSegmentKey, CSegmentKey* pAheadSegmentKey) const
{
   GET_IFACE(IBridgeDescription, pIBridgeDesc);
   const CPierData2* pPier = pIBridgeDesc->GetPier(pierIdx);
   if (pPier->IsInteriorPier() && (pPier->GetSegmentConnectionType() == pgsTypes::psctContinuousSegment || pPier->GetSegmentConnectionType() == pgsTypes::psctIntegralSegment))
   {
      // This method is intended to return the segment keys at a boundary pier or a pier where segments connect.
      // If this method gets called for an interior pier (segments are continuous over pier) this method should still
      // work, so here we do the work to call the GetSegmentAtPier and then return.
      GroupIndexType backGroupIdx, aheadGroupIdx;
      GetGirderGroupIndex(pierIdx, &backGroupIdx, &aheadGroupIdx);
      ATLASSERT(backGroupIdx == aheadGroupIdx);

      CGirderKey girderKey(backGroupIdx, gdrIdx);
      CSegmentKey segmentKey = GetSegmentAtPier(pierIdx, girderKey);
      *pBackSegmentKey = segmentKey;
      *pAheadSegmentKey = segmentKey;
      return;
   }

   CSegmentKey backSegmentKey, aheadSegmentKey;
   GroupIndexType backGroupIdx, aheadGroupIdx;
   GetGirderGroupIndex(pierIdx, &backGroupIdx, &aheadGroupIdx);
   if (backGroupIdx != INVALID_INDEX)
   {
      std::vector<CGirderKey> vGirderKeys;
      GetGirderline(gdrIdx, backGroupIdx, backGroupIdx, &vGirderKeys);
      ATLASSERT(vGirderKeys.size() == 1);
      const auto& thisGirderKey = vGirderKeys.front();
      SegmentIndexType nSegments = GetSegmentCount(thisGirderKey);
      for (SegmentIndexType segIdx = 0; segIdx < nSegments; segIdx++)
      {
         CSegmentKey segmentKey(thisGirderKey, segIdx);
         const CPrecastSegmentData* pSegment = pIBridgeDesc->GetPrecastSegmentData(segmentKey);
         const CPierData2* pPier;
         const CTemporarySupportData* pTS;
         pSegment->GetSupport(pgsTypes::metEnd, &pPier, &pTS);
         if (pPier && pPier->GetIndex() == pierIdx)
         {
            backSegmentKey = segmentKey;
            break;
         }
      }
   }

   if (aheadGroupIdx != INVALID_INDEX)
   {
      std::vector<CGirderKey> vGirderKeys;
      GetGirderline(gdrIdx, aheadGroupIdx, aheadGroupIdx, &vGirderKeys);
      ATLASSERT(vGirderKeys.size() == 1);
      const auto& thisGirderKey = vGirderKeys.front();
      SegmentIndexType nSegments = GetSegmentCount(thisGirderKey);
      for (SegmentIndexType segIdx = 0; segIdx < nSegments; segIdx++)
      {
         CSegmentKey segmentKey(thisGirderKey, segIdx);
         const CPrecastSegmentData* pSegment = pIBridgeDesc->GetPrecastSegmentData(segmentKey);
         const CPierData2* pPier;
         const CTemporarySupportData* pTS;
         pSegment->GetSupport(pgsTypes::metStart, &pPier, &pTS);
         if (pPier && pPier->GetIndex() == pierIdx)
         {
            aheadSegmentKey = segmentKey;
            break;
         }
      }
   }

   *pBackSegmentKey = backSegmentKey;
   *pAheadSegmentKey = aheadSegmentKey;
}

void CBridgeAgentImp::GetSpansForSegment(const CSegmentKey& segmentKey,SpanIndexType* pStartSpanIdx,SpanIndexType* pEndSpanIdx) const
{
   GET_IFACE(IBridgeDescription,pIBridgeDesc);
   const CBridgeDescription2* pBridgeDesc = pIBridgeDesc->GetBridgeDescription();
   const CPrecastSegmentData* pSegment = pBridgeDesc->GetGirderGroup(segmentKey.groupIndex)->GetGirder(segmentKey.girderIndex)->GetSegment(segmentKey.segmentIndex);
   const CSpanData2* pStartSpan = pSegment->GetSpan(pgsTypes::metStart);
   const CSpanData2* pEndSpan   = pSegment->GetSpan(pgsTypes::metEnd);

   *pStartSpanIdx = pStartSpan->GetIndex();
   *pEndSpanIdx   = pEndSpan->GetIndex();
}

//-----------------------------------------------------------------------------
bool CBridgeAgentImp::GetSpan(Float64 station,SpanIndexType* pSpanIdx) const
{
   PierIndexType nPiers = GetPierCount();
   Float64 prev_pier = GetPierStation(0);
   for ( PierIndexType pierIdx = 1; pierIdx < nPiers; pierIdx++ )
   {
      Float64 next_pier;
      next_pier = GetPierStation(pierIdx);

      if ( IsLE(prev_pier,station) && IsLE(station,next_pier) )
      {
         *pSpanIdx = SpanIndexType(pierIdx-1);
         return true;
      }

      prev_pier = next_pier;
   }

   return false; // not found
}

//-----------------------------------------------------------------------------
GDRCONFIG CBridgeAgentImp::GetSegmentConfiguration(const CSegmentKey& segmentKey) const
{
   // Make sure girder is properly modeled before beginning
   VALIDATE(GIRDER);

   GDRCONFIG config;

   config.SegmentKey = segmentKey;

   // Get the girder
   CComPtr<IPrecastGirder> girder;
   GetGirder(segmentKey, &girder);

   GET_IFACE(ISegmentData, pSegmentData);
   const CStrandData* pStrands = pSegmentData->GetStrandData(segmentKey);
   const CGirderMaterial* pMaterial = pSegmentData->GetSegmentMaterial(segmentKey);

   ATLASSERT(pStrands->GetStrandDefinitionType() != pgsTypes::sdtDirectStrandInput); // NOTE: Strand Point model is a grid based model in WBFL

   CComPtr<IStrandModel> strandModel;
   girder->get_StrandModel(&strandModel);
   CComQIPtr<IStrandGridModel> strandGridModel(strandModel);
   ATLASSERT(strandGridModel); // must be using a grid based mode to get a config

   // Strand fills
   CComPtr<IIndexArray> fill[3];
   ConfigStrandFillVector fillVec[3];

   strandGridModel->get_StrandFill(Straight, &fill[pgsTypes::Straight]);
   IndexArray2ConfigStrandFillVec(fill[pgsTypes::Straight], fillVec[pgsTypes::Straight]);
   config.PrestressConfig.SetStrandFill(pgsTypes::Straight, fillVec[pgsTypes::Straight]);

   strandGridModel->get_StrandFill(Harped, &fill[pgsTypes::Harped]);
   IndexArray2ConfigStrandFillVec(fill[pgsTypes::Harped], fillVec[pgsTypes::Harped]);
   config.PrestressConfig.SetStrandFill(pgsTypes::Harped, fillVec[pgsTypes::Harped]);

   strandGridModel->get_StrandFill(Temporary, &fill[pgsTypes::Temporary]);
   IndexArray2ConfigStrandFillVec(fill[pgsTypes::Temporary], fillVec[pgsTypes::Temporary]);
   config.PrestressConfig.SetStrandFill(pgsTypes::Temporary, fillVec[pgsTypes::Temporary]);

   // Get harping point offsets
   strandGridModel->get_HarpedStrandAdjustmentEnd(etStart, &config.PrestressConfig.EndOffset[pgsTypes::metStart]);
   strandGridModel->get_HarpedStrandAdjustmentEnd(etEnd, &config.PrestressConfig.EndOffset[pgsTypes::metEnd]);
   strandGridModel->get_HarpedStrandAdjustmentHP(etStart, &config.PrestressConfig.HpOffset[pgsTypes::metStart]);
   strandGridModel->get_HarpedStrandAdjustmentHP(etEnd, &config.PrestressConfig.HpOffset[pgsTypes::metEnd]);

   // Get jacking force
   pgsTypes::AdjustableStrandType adj_type = pStrands->GetAdjustableStrandType();
   config.PrestressConfig.AdjustableStrandType = adj_type;

   for (Uint16 i = 0; i < 3; i++)
   {
      pgsTypes::StrandType strandType = (pgsTypes::StrandType)i;

      config.PrestressConfig.Pjack[strandType] = pStrands->GetPjack(strandType);

      // Convert debond data
      // Use tool to compute strand position index from grid index used by CDebondInfo
      ConfigStrandFillTool fillTool(fillVec[strandType]);

      const std::vector<CDebondData>& vDebond(pStrands->GetDebonding(strandType));
      for (const auto& debond_data : vDebond)
      {
         // convert grid index to strands index
         StrandIndexType index1, index2;
         fillTool.GridIndexToStrandPositionIndex(debond_data.strandTypeGridIdx, &index1, &index2);

         DEBONDCONFIG di;
         ATLASSERT(index1 != INVALID_INDEX);
         di.strandIdx = index1;
         di.DebondLength[pgsTypes::metStart] = debond_data.Length[pgsTypes::metStart];
         di.DebondLength[pgsTypes::metEnd] = debond_data.Length[pgsTypes::metEnd];

         config.PrestressConfig.Debond[i].push_back(di);

         if (index2 != INVALID_INDEX)
         {
            di.strandIdx = index2;
            di.DebondLength[pgsTypes::metStart] = debond_data.Length[pgsTypes::metStart];
            di.DebondLength[pgsTypes::metEnd] = debond_data.Length[pgsTypes::metEnd];

            config.PrestressConfig.Debond[i].push_back(di);
         }
      }

      // sorts based on strand index
      std::sort(config.PrestressConfig.Debond[strandType].begin(), config.PrestressConfig.Debond[strandType].end());

      for (Uint16 j = 0; j < 2; j++)
      {
         pgsTypes::MemberEndType endType = pgsTypes::MemberEndType(j);
         const std::vector<GridIndexType>& gridIndicies(pStrands->GetExtendedStrands(strandType, endType));
         std::vector<StrandIndexType> strandIndicies;
         for (const auto& gridIdx : gridIndicies)
         {
            // convert grid index to strands index
            StrandIndexType index1, index2;
            fillTool.GridIndexToStrandPositionIndex(gridIdx, &index1, &index2);
            ATLASSERT(index1 != INVALID_INDEX);
            strandIndicies.push_back(index1);
            if (index2 != INVALID_INDEX)
            {
               strandIndicies.push_back(index2);
            }
         }
         std::sort(strandIndicies.begin(), strandIndicies.end());
         config.PrestressConfig.SetExtendedStrands(strandType, endType, strandIndicies);
      }
   }

   config.PrestressConfig.TempStrandUsage = pStrands->GetTemporaryStrandUsage();

   // Get concrete properties
   // NOTE: Since this is only for PGSuper (and not for time-step analysis) the concrete
   // model is LRFD and that is a "stepped" model (f'ci then steps up to f'c)
   IntervalIndexType releaseIntervalIdx = m_IntervalManager.GetPrestressReleaseInterval(segmentKey);
   IntervalIndexType haulingIntervalIdx = m_IntervalManager.GetHaulingInterval(segmentKey); // steps up to f'c at hauling (see Concrete Manager)
   config.fc28     = GetSegmentFc28(segmentKey);
   config.fc       = GetSegmentFc(segmentKey,haulingIntervalIdx);
   config.fci      = GetSegmentFc(segmentKey,releaseIntervalIdx);
   config.ConcType = GetSegmentConcreteType(segmentKey);
   config.bHasFct  = DoesSegmentConcreteHaveAggSplittingStrength(segmentKey);
   config.Fct      = GetSegmentConcreteAggSplittingStrength(segmentKey);

   config.Ec  = GetSegmentEc(segmentKey,haulingIntervalIdx);
   config.Eci = GetSegmentEc(segmentKey,releaseIntervalIdx);
   config.bUserEci = pMaterial->Concrete.bUserEci;
   config.bUserEc  = pMaterial->Concrete.bUserEc;

   // Slab offset
   if (this->GetHaunchInputDepthType() == pgsTypes::hidACamber)
   {
      GetSlabOffset(segmentKey,&config.SlabOffset[pgsTypes::metStart],&config.SlabOffset[pgsTypes::metEnd]);
   config.AssumedExcessCamber = GetAssumedExcessCamber(segmentKey.groupIndex,segmentKey.girderIndex);
   }
   else
   {
      // haunch is defined by direct input - slab offsets are not used - make zero 
      config.SlabOffset[pgsTypes::metStart] = config.SlabOffset[pgsTypes::metEnd] = GetGrossSlabDepth();
      config.AssumedExcessCamber = 0.0;
   }

   // Stirrup data
	const CShearData2* pShearData = GetShearData(segmentKey);

   WriteShearDataToStirrupConfig(pShearData, config.StirrupConfig);

   return config;
}

bool CBridgeAgentImp::DoesPierDiaphragmLoadGirder(PierIndexType pierIdx,pgsTypes::PierFaceType pierFace) const
{
   VALIDATE( BRIDGE );
  
   GET_IFACE(IBridgeDescription,pIBridgeDesc);
   const CBridgeDescription2* pBridgeDesc = pIBridgeDesc->GetBridgeDescription();
   const CPierData2* pPierData = pBridgeDesc->GetPier(pierIdx);
   ATLASSERT( pPierData );

   // if there isn't a span on the specified face of this pier, then
   // the loads from the span on that face can't be applied
   if ( pPierData->GetSpan(pierFace) == nullptr )
   {
      return false;
   }

   return (pPierData->GetDiaphragmLoadType(pierFace) != ConnectionLibraryEntry::DontApply);
}

Float64 CBridgeAgentImp::GetPierDiaphragmLoadLocation(const CSegmentKey& segmentKey,pgsTypes::MemberEndType endType) const
{
   VALIDATE( BRIDGE );
  
   GET_IFACE(IBridgeDescription,pIBridgeDesc);
   const CBridgeDescription2* pBridgeDesc = pIBridgeDesc->GetBridgeDescription();
   const CGirderGroupData* pGroup = pBridgeDesc->GetGirderGroup(segmentKey.groupIndex);
   const CSplicedGirderData* pSplicedGirder = pGroup->GetGirder(segmentKey.girderIndex);
   const CPierData2* pPierData = pSplicedGirder->GetPier(endType);
   pgsTypes::PierFaceType pierFace = (endType == pgsTypes::metStart ? pgsTypes::Ahead : pgsTypes::Back);
#if defined _DEBUG
   if ( endType == pgsTypes::metStart )
   {
      ATLASSERT( segmentKey.segmentIndex == 0 );
   }
   else
   {
      ATLASSERT( segmentKey.segmentIndex == pSplicedGirder->GetSegmentCount()-1 );
   }
#endif

   Float64 dist = 0;
   if (pPierData->GetDiaphragmLoadType(pierFace) == ConnectionLibraryEntry::ApplyAtSpecifiedLocation)
   {
      // return distance adjusted for skew
      dist = pPierData->GetDiaphragmLoadLocation(pierFace); // distance from CL Bearing

      CComPtr<IAngle> angle;
      GetPierSkew(pPierData->GetIndex(),&angle);
      Float64 value;
      angle->get_Value(&value);

      dist /=  cos ( fabs(value) );
   }

   return dist;
}

std::vector<IntermedateDiaphragm> CBridgeAgentImp::GetPrecastDiaphragms(const CSegmentKey& segmentKey) const
{
   ASSERT_SEGMENT_KEY(segmentKey);

   const GirderLibraryEntry* pGirderEntry = GetGirderLibraryEntry(segmentKey);

   Float64 segment_length   = GetSegmentLength( segmentKey );
   bool   bIsInterior       = IsInteriorGirder( segmentKey );

   Float64 span_length = GetSegmentSpanLength(segmentKey);

   Float64 end_size = GetSegmentStartEndDistance( segmentKey );

   // base the span length on the maximum span length in this span
   // we want the same number of diaphragms on every girder
   GirderIndexType nGirders = this->GetGirderCount(segmentKey.groupIndex);
   Float64 max_span_length = 0;
   for ( GirderIndexType i = 0; i < nGirders; i++ )
   {
      max_span_length = Max(max_span_length, GetSegmentSpanLength( CSegmentKey(segmentKey.groupIndex,i,segmentKey.segmentIndex)) );
   }


   // These are indicies into the generic bridge object. They could be piers or temporary support
   PierIndexType startPierIdx = GetGenericBridgePierIndex(segmentKey,pgsTypes::metStart);
   PierIndexType endPierIdx   = GetGenericBridgePierIndex(segmentKey,pgsTypes::metEnd);

   // get the actual generic bridge pier objects
   CComPtr<IPierCollection> piers;
   m_Bridge->get_Piers(&piers);
   CComPtr<IBridgePier> objPier1, objPier2;
   piers->get_Item(startPierIdx,&objPier1);
   piers->get_Item(endPierIdx,  &objPier2);

   // get the skew angles
   CComPtr<IAngle> objSkew1, objSkew2;
   objPier1->get_SkewAngle(&objSkew1);
   objPier2->get_SkewAngle(&objSkew2);

   Float64 skew1, skew2;
   objSkew1->get_Value(&skew1);
   objSkew2->get_Value(&skew2);

   std::vector<IntermedateDiaphragm> diaphragms;

   const GirderLibraryEntry::DiaphragmLayoutRules& rules = pGirderEntry->GetDiaphragmLayoutRules();

   GirderLibraryEntry::DiaphragmLayoutRules::const_iterator ruleIter(rules.begin());
   GirderLibraryEntry::DiaphragmLayoutRules::const_iterator ruleIterEnd(rules.end());
   for ( ; ruleIter != ruleIterEnd; ruleIter++ )
   {
      const GirderLibraryEntry::DiaphragmLayoutRule& rule = *ruleIter;

      if ( rule.Construction != GirderLibraryEntry::ctCastingYard )
      {
         continue; // not our kind of rule
      }

      if ( max_span_length <= rule.MinSpan || rule.MaxSpan < max_span_length )
      {
         continue; // this rule doesn't apply
      }

      // determine location of diaphragm load (from the reference point - whatever that is, see below)
      Float64 location1 = rule.Location;
      Float64 location2 = rule.Location;
      if ( rule.MeasureType == GirderLibraryEntry::mtFractionOfSpanLength )
      {
         location1 *= span_length;
         location2 = (1 - location2)*span_length;
      }
      else if ( rule.MeasureType == GirderLibraryEntry::mtFractionOfGirderLength )
      {
         location1 *= segment_length;
         location2 = (1 - location2)*segment_length;
      }

      // adjust location so that it is measured from the end of the girder
      if ( rule.MeasureLocation == GirderLibraryEntry::mlBearing )
      {
         // reference point is the bearing so add the end size
         location1 += end_size;
         location2 += end_size;
      }
      else if ( rule.MeasureLocation == GirderLibraryEntry::mlCenterlineOfGirder )
      {
         // reference point is the center line of the girder so go back from the centerline
         location1 = segment_length/2 - location1;
         location2 = segment_length/2 + location2; // locate the diaphragm -/+ from cl girder
      }

      if ( location1 < 0.0 || span_length < location1 || location2 < 0.0 || span_length < location2 )
      {
         GET_IFACE(IEAFStatusCenter,pStatusCenter);
         std::_tstring str(_T("An interior diaphragm is located off the precast element. The diaphragm load will not be applied. Check the diaphragm rules."));

         std::unique_ptr<pgsInformationalStatusItem> pStatusItem = std::make_unique<pgsInformationalStatusItem>(m_StatusGroupID,m_scidInformationalWarning,str.c_str());
         pStatusCenter->Add(pStatusItem.release());
         break;
      }

      for ( int i = 0; i < 2; i++ )
      {
         if ( i == 1 && IsEqual(location1,location2) )
         {
            break;
         }

         IntermedateDiaphragm diaphragm;
         if ( rule.Method == GirderLibraryEntry::dwmInput )
         {
            diaphragm.m_bCompute = false;
            diaphragm.P = rule.Weight;
         }
         else
         {
            diaphragm.m_bCompute = true;
            diaphragm.H = rule.Height;
            diaphragm.T = rule.Thickness;
         }

         // location the diaphragm
         diaphragm.Location = (i == 0 ? location1 : location2);
         Float64 skew = ::LinInterp(diaphragm.Location,skew1,skew2,span_length);
         pgsPointOfInterest poi(segmentKey,diaphragm.Location);

         if ( diaphragm.m_bCompute )
         {
            // determine length (width) of the diaphragm
            Float64 W = 0;
            WebIndexType nWebs = GetWebCount(segmentKey);
            if ( 1 < nWebs )
            {
               SpacingIndexType nSpaces = nWebs-1;

               // add up the spacing between the centerlines of webs in the girder cross section
               for ( SpacingIndexType spaceIdx = 0; spaceIdx < nSpaces; spaceIdx++ )
               {
                  Float64 s = GetWebSpacing(poi,spaceIdx);
                  W += s;
               }

               // deduct the thickness of the webs
               for ( WebIndexType webIdx = 0; webIdx < nWebs; webIdx++ )
               {
                  Float64 t = GetWebThickness(poi,webIdx);

                  if ( webIdx == 0 || webIdx == nWebs-1 )
                  {
                     W -= t/2;
                  }
                  else
                  {
                     W -= t;
                  }
               }

               diaphragm.W = W/cos(skew);
            }
         }
         diaphragms.push_back(diaphragm);
      } // next diaphragm
   } // next rule

   return diaphragms;
}

std::vector<IntermedateDiaphragm> CBridgeAgentImp::GetCastInPlaceDiaphragms(const CSpanKey& spanKey) const
{
   return GetCastInPlaceDiaphragms(spanKey, false);
}

std::vector<IntermedateDiaphragm> CBridgeAgentImp::GetCastInPlaceDiaphragms(const CSpanKey& spanKey,bool bLocationOnly) const
{
   // NOTE: in future versions we may want to update the diaphragm model to match the model in TxDOT BGS
   // right now it is assumed that diaphramgs for a straight line. BGS and the Bridge Geometry Model support
   // more robust layouts

   ASSERT_SPAN_KEY(spanKey);

   GET_IFACE(IBridgeDescription,pIBridgeDesc);
   const CBridgeDescription2* pBridgeDesc = pIBridgeDesc->GetBridgeDescription();
   const CSpanData2* pSpan = pBridgeDesc->GetSpan(spanKey.spanIndex);
   const CGirderGroupData* pGroup = pBridgeDesc->GetGirderGroup(pSpan);
   const GirderLibraryEntry* pGirderEntry = pGroup->GetGirderLibraryEntry(spanKey.girderIndex);

   CGirderKey girderKey(pGroup->GetIndex(),spanKey.girderIndex);

   SegmentIndexType nSegments = pGroup->GetGirder(spanKey.girderIndex)->GetSegmentCount();

   Float64 span_length   = GetSpanLength(spanKey);
   Float64 girder_length = GetGirderLength(girderKey);

   Float64 start_end_size = 0; // distance from start CL Bearing to start face of girder
   // if this span is in the middle of a group (ie. the girder doesn't start or end in this span,
   // then the end size is zero because the girder spans over the piers)
   if ( pGroup->GetPierIndex(pgsTypes::metStart) == spanKey.spanIndex )
   {
      start_end_size = GetSegmentStartEndDistance(CSegmentKey(girderKey,0));
   }

   Float64 end_end_size = 0; // distance from end CL Bearing to end face of girder
   if ( pGroup->GetPierIndex(pgsTypes::metEnd) == spanKey.spanIndex+1 )
   {
      end_end_size = GetSegmentEndEndDistance(CSegmentKey(girderKey,nSegments-1));
   }

   bool bIsInterior = IsInteriorGirder( girderKey );

   // base the span length on the maximum span length in this span
   // we want the same number of diaphragms on every girder
   GirderIndexType nGirders = pGroup->GetGirderCount();
   Float64 max_span_length = 0;
   for ( GirderIndexType i = 0; i < nGirders; i++ )
   {
      SegmentIndexType segIdx = 0;
      max_span_length = Max(max_span_length, GetSpanLength( CSpanKey(spanKey.spanIndex,i) ));
   }

   PierIndexType startPierIdx = spanKey.spanIndex;
   PierIndexType endPierIdx   = startPierIdx+1;

   CComPtr<IAngle> objSkew1, objSkew2;
   GetPierSkew(startPierIdx,&objSkew1);
   GetPierSkew(endPierIdx,&objSkew2);

   Float64 skew1, skew2;
   objSkew1->get_Value(&skew1);
   objSkew2->get_Value(&skew2);

   std::vector<IntermedateDiaphragm> diaphragms;

   const GirderLibraryEntry::DiaphragmLayoutRules& rules = pGirderEntry->GetDiaphragmLayoutRules();

   GirderLibraryEntry::DiaphragmLayoutRules::const_iterator ruleIter(rules.begin());
   GirderLibraryEntry::DiaphragmLayoutRules::const_iterator ruleIterEnd(rules.end());
   for ( ; ruleIter != ruleIterEnd; ruleIter++ )
   {
      const GirderLibraryEntry::DiaphragmLayoutRule& rule = *ruleIter;

      if ( rule.Construction != GirderLibraryEntry::ctBridgeSite )
      {
         continue; // not our kind of rule
      }

      if ( max_span_length <= rule.MinSpan || rule.MaxSpan < max_span_length )
      {
         continue; // this rule doesn't apply
      }

      // determine location of diaphragm load (from the reference point - whatever that is, see below)
      Float64 location1, location2;
      if ( rule.MeasureType == GirderLibraryEntry::mtFractionOfSpanLength )
      {
         location1 = rule.Location*span_length;
         location2 = (1 - rule.Location)*span_length;
      }
      else if ( rule.MeasureType == GirderLibraryEntry::mtFractionOfGirderLength )
      {
         location1 = rule.Location*girder_length;
         location2 = (1 - rule.Location)*girder_length;
      }
      else if ( rule.MeasureType == GirderLibraryEntry::mtAbsoluteDistance )
      {
         location1 = rule.Location;
         if ( 1 < nSegments )
         {
            location2 = span_length - rule.Location;
         }
         else
         {
            location2 = girder_length - rule.Location;
         }
      }

      // adjust location so that it is measured from the CL Bearing
      if ( rule.MeasureLocation == GirderLibraryEntry::mlBearing )
      {
         // do nothing
      }
      else if ( rule.MeasureLocation == GirderLibraryEntry::mlCenterlineOfGirder )
      {
         // reference point is the center line of the girder or span so go back from the centerline

         if ( 1 < nSegments )
         {
            // for spliced girders, mlCenterlineOfGirder actually means CL Span since the
            // girders are more than one span long (in general). The diaphragm rule definition 
            // dialog for the girder library entry restricts the input such that the meaning
            // of mlCenterlineOfGirder is CL Span for spliced girders
#if defined _DEBUG
            GET_IFACE(IDocumentType,pDocType);
            ATLASSERT(pDocType->IsPGSpliceDocument());
#endif
            // locate the diaphragm -/+ from cl span
            location1 = span_length/2 - rule.Location;
            location2 = span_length/2 + rule.Location;
         }
         else
         {
            // locate the diaphragm -/+ from cl girder
            location1 = girder_length/2 - rule.Location;
            location2 = girder_length/2 + rule.Location;

            // location is from the start face of the girder.. make it from the CL Bearing = Start of Span
            location1 -= start_end_size;
            location2 -= start_end_size;
         }
      }

      if ( location1 < 0.0 || span_length < location1 || location2 < 0.0 || span_length < location2 )
      {
         GET_IFACE(IEAFStatusCenter,pStatusCenter);
         std::_tstring str(_T("An interior diaphragm is located outside of the span length. The diaphragm load will not be applied. Check the diaphragm rules for this girder."));

         std::unique_ptr<pgsInformationalStatusItem> pStatusItem = std::make_unique<pgsInformationalStatusItem>(m_StatusGroupID,m_scidInformationalWarning,str.c_str());
         pStatusCenter->Add(pStatusItem.release());
         break;
      }

      for ( int i = 0; i < 2; i++ )
      {
         if ( i == 1 && IsEqual(location1,location2) )
         {
            // don't add two identical diaphragms at the same location
            break;
         }

         IntermedateDiaphragm diaphragm;

         // location the diaphragm
         diaphragm.Location = (i == 0 ? location1 : location2);

         if (bLocationOnly)
         {
            diaphragm.H = 0;
            diaphragm.T = 0;
            diaphragm.W = 0;
            diaphragm.P = 0;
            diaphragm.m_bCompute = false;
         }
         else
         {
            if (rule.Method == GirderLibraryEntry::dwmInput)
            {
               diaphragm.m_bCompute = false;
               diaphragm.P = rule.Weight;
            }
            else
            {
               diaphragm.m_bCompute = true;
               diaphragm.H = rule.Height;
               diaphragm.T = rule.Thickness;
            }

            Float64 skew = ::LinInterp(diaphragm.Location, skew1, skew2, start_end_size + span_length + end_end_size);
            pgsPointOfInterest poi = ConvertGirderCoordinateToPoi(girderKey, diaphragm.Location);

            Float64 left_spacing, right_spacing;
            GetSpacingAlongGirder(girderKey, diaphragm.Location, &left_spacing, &right_spacing);

            // determine length (width) of the diaphragm as girder spacing minus web width
            Float64 W = 0;
            WebIndexType nWebs = GetWebCount(girderKey);

            Float64 web_location_left = GetWebLocation(poi, 0);
            Float64 web_location_right = GetWebLocation(poi, nWebs - 1);

            Float64 tweb_left = GetWebThickness(poi, 0) / 2;
            Float64 tweb_right = GetWebThickness(poi, nWebs - 1) / 2;

            if (bIsInterior)
            {
               W = (left_spacing / 2 + right_spacing / 2 - fabs(web_location_left) - tweb_left - fabs(web_location_right) - tweb_right);
            }
            else
            {
               W = (spanKey.girderIndex == 0 ? right_spacing / 2 - fabs(web_location_right) - tweb_right : left_spacing / 2 - fabs(web_location_left) - tweb_left);
            }

            diaphragm.W = W / cos(skew);

            if (!diaphragm.m_bCompute)
            {
               // P is weight/length of external application
               // make P the total weight here
               diaphragm.P *= diaphragm.W;
            }
         }

         diaphragms.push_back(diaphragm);
      } // next diaphragm
   } // next rule

   return diaphragms;
}

pgsTypes::SupportedDeckType CBridgeAgentImp::GetDeckType() const
{
   GET_IFACE(IBridgeDescription,pIBridgeDesc);
   const CBridgeDescription2* pBridgeDesc = pIBridgeDesc->GetBridgeDescription();
   const CDeckDescription2*   pDeck       = pBridgeDesc->GetDeckDescription();
   return pDeck->GetDeckType();
}

pgsTypes::WearingSurfaceType CBridgeAgentImp::GetWearingSurfaceType() const
{
   GET_IFACE(IBridgeDescription,pIBridgeDesc);
   const CBridgeDescription2* pBridgeDesc = pIBridgeDesc->GetBridgeDescription();
   const CDeckDescription2*   pDeck       = pBridgeDesc->GetDeckDescription();
   return pDeck->WearingSurface;
}

Float64 CBridgeAgentImp::GetSlabOffset(const CSegmentKey& segmentKey, pgsTypes::MemberEndType end) const
{
   ASSERT_SEGMENT_KEY(segmentKey);
   GET_IFACE(IBridgeDescription, pIBridgeDesc);
   const CBridgeDescription2* pBridgeDesc = pIBridgeDesc->GetBridgeDescription();
   const CPrecastSegmentData* pSegment = pBridgeDesc->GetSegment(segmentKey);
   return pSegment->GetSlabOffset(end);
}

void CBridgeAgentImp::GetSlabOffset(const CSegmentKey& segmentKey, Float64* pStart, Float64* pEnd) const
{
   ASSERT_SEGMENT_KEY(segmentKey);
   GET_IFACE(IBridgeDescription, pIBridgeDesc);
   const CBridgeDescription2* pBridgeDesc = pIBridgeDesc->GetBridgeDescription();
   const CPrecastSegmentData* pSegment = pBridgeDesc->GetSegment(segmentKey);
   pSegment->GetSlabOffset(pStart, pEnd);
}

Float64 CBridgeAgentImp::GetElevationAdjustment(IntervalIndexType intervalIdx, const pgsPointOfInterest& poi) const
{
   const CSegmentKey& segmentKey(poi.GetSegmentKey());

   Float64 elevAdj = 0;
   IntervalIndexType erectSegmentIntervalIdx = GetErectSegmentInterval(segmentKey);
   if (erectSegmentIntervalIdx <= intervalIdx)
   {
      GET_IFACE(IBridgeDescription, pIBridgeDesc);
      const CBridgeDescription2* pBridgeDesc = pIBridgeDesc->GetBridgeDescription();
      const CPrecastSegmentData* pSegment = pBridgeDesc->GetSegment(segmentKey);

      // get elevation adjustments at the ends of the segment
      std::array<Float64, 2> elev_adj{ 0.0,0.0 };
      for (int i = 0; i < 2; i++)
      {
         pgsTypes::MemberEndType end = (pgsTypes::MemberEndType)i;
         const CPierData2* pPier;
         const CTemporarySupportData* pTS;
         pSegment->GetSupport(end, &pPier, &pTS);
         if (pTS)
         {
            ATLASSERT(pTS->HasElevationAdjustment());
            elev_adj[end] = pTS->GetElevationAdjustment();
         }
      }

      // Elevation adjustments are along entire segment length
      // interpolate for the subject poi
      Float64 Ls = GetSegmentLength(segmentKey); 
      Float64 Xpoi = poi.GetDistFromStart();
      elevAdj = ::LinInterp(Xpoi, elev_adj[pgsTypes::metStart], elev_adj[pgsTypes::metEnd], Ls);
   }

   return elevAdj;
}

Float64 CBridgeAgentImp::GetRotationAdjustment(IntervalIndexType intervalIdx, const pgsPointOfInterest& poi) const
{
   VALIDATE(BRIDGE);

   const CSegmentKey& segmentKey(poi.GetSegmentKey());

   Float64 slopeAdj = 0;
   IntervalIndexType erectSegmentIntervalIdx = GetErectSegmentInterval(segmentKey);
   if (erectSegmentIntervalIdx <= intervalIdx)
   {
      GET_IFACE(IBridgeDescription, pIBridgeDesc);
      const CBridgeDescription2* pBridgeDesc = pIBridgeDesc->GetBridgeDescription();
      const CPrecastSegmentData* pSegment = pBridgeDesc->GetSegment(segmentKey);

      // get elevation adjustments at the ends of the segment
      // elevation adjustments are measured at the CL Bearing
      std::array<Float64, 2> elev_adj{ 0.0,0.0 };
      for (int i = 0; i < 2; i++)
      {
         pgsTypes::MemberEndType end = (pgsTypes::MemberEndType)i;
         const CPierData2* pPier;
         const CTemporarySupportData* pTS;
         pSegment->GetSupport(end, &pPier, &pTS);
         if (pTS)
         {
            ATLASSERT(pTS->HasElevationAdjustment());
            elev_adj[end] = pTS->GetElevationAdjustment();
         }
      }

      // interpolate for the subject poi
      Float64 Ls = GetSegmentLength(segmentKey); // CL Brg to CL Brg span length of segment
      slopeAdj = (elev_adj[pgsTypes::metStart] - elev_adj[pgsTypes::metEnd])/ Ls;
   }

   return slopeAdj;
}

bool CBridgeAgentImp::IsCompositeDeck() const
{
   pgsTypes::SupportedDeckType deckType = GetDeckType();

   return ( deckType == pgsTypes::sdtCompositeCIP ||
            deckType == pgsTypes::sdtCompositeSIP ||
            deckType == pgsTypes::sdtCompositeOverlay );
}

bool CBridgeAgentImp::HasOverlay() const
{
   GET_IFACE(IBridgeDescription,pIBridgeDesc);
   const CBridgeDescription2* pBridgeDesc = pIBridgeDesc->GetBridgeDescription();
   const CDeckDescription2* pDeck = pBridgeDesc->GetDeckDescription();

   return (pDeck->WearingSurface == pgsTypes::wstFutureOverlay || pDeck->WearingSurface == pgsTypes::wstOverlay);
}

bool CBridgeAgentImp::IsFutureOverlay() const
{
   GET_IFACE(IBridgeDescription,pIBridgeDesc);
   const CBridgeDescription2* pBridgeDesc = pIBridgeDesc->GetBridgeDescription();
   const CDeckDescription2* pDeck = pBridgeDesc->GetDeckDescription();

   if ( pDeck->WearingSurface == pgsTypes::wstSacrificialDepth )
   {
      return false; // definately not a future overlay (not even an overlay)
   }

   if (pDeck->WearingSurface == pgsTypes::wstFutureOverlay)
   {
      return true; // explicitly an overlay
   }

   ATLASSERT(pDeck->WearingSurface == pgsTypes::wstOverlay);

   IntervalIndexType overlayIntervalIdx  = GetOverlayInterval();
   ATLASSERT(overlayIntervalIdx != INVALID_INDEX);

   IntervalIndexType liveLoadIntervalIdx = GetLiveLoadInterval();
   if ( liveLoadIntervalIdx < overlayIntervalIdx )
   {
      return true; // overlay is applied after the bridge is open to traffic so it is a future overlay
   }

   return false; // has an overlay, but it goes not before at the interval when the bridge opens to traffic
}

Float64 CBridgeAgentImp::GetOverlayWeight() const
{
   Float64 depth, density;
   m_Bridge->get_WearingSurfaceDepth(&depth);
   m_Bridge->get_WearingSurfaceDensity(&density);
   
   Float64 weight = depth*density*WBFL::Units::System::GetGravitationalAcceleration();
   return weight;
}

Float64 CBridgeAgentImp::GetOverlayDepth(IntervalIndexType interval) const
{
   Float64 depth(0.0);
   if (HasOverlay() && !IsFutureOverlay())
   {
      if (interval >= GetOverlayInterval())
      {
         m_Bridge->get_WearingSurfaceDepth(&depth);
      }
   }

   return depth;
}

Float64 CBridgeAgentImp::GetSacrificalDepth() const
{
   Float64 depth;
   m_Bridge->get_SacrificialDepth(&depth);

#if defined _DEBUG
   GET_IFACE(IBridgeDescription,pIBridgeDesc);
   const CBridgeDescription2* pBridgeDesc = pIBridgeDesc->GetBridgeDescription();
   const CDeckDescription2* pDeck = pBridgeDesc->GetDeckDescription();

   if ( HasOverlay() && !IsFutureOverlay() )
   {
      ATLASSERT(IsZero(depth));
   }
   else
   {
      ATLASSERT(IsEqual(depth,pDeck->SacrificialDepth));
   }

#endif

   return depth;
}

Float64 CBridgeAgentImp::GetFillet() const
{
   GET_IFACE(IBridgeDescription,pIBridgeDesc);
   const CBridgeDescription2* pBridgeDesc = pIBridgeDesc->GetBridgeDescription();
   const CDeckDescription2* pDeck = pBridgeDesc->GetDeckDescription();
   if ( pDeck->GetDeckType() == pgsTypes::sdtNone )
   {
      return 0.0;
   }
   else
   {
      return pIBridgeDesc->GetFillet();
   }
}

Float64 CBridgeAgentImp::GetAssumedExcessCamber(SpanIndexType spanIdx, GirderIndexType gdrIdx) const
{
   GET_IFACE(ISpecification, pSpec );
   bool bIsParabolic = pSpec->IsAssumedExcessCamberInputEnabled();
   if (bIsParabolic)
   {
      GET_IFACE(IBridgeDescription, pIBridgeDesc);
      const CBridgeDescription2* pBridgeDesc = pIBridgeDesc->GetBridgeDescription();
      const CSpanData2* pSpan = pIBridgeDesc->GetSpan(spanIdx);
      return pSpan->GetAssumedExcessCamber(gdrIdx);
   }
   else
   {
      // parabolic camber is disabled in project. Girder is flat
      return 0.0;
   }
}

Float64 CBridgeAgentImp::GetGrossSlabDepth(const pgsPointOfInterest& poi) const
{
   VALIDATE( BRIDGE );
   return GetGrossSlabDepth();
}

Float64 CBridgeAgentImp::GetStructuralSlabDepth(const pgsPointOfInterest& poi) const
{
   VALIDATE( BRIDGE );

   if (IsNonstructuralDeck(GetDeckType()) )
   {
      return 0.00;
   }

   CComPtr<IBridgeDeck> deck;
   m_Bridge->get_Deck(&deck);

   Float64 structural_depth;
   deck->get_StructuralDepth(&structural_depth);

   return structural_depth;
}

Float64 CBridgeAgentImp::GetCastSlabDepth(const pgsPointOfInterest& poi) const
{
   VALIDATE( BRIDGE );
   Float64 cast_depth = GetCastDepth();
   return cast_depth;
}

Float64 CBridgeAgentImp::GetPanelDepth(const pgsPointOfInterest& poi) const
{
   VALIDATE( BRIDGE );
   Float64 panel_depth = GetPanelDepth();
   return panel_depth;
}

pgsTypes::HaunchInputDepthType CBridgeAgentImp::GetHaunchInputDepthType() const
{
   GET_IFACE(IBridgeDescription,pIBridgeDesc);
   const CBridgeDescription2* pBridgeDesc = pIBridgeDesc->GetBridgeDescription();
   return pBridgeDesc->GetHaunchInputDepthType();
}

Float64 CBridgeAgentImp::GetLeftSlabOverhang(Float64 Xb) const
{
   VALIDATE( BRIDGE );
   Float64 left, right;
   HRESULT hr = GetSlabOverhangs(Xb,&left,&right);
   ATLASSERT(hr == S_OK);
   return left;
}

Float64 CBridgeAgentImp::GetRightSlabOverhang(Float64 Xb) const
{
   VALIDATE( BRIDGE );
   Float64 left, right;
   HRESULT hr = GetSlabOverhangs(Xb,&left,&right);
   ATLASSERT(hr == S_OK);
   return right;
}

Float64 CBridgeAgentImp::GetLeftSlabOverhang(SpanIndexType spanIdx,Float64 Xspan) const
{
   VALIDATE( BRIDGE );
   Float64 pierStation = this->GetPierStation(spanIdx);
   Float64 station = pierStation + Xspan;
   Float64 firstPierStation = GetPierStation(0);
   Float64 Xb = station - firstPierStation;
   return GetLeftSlabOverhang(Xb);
}

Float64 CBridgeAgentImp::GetRightSlabOverhang(SpanIndexType spanIdx,Float64 Xspan) const
{
   VALIDATE( BRIDGE );
   Float64 pierStation = GetPierStation(spanIdx);
   Float64 station = pierStation + Xspan;
   Float64 firstPierStation = GetPierStation(0);
   Float64 Xb = station - firstPierStation;
   return GetRightSlabOverhang(Xb);
}

Float64 CBridgeAgentImp::GetLeftSlabEdgeOffset(PierIndexType pierIdx) const
{
   VALIDATE( BRIDGE );
   Float64 start_station = GetPierStation(0);
   Float64 pier_station  = GetPierStation(pierIdx);
   Float64 Xb = pier_station - start_station;
   return GetLeftSlabEdgeOffset(Xb);
}

Float64 CBridgeAgentImp::GetRightSlabEdgeOffset(PierIndexType pierIdx) const
{
   VALIDATE( BRIDGE );
   Float64 start_station = GetPierStation(0);
   Float64 pier_station  = GetPierStation(pierIdx);
   Float64 Xb = pier_station - start_station;
   return GetRightSlabEdgeOffset(Xb);
}

Float64 CBridgeAgentImp::GetLeftSlabEdgeOffset(Float64 Xb) const
{
   return GetSlabEdgeOffset(m_LeftSlabEdgeOffset, qcbLeft, Xb);
}

Float64 CBridgeAgentImp::GetRightSlabEdgeOffset(Float64 Xb) const
{
   return GetSlabEdgeOffset(m_RightSlabEdgeOffset, qcbRight, Xb);
}

Float64 CBridgeAgentImp::GetSlabEdgeOffset(std::map<Float64, Float64>& slabEdgeOffset, DirectionType side, Float64 Xb) const
{
   const auto& found = slabEdgeOffset.find(Xb);
   if (found != slabEdgeOffset.end())
   {
      return found->second;
   }

   VALIDATE(BRIDGE);
   Float64 station = GetPierStation(0);
   station += Xb;
   CComPtr<IStation> objOffsetStation;
   Float64 offset;
   m_BridgeGeometryTool->DeckOffset(m_Bridge, station, nullptr, side, &objOffsetStation, &offset);

   CComPtr<IAlignment> alignment;
   GetAlignment(&alignment);

   Float64 offsetStation;
   alignment->ConvertToNormalizedStation(CComVariant(objOffsetStation), &offsetStation);

   if (!IsEqual(station, offsetStation))
   {
      // the cut station and the offset station are different... compute the offset
      // with respect to the cut station
      CComPtr<IPoint2d> pntOnAlignment;
      alignment->LocatePoint(CComVariant(station), omtAlongDirection, 0.0, CComVariant((IUnknown*)nullptr), &pntOnAlignment);

      CComPtr<IPoint2d> pntOffset;
      alignment->LocatePoint(CComVariant(objOffsetStation), omtAlongDirection, offset, CComVariant((IUnknown*)nullptr), &pntOffset);

      Float64 sign = ::BinarySign(offset);

      pntOnAlignment->DistanceEx(pntOffset, &offset);
      offset *= sign;
   }


   slabEdgeOffset.insert(std::make_pair(Xb, offset));

   return offset;
}

Float64 CBridgeAgentImp::GetLeftCurbOffset(Float64 Xb) const
{
   return GetCurbOffset(qcbLeft, Xb);
}

Float64 CBridgeAgentImp::GetRightCurbOffset(Float64 Xb) const
{
   return GetCurbOffset(qcbRight, Xb);
}

Float64 CBridgeAgentImp::GetCurbOffset(DirectionType side,Float64 Xb) const
{
   VALIDATE(BRIDGE);
   Float64 station = GetPierStation(0);
   station += Xb;
   CComPtr<IStation> objOffsetStation;
   Float64 offset;
   m_BridgeGeometryTool->CurbOffset(m_Bridge, station, nullptr, side, &objOffsetStation, &offset);

   CComPtr<IAlignment> alignment;
   GetAlignment(&alignment);

   Float64 offsetStation;
   alignment->ConvertToNormalizedStation(CComVariant(objOffsetStation), &offsetStation);

   if (!IsEqual(station, offsetStation))
   {
      // the cut station and the offset station are different... compute the offset
      // with respect to the cut station
      CComPtr<IPoint2d> pntOnAlignment;
      alignment->LocatePoint(CComVariant(station), omtAlongDirection, 0.0, CComVariant((IUnknown*)nullptr), &pntOnAlignment);

      CComPtr<IPoint2d> pntOffset;
      alignment->LocatePoint(CComVariant(objOffsetStation), omtAlongDirection, offset, CComVariant((IUnknown*)nullptr), &pntOffset);

      Float64 sign = ::BinarySign(offset);

      pntOnAlignment->DistanceEx(pntOffset, &offset);
      offset *= sign;
   }


   return offset;
}

Float64 CBridgeAgentImp::GetLeftCurbOffset(SpanIndexType spanIdx,Float64 Xspan) const
{
   Float64 pierStation = GetPierStation(spanIdx);
   Float64 station = pierStation + Xspan;
   Float64 firstPierStation = GetPierStation(0);
   Float64 Xb = station - firstPierStation;
   return GetLeftCurbOffset(Xb);
}

Float64 CBridgeAgentImp::GetRightCurbOffset(SpanIndexType spanIdx,Float64 Xspan) const
{
   Float64 pierStation = GetPierStation(spanIdx);
   Float64 station = pierStation + Xspan;
   Float64 firstPierStation = GetPierStation(0);
   Float64 Xb = station - firstPierStation;
   return GetRightCurbOffset(Xb);
}

Float64 CBridgeAgentImp::GetLeftCurbOffset(PierIndexType pierIdx) const
{
   Float64 start_station = GetPierStation(0);
   Float64 pier_station = GetPierStation(pierIdx);
   Float64 Xb = pier_station - start_station;
   return GetLeftCurbOffset(Xb);
}

Float64 CBridgeAgentImp::GetRightCurbOffset(PierIndexType pierIdx) const
{
   Float64 start_station = GetPierStation(0);
   Float64 pier_station = GetPierStation(pierIdx);
   Float64 Xb = pier_station - start_station;
   return GetRightCurbOffset(Xb);
}

Float64 CBridgeAgentImp::GetCurbToCurbWidth(const pgsPointOfInterest& poi) const
{
   Float64 Xb = ConvertPoiToBridgeLineCoordinate(poi);
   return GetCurbToCurbWidth(Xb);
}

Float64 CBridgeAgentImp::GetCurbToCurbWidth(const CSegmentKey& segmentKey,Float64 Xs) const
{
   Float64 Xb = ConvertSegmentToBridgeLineCoordinate(segmentKey,Xs);
   return GetCurbToCurbWidth(Xb);
}

Float64 CBridgeAgentImp::GetCurbToCurbWidth(Float64 Xb) const
{
   Float64 left_offset, right_offset;
   left_offset = GetLeftCurbOffset(Xb);
   right_offset = GetRightCurbOffset(Xb);
   return right_offset - left_offset;
}

Float64 CBridgeAgentImp::GetLeftInteriorCurbOffset(PierIndexType pierIdx) const
{
   Float64 start_station = GetPierStation(0);
   Float64 pier_station = GetPierStation(pierIdx);
   Float64 Xb = pier_station - start_station;
   return GetLeftInteriorCurbOffset(Xb);
}

Float64 CBridgeAgentImp::GetRightInteriorCurbOffset(PierIndexType pierIdx) const
{
   Float64 start_station = GetPierStation(0);
   Float64 pier_station = GetPierStation(pierIdx);
   Float64 Xb = pier_station - start_station;
   return GetRightInteriorCurbOffset(Xb);
}

Float64 CBridgeAgentImp::GetLeftInteriorCurbOffset(Float64 Xb) const
{
   VALIDATE( BRIDGE );
   Float64 station = GetPierStation(0);
   station += Xb;
   CComPtr<IStation> offsetStation;
   Float64 offset;
   m_BridgeGeometryTool->InteriorCurbOffset(m_Bridge,station,nullptr,qcbLeft,&offsetStation,&offset);
   return offset;
}

Float64 CBridgeAgentImp::GetRightInteriorCurbOffset(Float64 Xb) const
{
   VALIDATE( BRIDGE );
   Float64 station = GetPierStation(0);
   station += Xb;
   CComPtr<IStation> offsetStation;
   Float64 offset;
   m_BridgeGeometryTool->InteriorCurbOffset(m_Bridge,station,nullptr,qcbRight,&offsetStation,&offset);
   return offset;
}

Float64 CBridgeAgentImp::GetInteriorCurbToCurbWidth(Float64 Xb) const
{
   Float64 left_offset, right_offset;
   left_offset = GetLeftInteriorCurbOffset(Xb);
   right_offset = GetRightInteriorCurbOffset(Xb);
   return right_offset - left_offset;
}

Float64 CBridgeAgentImp::GetLeftOverlayToeOffset(Float64 Xb) const
{
   Float64 slab_edge = GetLeftSlabEdgeOffset(Xb);

   CComPtr<ISidewalkBarrier> pSwBarrier;
   m_Bridge->get_LeftBarrier(&pSwBarrier);

   Float64 toe_width;
   pSwBarrier->get_OverlayToeWidth(&toe_width);

   return slab_edge + toe_width;
}

Float64 CBridgeAgentImp::GetRightOverlayToeOffset(Float64 Xb) const
{
   Float64 slab_edge = GetRightSlabEdgeOffset(Xb);

   CComPtr<ISidewalkBarrier> pSwBarrier;
   m_Bridge->get_RightBarrier(&pSwBarrier);

   Float64 toe_width;
   pSwBarrier->get_OverlayToeWidth(&toe_width);

   return slab_edge - toe_width;
}

Float64 CBridgeAgentImp::GetLeftOverlayToeOffset(const pgsPointOfInterest& poi) const
{
   Float64 Xb = ConvertPoiToBridgeLineCoordinate(poi);
   return GetLeftOverlayToeOffset(Xb);
}

Float64 CBridgeAgentImp::GetRightOverlayToeOffset(const pgsPointOfInterest& poi) const
{
   Float64 Xb = ConvertPoiToBridgeLineCoordinate(poi);
   return GetRightOverlayToeOffset(Xb);
}

void CBridgeAgentImp::GetSlabPerimeter(CollectionIndexType nPoints,pgsTypes::PlanCoordinateType pcType,IPoint2dCollection** ppPoints) const
{
   VALIDATE( BRIDGE );

   CComPtr<IBridgeGeometry> geometry;
   m_Bridge->get_BridgeGeometry(&geometry);

   CComPtr<IDeckBoundary> deckBoundary;
   geometry->get_DeckBoundary(&deckBoundary);

   if(deckBoundary == nullptr)
   {
      ATLASSERT(false); // you are asking for something that doesn't exist
      CComPtr<IPoint2dCollection> points;
      points.CoCreateInstance(CLSID_Point2dCollection);
      points.CopyTo(ppPoints);
      return;
   }

   deckBoundary->get_Perimeter(nPoints, ppPoints);

   if ( pcType == pgsTypes::pcGlobal )
   {
      (*ppPoints)->Offset(m_DeltaX,m_DeltaY);
   }
}

void CBridgeAgentImp::GetSlabPerimeter(PierIndexType startPierIdx, Float64 Xstart, PierIndexType endPierIdx, Float64 Xend, CollectionIndexType nPoints, pgsTypes::PlanCoordinateType pcType, IPoint2dCollection** ppPoints) const
{
   GetSlabPerimeter(startPierIdx, Xstart, endPierIdx, Xend, nPoints, pcType, nullptr, ppPoints);
}

void CBridgeAgentImp::GetSlabPerimeter(PierIndexType startPierIdx, Float64 Xstart, PierIndexType endPierIdx, Float64 Xend, CollectionIndexType nPoints, pgsTypes::PlanCoordinateType pcType, const CCastDeckActivity* pCastDeckActivity, IPoint2dCollection** ppPoints) const
{
   VALIDATE(BRIDGE);
   ATLASSERT(startPierIdx != INVALID_INDEX && endPierIdx != INVALID_INDEX);

   CComPtr<IBridgeGeometry> geometry;
   m_Bridge->get_BridgeGeometry(&geometry);

   CComPtr<IDeckBoundary> deckBoundary;
   geometry->get_DeckBoundary(&deckBoundary);

   if (deckBoundary == nullptr)
   {
      CComPtr<IPoint2dCollection> points;
      points.CoCreateInstance(CLSID_Point2dCollection);
      points.CopyTo(ppPoints);
      return;
   }

   PierIDType startPierID = ::GetPierLineID(startPierIdx);
   PierIDType endPierID = ::GetPierLineID(endPierIdx);

   if (pCastDeckActivity == nullptr)
   {
      GET_IFACE(IBridgeDescription, pIBridgeDesc);
      EventIndexType castDeckEventIdx = pIBridgeDesc->GetCastDeckEventIndex();
      ATLASSERT(castDeckEventIdx != INVALID_INDEX);
      const CTimelineEvent* pEvent = pIBridgeDesc->GetEventByIndex(castDeckEventIdx);
      ATLASSERT(pEvent && pEvent->GetCastDeckActivity().IsEnabled());
      const CCastDeckActivity& castDeckActivity = pEvent->GetCastDeckActivity();
      pCastDeckActivity = &castDeckActivity;
   }
   VARIANT_BOOL vbRegionBounariesParallelToPier = (pCastDeckActivity->GetDeckCastingRegionBoundary() == pgsTypes::dcrbParallelToPier ? VARIANT_TRUE : VARIANT_FALSE);

   deckBoundary->get_PerimeterEx(nPoints, startPierID, Xstart, endPierID, Xend, vbRegionBounariesParallelToPier, ppPoints);

   if (pcType == pgsTypes::pcGlobal)
   {
      (*ppPoints)->Offset(m_DeltaX, m_DeltaY);
   }
}

void CBridgeAgentImp::GetSpanPerimeter(SpanIndexType spanIdx, CollectionIndexType nPoints, pgsTypes::PlanCoordinateType pcType, IPoint2dCollection** ppPoints) const
{
   GetSlabPerimeter(spanIdx, spanIdx, nPoints, pcType, ppPoints);
}

void CBridgeAgentImp::GetLeftSlabEdgePoint(Float64 station, IDirection* direction,pgsTypes::PlanCoordinateType pcType,IPoint2d** point) const
{
   GetSlabEdgePoint(station,direction,qcbLeft,pcType,point);
}

void CBridgeAgentImp::GetLeftSlabEdgePoint(Float64 station, IDirection* direction,pgsTypes::PlanCoordinateType pcType,IPoint3d** point) const
{
   GetSlabEdgePoint(station,direction,qcbLeft,pcType,point);
}

void CBridgeAgentImp::GetRightSlabEdgePoint(Float64 station, IDirection* direction,pgsTypes::PlanCoordinateType pcType,IPoint2d** point) const
{
   GetSlabEdgePoint(station,direction,qcbRight,pcType,point);
}

void CBridgeAgentImp::GetRightSlabEdgePoint(Float64 station, IDirection* direction,pgsTypes::PlanCoordinateType pcType,IPoint3d** point) const
{
   GetSlabEdgePoint(station,direction,qcbRight,pcType,point);
}

void CBridgeAgentImp::GetLeftCurbLinePoint(Float64 station, IDirection* direction,pgsTypes::PlanCoordinateType pcType,IPoint2d** point) const
{
   GetCurbLinePoint(station,direction,qcbLeft,pcType,point);
}

void CBridgeAgentImp::GetLeftCurbLinePoint(Float64 station, IDirection* direction,pgsTypes::PlanCoordinateType pcType,IPoint3d** point) const
{
   GetCurbLinePoint(station,direction,qcbLeft,pcType,point);
}

void CBridgeAgentImp::GetRightCurbLinePoint(Float64 station, IDirection* direction,pgsTypes::PlanCoordinateType pcType,IPoint2d** point) const
{
   GetCurbLinePoint(station,direction,qcbRight,pcType,point);
}

void CBridgeAgentImp::GetRightCurbLinePoint(Float64 station, IDirection* direction,pgsTypes::PlanCoordinateType pcType,IPoint3d** point) const
{
   GetCurbLinePoint(station,direction,qcbRight,pcType,point);
}

Float64 CBridgeAgentImp::GetPierStation(PierIndexType pierIdx) const
{
   VALIDATE( BRIDGE );

   CComPtr<IBridgeGeometry> geometry;
   m_Bridge->get_BridgeGeometry(&geometry);

   CComPtr<IPierLine> pier;
   PierIDType pierID = ::GetPierLineID(pierIdx);
   geometry->FindPierLine( pierID ,&pier);

   CComPtr<IStation> station;
   pier->get_Station(&station);

   Float64 value;
   station->get_Value(&value);

   return value;
}

void CBridgeAgentImp::GetSlabPerimeter(SpanIndexType startSpanIdx,SpanIndexType endSpanIdx,CollectionIndexType nPoints,pgsTypes::PlanCoordinateType pcType,IPoint2dCollection** points) const
{
   VALIDATE( BRIDGE );

   GroupIndexType startGroupIdx = GetGirderGroupIndex(startSpanIdx);
   CSegmentKey startSegmentKey(startGroupIdx, 0, 0);
   GroupIndexType endGroupIdx = GetGirderGroupIndex(endSpanIdx);
   GirderIndexType gdrIdx = GetGirderCount(endGroupIdx) - 1;
   SegmentIndexType segIdx = GetSegmentCount(endGroupIdx, gdrIdx) - 1;
   CSegmentKey endSegmentKey(endGroupIdx, gdrIdx, segIdx);

   bool bCantileverStart, bCantileverEnd, bDummy;
   ModelCantilevers(startSegmentKey, &bCantileverStart, &bDummy);
   ModelCantilevers(endSegmentKey, &bDummy, &bCantileverEnd);
   if (bCantileverStart || bCantileverEnd)
   {
      // the deck boundary perimeter doesn't include cantilevers... if we have cantilevers, we have
      // to model this the hard way

      // NOTE: Do all work in local coordinates and then convert at end if requested
      CComPtr<IAlignment> alignment;
      GetAlignment(&alignment);

      ASSERT(3 <= nPoints);

      CComPtr<IPoint2dCollection> thePoints;
      thePoints.CoCreateInstance(CLSID_Point2dCollection);

      PierIndexType startPierIdx = startSpanIdx;
      PierIndexType endPierIdx = endSpanIdx + 1;

      Float64 startStation = GetPierStation(startPierIdx);
      Float64 endStation = GetPierStation(endPierIdx);

      // If at start or end of bridge, adjust for cantilevered girders
      if (startSpanIdx == 0)
      {
         CComPtr<IPoint2d> pntPier1, pntEnd1, pntBrg1, pntBrg2, pntEnd2, pntPier2;
         GetSegmentEndPoints(CSegmentKey(0, 0, 0), pgsTypes::pcLocal, &pntPier1, &pntEnd1, &pntBrg1, &pntBrg2, &pntEnd2, &pntPier2);

         CComPtr<IPoint2d> p1 = pntEnd1;

         pntPier1.Release();
         pntEnd1.Release();
         pntBrg1.Release();
         pntBrg2.Release();
         pntEnd2.Release();
         pntPier2.Release();

         GirderIndexType nGirders = GetGirderCountBySpan(startSpanIdx);
         GetSegmentEndPoints(CSegmentKey(0, nGirders - 1, 0), pgsTypes::pcLocal, &pntPier1, &pntEnd1, &pntBrg1, &pntBrg2, &pntEnd2, &pntPier2);

         CComPtr<IPoint2d> p2 = pntEnd1;

         CComPtr<ILine2d> line;
         line.CoCreateInstance(CLSID_Line2d);
         HRESULT hr = line->ThroughPoints(p1, p2);

         CComPtr<IPoint2d> pntIntersect;
         if (SUCCEEDED(hr))
         {
            alignment->IntersectEx(line, p1, VARIANT_TRUE, VARIANT_TRUE, &pntIntersect);
         }
         else
         {
            // p1 and p2 are at the same point... can't create a line
            CComPtr<IStation> station;
            VARIANT_BOOL vbOnProjection;
            alignment->ProjectPoint(p1, &pntIntersect, &station,&vbOnProjection);
         }

         CComPtr<IStation> objStation;
         Float64 offset;
         alignment->StationAndOffset(pntIntersect, &objStation, &offset);

         Float64 station;
         objStation->get_Value(&station);
         if (station < startStation)
         {
            startStation = station;
         }
      }


      SpanIndexType nSpans = GetSpanCount();
      if (endSpanIdx == nSpans - 1)
      {
         GroupIndexType grpIdx = GetGirderGroupIndex(endSpanIdx);
         SegmentIndexType segIdx = GetSegmentCount(grpIdx, 0) - 1;
         CComPtr<IPoint2d> pntPier1, pntEnd1, pntBrg1, pntBrg2, pntEnd2, pntPier2;
         GetSegmentEndPoints(CSegmentKey(grpIdx, 0, segIdx), pgsTypes::pcLocal, &pntPier1, &pntEnd1, &pntBrg1, &pntBrg2, &pntEnd2, &pntPier2);

         CComPtr<IPoint2d> p1 = pntEnd2;

         pntPier1.Release();
         pntEnd1.Release();
         pntBrg1.Release();
         pntBrg2.Release();
         pntEnd2.Release();
         pntPier2.Release();

         GirderIndexType nGirders = GetGirderCountBySpan(endSpanIdx);
         GetSegmentEndPoints(CSegmentKey(grpIdx, nGirders - 1, segIdx), pgsTypes::pcLocal, &pntPier1, &pntEnd1, &pntBrg1, &pntBrg2, &pntEnd2, &pntPier2);

         CComPtr<IPoint2d> p2 = pntEnd2;

         CComPtr<ILine2d> line;
         line.CoCreateInstance(CLSID_Line2d);
         HRESULT hr = line->ThroughPoints(p1, p2);

         CComPtr<IPoint2d> pntIntersect;
         if (SUCCEEDED(hr))
         {
            alignment->IntersectEx(line, p1, VARIANT_TRUE, VARIANT_TRUE, &pntIntersect);
         }
         else
         {
            // p1 and p2 are at the same point... can't create a line
            CComPtr<IStation> station;
            VARIANT_BOOL vbOnProjection;
            alignment->ProjectPoint(p1, &pntIntersect, &station, &vbOnProjection);
         }

         CComPtr<IStation> objStation;
         Float64 offset;
         alignment->StationAndOffset(pntIntersect, &objStation, &offset);

         Float64 station;
         objStation->get_Value(&station);

         if (endStation < station)
         {
            endStation = station;
         }
      }

      Float64 stationInc = (endStation - startStation) / (nPoints - 1);

      // Store all deck stations in a set so we are sorted and don't have any duplicate points
      std::set<Float64> deckStations;
      Float64 station = startStation;

      for (CollectionIndexType pntIdx = 0; pntIdx < nPoints; pntIdx++)
      {
         deckStations.insert(station);
         station += stationInc;
      }

      // Add in deck transition stations so we don't miss sharp changes in deck geometry
      GET_IFACE(IBridgeDescription, pIBridgeDesc);
      const CDeckDescription2* pDeck = pIBridgeDesc->GetDeckDescription();

      for (const auto& deckPoint : pDeck->DeckEdgePoints)
      {
         // No need to check if location is on bridge - that will be picked up later
         deckStations.insert(deckPoint.Station);
      }

      // Add pier stations
      for (PierIndexType pierIdx = startPierIdx; pierIdx <= endPierIdx; pierIdx++)
      {
         deckStations.insert(pIBridgeDesc->GetPier(pierIdx)->GetStation());
      }

      CComPtr<IDirection> startDirection, endDirection;
      GetPierDirection(startPierIdx, &startDirection);
      GetPierDirection(endPierIdx, &endDirection);
      Float64 dirStart, dirEnd;
      startDirection->get_Value(&dirStart);
      endDirection->get_Value(&dirEnd);

      // Locate points along right side of deck
      // Get station of deck points at first and last piers, projected normal to aligment
      CComPtr<IPoint2d> objStartPointRight, objEndPointRight;
      m_BridgeGeometryTool->DeckEdgePoint(m_Bridge, startStation, startDirection, qcbRight, &objStartPointRight);
      m_BridgeGeometryTool->DeckEdgePoint(m_Bridge, endStation, endDirection, qcbRight, &objEndPointRight);

      Float64 start_normal_station_right, end_normal_station_right;
      Float64 offset;

      GetStationAndOffset(pgsTypes::pcLocal, objStartPointRight, &start_normal_station_right, &offset);
      GetStationAndOffset(pgsTypes::pcLocal, objEndPointRight, &end_normal_station_right, &offset);

      // If there is a skew, the first deck edge can be before the pier station, or after it. 
      // Same for the last deck edge. We must deal with this
      thePoints->Add(objStartPointRight);

      for (const auto& station : deckStations)
      {
         if (start_normal_station_right < station && station < end_normal_station_right)
         {
            CComPtr<IDirection> objDirection;
            alignment->GetNormal(CComVariant(station), &objDirection);

            CComPtr<IPoint2d> point;
            HRESULT hr = m_BridgeGeometryTool->DeckEdgePoint(m_Bridge, station, objDirection, qcbRight, &point);
            ATLASSERT(SUCCEEDED(hr));

            thePoints->Add(point);
         }
      }

      thePoints->Add(objEndPointRight);

      // Locate points along left side of deck (working backwards)
      CComPtr<IPoint2d> objStartPointLeft, objEndPointLeft;
      m_BridgeGeometryTool->DeckEdgePoint(m_Bridge, startStation, startDirection, qcbLeft, &objStartPointLeft);
      m_BridgeGeometryTool->DeckEdgePoint(m_Bridge, endStation, endDirection, qcbLeft, &objEndPointLeft);

      Float64 start_normal_station_left, end_normal_station_left;

      GetStationAndOffset(pgsTypes::pcLocal, objStartPointLeft, &start_normal_station_left, &offset);
      GetStationAndOffset(pgsTypes::pcLocal, objEndPointLeft, &end_normal_station_left, &offset);

      thePoints->Add(objEndPointLeft);

      BOOST_REVERSE_FOREACH(Float64 station, deckStations)
      {
         if (start_normal_station_left < station && station < end_normal_station_left)
         {
            CComPtr<IDirection> objDirection;
            alignment->GetNormal(CComVariant(station), &objDirection);

            CComPtr<IPoint2d> point;
            HRESULT hr = m_BridgeGeometryTool->DeckEdgePoint(m_Bridge, station, objDirection, qcbLeft, &point);
            ATLASSERT(SUCCEEDED(hr));

            thePoints->Add(point);
         }
      }

      thePoints->Add(objStartPointLeft);

      (*points) = thePoints;
      (*points)->AddRef();
   }
   else
   {
      PierIndexType startPierIdx = startSpanIdx;
      PierIndexType endPierIdx = endSpanIdx + 1;

      CComPtr<IBridgeGeometry> geometry;
      m_Bridge->get_BridgeGeometry(&geometry);

      CComPtr<IDeckBoundary> deckBoundary;
      geometry->get_DeckBoundary(&deckBoundary);

      PierIDType startPierID = ::GetPierLineID(startPierIdx);
      PierIDType endPierID = ::GetPierLineID(endPierIdx);

      deckBoundary->get_PerimeterEx(nPoints, startPierID, 0.0, endPierID, 0.0, VARIANT_TRUE, points);
   }

   if (pcType == pgsTypes::pcGlobal)
   {
      (*points)->Offset(m_DeltaX, m_DeltaY);
   }
}

Float64 CBridgeAgentImp::GetBearingStation(PierIndexType pierIdx, pgsTypes::PierFaceType pierFace) const
{
   VALIDATE(BRIDGE);

   GroupIndexType grpIdx = GetGirderGroupAtPier(pierIdx, pierFace);
   CGirderKey leftGirderKey(grpIdx, 0);
   CGirderKey rightGirderKey(grpIdx, GetGirderCount(grpIdx) - 1);

   // Get the segments that intersects this pier
   CComPtr<ISuperstructureMemberSegment> leftSegment, rightSegment;
   GetSegmentAtPier(pierIdx, leftGirderKey, &leftSegment);
   GetSegmentAtPier(pierIdx, rightGirderKey, &rightSegment);

   // Get the girder line for the segments
   CComPtr<IGirderLine> leftGirderLine, rightGirderLine;
   leftSegment->get_GirderLine(&leftGirderLine);
   rightSegment->get_GirderLine(&rightGirderLine);

   // Get the pier line
   CComPtr<IPierLine> pierLine;
   GetPierLine(pierIdx, &pierLine);

   // Get intersection of alignment and pier
   CComPtr<IPoint2d> pntPierAlignment;
   pierLine->get_AlignmentPoint(&pntPierAlignment);

   // Get the intersection of the pier line and the girder lines
   CComPtr<ILine2d> clPier;
   pierLine->get_Centerline(&clPier);

   CComPtr<IPath> leftGdrPath, rightGdrPath;
   leftGirderLine->get_Path(&leftGdrPath);
   rightGirderLine->get_Path(&rightGdrPath);

   CComPtr<IPoint2d> pntPierLeftGirder, pntPierRightGirder;
   leftGdrPath->Intersect(clPier, pntPierAlignment, &pntPierLeftGirder);
   rightGdrPath->Intersect(clPier, pntPierAlignment, &pntPierRightGirder);

   // Get the offset from the CL pier to the point of bearing, measured along the CL girder
   CComPtr<IDirection> leftGirderDirection, rightGirderDirection;
   leftGirderLine->get_Direction(&leftGirderDirection);
   rightGirderLine->get_Direction(&rightGirderDirection);

   Float64 leftBrgOffset, rightBrgOffset;
   pierLine->GetBearingOffset(pierFace == pgsTypes::Ahead ? pfAhead : pfBack, leftGirderDirection, &leftBrgOffset);
   pierLine->GetBearingOffset(pierFace == pgsTypes::Ahead ? pfAhead : pfBack, rightGirderDirection, &rightBrgOffset);

   if (pierFace == pgsTypes::Back)
   {
      leftBrgOffset *= -1;
      rightBrgOffset *= -1;
   }


   // Locate the intersection of the CL girder and the point of bearing
   CComPtr<ILocate2> locate;
   m_CogoEngine->get_Locate(&locate);
   CComPtr<IPoint2d> pntBrgLeftGirder, pntBrgRightGirder;
   locate->ByDistDir(pntPierLeftGirder, leftBrgOffset, CComVariant(leftGirderDirection), 0.0, &pntBrgLeftGirder);
   locate->ByDistDir(pntPierRightGirder, rightBrgOffset, CComVariant(rightGirderDirection), 0.0, &pntBrgRightGirder);

	// Create a line for the CL Bearing line by connecting the left/right brg/girder intersection points
   CComPtr<IAlignment> alignment;
   GetAlignment(&alignment);
   CComPtr<IPoint2d> pntAlignmentBearingIntersection;

	CComPtr<ILine2d> brgLine;
	brgLine.CoCreateInstance(CLSID_Line2d);
	if (SUCCEEDED(brgLine->ThroughPoints(pntBrgLeftGirder, pntBrgRightGirder)))
	{
		// Intersect the bearing line with the alignment
		alignment->Intersect(brgLine, pntBrgLeftGirder, &pntAlignmentBearingIntersection);
	}
	else
	{
		// if this fails, it is because there is only a single girder line
		pntAlignmentBearingIntersection = pntBrgLeftGirder;
	}

	// Get station and offset for this point
	CComPtr<IStation> objStation;
	Float64 station, offset;
	alignment->StationAndOffset(pntAlignmentBearingIntersection,&objStation,&offset);
	objStation->get_Value(&station);

	ATLASSERT(IsZero(offset));

   return station;
}

void CBridgeAgentImp::GetWorkingPointLocation(PierIndexType pierIdx,pgsTypes::PierFaceType pierFace,const CGirderKey& girderKey,Float64* pStation,Float64* pOffset) const
{
   // returns the station, where a line projected from the intersection of the
   // centerline of bearing and the centerline of girder, intersects the alignment
   // at a right angle
   VALIDATE( BRIDGE );

   // Get the segment that intersects this pier
   CComPtr<ISuperstructureMemberSegment> segment;
   GetSegmentAtPier(pierIdx,girderKey,&segment);

   // Get the girder line for that segment
   CComPtr<IGirderLine> girderLine;
   segment->get_GirderLine(&girderLine);

   // Get the pier line
   CComPtr<IPierLine> pierLine;
   GetPierLine(pierIdx,&pierLine);

   // Get intersection of alignment and pier
   CComPtr<IPoint2d> pntPierAlignment;
   pierLine->get_AlignmentPoint(&pntPierAlignment);

   // Get the intersection of the pier line and the girder line
   CComPtr<ILine2d> clPier;
   pierLine->get_Centerline(&clPier);

   CComPtr<IPath> gdrPath;
   girderLine->get_Path(&gdrPath);

   CComPtr<IPoint2d> pntPierGirder;
   gdrPath->Intersect(clPier,pntPierAlignment,&pntPierGirder);

   // Get the offset from the CL pier to the point of bearing, measured along the CL girder
   CComPtr<IDirection> girderDirection;
   girderLine->get_Direction(&girderDirection);

   Float64 brgOffset;
   pierLine->GetBearingOffset(pierFace == pgsTypes::Ahead ? pfAhead : pfBack,girderDirection,&brgOffset);

   if ( pierFace == pgsTypes::Back )
   {
      brgOffset *= -1;
   }

   // Locate the intersection of the CL girder and the point of bearing
   CComPtr<ILocate2> locate;
   m_CogoEngine->get_Locate(&locate);
   CComPtr<IPoint2d> pntBrgGirder;
   locate->ByDistDir(pntPierGirder,brgOffset,CComVariant(girderDirection),0.0,&pntBrgGirder);

   // Get station and offset for this point
   CComPtr<IStation> objStation;
   Float64 station, offset;
   CComPtr<IAlignment> alignment;
   GetAlignment(&alignment);
   alignment->StationAndOffset(pntBrgGirder,&objStation,&offset);
   objStation->get_Value(&station);

   *pStation = station;
   *pOffset = offset;
}

void CBridgeAgentImp::GetPierDirection(PierIndexType pierIdx,IDirection** ppDirection) const
{
   VALIDATE( BRIDGE );

   CComPtr<IBridgeGeometry> bridgeGeometry;
   m_Bridge->get_BridgeGeometry(&bridgeGeometry);

   PierIDType pierLineID = ::GetPierLineID(pierIdx);

   CComPtr<IPierLine> line;
   bridgeGeometry->FindPierLine(pierLineID,&line);

   line->get_Direction(ppDirection);
}

void CBridgeAgentImp::GetPierSkew(PierIndexType pierIdx,IAngle** ppAngle) const
{
   VALIDATE( BRIDGE );

   CComPtr<IBridgeGeometry> bridgeGeometry;
   m_Bridge->get_BridgeGeometry(&bridgeGeometry);

   PierIDType pierLineID = ::GetPierLineID(pierIdx);

   CComPtr<IPierLine> line;
   bridgeGeometry->FindPierLine(pierLineID,&line);

   line->get_Skew(ppAngle);
}

void CBridgeAgentImp::GetPierPoints(PierIndexType pierIdx,pgsTypes::PlanCoordinateType pcType,IPoint2d** left,IPoint2d** alignment,IPoint2d** bridge,IPoint2d** right) const
{
   VALIDATE( BRIDGE );

   CComPtr<IBridgeGeometry> geometry;
   m_Bridge->get_BridgeGeometry(&geometry);

   CComPtr<IPierLine> pierLine;
   geometry->FindPierLine(::GetPierLineID(pierIdx),&pierLine);

   pierLine->get_LeftPoint(left);
   pierLine->get_AlignmentPoint(alignment);
   pierLine->get_BridgePoint(bridge);
   pierLine->get_RightPoint(right);

   if ( pcType == pgsTypes::pcGlobal )
   {
      (*left)->Offset(m_DeltaX,m_DeltaY);
      (*alignment)->Offset(m_DeltaX,m_DeltaY);
      (*bridge)->Offset(m_DeltaX,m_DeltaY);
      (*right)->Offset(m_DeltaX,m_DeltaY);
   }
}

void CBridgeAgentImp::IsContinuousAtPier(PierIndexType pierIdx,bool* pbLeft,bool* pbRight) const
{
   GET_IFACE(IBridgeDescription,pIBridgeDesc);
   const CBridgeDescription2* pBridgeDesc = pIBridgeDesc->GetBridgeDescription();
   const CPierData2* pPierData = pBridgeDesc->GetPier(pierIdx);
   ATLASSERT( pPierData );

   *pbLeft  = pPierData->IsContinuous();
   *pbRight = *pbLeft;

   if ( pierIdx == 0 && *pbRight == false )
   {
      // first pier and not already continuous... see if
      // there is a cantilever as that will make it continuous
      bool bCantileverStart, bCantileverEnd;
      ModelCantilevers(CSegmentKey(0,0,0),&bCantileverStart,&bCantileverEnd);
      *pbRight = bCantileverStart;
      *pbLeft  = bCantileverStart;
   }

   if ( pierIdx == pBridgeDesc->GetPierCount()-1 && *pbLeft == false )
   {
      // last pier and not already continuous... see if
      // there is a cantilever as that will make it continuous
      GroupIndexType grpIdx = pBridgeDesc->GetGirderGroupCount()-1;
      SegmentIndexType segIdx = pBridgeDesc->GetGirderGroup(grpIdx)->GetGirder(0)->GetSegmentCount()-1;
      bool bCantileverStart, bCantileverEnd;
      ModelCantilevers(CSegmentKey(grpIdx,0,segIdx),&bCantileverStart,&bCantileverEnd);
      *pbRight = bCantileverEnd;
      *pbLeft  = bCantileverEnd;
   }
}

void CBridgeAgentImp::IsIntegralAtPier(PierIndexType pierIdx,bool* pbLeft,bool* pbRight) const
{
   GET_IFACE(IBridgeDescription,pIBridgeDesc);
   const CBridgeDescription2* pBridgeDesc = pIBridgeDesc->GetBridgeDescription();
   const CPierData2* pPierData = pBridgeDesc->GetPier(pierIdx);
   ATLASSERT( pPierData );

   pPierData->IsIntegral(pbLeft,pbRight);
}

bool CBridgeAgentImp::GetPierLocation(PierIndexType pierIdx,const CSegmentKey& segmentKey,Float64* pXs) const
{
   CComPtr<IPoint2d> pntSupport1,pntEnd1,pntBrg1,pntBrg2,pntEnd2,pntSupport2;
   GetSegmentEndPoints(segmentKey,pgsTypes::pcLocal,&pntSupport1,&pntEnd1,&pntBrg1,&pntBrg2,&pntEnd2,&pntSupport2);

   CComPtr<IPoint2d> pntPier;
   if ( !GetSegmentPierIntersection(segmentKey,pierIdx,pgsTypes::pcLocal,&pntPier) )
   {
      return false;
   }

   CComPtr<IMeasure2> measure;
   m_CogoEngine->get_Measure(&measure);

   // Measure offset from pntEnd1 so that offset is in the segment coordinate system
   CComPtr<IDirection> direction; // direction from end to pier point
   Float64 offset; // this is always a positive value because it is a distance
   measure->Inverse(pntEnd1,pntPier,&offset,&direction);
   if ( IsZero(offset) )
   {
      *pXs = 0;
   }
   else
   {
      // need to determine if the intersection with the pier line is before or after the
      // start end of the segment. we do this by comparing directions
      CComPtr<IDirection> dirSegment;
      measure->Direction(pntEnd1,pntEnd2,&dirSegment); // direction of segment

      Float64 d1,d2;
      direction->get_Value(&d1);
      dirSegment->get_Value(&d2);

      if ( IsEqual(d1,d2) )
      {
         // same direction so offset is fine
         *pXs = offset;
      }
      else
      {
         // opposite directions so pier point is before the start of the segment
         // so offset is negative in segment coordinates
         *pXs = -offset;
      }
   }
 
   return true;
}

bool CBridgeAgentImp::GetPierLocation(const CGirderKey& girderKey,PierIndexType pierIdx,Float64* pXgp) const
{
   ASSERT_GIRDER_KEY(girderKey);
   PierIndexType startPierIdx, endPierIdx;
   GetGirderGroupPiers(girderKey.groupIndex,&startPierIdx,&endPierIdx);
   if ( pierIdx < startPierIdx || endPierIdx < pierIdx )
   {
      ATLASSERT(false); // why aren't you asking for a pier that is in the group?
      return false;
   }

   SegmentIndexType nSegments = GetSegmentCount(girderKey);
   for ( SegmentIndexType segIdx = 0; segIdx < nSegments; segIdx++ )
   {
      CSegmentKey segmentKey(girderKey,segIdx);
      Float64 Xs;
      bool bResult = GetPierLocation(pierIdx,segmentKey,&Xs);
      if ( bResult == true )
      {
         Float64 Xsp = ConvertSegmentCoordinateToSegmentPathCoordinate(segmentKey,Xs);
         Float64 Xgp = ConvertSegmentPathCoordinateToGirderPathCoordinate(segmentKey,Xsp);
         *pXgp = Xgp;
         return true;
      }
   }

   ATLASSERT(false); // why aren't you asking for a pier that is in the group?
   return false;
}

bool CBridgeAgentImp::GetSkewAngle(Float64 station,LPCTSTR strOrientation,Float64* pSkew) const
{
   VALIDATE( COGO_MODEL );

   CComPtr<IAlignment> alignment;
   GetAlignment(&alignment);

   std::_tstring orientation(strOrientation);
   std::transform(std::cbegin(orientation),std::cend(orientation),std::begin(orientation),(int(*)(int))std::toupper);

   if ( orientation.compare(_T("N")) == 0 || orientation.compare(_T("NORMAL")) == 0 )
   {
      // normal to alignment
      *pSkew = 0.0;
   }
   else if ( orientation[0] == _T('N') || orientation[0] == _T('S') )
   {
      // defined by bearing
      CComPtr<IDirection> brg;
      brg.CoCreateInstance(CLSID_Direction);
      HRESULT hr = brg->FromString(CComBSTR(strOrientation));
      if ( FAILED(hr) )
      {
         return false;
      }

      CComPtr<IDirection> normal;
      alignment->GetNormal(CComVariant(station),&normal);

      CComPtr<IAngle> angle;
      brg->AngleBetween(normal,&angle);

      Float64 value;
      angle->get_Value(&value);

      while ( PI_OVER_2 < value )
      {
         value -= M_PI;
      }

      *pSkew = value;
   }
   else
   {
      // defined by skew angle
      CComPtr<IAngle> angle;
      angle.CoCreateInstance(CLSID_Angle);
      HRESULT hr = angle->FromString(CComBSTR(strOrientation));
      if ( FAILED(hr) )
      {
         return false;
      }

      Float64 value;
      angle->get_Value(&value);
      *pSkew = value;
   }

   return true;
}

pgsTypes::PierModelType CBridgeAgentImp::GetPierModelType(PierIndexType pierIdx) const
{
   GET_IFACE(IBridgeDescription,pIBridgeDesc);
   const CPierData2* pPier = pIBridgeDesc->GetPier(pierIdx);
   return pPier->GetPierModelType();
}

ColumnIndexType CBridgeAgentImp::GetColumnCount(PierIndexType pierIdx) const
{
   GET_IFACE(IBridgeDescription,pIBridgeDesc);
   const CPierData2* pPier = pIBridgeDesc->GetPier(pierIdx);
   if ( pPier->GetPierModelType() == pgsTypes::pmtIdealized )
   {
      return 0;
   }
   else
   {
      return pPier->GetColumnCount();
   }
}

void CBridgeAgentImp::GetColumnProperties(PierIndexType pierIdx,ColumnIndexType colIdx,bool bSkewAdjust,Float64* pHeight,Float64* pA,Float64* pI) const
{
   GET_IFACE(IBridgeDescription,pIBridgeDesc);
   const CPierData2* pPier = pIBridgeDesc->GetPier(pierIdx);
   if ( pPier->GetPierModelType() == pgsTypes::pmtIdealized )
   {
      *pHeight = 0;
      *pA = 0;
      *pI = 0;
   }
   else
   {
#pragma Reminder("UPDATE: this information should be coming from the generic bridge model")
      const CColumnData& columnData = pPier->GetColumnData(colIdx);
      Float64 A, I;
      Float64 D1, D2;
      columnData.GetColumnDimensions(&D1,&D2);
      if ( columnData.GetColumnShape() == CColumnData::cstCircle )
      {
         A = M_PI*D1*D1/4;
         I = M_PI*D1*D1*D1*D1/64;
      }
      else
      {
         A = D1*D2;

         // in centroidal coodinates
         Float64 Ix = D1*D2*D2*D2/12;
         Float64 Iy = D2*D1*D1*D1/12;

         // use Mohr's circle to get ix about an axis that is normal to the alignment
         if ( bSkewAdjust )
         {
            CComPtr<IMohrCircle> mc;
            mc.CoCreateInstance(CLSID_MohrCircle);
            mc->put_Sii(Ix);
            mc->put_Sjj(Iy);
            mc->put_Sij(0);

            CComPtr<IAngle> objSkew;
            GetPierSkew(pierIdx,&objSkew);
            Float64 skew;
            objSkew->get_Value(&skew);

            Float64 ix;
            mc->ComputeSxx(-skew,&ix);
            ATLASSERT(0 < ix);
            I = ix;
         }
         else
         {
            I = Ix;
         }
      }

      *pA = A;
      *pI = I;

      if ( columnData.GetColumnHeightMeasurementType() == CColumnData::chtHeight )
      {
         *pHeight = columnData.GetColumnHeight();
      }
      else
      {
         ATLASSERT(columnData.GetColumnHeightMeasurementType() == CColumnData::chtBottomElevation);
         Float64 top_roadway_elevation = GetElevation(pPier->GetStation(),0.0);
         Float64 superstructure_depth = GetSuperstructureDepth(pierIdx);
        
#pragma Reminder("UPDATE - need a better way to determine cross beam depth")
         // Need to use the WBFLGenericBridge::BridgePier object for pier geometry
         // If we build a full pier model in the generic bridge model, we could
         // just request this information
         Float64 h1, h2, lt, eso;
         pPier->GetXBeamDimensions(pgsTypes::stLeft,&h1,&h2,&lt,&eso);
         Float64 cross_beam_depth = h1 + h2;

#pragma Reminder("UPDATE: need to account for bearing recess, bearing depth, and grout pad depth")
         Float64 bottom_column_elevation = columnData.GetColumnHeight();
         Float64 column_height = top_roadway_elevation - superstructure_depth - cross_beam_depth - bottom_column_elevation;
         *pHeight = column_height;
      }
   }
}

pgsTypes::BoundaryConditionType CBridgeAgentImp::GetBoundaryConditionType(PierIndexType pierIdx) const
{
   GET_IFACE(IBridgeDescription,pIBridgeDesc);
   const CPierData2* pPier = pIBridgeDesc->GetPier(pierIdx);
   ATLASSERT(pPier->IsBoundaryPier());
   return pPier->GetBoundaryConditionType();
}

pgsTypes::PierSegmentConnectionType CBridgeAgentImp::GetPierSegmentConnectionType(PierIndexType pierIdx) const
{
   GET_IFACE(IBridgeDescription,pIBridgeDesc);
   const CPierData2* pPier = pIBridgeDesc->GetPier(pierIdx);
   ATLASSERT(pPier->IsInteriorPier());
   return pPier->GetSegmentConnectionType();
}

bool CBridgeAgentImp::IsAbutment(PierIndexType pierIdx) const
{
   GET_IFACE(IBridgeDescription,pIBridgeDesc);
   const CPierData2* pPier = pIBridgeDesc->GetPier(pierIdx);
   return pPier->IsAbutment();
}

bool CBridgeAgentImp::IsPier(PierIndexType pierIdx) const
{
   GET_IFACE(IBridgeDescription,pIBridgeDesc);
   const CPierData2* pPier = pIBridgeDesc->GetPier(pierIdx);
   return pPier->IsPier();
}

bool CBridgeAgentImp::IsInteriorPier(PierIndexType pierIdx) const
{
   GET_IFACE(IBridgeDescription,pIBridgeDesc);
   const CPierData2* pPier = pIBridgeDesc->GetPier(pierIdx);
   return pPier->IsInteriorPier();
}

bool CBridgeAgentImp::IsBoundaryPier(PierIndexType pierIdx) const
{
   GET_IFACE(IBridgeDescription,pIBridgeDesc);
   const CPierData2* pPier = pIBridgeDesc->GetPier(pierIdx);
   return pPier->IsBoundaryPier();
}

bool CBridgeAgentImp::ProcessNegativeMoments(SpanIndexType spanIdx) const
{
   PierIndexType startPierIdx = PierIndexType(spanIdx == ALL_SPANS ? 0 : spanIdx);
   PierIndexType endPierIdx   = PierIndexType(spanIdx == ALL_SPANS ? GetSpanCount() : spanIdx+1);

   // Start by checking if there are cantilevers at the start/end of the span. If so,
   // there will be negative moments
   if ( startPierIdx == 0 )
   {
      CSegmentKey segmentKey(0,0,0);
      bool bStartCantilever, bEndCantilever;
      ModelCantilevers(segmentKey,&bStartCantilever,&bEndCantilever);
      if ( bStartCantilever )
      {
         // there will be negative moments in this span
         return true;
      }
   }

   PierIndexType nPiers = GetPierCount();
   if ( endPierIdx == nPiers-1 )
   {
      GroupIndexType nGroups = GetGirderGroupCount();
      SegmentIndexType nSegments = GetSegmentCount(nGroups-1,0);
      CSegmentKey segmentKey(nGroups-1,0,nSegments-1);
      bool bStartCantilever, bEndCantilever;
      ModelCantilevers(segmentKey,&bStartCantilever,&bEndCantilever);
      if ( bEndCantilever )
      {
         // there will be negative moments in this span
         return true;
      }
   }

   // don't need to process negative moments if this is a simple span design
   // or if there isn't any continuity
   GET_IFACE(ISpecification,pSpec);
   pgsTypes::AnalysisType analysisType = pSpec->GetAnalysisType();
   if ( analysisType == pgsTypes::Simple )
   {
      return false;
   }

   for ( PierIndexType pierIdx = startPierIdx; pierIdx <= endPierIdx; pierIdx++ )
   {
      bool bContinuousLeft,bContinuousRight;
      IsContinuousAtPier(pierIdx,&bContinuousLeft,&bContinuousRight);

      bool bIntegralLeft,bIntegralRight;
      IsIntegralAtPier(pierIdx,&bIntegralLeft,&bIntegralRight);

      if ( bContinuousLeft || bContinuousRight || bIntegralLeft || bIntegralRight )
      {
         return true;
      }
   }

   return false;
}

void CBridgeAgentImp::GetTemporarySupportLocation(SupportIndexType tsIdx,GirderIndexType gdrIdx,SpanIndexType* pSpanIdx,Float64* pXspan) const
{
   // validate the bridge geometry because we are going to use it
   VALIDATE( BRIDGE );

   CComPtr<IBridgeGeometry> geometry;
   m_Bridge->get_BridgeGeometry(&geometry);


   // Figure out which span the temporary support is in
   GET_IFACE(IBridgeDescription,pIBridgeDesc);
   const CBridgeDescription2* pBridgeDesc = pIBridgeDesc->GetBridgeDescription();
   const CTemporarySupportData* pTS = pBridgeDesc->GetTemporarySupport(tsIdx);
   const CSpanData2* pSpan = pTS->GetSpan();
   *pSpanIdx = pSpan->GetIndex();

   // get the spliced girder object
   const CGirderGroupData* pGroup = pBridgeDesc->GetGirderGroup(pSpan);
   GroupIndexType grpIdx = pGroup->GetIndex();
   const CSplicedGirderData* pGirder = pGroup->GetGirder(gdrIdx);

   // get some geometric information about the temporary support
   Float64 tsStation = pTS->GetStation();

   CComPtr<IPierLine> tsLine;
   geometry->FindPierLine(::GetTempSupportLineID(tsIdx),&tsLine);

   CComPtr<ILine2d> clTS;
   tsLine->get_Centerline(&clTS);

   CComPtr<IPoint2d> pntNearest;
   tsLine->get_AlignmentPoint(&pntNearest);

   // find where the temporary support intersects the girder line.... sum up the distances
   // to find the location from the start of the span
   Float64 location = 0;
   std::vector<std::pair<SegmentIndexType,Float64>> seg_lengths(GetSegmentLengths(CSpanKey(*pSpanIdx,gdrIdx)));
   std::vector<std::pair<SegmentIndexType,Float64>>::iterator iter(seg_lengths.begin());
   std::vector<std::pair<SegmentIndexType,Float64>>::iterator iterEnd(seg_lengths.end());
   for ( ; iter != iterEnd; iter++ )
   {
      SegmentIndexType segIdx = (*iter).first;
      Float64 seg_length = (*iter).second; // length of segment in this span

      // get the segment
      const CPrecastSegmentData* pSegment = pGirder->GetSegment(segIdx);
      CSegmentKey segmentKey = pSegment->GetSegmentKey();

      // get the station boundary of the segment
      Float64 startStation, endStation;
      pSegment->GetStations(&startStation,&endStation);

      if ( IsEqual(tsStation,startStation) )
      {
         // Temp Support is at the start of this segment
         break;
      }

      if ( IsEqual(tsStation,endStation) )
      {
         // Temp Support is at the end of this segment. Add this segment's length
         location += seg_length;
         break;
      }

      if ( startStation < tsStation && tsStation < endStation )
      {
         // Temp support is in the middle of this segment. Determine how far it is from
         // the start of this segment to the temporary support. Add this distance to the running total

         // get the girder line
         LineIDType segID = ::GetGirderSegmentLineID(segmentKey);
         CComPtr<IGirderLine> girderLine;
         geometry->FindGirderLine(segID,&girderLine);

         // get the path (the actual geometry of the girder line)
         CComPtr<IPath> gdrPath;
         girderLine->get_Path(&gdrPath);

         // intersect the girder path and the CL of the temporar support
         CComPtr<IPoint2d> pntIntersect;
         gdrPath->Intersect(clTS,pntNearest,&pntIntersect);

         // get the distance and offset of intersection point from the start of the segment
         // dist is the distance from the start of this segment... if the segment starts in the
         // previous span this distance needs to be reduced by the length of this segment in the
         // previous span
         Float64 dist,offset;
         gdrPath->DistanceAndOffset(pntIntersect,&dist,&offset);
         ATLASSERT(IsZero(offset));

         if ( segIdx == 0 )
         {
            Float64 brgOffset = GetSegmentStartBearingOffset(CSegmentKey(grpIdx,gdrIdx,0));
            dist -= brgOffset; // want to measure location from start of span which begins at CL Bearing
         }

         Float64 length_in_prev_span = 0;
         if ( pSegment->GetSpanIndex(pgsTypes::metStart) < *pSpanIdx )
         {
            // part of this segment is in the previous span...
            Float64 true_segment_length = this->GetSegmentLayoutLength(CSegmentKey(grpIdx,gdrIdx,segIdx));
            length_in_prev_span = true_segment_length - seg_length;
         }
         dist -= length_in_prev_span;

         ATLASSERT( 0 < dist && dist < seg_length );

         // add in this distance
         location += dist;
         break;
      }

      // the temporary support doesn't intersect this segment... just add up the segment length
      // and go to the next segment
      location += seg_length;
   }

   *pXspan = location;

   ATLASSERT(*pXspan <= GetSpanLength(*pSpanIdx,gdrIdx));
}

bool CBridgeAgentImp::GetTemporarySupportLocation(SupportIndexType tsIdx,const CSegmentKey& segmentKey,Float64* pXs) const
{
   CComPtr<IPoint2d> pntSupport1,pntEnd1,pntBrg1,pntBrg2,pntEnd2,pntSupport2;
   GetSegmentEndPoints(segmentKey,pgsTypes::pcLocal,&pntSupport1,&pntEnd1,&pntBrg1,&pntBrg2,&pntEnd2,&pntSupport2);

   CComPtr<IPoint2d> pntTS;
   if ( !GetSegmentTempSupportIntersection(segmentKey,tsIdx,pgsTypes::pcLocal,&pntTS) )
   {
      *pXs = -99999; // obvious bogus value
      return false;
   }

   // Measure from pntEnd1 so that location is in the segment coordinate system
   pntTS->DistanceEx(pntEnd1,pXs);
 
   return true;
}

Float64 CBridgeAgentImp::GetTemporarySupportLocation(SupportIndexType tsIdx,GirderIndexType gdrIdx) const
{
   std::vector<CGirderKey> vGirderKeys;
   GetGirderline(gdrIdx, &vGirderKeys);
   for(const auto& thisGirderKey : vGirderKeys)
   {
      SegmentIndexType nSegments = GetSegmentCount(thisGirderKey);
      for ( SegmentIndexType segIdx = 0; segIdx < nSegments; segIdx++ )
      {
         CSegmentKey segmentKey(thisGirderKey,segIdx);
         Float64 Xs;
         bool bResult = GetTemporarySupportLocation(tsIdx,segmentKey,&Xs);
         if ( bResult == true )
         {
            Float64 Xsp = ConvertSegmentCoordinateToSegmentPathCoordinate(segmentKey, Xs);
            Float64 Xgp = ConvertSegmentPathCoordinateToGirderPathCoordinate(segmentKey, Xsp);
            return Xgp;
         }
      }
   }

   ATLASSERT(false); // should never get here
   return -99999;

}

pgsTypes::TemporarySupportType CBridgeAgentImp::GetTemporarySupportType(SupportIndexType tsIdx) const
{
   GET_IFACE(IBridgeDescription,pIBridgeDesc);
   const CBridgeDescription2* pBridgeDesc = pIBridgeDesc->GetBridgeDescription();
   const CTemporarySupportData* pTS = pBridgeDesc->GetTemporarySupport(tsIdx);

   return pTS->GetSupportType();
}

Float64 CBridgeAgentImp::GetTemporarySupportStation(SupportIndexType tsIdx) const
{
   GET_IFACE(IBridgeDescription, pIBridgeDesc);
   const CBridgeDescription2* pBridgeDesc = pIBridgeDesc->GetBridgeDescription();
   const CTemporarySupportData* pTS = pBridgeDesc->GetTemporarySupport(tsIdx);

   return pTS->GetStation();
}

pgsTypes::TempSupportSegmentConnectionType CBridgeAgentImp::GetSegmentConnectionTypeAtTemporarySupport(SupportIndexType tsIdx) const
{
   GET_IFACE(IBridgeDescription,pIBridgeDesc);
   const CBridgeDescription2* pBridgeDesc = pIBridgeDesc->GetBridgeDescription();
   const CTemporarySupportData* pTS = pBridgeDesc->GetTemporarySupport(tsIdx);
   return pTS->GetConnectionType();
}

void CBridgeAgentImp::GetSegmentsAtTemporarySupport(GirderIndexType gdrIdx,SupportIndexType tsIdx,CSegmentKey* pLeftSegmentKey,CSegmentKey* pRightSegmentKey) const
{
   GET_IFACE(IBridgeDescription,pIBridgeDesc);
   const CBridgeDescription2* pBridgeDesc = pIBridgeDesc->GetBridgeDescription();
   pBridgeDesc->GetSegmentsAtTemporarySupport(tsIdx,pLeftSegmentKey,pRightSegmentKey);
   pLeftSegmentKey->girderIndex = gdrIdx;
   pRightSegmentKey->girderIndex = gdrIdx;
}

void CBridgeAgentImp::GetTemporarySupportDirection(SupportIndexType tsIdx,IDirection** ppDirection) const
{
   VALIDATE( BRIDGE );

   CComPtr<IBridgeGeometry> bridgeGeometry;
   m_Bridge->get_BridgeGeometry(&bridgeGeometry);

   PierIDType pierLineID = ::GetTempSupportLineID(tsIdx);

   CComPtr<IPierLine> line;
   bridgeGeometry->FindPierLine(pierLineID,&line);

   line->get_Direction(ppDirection);
}

bool CBridgeAgentImp::HasTemporarySupportElevationAdjustments() const
{
   GET_IFACE(IBridgeDescription, pIBridgeDesc);
   const CBridgeDescription2* pBridgeDesc = pIBridgeDesc->GetBridgeDescription();
   SupportIndexType nTS = pBridgeDesc->GetTemporarySupportCount();
   for (SupportIndexType tsIdx = 0; tsIdx < nTS; tsIdx++)
   {
      const CTemporarySupportData* pTS = pBridgeDesc->GetTemporarySupport(tsIdx);
      if (pTS->HasElevationAdjustment() && !IsZero(pTS->GetElevationAdjustment()))
      {
         // just have to find one TS with a non-zero elevation adjustment
         return true;
      }
   }
   return false;
}

std::vector<BearingElevationDetails> CBridgeAgentImp::GetBearingElevationDetails(PierIndexType pierIdx, pgsTypes::PierFaceType face, GirderIndexType gdrIdx, bool bIgnoreUnrecoverableDeformations) const
{
   return GetBearingElevationDetails_Generic(pierIdx, face, CBridgeAgentImp::batBearings, gdrIdx, bIgnoreUnrecoverableDeformations);
}

std::vector<BearingElevationDetails> CBridgeAgentImp::GetBearingElevationDetailsAtGirderEdges(PierIndexType pierIdx, pgsTypes::PierFaceType face, GirderIndexType gdrIdx) const
{
   return GetBearingElevationDetails_Generic(pierIdx, face, CBridgeAgentImp::batGirderEdges, gdrIdx, false);
}

void CBridgeAgentImp::GetPierDisplaySettings(pgsTypes::DisplayEndSupportType* pStartPierType, pgsTypes::DisplayEndSupportType* pEndPierType, PierIndexType* pStartPierNumber) const
{
   GET_IFACE(IBridgeDescription,pIBridgeDesc);
   const CBridgeDescription2* pBridgeDesc = pIBridgeDesc->GetBridgeDescription();

   pBridgeDesc->GetPierDisplaySettings(pStartPierType, pEndPierType, pStartPierNumber);
}

std::vector<BearingElevationDetails> CBridgeAgentImp::GetBearingElevationDetails_Generic(PierIndexType pierIdx, pgsTypes::PierFaceType face, CBridgeAgentImp::BearingElevLocType locType,GirderIndexType gdrIndex,bool bIgnoreUnrecoverableDeformations) const
{
   PierIndexType nPiers = GetPierCount();
   // these are invalid locations so return an empty vector
   if ( pierIdx == 0 && face == pgsTypes::Back || pierIdx == nPiers-1 && face == pgsTypes::Ahead )
   {
      return std::vector<BearingElevationDetails>();
   }

   GroupIndexType grpIdx    = GetGirderGroupAtPier(pierIdx,face);

   GirderIndexType startGirder,endGirder;
   if (gdrIndex == ALL_GIRDERS)
   {
      startGirder = 0;
      endGirder = GetGirderCount(grpIdx) - 1;
   }
   else
   {
      startGirder = gdrIndex;
      endGirder   = gdrIndex;
   }
      
   bool isBoundaryPier = IsBoundaryPier(pierIdx);

   GET_IFACE(IBridgeDescription,pBridgeDesc);
   GET_IFACE_NOCHECK(IDeformedGirderGeometry,pDeformedGirderGeometry);

   // If haunchInputDepthType==hidACamber, we know that design and computed deck elevations are the same at bearings.
   pgsTypes::HaunchInputDepthType haunchInputDepthType = pBridgeDesc->GetHaunchInputDepthType();

   std::vector<BearingElevationDetails> vElevDetails;

   // Bearing elevation values are reported at the GCE
   IntervalIndexType gceInterval = GetGeometryControlInterval();

   bool bIsDeck = GetDeckType() != pgsTypes::sdtNone;

   Float64 overlayDepth = GetOverlayDepth(gceInterval);

   // Get pier direction
   CComPtr<IDirection> pierDirection;
   GetPierDirection(pierIdx, &pierDirection);
   Float64 pierDir;
   pierDirection->get_Value(&pierDir);
   CComVariant pierDirVar(pierDir);

   for ( GirderIndexType gdrIdx = startGirder; gdrIdx <= endGirder; gdrIdx++ )
   {
      const CBearingData2* pBearingData = pBridgeDesc->GetBearingData(pierIdx, face, gdrIdx);
      if (pBearingData == nullptr)
      {
         THROW_UNWIND(_T("Bearing data is incomplete. Cannot compute bearing seat elevations"), XREASON_BAD_BEARING_DATA);
      }

      // Get segment that intersects this pier
      CGirderKey girderKey(grpIdx, gdrIdx);
      CSegmentKey segmentKey = GetSegmentAtPier(pierIdx, girderKey);

      pgsPointOfInterest poi;
      if (isBoundaryPier)
      {
         PoiAttributeType attrib = face == pgsTypes::Ahead ? (POI_0L | POI_ERECTED_SEGMENT) : (POI_10L | POI_ERECTED_SEGMENT);
         PoiList vPois;
         GetPointsOfInterest(segmentKey, attrib, &vPois);
         ATLASSERT(vPois.size() == 1);
         poi = vPois.front();
      }
      else
      {
         // Interior Pier
         poi = GetPierPointOfInterest(girderKey, pierIdx);
      }

      Float64 grossSlabDepth = GetGrossSlabDepth();

      // girder slope angles
      Float64 girderOrientation = GetOrientation(segmentKey);
      girderOrientation = IsZero(girderOrientation) ? 0 : girderOrientation;

      Float64 basicGirderSlope = GetSegmentSlope(segmentKey); // includes temporary support elevation adjustment slopes
      basicGirderSlope = IsZero(basicGirderSlope) ? 0 : basicGirderSlope;
      Float64 precamberSlope = GetPrecamberSlope(poi);
      precamberSlope = IsZero(precamberSlope) ? 0 : precamberSlope;

      Float64 girderSlope = basicGirderSlope + precamberSlope;

      Float64 cosGirderLatSlope = CosSlope(girderOrientation);
      Float64 cosGirderLongSlope = CosSlope(girderSlope);

      // Find Work Point (WP) Location. WP is at the top CL of girder at girderline/bearingline intersections
      // Get point at along girder cl at bearing cl. This is x,y of work point
      Float64 workPointStation, workPointOffset;
      GetWorkingPointLocation(pierIdx, face, girderKey, &workPointStation, &workPointOffset);

      CComPtr<IDirection> normal;
      GetBearingNormal(workPointStation,&normal);

      // 2D Location of work point at CL girder/bearingline intersect
      CComPtr<IPoint2d> workPointPoint;
      GetPoint(workPointStation, workPointOffset,  normal, pgsTypes::pcLocal, &workPointPoint);

      // Get finished grade elevation at work point
      Float64 workPointDesignGradeElevation = GetElevation(workPointStation, workPointOffset);

      Float64 crossSlope = GetSlope(workPointStation, workPointOffset);
      crossSlope = IsZero(crossSlope) ? 0 : crossSlope;
      Float64 crossSlopeAngleAdjust = sqrt(1 +crossSlope*crossSlope);

      Float64 profileGrade = GetProfileGrade(workPointStation);
      profileGrade = IsZero(profileGrade) ? 0 : profileGrade;

      // Height of overlay lies along roadway grade and super
      Float64 profileAngleAdjust = sqrt(1 + profileGrade*profileGrade);
      Float64 roadwayAngleAdjust = crossSlopeAngleAdjust * profileAngleAdjust;

      Float64 adjOverlayDepth = overlayDepth * roadwayAngleAdjust; // Height increases with slope

      // Slab Offset can vary along segment since it can be different at each end, and affected by erection tower elevation adjustment
      // Get actual geometric slab offset at CL girder. Fix for Mantis 1256
      Float64 slabOffset(0.0), haunchDepth(0.0);
      if (bIsDeck)
      {
         if (haunchInputDepthType == pgsTypes::hidACamber)
         {
            slabOffset = GetTopSlabToTopGirderChordDistance(poi);
            haunchDepth = slabOffset - grossSlabDepth;
         }
         else
         {
            // Elevations for direct haunch input are not attached to the girder chord
            haunchDepth = GetStructuralHaunchDepth(poi,pgsTypes::hspDetailedDescription);
            slabOffset = haunchDepth + grossSlabDepth;
         }
      }

      // Compute elevation as if pier is not deflected from pgl. We will adjust for that later
      Float64 workPointElevation = workPointDesignGradeElevation - adjOverlayDepth - slabOffset;

      // Now locate BCL. BCL is CL bearing seat location at CL girder adjusted for girder orientation.
      // This is the location on pier where bearings are measured from along bearing line
      // BCL exists even if no physical bearing is actually there.
      // Refer to bearing computations documentation for more details
      IntervalIndexType intervalIdx = GetPrestressReleaseInterval(segmentKey);
      Float64 Hg = GetHg(intervalIdx, poi);
      Float64 Hb = pBearingData->GetNetBearingHeight();

      // BCL elevation
      // Adjust height for cross slope orientation. This is an increase because the distance is measured along the cl of the tilted girder
      // Adjust height for profile longitudinal slope. This increases height because the bearing lies vertically below the bearing station.
      Float64 girderHeightAdjustment = 1/(cosGirderLatSlope * cosGirderLongSlope);
      Float64 heightBCL = (Hg + Hb) * girderHeightAdjustment;

      Float64 elevBCL = workPointElevation - heightBCL;

      // BCL station and offset
      // Need slope of girder in plane of pier - this changes with skew angle between pier and girderline
      CComPtr<ISuperstructureMemberSegment> segment;
      GetSegment(segmentKey, &segment);
      CComPtr<IGirderLine> girderLine;
      segment->get_GirderLine(&girderLine);
      CComPtr<IDirection> girderDirection;
      girderLine->get_Direction(&girderDirection);
      CComPtr<IAngle> angleBetweenPierGirder;
      pierDirection->AngleBetween(girderDirection, &angleBetweenPierGirder);
      Float64 girderPierSkewAngle;
      angleBetweenPierGirder->get_Value(&girderPierSkewAngle);
      girderPierSkewAngle = M_PI - girderPierSkewAngle; // see sign convention in design doc

      // Horizontal distance between WP and BCL along pier line. Girder orientation is only aspect that affects this
      Float64 horizDistAlongPierToBCL = heightBCL * girderOrientation / sin(girderPierSkewAngle);

      CComPtr<IPoint2d> pointBCL;
      ByDistDir(workPointPoint, horizDistAlongPierToBCL, pierDirVar, 0.0, &pointBCL);

      Float64 stationBCL, offsetBCL;
      GetStationAndOffset(pgsTypes::pcLocal, pointBCL, &stationBCL, &offsetBCL);

      // Girders can have multiple bearings measured by spacing from BCL. Need total slope of girder along pier
      // Sign convention here is looking up station; right to left going upwards
      Float64 girderSlopeAlongPier = girderOrientation*sin(girderPierSkewAngle) + girderSlope*cos(girderPierSkewAngle);
      Float64 cosGirderSlopeAlongPier = CosSlope(girderSlopeAlongPier);

      // Tricky:
      // Bearing Dependent data. Girders can have multiple bearings or two edges 
      Float64 BrgRecess = pBearingData->RecessHeight;
      Float64 BrgHeight = pBearingData->Height;
      Float64 SolePlateHeight  = pBearingData->SolePlateHeight;

      IndexType numBrgs;
      Float64 leftBrgLoc;
      Float64 Spacing;

      if (locType == batBearings)
      {
         // Need data for each bearing at girder
         numBrgs = pBearingData->BearingCount;
         Spacing = pBearingData->Spacing;
         leftBrgLoc = (numBrgs==0) ? 0.0 : ((numBrgs-1) * Spacing)/2.0; // location of first bearing from cl girder
      }
      else
      {
         // Need data at bottom girder edges
         ATLASSERT(locType == batGirderEdges);
         numBrgs = 2;
         Spacing = GetBottomWidth(poi);
         leftBrgLoc = Spacing/2.0; // location of first bearing from cl girder
      }

      // Tricky: For multiple bearings at a girder, Bearing information of the BCL will always be the first result in the collection
      //         and the number of bearings reported will be numBrgs + 1.
      //         For single bearing cases, there will be only one result
      Float64 brgLoc = 0;
      for (IndexType brgIdx = 0; brgIdx <= numBrgs; brgIdx++)
      {
         if (1 == brgIdx)
         {
            if (1 == numBrgs)
            {
               break; // Only one result is created for this case
            }
            else
            {
               brgLoc = leftBrgLoc;
            }
         }
         else if (1 < brgIdx)
         {
            brgLoc -= Spacing;
         }

         // brgLoc is along pier at pier slope. Adjust bearing location to horizontal distance from BCL
         Float64 brgLocAdjusted = brgLoc * cosGirderSlopeAlongPier;

         // Begin filling our struct
         BearingElevationDetails elevDetails;
         elevDetails.GirderKey = girderKey;
         elevDetails.PierFace = face;

         if (0 == brgIdx)
         {
            if (1 == numBrgs)
            {
               // only one bearing and this one is it
               elevDetails.BearingIdx = IBridge::sbiSingleBearingValue;
            }
            else
            {
               // multiple bearings exist and the first one is the CL value
               elevDetails.BearingIdx = IBridge::sbiCLValue;
            }
         }
         else
         {
            // multiple bearings exist and this is just one of them
            elevDetails.BearingIdx = brgIdx - 1;
         }

         // Compute station, offset and Design elevation directly above CL Bearing
         Float64 brgClStation, brgClOffset;
         CComPtr<IPoint2d> brgClPoint;
         ByDistDir(pointBCL, brgLocAdjusted, pierDirVar, 0.0, &brgClPoint);
         GetStationAndOffset(pgsTypes::pcLocal, brgClPoint, &brgClStation, &brgClOffset);

         Float64 brgClDesignElevation = GetElevation(brgClStation,brgClOffset);

         elevDetails.Station = brgClStation;
         elevDetails.Offset = brgClOffset;
         elevDetails.DesignGradeElevation = brgClDesignElevation;

         // Finished elevation is tricky
         Float64 elevationAdjustmentForDeformation = 0.0;
         if (haunchInputDepthType == pgsTypes::hidACamber || bIgnoreUnrecoverableDeformations)
         {
            // For "A" dim input, the finished elevation is at the PGL by definition
            elevDetails.FinishedGradeElevation = brgClDesignElevation;
         }
         else
         {
            // Haunch depth input - including unrecoverable deformations. 
            // The elevation of the beam at bearing cl depends on the pre-deformed girder shape and bearing location.
            // ASSUMPTION: The elevation adjustment at the CL girder-bearing is the same as at the workpoint location
            // Compute the relative excursion of the finished elevation due to adjusments made at the time of pier erection at CL.
            Float64 clStation,clOffset;
            GetStationAndOffset(poi,&clStation,&clOffset);
            Float64 clDesignElevation = GetElevation(clStation,clOffset);

            // Note that the call below starts a full bridge analysis up to the geometry control event interval. This is no longer just a geometry comp
            Float64 lftHaunch,ctrHaunch,rgtHaunch;
            Float64 clFinishedElevation = pDeformedGirderGeometry->GetFinishedElevation(poi, gceInterval, &lftHaunch, &ctrHaunch, &rgtHaunch);

            // Adjustment at girder cl - bearing line intersection
            elevationAdjustmentForDeformation = clFinishedElevation - clDesignElevation;

            // Apply adjustment to elevation at workpoint
            elevDetails.FinishedGradeElevation = brgClDesignElevation + elevationAdjustmentForDeformation;
         }

         elevDetails.GrossSlabDepth = grossSlabDepth;

         elevDetails.Hg = Hg * girderHeightAdjustment;

         // adjust bearing and soleplate heights for angle
         elevDetails.BrgRecess =       BrgRecess * girderHeightAdjustment;
         elevDetails.BrgHeight =       BrgHeight * girderHeightAdjustment;
         elevDetails.SolePlateHeight = SolePlateHeight * girderHeightAdjustment;

         elevDetails.BasicGirderGrade = basicGirderSlope;
         elevDetails.PrecamberSlope = precamberSlope;

         elevDetails.CrossSlope        = crossSlope;
         elevDetails.ProfileGrade      = profileGrade;
         elevDetails.GirderGrade       = girderSlope;
         elevDetails.GirderOrientation = girderOrientation;

         elevDetails.OverlayDepth = adjOverlayDepth;
         elevDetails.SlabOffset = slabOffset; // this is a vertical dimension.... don't adjust for roadway angle
         elevDetails.HaunchDepth = haunchDepth;

         // bearing seat elevation is roadway surface elevation directly above CL bearing less height of girder, bearing, overlay, and slab offset
         elevDetails.BrgSeatElevation = elevDetails.FinishedGradeElevation - (heightBCL + elevDetails.OverlayDepth + elevDetails.SlabOffset);

         // top of bearing is bottom of bearing + bearing height
         elevDetails.TopBrgElevation =  elevDetails.BrgSeatElevation + elevDetails.BrgHeight;

         elevDetails.BearingDeduct = elevDetails.FinishedGradeElevation - elevDetails.BrgSeatElevation;
         elevDetails.BearingDeduct = RoundOff(elevDetails.BearingDeduct, WBFL::Units::ConvertToSysUnits(0.125, WBFL::Units::Measure::Inch) ); // TxDOT standard rounding

         vElevDetails.push_back(elevDetails);
      }
   }
   
   return vElevDetails;
}

/////////////////////////////////////////////////////////////////////////
// IMaterials
Float64 CBridgeAgentImp::GetSegmentFc28(const CSegmentKey& segmentKey) const
{
   Float64 time_at_casting = m_ConcreteManager.GetSegmentCastingTime(segmentKey);
   Float64 age = 28.0; // days
   Float64 t = time_at_casting + age;
   return m_ConcreteManager.GetSegmentFc(segmentKey,t);
}

Float64 CBridgeAgentImp::GetClosureJointFc28(const CSegmentKey& closureKey) const
{
   Float64 time_at_casting = m_ConcreteManager.GetClosureJointCastingTime(closureKey);
   Float64 age = 28.0; // days
   Float64 t = time_at_casting + age;
   return m_ConcreteManager.GetClosureJointFc(closureKey,t);
}

Float64 CBridgeAgentImp::GetDeckFc28() const
{
   // Fc28 is the same for all deck casting regions so use region 0
   IndexType deckCastingRegionIdx = 0;
   Float64 time_at_casting = m_ConcreteManager.GetDeckCastingTime(deckCastingRegionIdx);
   Float64 age = 28.0; // days
   Float64 t = time_at_casting + age;
   return m_ConcreteManager.GetDeckFc(deckCastingRegionIdx,t);
}

Float64 CBridgeAgentImp::GetRailingSystemFc28(pgsTypes::TrafficBarrierOrientation orientation) const
{
   Float64 time_at_casting = m_ConcreteManager.GetRailingSystemCastingTime(orientation);
   Float64 age = 28.0; // days
   Float64 t = time_at_casting + age;
   return m_ConcreteManager.GetRailingSystemFc(orientation,t);
}

Float64 CBridgeAgentImp::GetPierFc28(IndexType pierIdx) const
{
   return m_ConcreteManager.GetPierConcrete(pierIdx)->GetFc();
}

Float64 CBridgeAgentImp::GetLongitudinalJointFc28() const
{
   Float64 time_at_casting = m_ConcreteManager.GetLongitudinalJointCastingTime();
   Float64 age = 28.0; // days
   Float64 t = time_at_casting + age;
   return m_ConcreteManager.GetLongitudinalJointFc(t);
}

Float64 CBridgeAgentImp::GetSegmentEc28(const CSegmentKey& segmentKey) const
{
   Float64 time_at_casting = m_ConcreteManager.GetSegmentCastingTime(segmentKey);
   Float64 age = 28.0; // days
   Float64 t = time_at_casting + age;
   return m_ConcreteManager.GetSegmentEc(segmentKey,t);
}

Float64 CBridgeAgentImp::GetClosureJointEc28(const CSegmentKey& closureKey) const
{
   Float64 time_at_casting = m_ConcreteManager.GetClosureJointCastingTime(closureKey);
   Float64 age = 28.0; // days
   Float64 t = time_at_casting + age;
   return m_ConcreteManager.GetClosureJointEc(closureKey,t);
}

Float64 CBridgeAgentImp::GetDeckEc28() const
{
   // Ec28 is the same for all deck casting regions so use region 0
   IndexType deckCastingRegionIdx = 0;
   Float64 time_at_casting = m_ConcreteManager.GetDeckCastingTime(deckCastingRegionIdx);
   Float64 age = 28.0; // days
   Float64 t = time_at_casting + age;
   return m_ConcreteManager.GetDeckEc(deckCastingRegionIdx,t);
}

Float64 CBridgeAgentImp::GetRailingSystemEc28(pgsTypes::TrafficBarrierOrientation orientation) const
{
   Float64 time_at_casting = m_ConcreteManager.GetRailingSystemCastingTime(orientation);
   Float64 age = 28.0; // days
   Float64 t = time_at_casting + age;
   return m_ConcreteManager.GetRailingSystemEc(orientation,t);
}

Float64 CBridgeAgentImp::GetPierEc28(IndexType pierIdx) const
{
   return m_ConcreteManager.GetPierConcrete(pierIdx)->GetE();
}

Float64 CBridgeAgentImp::GetLongitudinalJointEc28() const
{
   Float64 time_at_casting = m_ConcreteManager.GetLongitudinalJointCastingTime();
   Float64 age = 28.0; // days
   Float64 t = time_at_casting + age;
   return m_ConcreteManager.GetLongitudinalJointEc(t);
}

Float64 CBridgeAgentImp::GetSegmentWeightDensity(const CSegmentKey& segmentKey,IntervalIndexType intervalIdx) const
{
   Float64 age = GetSegmentConcreteAge(segmentKey,intervalIdx,pgsTypes::Middle);
   if ( age < 0 )
   {
      return 0;
   }

   GET_IFACE(IBridgeDescription,pIBridgeDesc);
   const CPrecastSegmentData* pSegment = pIBridgeDesc->GetPrecastSegmentData(segmentKey);
   return pSegment->Material.Concrete.WeightDensity;
}

Float64 CBridgeAgentImp::GetClosureJointWeightDensity(const CClosureKey& closureKey,IntervalIndexType intervalIdx) const
{
   Float64 age = GetClosureJointConcreteAge(closureKey,intervalIdx,pgsTypes::Middle);
   if ( age < 0 )
   {
      return 0;
   }

   GET_IFACE(IBridgeDescription,pIBridgeDesc);
   const CClosureJointData* pClosure = pIBridgeDesc->GetClosureJointData(closureKey);
   return pClosure->GetConcrete().WeightDensity;
}

Float64 CBridgeAgentImp::GetDeckWeightDensity(IndexType castingRegionIdx, IntervalIndexType intervalIdx) const
{
   Float64 age = GetDeckConcreteAge(castingRegionIdx, intervalIdx,pgsTypes::Middle);
   if ( age < 0 )
   {
      return 0;
   }


   GET_IFACE(IBridgeDescription,pIBridgeDesc);
   const CDeckDescription2* pDeck = pIBridgeDesc->GetDeckDescription();
   return pDeck->Concrete.WeightDensity;
}

Float64 CBridgeAgentImp::GetDiaphragmWeightDensity(IntervalIndexType intervalIdx) const
{
   // assumes diaphragm concrete is the same as the deck concrete and all diaphragms
   // are cast at the same time as the first deck region is cast
   return GetDeckWeightDensity(0, intervalIdx);
}

Float64 CBridgeAgentImp::GetRailingSystemWeightDensity(pgsTypes::TrafficBarrierOrientation orientation,IntervalIndexType intervalIdx) const
{
   Float64 age = GetRailingSystemAge(orientation,intervalIdx,pgsTypes::Middle);
   if ( age < 0 )
   {
      return 0;
   }

   GET_IFACE(IBridgeDescription,pIBridgeDesc);
   const CRailingSystem* pRailingSystem;
   if ( orientation == pgsTypes::tboLeft )
   {
      pRailingSystem = pIBridgeDesc->GetBridgeDescription()->GetLeftRailingSystem();
   }
   else
   {
      pRailingSystem = pIBridgeDesc->GetBridgeDescription()->GetRightRailingSystem();
   }

   return pRailingSystem->Concrete.WeightDensity;
}

Float64 CBridgeAgentImp::GetLongitudinalJointWeightDensity(IntervalIndexType intervalIdx) const
{
   Float64 age = GetLongitudinalJointConcreteAge(intervalIdx, pgsTypes::Middle);
   if (age < 0)
   {
      return 0;
   }

   GET_IFACE(IBridgeDescription, pIBridgeDesc);
   return pIBridgeDesc->GetBridgeDescription()->GetLongitudinalJointMaterial().WeightDensity;

   return 0;
}

Float64 CBridgeAgentImp::GetSegmentConcreteAge(const CSegmentKey& segmentKey,IntervalIndexType intervalIdx,pgsTypes::IntervalTimeType timeType) const
{
   IntervalIndexType stressStrandIntervalIdx = m_IntervalManager.GetStressStrandInterval(segmentKey);
   if ( intervalIdx < stressStrandIntervalIdx )
   {
      return 0; // segment hasn't been cast yet
   }

   Float64 time = m_IntervalManager.GetTime(intervalIdx,timeType);
   Float64 casting_day = m_IntervalManager.GetTime(stressStrandIntervalIdx,pgsTypes::Start);

   // age is the difference in time between point in time for the interval in question and the casting day
   Float64 age = time - casting_day;

   return age;
}

Float64 CBridgeAgentImp::GetClosureJointConcreteAge(const CSegmentKey& closureKey,IntervalIndexType intervalIdx,pgsTypes::IntervalTimeType timeType) const
{
   IntervalIndexType castClosureIntervalIdx = m_IntervalManager.GetCastClosureInterval(closureKey);
   if ( intervalIdx < castClosureIntervalIdx )
   {
      return 0; // closure joint hasn't been cast yet
   }

   Float64 time = m_IntervalManager.GetTime(intervalIdx,timeType);
   Float64 casting_day = m_IntervalManager.GetTime(castClosureIntervalIdx,pgsTypes::Start);

   // age is the difference in time between point in time for the interval in question and the casting day
   Float64 age = time - casting_day;

   return age;
}

Float64 CBridgeAgentImp::GetDeckConcreteAge(IndexType castingRegionIdx, IntervalIndexType intervalIdx,pgsTypes::IntervalTimeType timeType) const
{
   IntervalIndexType castDeckIntervalIdx = m_IntervalManager.GetCastDeckInterval(castingRegionIdx);
   if ( intervalIdx < castDeckIntervalIdx )
   {
      return 0; // deck hasn't been cast yet
   }

   GET_IFACE(IBridgeDescription,pIBridgeDesc);
   const CTimelineManager* pTimelineMgr = pIBridgeDesc->GetTimelineManager();

   // want age at specified time
   Float64 time = m_IntervalManager.GetTime(intervalIdx,timeType);
   Float64 casting_day = m_IntervalManager.GetTime(castDeckIntervalIdx,pgsTypes::Start);

   // age is the difference in time between point in time for the interval in question and the casting day
   Float64 age = time - casting_day;

   return age;
}

Float64 CBridgeAgentImp::GetRailingSystemAge(pgsTypes::TrafficBarrierOrientation orientation,IntervalIndexType intervalIdx,pgsTypes::IntervalTimeType timeType) const
{
   IntervalIndexType railingSystemIntervalIdx = m_IntervalManager.GetInstallRailingSystemInterval();
   if ( intervalIdx < railingSystemIntervalIdx )
   {
      return 0; // railing system hasn't been cast yet
   }

   Float64 time = m_IntervalManager.GetTime(intervalIdx,timeType);
   Float64 casting_day = m_IntervalManager.GetTime(railingSystemIntervalIdx,pgsTypes::Start);

   // age is the difference in time between point in time for the interval in question and the casting day
   Float64 age = time - casting_day;

   return age;
}

Float64 CBridgeAgentImp::GetLongitudinalJointConcreteAge(IntervalIndexType intervalIdx, pgsTypes::IntervalTimeType timeType) const
{
   IntervalIndexType castLongitudinalJointIntervalIdx = m_IntervalManager.GetCastLongitudinalJointInterval();
   if (intervalIdx < castLongitudinalJointIntervalIdx)
   {
      return 0; // joint hasn't been cast yet
   }

   Float64 time = m_IntervalManager.GetTime(intervalIdx, timeType);
   Float64 casting_day = m_IntervalManager.GetTime(castLongitudinalJointIntervalIdx, pgsTypes::Start);

   // age is the difference in time between point in time for the interval in question and the casting day
   Float64 age = time - casting_day;

   return age;
}

Float64 CBridgeAgentImp::GetSegmentFc(const CSegmentKey& segmentKey,IntervalIndexType intervalIdx,pgsTypes::IntervalTimeType timeType) const
{
   Float64 time = m_IntervalManager.GetTime(intervalIdx,timeType);
   return m_ConcreteManager.GetSegmentFc(segmentKey,time);
}

Float64 CBridgeAgentImp::GetClosureJointFc(const CClosureKey& closureKey,IntervalIndexType intervalIdx,pgsTypes::IntervalTimeType timeType) const
{
   Float64 time = m_IntervalManager.GetTime(intervalIdx,timeType);
   return m_ConcreteManager.GetClosureJointFc(closureKey,time);
}

Float64 CBridgeAgentImp::GetDeckFc(IndexType castingRegionIdx, IntervalIndexType intervalIdx,pgsTypes::IntervalTimeType timeType) const
{
   Float64 time = m_IntervalManager.GetTime(intervalIdx,timeType);
   return m_ConcreteManager.GetDeckFc(castingRegionIdx,time);
}

Float64 CBridgeAgentImp::GetRailingSystemFc(pgsTypes::TrafficBarrierOrientation orientation,IntervalIndexType intervalIdx,pgsTypes::IntervalTimeType timeType) const
{
   Float64 time = m_IntervalManager.GetTime(intervalIdx,timeType);
   return m_ConcreteManager.GetRailingSystemFc(orientation,time);
}

Float64 CBridgeAgentImp::GetLongitudinalJointFc(IntervalIndexType intervalIdx, pgsTypes::IntervalTimeType timeType) const
{
   Float64 time = m_IntervalManager.GetTime(intervalIdx, timeType);
   return m_ConcreteManager.GetLongitudinalJointFc(time);
}

Float64 CBridgeAgentImp::GetSegmentDesignFc(const CSegmentKey& segmentKey,IntervalIndexType intervalIdx) const
{
   GET_IFACE(ILibrary,pLib);
   GET_IFACE(ISpecification,pSpec);
   const SpecLibraryEntry* pSpecEntry = pLib->GetSpecEntry( pSpec->GetSpecification().c_str() );
   if ( pSpecEntry->GetLossMethod() == pgsTypes::TIME_STEP )
   {
      if ( pSpecEntry->GetLimitStateConcreteStrength() == pgsTypes::lscStrengthAtTimeOfLoading )
      {
         return GetSegmentFc(segmentKey,intervalIdx);
      }
      else
      {
         // basing allowable stresses and nominal strength on specified values
         GET_IFACE(IBridgeDescription,pIBridgeDesc);
         const CPrecastSegmentData* pSegment = pIBridgeDesc->GetPrecastSegmentData(segmentKey);
         IntervalIndexType releaseIntervalIdx = GetPrestressReleaseInterval(segmentKey);
         IntervalIndexType liftingIntervalIdx = GetLiftSegmentInterval(segmentKey);
         IntervalIndexType storageIntervalIdx = GetStorageInterval(segmentKey);
         if ( intervalIdx == releaseIntervalIdx || 
              intervalIdx == liftingIntervalIdx || 
              intervalIdx == storageIntervalIdx )
         {
            // interval is associated with initial strength
            if ( pSegment->Material.Concrete.bHasInitial )
            {
               // an initial strength was specified.. return it
               return pSegment->Material.Concrete.Fci;
            }
            else
            {
               // initial strength was not specified, just compute it
               return GetSegmentFc(segmentKey,releaseIntervalIdx);
            }
         }
         else
         {
            // return the specified 28 day strength
            GET_IFACE(ILibrary, pLib);
            GET_IFACE(ISpecification, pSpec);
            const SpecLibraryEntry* pSpecEntry = pLib->GetSpecEntry(pSpec->GetSpecification().c_str());
            bool bUse90DayStrength;
            Float64 factor;
            pSpecEntry->Use90DayStrengthForSlowCuringConcrete(&bUse90DayStrength, &factor);
            Float64 age = GetSegmentConcreteAge(segmentKey, intervalIdx, pgsTypes::Middle);
            auto type = GetSegmentConcreteType(segmentKey);
            Float64 f = 1.0;
            if (type == pgsTypes::Normal && bUse90DayStrength && factor != 1.0 && 90 < age)
            {
               f = factor;
            }
               
            return f*pSegment->Material.Concrete.Fc;
         }
      }
   }
   else
   {
      return GetSegmentFc(segmentKey,intervalIdx);
   }
}

Float64 CBridgeAgentImp::GetClosureJointDesignFc(const CSegmentKey& closureKey,IntervalIndexType intervalIdx) const
{
   GET_IFACE(ILibrary,pLib);
   GET_IFACE(ISpecification,pSpec);
   const SpecLibraryEntry* pSpecEntry = pLib->GetSpecEntry( pSpec->GetSpecification().c_str() );
   if ( pSpecEntry->GetLossMethod() == pgsTypes::TIME_STEP )
   {
      if ( pSpecEntry->GetLimitStateConcreteStrength() == pgsTypes::lscStrengthAtTimeOfLoading )
      {
         return GetClosureJointFc(closureKey,intervalIdx);
      }
      else
      {
         // basing allowable stresses and nominatl strength on specified values
         GET_IFACE(IBridgeDescription,pIBridgeDesc);
         const CClosureJointData* pClosureJoint = pIBridgeDesc->GetClosureJointData(closureKey);
         IntervalIndexType castIntervalIdx      = GetCastClosureJointInterval(closureKey);
         IntervalIndexType compositeIntervalIdx = GetCompositeClosureJointInterval(closureKey);
         if ( intervalIdx <= castIntervalIdx )
         {
            return 0;
         }
         else if ( castIntervalIdx < intervalIdx && intervalIdx < compositeIntervalIdx )
         {
            // interval is associated with initial strength
            if ( pClosureJoint->GetConcrete().bHasInitial )
            {
               // an initial strength was specified.. return it
               return pClosureJoint->GetConcrete().Fci;
            }
            else
            {
               // initial strength was not specified, just compute it
               return GetClosureJointFc(closureKey,compositeIntervalIdx);
            }
         }
         else
         {
            // return the specified 28 day strength
            return pClosureJoint->GetConcrete().Fc;
         }
      }
   }
   else
   {
      return GetClosureJointFc(closureKey,intervalIdx);
   }
}

Float64 CBridgeAgentImp::GetDeckDesignFc(IntervalIndexType intervalIdx) const
{
   IndexType castingRegionIdx = 0; // assumes models that support design only support continuous deck placement so the one and only region index is 0
   GET_IFACE(ILibrary,pLib);
   GET_IFACE(ISpecification,pSpec);
   const SpecLibraryEntry* pSpecEntry = pLib->GetSpecEntry( pSpec->GetSpecification().c_str() );
   if ( pSpecEntry->GetLossMethod() == pgsTypes::TIME_STEP )
   {
      if ( pSpecEntry->GetLimitStateConcreteStrength() == pgsTypes::lscStrengthAtTimeOfLoading )
      {
         return GetDeckFc(castingRegionIdx, intervalIdx);
      }
      else
      {
         // basing allowable stresses and nominatl strength on specified values
         GET_IFACE(IBridgeDescription,pIBridgeDesc);
         const CDeckDescription2* pDeck = pIBridgeDesc->GetDeckDescription();
         // NOTE: this method is only used for Design and design is limited to PGSuper
         // There is only one deck casting region in PGSuper so just use the first deck intervals for simplicity
         IntervalIndexType castIntervalIdx      = GetFirstCastDeckInterval();
         IntervalIndexType compositeIntervalIdx = GetFirstCompositeDeckInterval();
         if ( intervalIdx <= castIntervalIdx )
         {
            return 0;
         }
         else if ( castIntervalIdx < intervalIdx && intervalIdx < compositeIntervalIdx )
         {
            // interval is associated with initial strength
            if ( pDeck->Concrete.bHasInitial )
            {
               // an initial strength was specified.. return it
               return pDeck->Concrete.Fci;
            }
            else
            {
               // initial strength was not specified, just compute it
               return GetDeckFc(castingRegionIdx,compositeIntervalIdx);
            }
         }
         else
         {
            // return the specified 28 day strength
            return pDeck->Concrete.Fc;
         }
      }
   }
   else
   {
      return GetDeckFc(castingRegionIdx,intervalIdx);
   }
}

Float64 CBridgeAgentImp::GetSegmentEc(const CSegmentKey& segmentKey,IntervalIndexType intervalIdx,pgsTypes::IntervalTimeType timeType, const GDRCONFIG* pConfig) const
{
   Float64 E;
   Float64 time = m_IntervalManager.GetTime(intervalIdx, timeType);
   if (pConfig == nullptr)
   {
      E = m_ConcreteManager.GetSegmentEc(segmentKey, time);
   }
   else
   {
      Float64 castTime = m_ConcreteManager.GetSegmentCastingTime(segmentKey);
      if ( time < castTime + 28 )
      {
         if (pConfig->bUserEci)
         {
            E = pConfig->Eci;
         }
         else
         {
            E = GetEconc(pConfig->ConcType, pConfig->fci, GetSegmentStrengthDensity(segmentKey), GetSegmentEccK1(segmentKey), GetSegmentEccK2(segmentKey));
         }
      }
      else
      {
         if (pConfig->bUserEc)
         {
            E = pConfig->Ec;
         }
         else
         {
            E = GetEconc(pConfig->ConcType, pConfig->fc, GetSegmentStrengthDensity(segmentKey), GetSegmentEccK1(segmentKey), GetSegmentEccK2(segmentKey));
         }
      }
   }

   return E;
}

Float64 CBridgeAgentImp::GetSegmentEc(const CSegmentKey& segmentKey,IntervalIndexType intervalIdx,Float64 trialFc,bool* pbChanged) const
{
#if defined _DEBUG
   // This function is for computing the modulus of elasticity during design for a trial concrete strength.
   // Design is not available for time-step analysis so this should not get called
   GET_IFACE(ILossParameters,pLossParams);
   ATLASSERT( pLossParams->GetLossMethod() != pgsTypes::TIME_STEP);
#endif

   GET_IFACE(ISegmentData,pSegmentData);

   const CGirderMaterial* pMaterial = pSegmentData->GetSegmentMaterial(segmentKey);

   // storage interval is the last interval for release strength
   IntervalIndexType storageIntervalIdx = GetStorageInterval(segmentKey);

   bool bInitial = (intervalIdx <= storageIntervalIdx ? true : false);
   Float64 E;
   if ( (bInitial && pMaterial->Concrete.bUserEci) || (!bInitial && pMaterial->Concrete.bUserEc) )
   {
      E = (bInitial ? pMaterial->Concrete.Eci : pMaterial->Concrete.Ec);
      *pbChanged = false;
   }
   else
   {
      E = lrfdConcreteUtil::ModE( (WBFL::Materials::ConcreteType)pMaterial->Concrete.Type, trialFc, pMaterial->Concrete.StrengthDensity, false /*ignore LRFD range checks*/ );

      if ( lrfdVersionMgr::ThirdEditionWith2005Interims <= lrfdVersionMgr::GetVersion() )
      {
         E *= (pMaterial->Concrete.EcK1*pMaterial->Concrete.EcK2);
      }

      Float64 Eorig = (bInitial ? pMaterial->Concrete.Eci : pMaterial->Concrete.Ec);
      *pbChanged = IsEqual(E,Eorig) ? false : true;
   }

   return E;
}

Float64 CBridgeAgentImp::GetClosureJointEc(const CClosureKey& closureKey,IntervalIndexType intervalIdx,pgsTypes::IntervalTimeType timeType) const
{
   Float64 time = m_IntervalManager.GetTime(intervalIdx,timeType);
   return m_ConcreteManager.GetClosureJointEc(closureKey,time);
}

Float64 CBridgeAgentImp::GetClosureJointEc(const CClosureKey& closureKey,IntervalIndexType intervalIdx,Float64 trialFc,bool* pbChanged) const
{
#if defined _DEBUG
   // This function is for computing the modulus of elasticity during design for a trial concrete strength.
   // Design is not available for time-step analysis so this should not get called
   GET_IFACE(ILossParameters,pLossParams);
   ATLASSERT( pLossParams->GetLossMethod() != pgsTypes::TIME_STEP);
#endif


   GET_IFACE(IBridgeDescription,pIBridgeDesc);

   const CSplicedGirderData* pGirder = pIBridgeDesc->GetGirder(closureKey);
   const CClosureJointData* pClosure = pGirder->GetClosureJoint(closureKey.segmentIndex);
   const CConcreteMaterial& concrete(pClosure->GetConcrete());

   IntervalIndexType compositeClosureIntervalIdx = GetCompositeClosureJointInterval(closureKey);

   bool bInitial = (intervalIdx <= compositeClosureIntervalIdx ? true : false);
   Float64 E;
   if ( (bInitial && concrete.bUserEci) || (!bInitial && concrete.bUserEc) )
   {
      E = (bInitial ? concrete.Eci : concrete.Ec);
      *pbChanged = false;
   }
   else
   {
      E = lrfdConcreteUtil::ModE( (WBFL::Materials::ConcreteType)concrete.Type, trialFc, concrete.StrengthDensity, false /*ignore LRFD range checks*/ );

      if ( lrfdVersionMgr::ThirdEditionWith2005Interims <= lrfdVersionMgr::GetVersion() )
      {
         E *= (concrete.EcK1*concrete.EcK2);
      }

      Float64 Eorig = (bInitial ? concrete.Eci : concrete.Ec);
      *pbChanged = IsEqual(E,Eorig) ? false : true;
   }

   return E;
}

Float64 CBridgeAgentImp::GetDeckEc(IndexType castingRegionIdx, IntervalIndexType intervalIdx,pgsTypes::IntervalTimeType timeType) const
{
   // For PGSuper models, when the deck curing duration is zero to avoid creep after deck casting
   // the casting, curing, and composite intervals all occur at the same time.
   // The call to GetTime and the GetDeckEc returns the Ec of the deck concrete at the time it becomes composite
   // 
   // If intervalIdx is before the deck is composite, Ec should be zero.
   IntervalIndexType compositeIntervalIdx = m_IntervalManager.GetCompositeDeckInterval(castingRegionIdx);
   if (intervalIdx < compositeIntervalIdx)
   {
      return 0;
   }

   Float64 time = m_IntervalManager.GetTime(intervalIdx,timeType);
   return m_ConcreteManager.GetDeckEc(castingRegionIdx,time);
}

Float64 CBridgeAgentImp::GetRailingSystemEc(pgsTypes::TrafficBarrierOrientation orientation,IntervalIndexType intervalIdx,pgsTypes::IntervalTimeType timeType) const
{
   Float64 time = m_IntervalManager.GetTime(intervalIdx,timeType);
   return m_ConcreteManager.GetRailingSystemEc(orientation,time);
}

Float64 CBridgeAgentImp::GetLongitudinalJointEc(IntervalIndexType intervalIdx, pgsTypes::IntervalTimeType timeType) const
{
   Float64 time = m_IntervalManager.GetTime(intervalIdx, timeType);
   return m_ConcreteManager.GetLongitudinalJointEc(time);
}

Float64 CBridgeAgentImp::GetSegmentLambda(const CSegmentKey& segmentKey) const
{
   return m_ConcreteManager.GetSegmentLambda(segmentKey);
}

Float64 CBridgeAgentImp::GetClosureJointLambda(const CClosureKey& closureKey) const
{
   return m_ConcreteManager.GetClosureJointLambda(closureKey);
}

Float64 CBridgeAgentImp::GetDeckLambda() const
{
   return m_ConcreteManager.GetDeckLambda();
}

Float64 CBridgeAgentImp::GetRailingSystemLambda(pgsTypes::TrafficBarrierOrientation orientation) const
{
   return m_ConcreteManager.GetRailingSystemLambda(orientation);
}

Float64 CBridgeAgentImp::GetLongitudinalJointLambda() const
{
   return m_ConcreteManager.GetLongitudinalJointLambda();
}

Float64 CBridgeAgentImp::GetSegmentFlexureFr(const CSegmentKey& segmentKey,IntervalIndexType intervalIdx,pgsTypes::IntervalTimeType timeType) const
{
   Float64 time = m_IntervalManager.GetTime(intervalIdx,timeType);
   return m_ConcreteManager.GetSegmentFlexureFr(segmentKey,time);
}

Float64 CBridgeAgentImp::GetSegmentShearFr(const CSegmentKey& segmentKey,IntervalIndexType intervalIdx,pgsTypes::IntervalTimeType timeType) const
{
   Float64 time = m_IntervalManager.GetTime(intervalIdx,timeType);
   return m_ConcreteManager.GetSegmentShearFr(segmentKey,time);
}

Float64 CBridgeAgentImp::GetClosureJointFlexureFr(const CClosureKey& closureKey,IntervalIndexType intervalIdx,pgsTypes::IntervalTimeType timeType) const
{
   Float64 time = m_IntervalManager.GetTime(intervalIdx,timeType);
   return m_ConcreteManager.GetClosureJointFlexureFr(closureKey,time);
}

Float64 CBridgeAgentImp::GetClosureJointShearFr(const CClosureKey& closureKey,IntervalIndexType intervalIdx,pgsTypes::IntervalTimeType timeType) const
{
   Float64 time = m_IntervalManager.GetTime(intervalIdx,timeType);
   return m_ConcreteManager.GetClosureJointShearFr(closureKey,time);
}

Float64 CBridgeAgentImp::GetDeckFlexureFr(IndexType castingRegionIdx, IntervalIndexType intervalIdx,pgsTypes::IntervalTimeType timeType) const
{
   Float64 time = m_IntervalManager.GetTime(intervalIdx,timeType);
   return m_ConcreteManager.GetDeckFlexureFr(castingRegionIdx,time);
}

Float64 CBridgeAgentImp::GetDeckShearFr(IndexType castingRegionIdx, IntervalIndexType intervalIdx,pgsTypes::IntervalTimeType timeType) const
{
   Float64 time = m_IntervalManager.GetTime(intervalIdx,timeType);
   return m_ConcreteManager.GetDeckShearFr(castingRegionIdx,time);
}

Float64 CBridgeAgentImp::GetLongitudinalJointFlexureFr(IntervalIndexType intervalIdx, pgsTypes::IntervalTimeType timeType) const
{
   Float64 time = m_IntervalManager.GetTime(intervalIdx, timeType);
   return m_ConcreteManager.GetLongitudinalJointFlexureFr(time);
}

Float64 CBridgeAgentImp::GetLongitudinalJointShearFr(IntervalIndexType intervalIdx, pgsTypes::IntervalTimeType timeType) const
{
   Float64 time = m_IntervalManager.GetTime(intervalIdx, timeType);
   return m_ConcreteManager.GetLongitudinalJointShearFr(time);
}

Float64 CBridgeAgentImp::GetSegmentAgingCoefficient(const CSegmentKey& segmentKey,IntervalIndexType intervalIdx) const
{
   // assume loading occurs at the middle of the interval
   Float64 middle = m_IntervalManager.GetTime(intervalIdx,pgsTypes::Middle);
   return m_ConcreteManager.GetSegmentAgingCoefficient(segmentKey,middle);
}

Float64 CBridgeAgentImp::GetClosureJointAgingCoefficient(const CClosureKey& closureKey,IntervalIndexType intervalIdx) const
{
   Float64 middle = m_IntervalManager.GetTime(intervalIdx,pgsTypes::Middle);
   return m_ConcreteManager.GetClosureJointAgingCoefficient(closureKey,middle);
}

Float64 CBridgeAgentImp::GetDeckAgingCoefficient(IndexType castingRegionIdx, IntervalIndexType intervalIdx) const
{
   Float64 middle = m_IntervalManager.GetTime(intervalIdx,pgsTypes::Middle);
   return m_ConcreteManager.GetDeckAgingCoefficient(castingRegionIdx,middle);
}

Float64 CBridgeAgentImp::GetRailingSystemAgingCoefficient(pgsTypes::TrafficBarrierOrientation orientation,IntervalIndexType intervalIdx) const
{
   Float64 middle = m_IntervalManager.GetTime(intervalIdx,pgsTypes::Middle);
   return m_ConcreteManager.GetRailingSystemAgingCoefficient(orientation,middle);
}

Float64 CBridgeAgentImp::GetLongitudinalJointAgingCoefficient(IntervalIndexType intervalIdx) const
{
   Float64 middle = m_IntervalManager.GetTime(intervalIdx, pgsTypes::Middle);
   return m_ConcreteManager.GetLongitudinalJointAgingCoefficient(middle);
}

Float64 CBridgeAgentImp::GetSegmentAgeAdjustedEc(const CSegmentKey& segmentKey,IntervalIndexType intervalIdx) const
{
   Float64 Ec = GetSegmentEc(segmentKey,intervalIdx);

   GET_IFACE(ILossParameters,pLossParams);
   if ( pLossParams->IgnoreCreepEffects() )
   {
      return Ec;
   }

   Float64 Y  = GetSegmentCreepCoefficient(segmentKey,intervalIdx,pgsTypes::Middle,intervalIdx,pgsTypes::End);
   Float64 X  = GetSegmentAgingCoefficient(segmentKey,intervalIdx);
   Float64 Ea = Ec/(1+X*Y);
   return Ea;
}

Float64 CBridgeAgentImp::GetClosureJointAgeAdjustedEc(const CClosureKey& closureKey,IntervalIndexType intervalIdx) const
{
   Float64 Ec = GetClosureJointEc(closureKey,intervalIdx);

   GET_IFACE(ILossParameters,pLossParams);
   if ( pLossParams->IgnoreCreepEffects() )
   {
      return Ec;
   }

   Float64 Y  = GetClosureJointCreepCoefficient(closureKey,intervalIdx,pgsTypes::Middle,intervalIdx,pgsTypes::End);
   Float64 X  = GetClosureJointAgingCoefficient(closureKey,intervalIdx);
   Float64 Ea = Ec/(1+X*Y);
   return Ea;
}

Float64 CBridgeAgentImp::GetDeckAgeAdjustedEc(IndexType castingRegionIdx, IntervalIndexType intervalIdx) const
{
   IntervalIndexType compositeDeckIntervalIdx = GetCompositeDeckInterval(castingRegionIdx);
   if ( intervalIdx < compositeDeckIntervalIdx )
   {
      return 0; // deck isn't composite yet
   }

   Float64 Ec = GetDeckEc(castingRegionIdx,intervalIdx);

   GET_IFACE(ILossParameters,pLossParams);
   if ( pLossParams->IgnoreCreepEffects() )
   {
      return Ec;
   }

   Float64 Y  = GetDeckCreepCoefficient(castingRegionIdx,intervalIdx,pgsTypes::Middle,intervalIdx,pgsTypes::End);
   Float64 X  = GetDeckAgingCoefficient(castingRegionIdx,intervalIdx);
   Float64 Ea = Ec/(1+X*Y);
   return Ea;
}

Float64 CBridgeAgentImp::GetRailingSystemAgeAdjustedEc(pgsTypes::TrafficBarrierOrientation orientation,IntervalIndexType intervalIdx) const
{
   Float64 Ec = GetRailingSystemEc(orientation,intervalIdx);

   GET_IFACE(ILossParameters,pLossParams);
   if ( pLossParams->IgnoreCreepEffects() )
   {
      return Ec;
   }

   Float64 Y  = GetRailingSystemCreepCoefficient(orientation,intervalIdx,pgsTypes::Middle,intervalIdx,pgsTypes::End);
   Float64 X  = GetRailingSystemAgingCoefficient(orientation,intervalIdx);
   Float64 Ea = Ec/(1+X*Y);
   return Ea;
}

Float64 CBridgeAgentImp::GetLongitudinalJointAgeAdjustedEc(IntervalIndexType intervalIdx) const
{
   Float64 Ec = GetLongitudinalJointEc(intervalIdx);

   GET_IFACE(ILossParameters, pLossParams);
   if (pLossParams->IgnoreCreepEffects())
   {
      return Ec;
   }

   Float64 Y = GetLongitudinalJointCreepCoefficient(intervalIdx, pgsTypes::Middle, intervalIdx, pgsTypes::End);
   Float64 X = GetLongitudinalJointAgingCoefficient(intervalIdx);
   Float64 Ea = Ec / (1 + X*Y);
   return Ea;
}

Float64 CBridgeAgentImp::GetTotalSegmentFreeShrinkageStrain(const CSegmentKey& segmentKey,IntervalIndexType intervalIdx,pgsTypes::IntervalTimeType timeType) const
{
   return GetTotalSegmentFreeShrinkageStrainDetails(segmentKey,intervalIdx,timeType)->esh;
}

Float64 CBridgeAgentImp::GetTotalClosureJointFreeShrinkageStrain(const CClosureKey& closureKey,IntervalIndexType intervalIdx,pgsTypes::IntervalTimeType timeType) const
{
   return GetTotalClosureJointFreeShrinkageStrainDetails(closureKey,intervalIdx,timeType)->esh;
}

Float64 CBridgeAgentImp::GetTotalDeckFreeShrinkageStrain(IndexType castingRegionIdx, IntervalIndexType intervalIdx,pgsTypes::IntervalTimeType timeType) const
{
   return GetTotalDeckFreeShrinkageStrainDetails(castingRegionIdx,intervalIdx,timeType)->esh;
}

Float64 CBridgeAgentImp::GetTotalRailingSystemFreeShrinakgeStrain(pgsTypes::TrafficBarrierOrientation orientation,IntervalIndexType intervalIdx,pgsTypes::IntervalTimeType timeType) const
{
   return GetTotalRailingSystemFreeShrinakgeStrainDetails(orientation,intervalIdx,timeType)->esh;
}

Float64 CBridgeAgentImp::GetTotalLongitudinalJointFreeShrinkageStrain(IntervalIndexType intervalIdx, pgsTypes::IntervalTimeType time) const
{
   return GetTotalLongitudinalJointFreeShrinkageStrainDetails(intervalIdx, time)->esh;
}

std::unique_ptr<WBFL::Materials::ConcreteBaseShrinkageDetails> CBridgeAgentImp::GetTotalSegmentFreeShrinkageStrainDetails(const CSegmentKey& segmentKey,IntervalIndexType intervalIdx,pgsTypes::IntervalTimeType timeType) const
{
   Float64 time = m_IntervalManager.GetTime(intervalIdx,timeType);
   return m_ConcreteManager.GetSegmentFreeShrinkageStrainDetails(segmentKey,time);
}

std::unique_ptr<WBFL::Materials::ConcreteBaseShrinkageDetails> CBridgeAgentImp::GetTotalClosureJointFreeShrinkageStrainDetails(const CClosureKey& closureKey,IntervalIndexType intervalIdx,pgsTypes::IntervalTimeType timeType) const
{
   Float64 time = m_IntervalManager.GetTime(intervalIdx,timeType);
   return m_ConcreteManager.GetClosureJointFreeShrinkageStrainDetails(closureKey,time);
}

std::unique_ptr<WBFL::Materials::ConcreteBaseShrinkageDetails> CBridgeAgentImp::GetTotalDeckFreeShrinkageStrainDetails(IndexType castingRegionIdx, IntervalIndexType intervalIdx,pgsTypes::IntervalTimeType timeType) const
{
   Float64 time = m_IntervalManager.GetTime(intervalIdx,timeType);
   return m_ConcreteManager.GetDeckFreeShrinkageStrainDetails(castingRegionIdx,time);
}

std::unique_ptr<WBFL::Materials::ConcreteBaseShrinkageDetails> CBridgeAgentImp::GetTotalRailingSystemFreeShrinakgeStrainDetails(pgsTypes::TrafficBarrierOrientation orientation,IntervalIndexType intervalIdx,pgsTypes::IntervalTimeType timeType) const
{
   Float64 time = m_IntervalManager.GetTime(intervalIdx,timeType);
   return m_ConcreteManager.GetRailingSystemFreeShrinkageStrainDetails(orientation,time);
}

std::unique_ptr<WBFL::Materials::ConcreteBaseShrinkageDetails> CBridgeAgentImp::GetTotalLongitudinalJointFreeShrinkageStrainDetails(IntervalIndexType intervalIdx, pgsTypes::IntervalTimeType timeType) const
{
   Float64 time = m_IntervalManager.GetTime(intervalIdx, timeType);
   return m_ConcreteManager.GetLongitudinalJointFreeShrinkageStrainDetails(time);
}

Float64 CBridgeAgentImp::GetIncrementalSegmentFreeShrinkageStrain(const CSegmentKey& segmentKey,IntervalIndexType intervalIdx) const
{
   return GetTotalSegmentFreeShrinkageStrain(segmentKey,intervalIdx,pgsTypes::End) - GetTotalSegmentFreeShrinkageStrain(segmentKey,intervalIdx,pgsTypes::Start);
}

Float64 CBridgeAgentImp::GetIncrementalClosureJointFreeShrinkageStrain(const CClosureKey& closureKey,IntervalIndexType intervalIdx) const
{
   return GetTotalClosureJointFreeShrinkageStrain(closureKey,intervalIdx,pgsTypes::End) - GetTotalClosureJointFreeShrinkageStrain(closureKey,intervalIdx,pgsTypes::Start);
}

Float64 CBridgeAgentImp::GetIncrementalDeckFreeShrinkageStrain(IndexType castingRegionIdx, IntervalIndexType intervalIdx) const
{
   return GetTotalDeckFreeShrinkageStrain(castingRegionIdx,intervalIdx,pgsTypes::End) - GetTotalDeckFreeShrinkageStrain(castingRegionIdx,intervalIdx,pgsTypes::Start);
}

Float64 CBridgeAgentImp::GetIncrementalRailingSystemFreeShrinakgeStrain(pgsTypes::TrafficBarrierOrientation orientation,IntervalIndexType intervalIdx) const
{
   return GetTotalRailingSystemFreeShrinakgeStrain(orientation,intervalIdx,pgsTypes::End) - GetTotalRailingSystemFreeShrinakgeStrain(orientation,intervalIdx,pgsTypes::Start);
}

Float64 CBridgeAgentImp::GetIncrementalLongitudinalJointFreeShrinkageStrain(IntervalIndexType intervalIdx) const
{
   return GetTotalLongitudinalJointFreeShrinkageStrain(intervalIdx, pgsTypes::End) - GetTotalLongitudinalJointFreeShrinkageStrain(intervalIdx, pgsTypes::Start);
}

INCREMENTALSHRINKAGEDETAILS CBridgeAgentImp::GetIncrementalSegmentFreeShrinkageStrainDetails(const CSegmentKey& segmentKey,IntervalIndexType intervalIdx) const
{
   INCREMENTALSHRINKAGEDETAILS details;
   // these calls return a unique_ptr.... when this method goes out of scope, the pointer will delete
   // we need to transfer the raw pointer into the shared_ptr so it doesn't get deleted
   details.pStartDetails = std::move(GetTotalSegmentFreeShrinkageStrainDetails(segmentKey,intervalIdx,pgsTypes::Start));
   details.pEndDetails   = std::move(GetTotalSegmentFreeShrinkageStrainDetails(segmentKey,intervalIdx,pgsTypes::End));
   return details;
}

INCREMENTALSHRINKAGEDETAILS CBridgeAgentImp::GetIncrementalClosureJointFreeShrinkageStrainDetails(const CClosureKey& closureKey,IntervalIndexType intervalIdx) const
{
   INCREMENTALSHRINKAGEDETAILS details;
   // these calls return a unique_ptr.... when this method goes out of scope, the pointer will delete
   // we need to transfer the raw pointer into the shared_ptr so it doesn't get deleted
   details.pStartDetails = std::move(GetTotalClosureJointFreeShrinkageStrainDetails(closureKey,intervalIdx,pgsTypes::Start));
   details.pEndDetails   = std::move(GetTotalClosureJointFreeShrinkageStrainDetails(closureKey,intervalIdx,pgsTypes::End));
   return details;
}

INCREMENTALSHRINKAGEDETAILS CBridgeAgentImp::GetIncrementalDeckFreeShrinkageStrainDetails(IndexType castingRegionIdx, IntervalIndexType intervalIdx) const
{
   INCREMENTALSHRINKAGEDETAILS details;
   details.pStartDetails = std::move(GetTotalDeckFreeShrinkageStrainDetails(castingRegionIdx,intervalIdx,pgsTypes::Start));
   details.pEndDetails   = std::move(GetTotalDeckFreeShrinkageStrainDetails(castingRegionIdx,intervalIdx,pgsTypes::End));
   return details;
}

INCREMENTALSHRINKAGEDETAILS CBridgeAgentImp::GetIncrementalRailingSystemFreeShrinakgeStrainDetails(pgsTypes::TrafficBarrierOrientation orientation,IntervalIndexType intervalIdx) const
{
   INCREMENTALSHRINKAGEDETAILS details;
   details.pStartDetails = std::move(GetTotalRailingSystemFreeShrinakgeStrainDetails(orientation,intervalIdx,pgsTypes::Start));
   details.pEndDetails   = std::move(GetTotalRailingSystemFreeShrinakgeStrainDetails(orientation,intervalIdx,pgsTypes::End));
   return details;
}

INCREMENTALSHRINKAGEDETAILS CBridgeAgentImp::GetIncrementalLongitudinalJointFreeShrinkageStrainDetails(IntervalIndexType intervalIdx) const
{
   INCREMENTALSHRINKAGEDETAILS details;
   details.pStartDetails = std::move(GetTotalLongitudinalJointFreeShrinkageStrainDetails(intervalIdx, pgsTypes::Start));
   details.pEndDetails   = std::move(GetTotalLongitudinalJointFreeShrinkageStrainDetails(intervalIdx, pgsTypes::End));
   return details;
}

Float64 CBridgeAgentImp::GetSegmentAutogenousShrinkage(const CSegmentKey& segmentKey) const
{
   return m_ConcreteManager.GetSegmentAutogenousShrinkage(segmentKey);
}

Float64 CBridgeAgentImp::GetClosureJointAutogenousShrinkage(const CClosureKey& closureKey) const
{
   return m_ConcreteManager.GetClosureJointAutogenousShrinkage(closureKey);
}

Float64 CBridgeAgentImp::GetDeckAutogenousShrinkage() const
{
   return m_ConcreteManager.GetDeckAutogenousShrinkage();
}

Float64 CBridgeAgentImp::GetSegmentCreepCoefficient(const CSegmentKey& segmentKey,IntervalIndexType loadingIntervalIdx,pgsTypes::IntervalTimeType loadingTimeType,IntervalIndexType intervalIdx,pgsTypes::IntervalTimeType timeType) const
{
   return GetSegmentCreepCoefficientDetails(segmentKey,loadingIntervalIdx,loadingTimeType,intervalIdx,timeType)->Ct;
}

Float64 CBridgeAgentImp::GetClosureJointCreepCoefficient(const CClosureKey& closureKey,IntervalIndexType loadingIntervalIdx,pgsTypes::IntervalTimeType loadingTimeType,IntervalIndexType intervalIdx,pgsTypes::IntervalTimeType timeType) const
{
   return GetClosureJointCreepCoefficientDetails(closureKey,loadingIntervalIdx,loadingTimeType,intervalIdx,timeType)->Ct;
}

Float64 CBridgeAgentImp::GetDeckCreepCoefficient(IndexType castingRegionIdx, IntervalIndexType loadingIntervalIdx,pgsTypes::IntervalTimeType loadingTimeType,IntervalIndexType intervalIdx,pgsTypes::IntervalTimeType timeType) const
{
   return GetDeckCreepCoefficientDetails(castingRegionIdx,loadingIntervalIdx,loadingTimeType,intervalIdx,timeType)->Ct;
}

Float64 CBridgeAgentImp::GetRailingSystemCreepCoefficient(pgsTypes::TrafficBarrierOrientation orientation,IntervalIndexType intervalIdx,pgsTypes::IntervalTimeType timeType,IntervalIndexType loadingIntervalIdx,pgsTypes::IntervalTimeType loadingTimeType) const
{
   return GetRailingSystemCreepCoefficientDetails(orientation,intervalIdx,timeType,loadingIntervalIdx,loadingTimeType)->Ct;
}

Float64 CBridgeAgentImp::GetLongitudinalJointCreepCoefficient(IntervalIndexType loadingIntervalIdx, pgsTypes::IntervalTimeType loadingTimeType, IntervalIndexType intervalIdx, pgsTypes::IntervalTimeType timeType) const
{
   return GetLongitudinalJointCreepCoefficientDetails(loadingIntervalIdx, loadingTimeType, intervalIdx, timeType)->Ct;
}

std::unique_ptr<WBFL::Materials::ConcreteBaseCreepDetails> CBridgeAgentImp::GetSegmentCreepCoefficientDetails(const CSegmentKey& segmentKey,IntervalIndexType loadingIntervalIdx,pgsTypes::IntervalTimeType loadingTimeType,IntervalIndexType intervalIdx,pgsTypes::IntervalTimeType timeType) const
{
   Float64 loading_time = m_IntervalManager.GetTime(loadingIntervalIdx,loadingTimeType);
   Float64 time         = m_IntervalManager.GetTime(intervalIdx,timeType);
   return m_ConcreteManager.GetSegmentCreepCoefficientDetails(segmentKey,time,loading_time);
}

std::unique_ptr<WBFL::Materials::ConcreteBaseCreepDetails> CBridgeAgentImp::GetClosureJointCreepCoefficientDetails(const CClosureKey& closureKey,IntervalIndexType loadingIntervalIdx,pgsTypes::IntervalTimeType loadingTimeType,IntervalIndexType intervalIdx,pgsTypes::IntervalTimeType timeType) const
{
   Float64 loading_time = m_IntervalManager.GetTime(loadingIntervalIdx,loadingTimeType);
   Float64 time = m_IntervalManager.GetTime(intervalIdx,timeType);
   return m_ConcreteManager.GetClosureJointCreepCoefficientDetails(closureKey,time,loading_time);
}

std::unique_ptr<WBFL::Materials::ConcreteBaseCreepDetails> CBridgeAgentImp::GetDeckCreepCoefficientDetails(IndexType castingRegionIdx, IntervalIndexType loadingIntervalIdx,pgsTypes::IntervalTimeType loadingTimeType,IntervalIndexType intervalIdx,pgsTypes::IntervalTimeType timeType) const
{
   Float64 loading_time = m_IntervalManager.GetTime(loadingIntervalIdx,loadingTimeType);
   Float64 time = m_IntervalManager.GetTime(intervalIdx,timeType);
   return m_ConcreteManager.GetDeckCreepCoefficientDetails(castingRegionIdx,time,loading_time);
}

std::unique_ptr<WBFL::Materials::ConcreteBaseCreepDetails> CBridgeAgentImp::GetRailingSystemCreepCoefficientDetails(pgsTypes::TrafficBarrierOrientation orientation,IntervalIndexType loadingIntervalIdx,pgsTypes::IntervalTimeType loadingTimeType,IntervalIndexType intervalIdx,pgsTypes::IntervalTimeType timeType) const
{
   Float64 loading_time = m_IntervalManager.GetTime(loadingIntervalIdx,loadingTimeType);
   Float64 time = m_IntervalManager.GetTime(intervalIdx,timeType);
   return m_ConcreteManager.GetRailingSystemCreepCoefficientDetails(orientation,time,loading_time);
}

std::unique_ptr<WBFL::Materials::ConcreteBaseCreepDetails> CBridgeAgentImp::GetLongitudinalJointCreepCoefficientDetails(IntervalIndexType loadingIntervalIdx, pgsTypes::IntervalTimeType loadingTimeType, IntervalIndexType intervalIdx, pgsTypes::IntervalTimeType timeType) const
{
   Float64 loading_time = m_IntervalManager.GetTime(loadingIntervalIdx, loadingTimeType);
   Float64 time = m_IntervalManager.GetTime(intervalIdx, timeType);
   return m_ConcreteManager.GetLongitudinalJointCreepCoefficientDetails(time, loading_time);
}

pgsTypes::ConcreteType CBridgeAgentImp::GetSegmentConcreteType(const CSegmentKey& segmentKey) const
{
   return m_ConcreteManager.GetSegmentConcreteType(segmentKey);
}

bool CBridgeAgentImp::DoesSegmentConcreteHaveAggSplittingStrength(const CSegmentKey& segmentKey) const
{
   return m_ConcreteManager.DoesSegmentConcreteHaveAggSplittingStrength(segmentKey);
}

Float64 CBridgeAgentImp::GetSegmentConcreteAggSplittingStrength(const CSegmentKey& segmentKey) const
{
   return m_ConcreteManager.GetSegmentConcreteAggSplittingStrength(segmentKey);
}

Float64 CBridgeAgentImp::GetSegmentStrengthDensity(const CSegmentKey& segmentKey) const
{
   return m_ConcreteManager.GetSegmentStrengthDensity(segmentKey);
}

Float64 CBridgeAgentImp::GetSegmentMaxAggrSize(const CSegmentKey& segmentKey) const
{
   return m_ConcreteManager.GetSegmentMaxAggrSize(segmentKey);
}

Float64 CBridgeAgentImp::GetSegmentConcreteFiberLength(const CSegmentKey& segmentKey) const
{
   return m_ConcreteManager.GetSegmentConcreteFiberLength(segmentKey);
}

Float64 CBridgeAgentImp::GetSegmentEccK1(const CSegmentKey& segmentKey) const
{
   return m_ConcreteManager.GetSegmentEccK1(segmentKey);
}

Float64 CBridgeAgentImp::GetSegmentEccK2(const CSegmentKey& segmentKey) const
{
   return m_ConcreteManager.GetSegmentEccK2(segmentKey);
}

Float64 CBridgeAgentImp::GetSegmentCreepK1(const CSegmentKey& segmentKey) const
{
   return m_ConcreteManager.GetSegmentCreepK1(segmentKey);
}

Float64 CBridgeAgentImp::GetSegmentCreepK2(const CSegmentKey& segmentKey) const
{
   return m_ConcreteManager.GetSegmentCreepK2(segmentKey);
}

Float64 CBridgeAgentImp::GetSegmentShrinkageK1(const CSegmentKey& segmentKey) const
{
   return m_ConcreteManager.GetSegmentShrinkageK1(segmentKey);
}

Float64 CBridgeAgentImp::GetSegmentShrinkageK2(const CSegmentKey& segmentKey) const
{
   return m_ConcreteManager.GetSegmentShrinkageK2(segmentKey);
}

const std::unique_ptr<WBFL::Materials::ConcreteBase>& CBridgeAgentImp::GetSegmentConcrete(const CSegmentKey& segmentKey) const
{
   return m_ConcreteManager.GetSegmentConcrete(segmentKey);
}

Float64 CBridgeAgentImp::GetSegmentConcreteFirstCrackingStrength(const CSegmentKey& segmentKey) const
{
   return m_ConcreteManager.GetSegmentConcreteFirstCrackingStrength(segmentKey);
}

Float64 CBridgeAgentImp::GetSegmentConcreteInitialEffectiveCrackingStrength(const CSegmentKey& segmentKey) const
{
   return m_ConcreteManager.GetSegmentConcreteInitialEffectiveCrackingStrength(segmentKey);
}

Float64 CBridgeAgentImp::GetSegmentConcreteDesignEffectiveCrackingStrength(const CSegmentKey& segmentKey) const
{
   return m_ConcreteManager.GetSegmentConcreteDesignEffectiveCrackingStrength(segmentKey);
}

Float64 CBridgeAgentImp::GetSegmentConcreteCrackLocalizationStrength(const CSegmentKey& segmentKey) const
{
   return m_ConcreteManager.GetSegmentConcreteCrackLocalizationStrength(segmentKey);
}

Float64 CBridgeAgentImp::GetSegmentConcreteCrackLocalizationStrain(const CSegmentKey& segmentKey) const
{
   return m_ConcreteManager.GetSegmentConcreteCrackLocalizationStrain(segmentKey);
}

Float64 CBridgeAgentImp::GetSegmentConcreteFiberOrientationReductionFactor(const CSegmentKey& segmentKey) const
{
   return m_ConcreteManager.GetSegmentConcreteFiberOrientationReductionFactor(segmentKey);
}

pgsTypes::ConcreteType CBridgeAgentImp::GetClosureJointConcreteType(const CClosureKey& closureKey) const
{
   return m_ConcreteManager.GetClosureJointConcreteType(closureKey);
}

bool CBridgeAgentImp::DoesClosureJointConcreteHaveAggSplittingStrength(const CClosureKey& closureKey) const
{
   return m_ConcreteManager.DoesClosureJointConcreteHaveAggSplittingStrength(closureKey);
}

Float64 CBridgeAgentImp::GetClosureJointConcreteAggSplittingStrength(const CClosureKey& closureKey) const
{
   return m_ConcreteManager.GetClosureJointConcreteAggSplittingStrength(closureKey);
}

Float64 CBridgeAgentImp::GetClosureJointStrengthDensity(const CClosureKey& closureKey) const
{
   return m_ConcreteManager.GetClosureJointStrengthDensity(closureKey);
}

Float64 CBridgeAgentImp::GetClosureJointMaxAggrSize(const CClosureKey& closureKey) const
{
   return m_ConcreteManager.GetClosureJointMaxAggrSize(closureKey);
}

Float64 CBridgeAgentImp::GetClosureJointConcreteFiberLength(const CClosureKey& closureKey) const
{
   return m_ConcreteManager.GetClosureJointConcreteFiberLength(closureKey);
}

Float64 CBridgeAgentImp::GetClosureJointEccK1(const CClosureKey& closureKey) const
{
   return m_ConcreteManager.GetClosureJointEccK1(closureKey);
}

Float64 CBridgeAgentImp::GetClosureJointEccK2(const CClosureKey& closureKey) const
{
   return m_ConcreteManager.GetClosureJointEccK2(closureKey);
}

Float64 CBridgeAgentImp::GetClosureJointCreepK1(const CClosureKey& closureKey) const
{
   return m_ConcreteManager.GetClosureJointCreepK1(closureKey);
}

Float64 CBridgeAgentImp::GetClosureJointCreepK2(const CClosureKey& closureKey) const
{
   return m_ConcreteManager.GetClosureJointCreepK2(closureKey);
}

Float64 CBridgeAgentImp::GetClosureJointShrinkageK1(const CClosureKey& closureKey) const
{
   return m_ConcreteManager.GetClosureJointShrinkageK1(closureKey);
}

Float64 CBridgeAgentImp::GetClosureJointShrinkageK2(const CClosureKey& closureKey) const
{
   return m_ConcreteManager.GetClosureJointShrinkageK2(closureKey);
}

const std::unique_ptr<WBFL::Materials::ConcreteBase>& CBridgeAgentImp::GetClosureJointConcrete(const CClosureKey& closureKey) const
{
   return m_ConcreteManager.GetClosureJointConcrete(closureKey);
}

pgsTypes::ConcreteType CBridgeAgentImp::GetDeckConcreteType() const
{
   return m_ConcreteManager.GetDeckConcreteType();
}

bool CBridgeAgentImp::DoesDeckConcreteHaveAggSplittingStrength() const
{
   return m_ConcreteManager.DoesDeckConcreteHaveAggSplittingStrength();
}

Float64 CBridgeAgentImp::GetDeckConcreteAggSplittingStrength() const
{
   return m_ConcreteManager.GetDeckConcreteAggSplittingStrength();
}

Float64 CBridgeAgentImp::GetDeckMaxAggrSize() const
{
   return m_ConcreteManager.GetDeckMaxAggrSize();
}

Float64 CBridgeAgentImp::GetDeckStrengthDensity() const
{
   return m_ConcreteManager.GetDeckStrengthDensity();
}

Float64 CBridgeAgentImp::GetDeckEccK1() const
{
   return m_ConcreteManager.GetDeckEccK1();
}

Float64 CBridgeAgentImp::GetDeckEccK2() const
{
   return m_ConcreteManager.GetDeckEccK2();
}

Float64 CBridgeAgentImp::GetDeckCreepK1() const
{
   return m_ConcreteManager.GetDeckCreepK1();
}

Float64 CBridgeAgentImp::GetDeckCreepK2() const
{
   return m_ConcreteManager.GetDeckCreepK2();
}

Float64 CBridgeAgentImp::GetDeckShrinkageK1() const
{
   return m_ConcreteManager.GetDeckShrinkageK1();
}

Float64 CBridgeAgentImp::GetDeckShrinkageK2() const
{
   return m_ConcreteManager.GetDeckShrinkageK2();
}

const std::unique_ptr<WBFL::Materials::ConcreteBase>& CBridgeAgentImp::GetDeckConcrete(IndexType castingRegionIdx) const
{
   return m_ConcreteManager.GetDeckConcrete(castingRegionIdx);
}

pgsTypes::ConcreteType CBridgeAgentImp::GetLongitudinalJointConcreteType() const
{
   return m_ConcreteManager.GetLongitudinalJointConcreteType();
}

bool CBridgeAgentImp::DoesLongitudinalJointConcreteHaveAggSplittingStrength() const
{
   return m_ConcreteManager.DoesLongitudinalJointConcreteHaveAggSplittingStrength();
}

Float64 CBridgeAgentImp::GetLongitudinalJointConcreteAggSplittingStrength() const
{
   return m_ConcreteManager.GetLongitudinalJointConcreteAggSplittingStrength();
}

Float64 CBridgeAgentImp::GetLongitudinalJointStrengthDensity() const
{
   return m_ConcreteManager.GetLongitudinalJointStrengthDensity();
}

Float64 CBridgeAgentImp::GetLongitudinalJointMaxAggrSize() const
{
   return m_ConcreteManager.GetLongitudinalJointMaxAggrSize();
}

Float64 CBridgeAgentImp::GetLongitudinalJointEccK1() const
{
   return m_ConcreteManager.GetLongitudinalJointEccK1();
}

Float64 CBridgeAgentImp::GetLongitudinalJointEccK2() const
{
   return m_ConcreteManager.GetLongitudinalJointEccK2();
}

Float64 CBridgeAgentImp::GetLongitudinalJointCreepK1() const
{
   return m_ConcreteManager.GetLongitudinalJointCreepK1();
}

Float64 CBridgeAgentImp::GetLongitudinalJointCreepK2() const
{
   return m_ConcreteManager.GetLongitudinalJointCreepK2();
}

Float64 CBridgeAgentImp::GetLongitudinalJointShrinkageK1() const
{
   return m_ConcreteManager.GetLongitudinalJointShrinkageK1();
}

Float64 CBridgeAgentImp::GetLongitudinalJointShrinkageK2() const
{
   return m_ConcreteManager.GetLongitudinalJointShrinkageK2();
}

const std::unique_ptr<WBFL::Materials::ConcreteBase>& CBridgeAgentImp::GetLongitudinalJointConcrete() const
{
   return m_ConcreteManager.GetLongitudinalJointConcrete();
}

const WBFL::Materials::PsStrand* CBridgeAgentImp::GetStrandMaterial(const CSegmentKey& segmentKey,pgsTypes::StrandType strandType) const
{
   GET_IFACE(ISegmentData,pSegmentData);
   return pSegmentData->GetStrandMaterial(segmentKey,strandType);
}

Float64 CBridgeAgentImp::GetIncrementalStrandRelaxation(const CSegmentKey& segmentKey,IntervalIndexType intervalIdx,Float64 fpi,pgsTypes::StrandType strandType) const
{
   return GetIncrementalStrandRelaxationDetails(segmentKey,intervalIdx,fpi,strandType).fr;
}

INCREMENTALRELAXATIONDETAILS CBridgeAgentImp::GetIncrementalStrandRelaxationDetails(const CSegmentKey& segmentKey,IntervalIndexType intervalIdx,Float64 fpi,pgsTypes::StrandType strandType) const
{
   IntervalIndexType stressStrandIntervalIdx = m_IntervalManager.GetStressStrandInterval(segmentKey);
   Float64 tStress = m_IntervalManager.GetTime(stressStrandIntervalIdx,pgsTypes::Start);
   Float64 tStart = m_IntervalManager.GetTime(intervalIdx,pgsTypes::Start);
   Float64 tEnd   = m_IntervalManager.GetTime(intervalIdx,pgsTypes::End);

   const auto* pStrand = GetStrandMaterial(segmentKey,strandType);

   if ( intervalIdx < stressStrandIntervalIdx || GetStrandCount(segmentKey,strandType) == 0 )
   {
      // no strands or strand not stressed yet, so no relaxation
      INCREMENTALRELAXATIONDETAILS details;
      details.tStart = tStart - tStress;
      details.tEnd = tEnd - tStress;
      details.epoxyFactor = 1.0;
      details.fpy = pStrand->GetYieldStrength();
      return details;
   }


   return GetIncrementalRelaxationDetails(fpi,pStrand,tStart,tEnd,tStress);
}

const WBFL::Materials::PsStrand* CBridgeAgentImp::GetGirderTendonMaterial(const CGirderKey& girderKey) const
{
   GET_IFACE(IBridgeDescription,pIBridgeDesc);
   const CPTData* pPTData = pIBridgeDesc->GetPostTensioning(girderKey);
   return pPTData->pStrand;
}

Float64 CBridgeAgentImp::GetGirderTendonIncrementalRelaxation(const CGirderKey& girderKey,DuctIndexType ductIdx,IntervalIndexType intervalIdx,Float64 fpi) const
{
   return GetGirderTendonIncrementalRelaxationDetails(girderKey,ductIdx,intervalIdx,fpi).fr;
}

INCREMENTALRELAXATIONDETAILS CBridgeAgentImp::GetGirderTendonIncrementalRelaxationDetails(const CGirderKey& girderKey,DuctIndexType ductIdx,IntervalIndexType intervalIdx,Float64 fpi) const
{
   IntervalIndexType stressTendonIntervalIdx = m_IntervalManager.GetStressGirderTendonInterval(girderKey,ductIdx);
   Float64 tStress = m_IntervalManager.GetTime(stressTendonIntervalIdx,pgsTypes::Start);
   Float64 tStart  = m_IntervalManager.GetTime(intervalIdx,pgsTypes::Start);
   Float64 tEnd    = m_IntervalManager.GetTime(intervalIdx,pgsTypes::End);

   const auto* pStrand = GetGirderTendonMaterial(girderKey);

   if ( intervalIdx < stressTendonIntervalIdx || GetTendonStrandCount(girderKey,ductIdx) == 0 )
   {
      // tendon not stressed yet, so no relaxation
      INCREMENTALRELAXATIONDETAILS details;
      details.tStart = tStart - tStress;
      details.tEnd = tEnd = tStress;
      details.epoxyFactor = 1.0;
      details.fpy = pStrand->GetYieldStrength();
      return details;
   }

   return GetIncrementalRelaxationDetails(fpi,pStrand,tStart,tEnd,tStress);
}

const WBFL::Materials::PsStrand* CBridgeAgentImp::GetSegmentTendonMaterial(const CSegmentKey& segmentKey) const
{
   GET_IFACE(IBridgeDescription, pIBridgeDesc);
   const CPrecastSegmentData* pSegment = pIBridgeDesc->GetPrecastSegmentData(segmentKey);
   return pSegment->Tendons.m_pStrand;
}

Float64 CBridgeAgentImp::GetSegmentTendonIncrementalRelaxation(const CSegmentKey& segmentKey, DuctIndexType ductIdx, IntervalIndexType intervalIdx, Float64 fpi) const
{
   return GetSegmentTendonIncrementalRelaxationDetails(segmentKey, ductIdx, intervalIdx, fpi).fr;
}

INCREMENTALRELAXATIONDETAILS CBridgeAgentImp::GetSegmentTendonIncrementalRelaxationDetails(const CSegmentKey& segmentKey, DuctIndexType ductIdx, IntervalIndexType intervalIdx, Float64 fpi) const
{
   IntervalIndexType stressTendonIntervalIdx = m_IntervalManager.GetStressSegmentTendonInterval(segmentKey);
   Float64 tStress = m_IntervalManager.GetTime(stressTendonIntervalIdx, pgsTypes::Start);
   Float64 tStart = m_IntervalManager.GetTime(intervalIdx, pgsTypes::Start);
   Float64 tEnd = m_IntervalManager.GetTime(intervalIdx, pgsTypes::End);

   const auto* pStrand = GetSegmentTendonMaterial(segmentKey);

   if (intervalIdx < stressTendonIntervalIdx || GetTendonStrandCount(segmentKey, ductIdx) == 0)
   {
      // tendon not stressed yet, so no relaxation
      INCREMENTALRELAXATIONDETAILS details;
      details.tStart = tStart - tStress;
      details.tEnd = tEnd = tStress;
      details.epoxyFactor = 1.0;
      details.fpy = pStrand->GetYieldStrength();
      return details;
   }

   return GetIncrementalRelaxationDetails(fpi, pStrand, tStart, tEnd, tStress);
}


void CBridgeAgentImp::GetSegmentLongitudinalRebarProperties(const CSegmentKey& segmentKey,Float64* pE,Float64 *pFy,Float64* pFu) const
{
   GET_IFACE(ILongitudinalRebar,pLongRebar);
   const CLongitudinalRebarData* pLRD = pLongRebar->GetSegmentLongitudinalRebarData(segmentKey);

   const auto* pRebar = lrfdRebarPool::GetInstance()->GetRebar(pLRD->BarType,pLRD->BarGrade,WBFL::Materials::Rebar::Size::bs3);
   *pE  = pRebar->GetE();
   *pFy = pRebar->GetYieldStrength();
   *pFu = pRebar->GetUltimateStrength();
}

void CBridgeAgentImp::GetSegmentLongitudinalRebarMaterial(const CSegmentKey& segmentKey,WBFL::Materials::Rebar::Type* pType,WBFL::Materials::Rebar::Grade* pGrade) const
{
   GET_IFACE(ILongitudinalRebar,pLongRebar);
   const CLongitudinalRebarData* pLRD = pLongRebar->GetSegmentLongitudinalRebarData(segmentKey);
   (*pType) = pLRD->BarType;
   (*pGrade) = pLRD->BarGrade;
}

std::_tstring CBridgeAgentImp::GetSegmentLongitudinalRebarName(const CSegmentKey& segmentKey) const
{
   GET_IFACE(ILongitudinalRebar,pLongRebar);
   return pLongRebar->GetSegmentLongitudinalRebarMaterial(segmentKey);
}

void CBridgeAgentImp::GetClosureJointLongitudinalRebarProperties(const CClosureKey& closureKey,Float64* pE,Float64 *pFy,Float64* pFu) const
{
   GET_IFACE(ILongitudinalRebar,pLongRebar);
   const CLongitudinalRebarData* pLRD = pLongRebar->GetClosureJointLongitudinalRebarData(closureKey);

   const auto* pRebar = lrfdRebarPool::GetInstance()->GetRebar(pLRD->BarType,pLRD->BarGrade,WBFL::Materials::Rebar::Size::bs3);
   *pE  = pRebar->GetE();
   *pFy = pRebar->GetYieldStrength();
   *pFu = pRebar->GetUltimateStrength();
}

void CBridgeAgentImp::GetClosureJointLongitudinalRebarMaterial(const CClosureKey& closureKey,WBFL::Materials::Rebar::Type* pType,WBFL::Materials::Rebar::Grade* pGrade) const
{
   GET_IFACE(ILongitudinalRebar,pLongRebar);
   const CLongitudinalRebarData* pLRD = pLongRebar->GetClosureJointLongitudinalRebarData(closureKey);
   (*pType) = pLRD->BarType;
   (*pGrade) = pLRD->BarGrade;
}

std::_tstring CBridgeAgentImp::GetClosureJointLongitudinalRebarName(const CClosureKey& closureKey) const
{
   GET_IFACE(ILongitudinalRebar,pLongRebar);
   return pLongRebar->GetClosureJointLongitudinalRebarMaterial(closureKey);
}

void CBridgeAgentImp::GetSegmentTransverseRebarProperties(const CSegmentKey& segmentKey,Float64* pE,Float64 *pFy,Float64* pFu) const
{
	GET_IFACE(IShear,pShear);
	const CShearData2* pShearData = pShear->GetSegmentShearData(segmentKey);
   const auto* pRebar = lrfdRebarPool::GetInstance()->GetRebar(pShearData->ShearBarType,pShearData->ShearBarGrade,WBFL::Materials::Rebar::Size::bs3);
   *pE  = pRebar->GetE();
   *pFy = pRebar->GetYieldStrength();
   *pFu = pRebar->GetUltimateStrength();

}

void CBridgeAgentImp::GetSegmentTransverseRebarMaterial(const CSegmentKey& segmentKey,WBFL::Materials::Rebar::Type* pType,WBFL::Materials::Rebar::Grade* pGrade) const
{
	GET_IFACE(IShear,pShear);
	const CShearData2* pShearData = pShear->GetSegmentShearData(segmentKey);
   (*pType)  = pShearData->ShearBarType;
   (*pGrade) = pShearData->ShearBarGrade;
}

std::_tstring CBridgeAgentImp::GetSegmentTransverseRebarName(const CSegmentKey& segmentKey) const
{
   GET_IFACE(IShear,pShear);
   return pShear->GetSegmentStirrupMaterial(segmentKey);
}

void CBridgeAgentImp::GetClosureJointTransverseRebarProperties(const CClosureKey& closureKey,Float64* pE,Float64 *pFy,Float64* pFu) const
{
	GET_IFACE(IShear,pShear);
	const CShearData2* pShearData = pShear->GetClosureJointShearData(closureKey);
   const auto* pRebar = lrfdRebarPool::GetInstance()->GetRebar(pShearData->ShearBarType,pShearData->ShearBarGrade,WBFL::Materials::Rebar::Size::bs3);
   *pE  = pRebar->GetE();
   *pFy = pRebar->GetYieldStrength();
   *pFu = pRebar->GetUltimateStrength();

}

void CBridgeAgentImp::GetClosureJointTransverseRebarMaterial(const CClosureKey& closureKey,WBFL::Materials::Rebar::Type* pType,WBFL::Materials::Rebar::Grade* pGrade) const
{
	GET_IFACE(IShear,pShear);
	const CShearData2* pShearData = pShear->GetClosureJointShearData(closureKey);
   (*pType)  = pShearData->ShearBarType;
   (*pGrade) = pShearData->ShearBarGrade;
}

std::_tstring CBridgeAgentImp::GetClosureJointTransverseRebarName(const CClosureKey& closureKey) const
{
   GET_IFACE(IShear,pShear);
   return pShear->GetClosureJointStirrupMaterial(closureKey);
}

void CBridgeAgentImp::GetDeckRebarProperties(Float64* pE,Float64 *pFy,Float64* pFu) const
{
   GET_IFACE(IBridgeDescription,pIBridgeDesc);
   const CDeckDescription2* pDeck = pIBridgeDesc->GetDeckDescription();
   const auto* pRebar = lrfdRebarPool::GetInstance()->GetRebar(pDeck->DeckRebarData.TopRebarType,pDeck->DeckRebarData.TopRebarGrade,WBFL::Materials::Rebar::Size::bs3);
   *pE  = pRebar->GetE();
   *pFy = pRebar->GetYieldStrength();
   *pFu = pRebar->GetUltimateStrength();
}

std::_tstring CBridgeAgentImp::GetDeckRebarName() const
{
   GET_IFACE(IBridgeDescription,pIBridgeDesc);
   const CDeckDescription2* pDeck = pIBridgeDesc->GetDeckDescription();
   return lrfdRebarPool::GetMaterialName(pDeck->DeckRebarData.TopRebarType,pDeck->DeckRebarData.TopRebarGrade);
}

void CBridgeAgentImp::GetDeckRebarMaterial(WBFL::Materials::Rebar::Type* pType,WBFL::Materials::Rebar::Grade* pGrade) const
{
   // top and bottom mat use the same material
   GET_IFACE(IBridgeDescription,pIBridgeDesc);
   const CDeckDescription2* pDeck = pIBridgeDesc->GetDeckDescription();
   (*pType)  = pDeck->DeckRebarData.TopRebarType;
   (*pGrade) = pDeck->DeckRebarData.TopRebarGrade;
}

Float64 CBridgeAgentImp::GetFlexureModRupture(Float64 fc,pgsTypes::ConcreteType type) const
{
   return m_ConcreteManager.GetFlexureModRupture(fc,type);
}

Float64 CBridgeAgentImp::GetShearModRupture(Float64 fc,pgsTypes::ConcreteType type) const
{
   return m_ConcreteManager.GetShearModRupture(fc,type);
}

Float64 CBridgeAgentImp::GetSegmentFlexureFrCoefficient(const CSegmentKey& segmentKey) const
{
   return m_ConcreteManager.GetSegmentFlexureFrCoefficient(segmentKey);
}

Float64 CBridgeAgentImp::GetSegmentShearFrCoefficient(const CSegmentKey& segmentKey) const
{
   return m_ConcreteManager.GetSegmentShearFrCoefficient(segmentKey);
}

Float64 CBridgeAgentImp::GetClosureJointFlexureFrCoefficient(const CClosureKey& closureKey) const
{
   return m_ConcreteManager.GetClosureJointFlexureFrCoefficient(closureKey);
}

Float64 CBridgeAgentImp::GetClosureJointShearFrCoefficient(const CClosureKey& closureKey) const
{
   return m_ConcreteManager.GetClosureJointShearFrCoefficient(closureKey);
}

Float64 CBridgeAgentImp::GetEconc(pgsTypes::ConcreteType type, Float64 fc,Float64 density,Float64 K1,Float64 K2) const
{
   return m_ConcreteManager.GetEconc(type, fc,density,K1,K2);
}

bool CBridgeAgentImp::HasUHPC() const
{
   return m_ConcreteManager.HasUHPC();
}

/////////////////////////////////////////////////////////////////////////
// ILongRebarGeometry
void CBridgeAgentImp::GetRebars(const pgsPointOfInterest& poi,IRebarSection** rebarSection) const
{
   Float64 Xpoi = poi.GetDistFromStart();

   CComPtr<IPrecastGirder> girder;
   GetGirder(poi.GetSegmentKey(),&girder);

   CComPtr<IRebarLayout> rebar_layout;

   CClosureKey closureKey;
   if ( IsInClosureJoint(poi,&closureKey) )
   {
      girder->get_ClosureJointRebarLayout(&rebar_layout);
   }
   else
   {
      girder->get_RebarLayout(&rebar_layout);
   }

   IntervalIndexType nIntervals = GetIntervalCount();
   IntervalIndexType lastIntervalIdx = nIntervals-1;
   rebar_layout->CreateRebarSection(Xpoi,lastIntervalIdx,rebarSection);
}

Float64 CBridgeAgentImp::GetAsBottomHalf(const pgsPointOfInterest& poi,bool bDevAdjust) const
{
   return GetAsTensionSideOfGirder(poi,bDevAdjust,false);
}

Float64 CBridgeAgentImp::GetAsTopHalf(const pgsPointOfInterest& poi,bool bDevAdjust) const
{
   return GetAsGirderTopHalf(poi,bDevAdjust) + GetAsDeckTopHalf(poi,bDevAdjust);
}

Float64 CBridgeAgentImp::GetAsGirderTopHalf(const pgsPointOfInterest& poi,bool bDevAdjust) const
{
   return GetAsTensionSideOfGirder(poi,bDevAdjust,true);
}

Float64 CBridgeAgentImp::GetAsDeckTopHalf(const pgsPointOfInterest& poi,bool bDevAdjust) const
{
   Float64 As_Top    = GetAsTopMat(poi,pgsTypes::drbAll,pgsTypes::drcAll);
   Float64 As_Bottom = GetAsBottomMat(poi,pgsTypes::drbAll,pgsTypes::drcAll);

   return As_Top + As_Bottom;
}

Float64 CBridgeAgentImp::GetDevLengthFactor(const pgsPointOfInterest& poi,IRebarSectionItem* rebarItem) const
{
   Float64 fc;
   pgsTypes::ConcreteType type;
   bool isFct;
   Float64 fct;

   CClosureKey closureKey;
   Float64 bIsInClosureJoint = IsInClosureJoint(poi,&closureKey);
   if ( bIsInClosureJoint )
   {
      fc = GetClosureJointFc28(closureKey);
      type = GetClosureJointConcreteType(closureKey);
      isFct = DoesClosureJointConcreteHaveAggSplittingStrength(closureKey);
      fct = isFct ? GetClosureJointConcreteAggSplittingStrength(closureKey) : 0.0;
   }
   else
   {
      const CSegmentKey& segmentKey(poi.GetSegmentKey());
      fc = GetSegmentFc28(segmentKey);
      type = GetSegmentConcreteType(segmentKey);
      isFct = DoesSegmentConcreteHaveAggSplittingStrength(segmentKey);
      fct = isFct ? GetSegmentConcreteAggSplittingStrength(segmentKey) : 0.0;
   }

   return GetDevLengthFactor(poi, rebarItem, type, fc, isFct, fct);
}

Float64 CBridgeAgentImp::GetDevLengthFactor(const pgsPointOfInterest& poi,IRebarSectionItem* rebarItem, pgsTypes::ConcreteType type, Float64 fc, bool isFct, Float64 fct) const
{
   Float64 fra = 1.0;

   CClosureKey closureKey;
   Float64 bIsInClosureJoint = IsInClosureJoint(poi,&closureKey);

   CComPtr<IRebar> rebar;
   rebarItem->get_Rebar(&rebar);

   REBARDEVLENGTHDETAILS details = GetSegmentRebarDevelopmentLengthDetails(poi.GetSegmentKey(), rebar, type, fc, isFct, fct, false/*not top bar*/, false/*not epoxy coated*/, true/*meets cover requirements*/);

   // Get distances from section cut to ends of bar
   Float64 start,end;
   rebarItem->get_LeftExtension(&start);
   rebarItem->get_RightExtension(&end);

   Float64 Xpoi = poi.GetDistFromStart();
   Float64 Xs = Xpoi - start;
   Float64 Xe = Xpoi + end;

   Float64 cut_length = Min(start, end);
   fra = cut_length/details.ld;
   fra = Min(fra, 1.0);

   if (fra < 1.0)
   {
      // the section cut is in the development length zone
      // check to see if there is a hook, and if so, assume
      // the bar to be fully developed
      HookType ht;
      if (start < end)
      {
         rebarItem->get_LeftHook(&ht);
      }
      else
      {
         rebarItem->get_RightHook(&ht);
      }

      if (ht != htNone)
      {
         fra = 1.0;
      }
   }

   return fra;
}

Float64 CBridgeAgentImp::GetPPRTopHalf(const pgsPointOfInterest& poi,const GDRCONFIG* pConfig) const
{
   const CSegmentKey& segmentKey = poi.GetSegmentKey();

   GET_IFACE(ILibrary,pLib);
   GET_IFACE(ISpecification, pSpec);
   const SpecLibraryEntry* pSpecEntry = pLib->GetSpecEntry( pSpec->GetSpecification().c_str() );

   Float64 As = GetAsDeckTopHalf(poi,false);
   As += GetAsGirderTopHalf(poi,false);

   Float64 Aps = GetApsTopHalf(poi,dlaNone,pConfig);

   const auto* pstrand = GetStrandMaterial(segmentKey,pgsTypes::Permanent);
   ATLASSERT(pstrand!=0);
   Float64 fps = pstrand->GetYieldStrength();
   ATLASSERT(fps>0.0);

   Float64 E,fs,fu;
   CClosureKey closureKey;
   if ( IsInClosureJoint(poi,&closureKey) )
   {
      GetClosureJointLongitudinalRebarProperties(closureKey,&E,&fs,&fu);
   }
   else
   {
      GetSegmentLongitudinalRebarProperties(segmentKey,&E,&fs,&fu);
   }

   Float64 denom = Aps*fps + As*fs;
   Float64 ppr = IsZero(denom) ? 0.0 : (Aps*fps)/denom;

   return ppr;
}

Float64 CBridgeAgentImp::GetPPRBottomHalf(const pgsPointOfInterest& poi,const GDRCONFIG* pConfig) const
{
   const CSegmentKey& segmentKey = poi.GetSegmentKey();

   GET_IFACE(ILibrary,pLib);
   GET_IFACE(ISpecification, pSpec);
   const SpecLibraryEntry* pSpecEntry = pLib->GetSpecEntry( pSpec->GetSpecification().c_str() );

   Float64 As = GetAsBottomHalf(poi,false);

   Float64 Aps = GetApsBottomHalf(poi,dlaNone,pConfig);

   const auto* pStrand = GetStrandMaterial(segmentKey,pgsTypes::Straight);
   ATLASSERT(pStrand);
   Float64 fpy = pStrand->GetYieldStrength();
   ATLASSERT(0.0 < fpy);

   Float64 E,fs,fu;
   CClosureKey closureKey;
   if ( IsInClosureJoint(poi,&closureKey) )
   {
      GetClosureJointLongitudinalRebarProperties(closureKey,&E,&fs,&fu);
   }
   else
   {
      GetSegmentLongitudinalRebarProperties(segmentKey,&E,&fs,&fu);
   }

   Float64 denom = Aps*fpy + As*fs;
   Float64 ppr = IsZero(denom) ? 0.0 : (Aps*fpy)/denom;

   return ppr;
}

REBARDEVLENGTHDETAILS CBridgeAgentImp::GetSegmentRebarDevelopmentLengthDetails(const CSegmentKey& segmentKey, IRebar* rebar,pgsTypes::ConcreteType type, Float64 fc, bool isFct, Float64 Fct, bool bIsTopBar, bool bEpoxyCoated, bool bMeetsCoverRequirements) const
{
   return GetRebarDevelopmentLengthDetails(segmentKey, rebar,type, fc, isFct, Fct, bIsTopBar, bEpoxyCoated, bMeetsCoverRequirements);
}

REBARDEVLENGTHDETAILS CBridgeAgentImp::GetDeckRebarDevelopmentLengthDetails(IRebar* rebar,pgsTypes::ConcreteType type, Float64 fc, bool isFct, Float64 Fct, bool bIsTopBar, bool bEpoxyCoated, bool bMeetsCoverRequirements) const
{
   return GetRebarDevelopmentLengthDetails(CSegmentKey(), rebar,type, fc, isFct, Fct, bIsTopBar, bEpoxyCoated, bMeetsCoverRequirements);
}

bool CBridgeAgentImp::IsAnchored(const pgsPointOfInterest& poi) const
{
   GET_IFACE(ILongitudinalRebar, pLongRebar);
   const CLongitudinalRebarData* pLRD = nullptr;
   CClosureKey closureKey;
   if (IsInClosureJoint(poi, &closureKey))
   {
      pLRD = pLongRebar->GetClosureJointLongitudinalRebarData(closureKey);
   }
   else
   {
      pLRD = pLongRebar->GetSegmentLongitudinalRebarData(poi.GetSegmentKey());
   }

   // this is a row by row evaluation... lets say that both ends of all 
   // rows must be anchored to consider the longitudinal rebar anchored
   bool bAnchored = true;
   for (const auto& rebarRow : pLRD->RebarRows)
   {
      if (!rebarRow.IsLeftEndExtended() || !rebarRow.IsRightEndExtended())
      {
         bAnchored = false;
         break;
      }
   }
   return bAnchored;
}

REBARDEVLENGTHDETAILS CBridgeAgentImp::GetRebarDevelopmentLengthDetails(const CSegmentKey& segmentKey, IRebar* rebar,pgsTypes::ConcreteType type, Float64 fc, bool isFct, Float64 Fct, bool bIsTopBar, bool bEpoxyCoated, bool bMeetsCoverRequirements) const
{
   USES_CONVERSION;
   CComBSTR name;
   rebar->get_Name(&name);

   WBFL::Materials::Rebar::Size size = lrfdRebarPool::GetBarSize(OLE2CT(name));

   Float64 Ab, db, fy;
   rebar->get_NominalArea(&Ab);
   rebar->get_NominalDiameter(&db);
   rebar->get_YieldStrength(&fy);

   Float64 density;
   if ( segmentKey.groupIndex == INVALID_INDEX && segmentKey.girderIndex == INVALID_INDEX && segmentKey.segmentIndex == INVALID_INDEX )
   {
      density = GetDeckStrengthDensity();
   }
   else
   {
      density = GetSegmentStrengthDensity(segmentKey);
   }

   // density is used to compute lambda factor
   return lrfdRebar::GetRebarDevelopmentLengthDetails(size, Ab, db, fy, (WBFL::Materials::ConcreteType)type, fc, isFct, Fct, density, bIsTopBar, bEpoxyCoated, bMeetsCoverRequirements);
}

Float64 CBridgeAgentImp::GetCoverTopMat() const
{
   GET_IFACE(IBridgeDescription,pIBridgeDesc);
   const CBridgeDescription2* pBridgeDesc = pIBridgeDesc->GetBridgeDescription();
   const CDeckDescription2* pDeck = pBridgeDesc->GetDeckDescription();
   const CDeckRebarData& rebarData = pDeck->DeckRebarData;

   return rebarData.TopCover;
}

Float64 CBridgeAgentImp::GetTopMatLocation(const pgsPointOfInterest& poi,pgsTypes::DeckRebarBarType barType,pgsTypes::DeckRebarCategoryType barCategory) const
{
   return GetLocationDeckMats(poi,barType,barCategory,true,false);
}

Float64 CBridgeAgentImp::GetAsTopMat(const pgsPointOfInterest& poi,pgsTypes::DeckRebarBarType barType,pgsTypes::DeckRebarCategoryType barCategory) const
{
   return GetAsDeckMats(poi,barType,barCategory,true,false);
}

Float64 CBridgeAgentImp::GetCoverBottomMat() const
{
   GET_IFACE(IBridgeDescription,pIBridgeDesc);
   const CBridgeDescription2* pBridgeDesc = pIBridgeDesc->GetBridgeDescription();
   const CDeckDescription2* pDeck = pBridgeDesc->GetDeckDescription();
   const CDeckRebarData& rebarData = pDeck->DeckRebarData;

   return rebarData.BottomCover;
}

Float64 CBridgeAgentImp::GetBottomMatLocation(const pgsPointOfInterest& poi,pgsTypes::DeckRebarBarType barType,pgsTypes::DeckRebarCategoryType barCategory) const
{
   return GetLocationDeckMats(poi,barType,barCategory,false,true);
}

Float64 CBridgeAgentImp::GetAsBottomMat(const pgsPointOfInterest& poi,pgsTypes::DeckRebarBarType barType,pgsTypes::DeckRebarCategoryType barCategory) const
{
   return GetAsDeckMats(poi,barType,barCategory,false,true);
}

void CBridgeAgentImp::GetDeckReinforcing(const pgsPointOfInterest& poi,pgsTypes::DeckRebarMatType matType,pgsTypes::DeckRebarBarType barType,pgsTypes::DeckRebarCategoryType barCategory,bool bAdjForDevLength,Float64* pAs,Float64* pYb) const
{
   bool bTopMat    = (matType == pgsTypes::drmTop    ? true : false);
   bool bBottomMat = (matType == pgsTypes::drmBottom ? true : false);
   GetDeckMatData(poi,barType,barCategory,bTopMat,bBottomMat,bAdjForDevLength,pAs,pYb);
}

void CBridgeAgentImp::GetRebarLayout(const CSegmentKey& segmentKey, IRebarLayout** rebarLayout) const
{
   CComPtr<IPrecastGirder> girder;
   GetGirder(segmentKey,&girder);

   CComPtr<IRebarLayout> rebar_layout;
   girder->get_RebarLayout(rebarLayout);
}

void CBridgeAgentImp::GetClosureJointRebarLayout(const CClosureKey& closureKey, IRebarLayout** rebarLayout) const
{
   CComPtr<IPrecastGirder> girder;
   GetGirder(closureKey,&girder);

   CComPtr<IRebarLayout> rebar_layout;
   girder->get_ClosureJointRebarLayout(rebarLayout);
}

/////////////////////////////////////////////////////////////////////////
// IStirrupGeometry
bool CBridgeAgentImp::AreStirrupZonesSymmetrical(const CSegmentKey& segmentKey) const
{
   const CShearData2* pShearData = GetShearData(segmentKey);
   return pShearData->bAreZonesSymmetrical;
}

ZoneIndexType CBridgeAgentImp::GetPrimaryZoneCount(const CSegmentKey& segmentKey) const
{
   const CShearData2* pShearData = GetShearData(segmentKey);
   ZoneIndexType nZones = pShearData->ShearZones.size();

   if (nZones == 0)
   {
      return 0;
   }
   else
   {
      // determine the actual number of zones within the girder
	   GET_IFACE(IBridge,pBridge);
      SegmentIndexType nSegments = pBridge->GetSegmentCount(segmentKey);
      CString strGirderLabel(1 == nSegments ? _T("Girder") : _T("Segment"));
      if (pShearData->bAreZonesSymmetrical)
      {
         Float64 half_segment_length = pBridge->GetSegmentLength(segmentKey)/2.0;

         Float64 end_of_zone = 0.0;
         for (ZoneIndexType zoneIdx = 0; zoneIdx < nZones; zoneIdx++)
         {
            end_of_zone += pShearData->ShearZones[zoneIdx].ZoneLength;
            if (half_segment_length < end_of_zone)
            {
               if ( zoneIdx < nZones-1 )
               {
                  // segment is shorter than stirrups layout. zones beyond mid-span are ignored
                  GET_IFACE(IEAFStatusCenter,pStatusCenter);
                  CString strMsg;
                  if ( 1 == nSegments )
                  {
                     strMsg.Format(_T("Span %s, %s %s: %s is shorter than the stirrup layout. For symmetrical stirrup zones, the zones beyond mid-point are ignored"),LABEL_SPAN(segmentKey.groupIndex),strGirderLabel,LABEL_GIRDER(segmentKey.girderIndex),strGirderLabel);
                  }
                  else
                  {
                     strMsg.Format(_T("Group %d Girder %s Segment %d: %s is shorter than the stirrup layout. For symmetrical stirrup zones, the zones beyond mid-point are ignored"),LABEL_GROUP(segmentKey.groupIndex),LABEL_GIRDER(segmentKey.girderIndex),LABEL_SEGMENT(segmentKey.segmentIndex),strGirderLabel);
                  }
                  std::unique_ptr<pgsGirderDescriptionStatusItem> pStatusItem = std::make_unique<pgsGirderDescriptionStatusItem>(segmentKey,EGD_STIRRUPS,m_StatusGroupID,m_scidGirderDescriptionInform,strMsg);
                  pStatusCenter->Add(pStatusItem.release());
               }
               return 2*(zoneIdx+1)-1;
            }
         }
         return nZones*2-1;
      }
      else
      {
         Float64 segment_length = pBridge->GetSegmentLength(segmentKey);

         Float64 end_of_zone = 0.0;
         for (ZoneIndexType zoneIdx = 0; zoneIdx < nZones; zoneIdx++)
         {
            end_of_zone += pShearData->ShearZones[zoneIdx].ZoneLength;
            if (segment_length < end_of_zone)
            {
               if ( zoneIdx < nZones-1 )
               {
                  // segment is shorter than stirrups layout. zones beyond mid-span are ignored
                  GET_IFACE(IEAFStatusCenter,pStatusCenter);
                  CString strMsg;
                  if ( 1 == nSegments )
                  {
                     strMsg.Format(_T("Span %s, %s %s: %s is shorter than the stirrup layout. Stirrups zones beyond the end of the %s are ignored"),LABEL_SPAN(segmentKey.groupIndex),strGirderLabel,LABEL_GIRDER(segmentKey.girderIndex),strGirderLabel,strGirderLabel);
                  }
                  else
                  {
                     strMsg.Format(_T("Group %d Girder %s Segment %d: %s is shorter than the stirrup layout. Stirrup zones beyond the end of the %s are ignored"),LABEL_GROUP(segmentKey.groupIndex),LABEL_GIRDER(segmentKey.girderIndex),LABEL_SEGMENT(segmentKey.segmentIndex),strGirderLabel,strGirderLabel);
                  }
                  std::unique_ptr<pgsGirderDescriptionStatusItem> pStatusItem = std::make_unique<pgsGirderDescriptionStatusItem>(segmentKey,EGD_STIRRUPS,m_StatusGroupID,m_scidGirderDescriptionInform,strMsg);
                  pStatusCenter->Add(pStatusItem.release());
               }
               return (zoneIdx+1);
            }
         }

         return nZones;
      }
   }
}

void CBridgeAgentImp::GetPrimaryZoneBounds(const CSegmentKey& segmentKey, ZoneIndexType zone, Float64* start, Float64* end) const
{
   const CShearData2* pShearData = GetShearData(segmentKey);
   Float64 segment_length = GetSegmentLength(segmentKey);

   ZoneIndexType nZones = GetPrimaryZoneCount(segmentKey);
   if (nZones == 0)
   {
      *start = 0.0;
      *end = segment_length;
      return;

   }

   if(pShearData->bAreZonesSymmetrical)
   {
      ZoneIndexType idx = GetPrimaryZoneIndex(segmentKey,pShearData,zone);

      // determine which side of girder zone is on
      enum side {OnLeft, OverCenter, OnRight} zside;
      if (zone == (nZones -1)/2)
      {
         zside = OverCenter;
      }
      else if (idx==zone)
      {
         zside = OnLeft;
      }
      else
      {
         zside = OnRight;
      }

      ZoneIndexType zsiz = pShearData->ShearZones.size();
      Float64 l_end=0.0;
      Float64 l_start=0.0;
      for (ZoneIndexType i = 0; i <= idx; i++)
      {
         if (i==zsiz-1)
         {
            l_end = Float64_Max; // last zone in infinitely long
         }
         else
         {
            l_end+= pShearData->ShearZones[i].ZoneLength;
         }

         if (segment_length/2.0 <= l_end)
         {
            ATLASSERT(i==idx);  // better be last one or too many zones
         }

         if (i != idx)
         {
            l_start = l_end;
         }
      }

      if (zside == OnLeft)
      {
         *start = l_start;
         *end =   l_end;
      }
      else if (zside == OverCenter)
      {
         *start = l_start;
         *end =   segment_length - l_start;
      }
      else if (zside == OnRight)
      {
         *start = segment_length - l_end;
         *end =   segment_length - l_start;
      }
   }
   else
   {
      // Non-symmetrical zones
      ZoneIndexType idx = GetPrimaryZoneIndex(segmentKey,pShearData,zone);
      ZoneIndexType zsiz = pShearData->ShearZones.size();

      Float64 l_end   = 0.0;
      Float64 l_start = 0.0;
      for (ZoneIndexType i = 0; i <= idx; i++)
      {
         if (i == zsiz-1)
         {
            l_end = segment_length; // last zone goes to end of girder
         }
         else
         {
            l_end += pShearData->ShearZones[i].ZoneLength;
         }

         if (segment_length <= l_end)
         {
            l_end = segment_length;
            break;
         }

         if (i != idx)
         {
            l_start = l_end;
         }
      }

      *start = l_start;
      *end =   l_end;
   }
}

void CBridgeAgentImp::GetPrimaryVertStirrupBarInfo(const CSegmentKey& segmentKey,ZoneIndexType zone, WBFL::Materials::Rebar::Size* pSize, Float64* pCount, Float64* pSpacing) const
{
   const CShearData2* pShearData = GetShearData(segmentKey);
   ZoneIndexType idx = GetPrimaryZoneIndex(segmentKey,pShearData, zone);
   const CShearZoneData2& rzone = pShearData->ShearZones[idx];

   *pSize    = rzone.VertBarSize;
   *pCount   = rzone.nVertBars;
   *pSpacing = rzone.BarSpacing;
}

Float64 CBridgeAgentImp::GetPrimaryHorizInterfaceBarCount(const CSegmentKey& segmentKey,ZoneIndexType zone) const
{
   const CShearData2* pShearData = GetShearData(segmentKey);
   ZoneIndexType idx = GetPrimaryZoneIndex(segmentKey,pShearData, zone);
   const CShearZoneData2& rzone = pShearData->ShearZones[idx];

   return rzone.nHorzInterfaceBars;
}

WBFL::Materials::Rebar::Size CBridgeAgentImp::GetPrimaryConfinementBarSize(const CSegmentKey& segmentKey,ZoneIndexType zone) const
{
   const CShearData2* pShearData = GetShearData(segmentKey);
   ZoneIndexType idx = GetPrimaryZoneIndex(segmentKey,pShearData, zone);
   const CShearZoneData2& rzone = pShearData->ShearZones[idx];

   return rzone.ConfinementBarSize;
}

ZoneIndexType CBridgeAgentImp::GetHorizInterfaceZoneCount(const CSegmentKey& segmentKey) const
{
   const CShearData2* pShearData = GetShearData(segmentKey);
   return GetHorizInterfaceZoneCount(segmentKey, pShearData);
}

ZoneIndexType CBridgeAgentImp::GetHorizInterfaceZoneCount(const CSegmentKey& segmentKey, const CShearData2* pShearData) const
{
   ZoneIndexType nZones = pShearData->HorizontalInterfaceZones.size();
   if (nZones == 0)
   {
      return 0;
   }
   else
   {
      // determine the actual number of zones within the girder
	   GET_IFACE(IBridge,pBridge);
      if (pShearData->bAreZonesSymmetrical)
      {
         Float64 half_segment_length = pBridge->GetSegmentLength(segmentKey)/2.0;

         Float64 end_of_zone = 0.0;
         for (ZoneIndexType zoneIdx = 0; zoneIdx < nZones; zoneIdx++)
         {
            end_of_zone += pShearData->HorizontalInterfaceZones[zoneIdx].ZoneLength;
            if (half_segment_length < end_of_zone)
            {
               return 2*(zoneIdx+1)-1;
            }
         }
         return nZones*2-1;
      }
      else
      {
         Float64 segment_length = pBridge->GetSegmentLength(segmentKey);

         Float64 end_of_zone = 0.0;
         for (ZoneIndexType zoneIdx = 0; zoneIdx < nZones; zoneIdx++)
         {
            end_of_zone += pShearData->HorizontalInterfaceZones[zoneIdx].ZoneLength;
            if (segment_length < end_of_zone)
            {
               return (zoneIdx+1);
            }
         }

         return nZones;
      }
   }
}

void CBridgeAgentImp::GetHorizInterfaceZoneBounds(const CSegmentKey& segmentKey, ZoneIndexType zone, Float64* start, Float64* end) const
{
   const CShearData2* pShearData = GetShearData(segmentKey);
   Float64 segment_length = GetSegmentLength(segmentKey);

   if(pShearData->bAreZonesSymmetrical)
   {
      ZoneIndexType nz = GetHorizInterfaceZoneCount(segmentKey, pShearData);
      ATLASSERT(zone < nz);

      ZoneIndexType idx = GetHorizInterfaceZoneIndex(segmentKey,pShearData,zone);

      // determine which side of girder zone is on
      enum side {OnLeft, OverCenter, OnRight} zside;
      if (zone == (nz-1)/2)
      {
         zside = OverCenter;
      }
      else if (idx == zone)
      {
         zside = OnLeft;
      }
      else
      {
         zside = OnRight;
      }

      ZoneIndexType zsiz = pShearData->HorizontalInterfaceZones.size();
      Float64 l_end   = 0.0;
      Float64 l_start = 0.0;
      for (ZoneIndexType i = 0; i <= idx; i++)
      {
         if (i == zsiz-1)
         {
            l_end = Float64_Max; // last zone in infinitely long
         }
         else
         {
            l_end += pShearData->HorizontalInterfaceZones[i].ZoneLength;
         }

         if (segment_length/2.0 <= l_end)
         {
            ATLASSERT(i == idx);  // better be last one or too many zones
         }

         if (i != idx)
         {
            l_start = l_end;
         }
      }

      if (zside == OnLeft)
      {
         *start = l_start;
         *end =   l_end;
      }
      else if (zside == OverCenter)
      {
         *start = l_start;
         *end =   segment_length - l_start;
      }
      else if (zside == OnRight)
      {
         *start = segment_length - l_end;
         *end =   segment_length - l_start;
      }
   }
   else
   {
      // Non-symmetrical zones
      ZoneIndexType idx = GetHorizInterfaceZoneIndex(segmentKey,pShearData,zone);
      ZoneIndexType zsiz = pShearData->HorizontalInterfaceZones.size();

      Float64 l_end   = 0.0;
      Float64 l_start = 0.0;
      for (ZoneIndexType i = 0; i <= idx; i++)
      {
         if (i == zsiz-1)
         {
            l_end = segment_length; // last zone goes to end of girder
         }
         else
         {
            l_end += pShearData->HorizontalInterfaceZones[i].ZoneLength;
         }

         if (segment_length <= l_end)
         {
            l_end = segment_length;
            break;
         }

         if (i != idx)
         {
            l_start = l_end;
         }
      }

      *start = l_start;
      *end =   l_end;
   }
}

void CBridgeAgentImp::GetHorizInterfaceBarInfo(const CSegmentKey& segmentKey,ZoneIndexType zone, WBFL::Materials::Rebar::Size* pSize, Float64* pCount, Float64* pSpacing) const
{
   const CShearData2* pShearData = GetShearData(segmentKey);
   ZoneIndexType idx = GetHorizInterfaceZoneIndex(segmentKey,pShearData,zone);

   const CHorizontalInterfaceZoneData& rdata = pShearData->HorizontalInterfaceZones[idx];
   *pSize = rdata.BarSize;
   *pCount = rdata.nBars;
   *pSpacing = rdata.BarSpacing;
}

void CBridgeAgentImp::GetAddSplittingBarInfo(const CSegmentKey& segmentKey, WBFL::Materials::Rebar::Size* pSize, Float64* pZoneLength, Float64* pnBars, Float64* pSpacing) const
{
   const CShearData2* pShearData = GetShearData(segmentKey);
   *pSize = pShearData->SplittingBarSize;
   if (*pSize!=WBFL::Materials::Rebar::Size::bsNone)
   {
      *pZoneLength = pShearData->SplittingZoneLength;
      *pnBars = pShearData->nSplittingBars;
      *pSpacing = pShearData->SplittingBarSpacing;
   }
   else
   {
      *pZoneLength = 0.0;
      *pnBars = 0.0;
      *pSpacing = 0.0;
   }
}

void CBridgeAgentImp::GetAddConfinementBarInfo(const CSegmentKey& segmentKey, WBFL::Materials::Rebar::Size* pSize, Float64* pZoneLength, Float64* pSpacing) const
{
   const CShearData2* pShearData = GetShearData(segmentKey);
   *pSize = pShearData->ConfinementBarSize;
   if (*pSize != WBFL::Materials::Rebar::Size::bsNone)
   {
      *pZoneLength = pShearData->ConfinementZoneLength;
      *pSpacing = pShearData->ConfinementBarSpacing;
   }
   else
   {
      *pZoneLength = 0.0;
      *pSpacing = 0.0;
   }
}


Float64 CBridgeAgentImp::GetVertStirrupBarNominalDiameter(const pgsPointOfInterest& poi) const
{
   const CShearData2* pShearData = GetShearData(poi.GetSegmentKey());
   
   const CShearZoneData2* pShearZoneData = GetPrimaryShearZoneDataAtPoi(poi, pShearData);
   if (pShearZoneData == nullptr)
   {
      return 0.0;
   }
   
   WBFL::Materials::Rebar::Size barSize = pShearZoneData->VertBarSize;
   if ( barSize!=WBFL::Materials::Rebar::Size::bsNone && !IsZero(pShearZoneData->BarSpacing) )
   {
      lrfdRebarPool* prp = lrfdRebarPool::GetInstance();
      const auto* pRebar = prp->GetRebar(pShearData->ShearBarType,pShearData->ShearBarGrade,barSize);

      return (pRebar ? pRebar->GetNominalDimension() : 0.0);
   }
   else
   {
      return 0.0;
   }
}

Float64 CBridgeAgentImp::GetAlpha(const pgsPointOfInterest& poi) const
{
   return WBFL::Units::ConvertToSysUnits(90.,WBFL::Units::Measure::Degree);
}

Float64 CBridgeAgentImp::GetVertStirrupAvs(const pgsPointOfInterest& poi, WBFL::Materials::Rebar::Size* pSize, Float64* pSingleBarArea, Float64* pCount, Float64* pSpacing) const
{
   Float64 avs(0.0);
   Float64 Abar(0.0);
   Float64 nBars(0.0);
   Float64 spacing(0.0);

   const CShearData2* pShearData;
   CClosureKey closureKey;
   if ( IsInClosureJoint(poi,&closureKey) )
   {
      GET_IFACE(IShear,pShear);
      pShearData = pShear->GetClosureJointShearData(closureKey);
   }
   else
   {
      pShearData = GetShearData(poi.GetSegmentKey());
   }

   const CShearZoneData2* pShearZoneData = GetPrimaryShearZoneDataAtPoi(poi, pShearData);
   if (pShearZoneData == nullptr)
   {
      *pSize = WBFL::Materials::Rebar::Size::bsNone;
      *pSingleBarArea = 0.0;
      *pCount = 0;
      *pSpacing = Float64_Max;
      return 0.0;
   }

   WBFL::Materials::Rebar::Size barSize = pShearZoneData->VertBarSize;
   if ( barSize != WBFL::Materials::Rebar::Size::bsNone && !IsZero(pShearZoneData->BarSpacing) )
   {
      lrfdRebarPool* prp = lrfdRebarPool::GetInstance();
      const auto* pBar = prp->GetRebar(pShearData->ShearBarType,pShearData->ShearBarGrade,barSize);

      Abar    = pBar->GetNominalArea();
      nBars   = pShearZoneData->nVertBars;
      spacing = pShearZoneData->BarSpacing;

      // area of stirrups per unit length for this zone
      // (assume stirrups are smeared out along zone)
      if (0.0 < spacing)
      {
         avs = nBars * Abar / spacing;
      }
   }

   *pSize          = barSize;
   *pSingleBarArea = Abar;
   *pCount         = nBars;
   *pSpacing       = spacing;

   return avs;
}

bool CBridgeAgentImp::DoStirrupsEngageDeck(const CSegmentKey& segmentKey) const
{
   // Just check if any stirrups engage deck
   const CShearData2* pShearData = GetShearData(segmentKey);

   CShearData2::ShearZoneConstIterator szIter(pShearData->ShearZones.begin());
   CShearData2::ShearZoneConstIterator szIterEnd(pShearData->ShearZones.end());
   for ( ; szIter != szIterEnd; szIter++ )
   {
      if (szIter->VertBarSize != WBFL::Materials::Rebar::Size::bsNone && 0 < szIter->nHorzInterfaceBars)
      {
         return true;
      }
   }

   CShearData2::HorizontalInterfaceZoneConstIterator hiIter(pShearData->HorizontalInterfaceZones.begin());
   CShearData2::HorizontalInterfaceZoneConstIterator hiIterEnd(pShearData->HorizontalInterfaceZones.end());
   for ( ; hiIter != hiIterEnd; hiIter++ )
   {
      if (hiIter->BarSize != WBFL::Materials::Rebar::Size::bsNone)
      {
         return true;
      }
   }

   return false;
}

bool CBridgeAgentImp::DoAllPrimaryStirrupsEngageDeck(const CSegmentKey& segmentKey) const
{
   // Check if all vertical stirrups engage deck
   const CShearData2* pShearData = GetShearData(segmentKey);

   if (pShearData->ShearZones.empty())
   {
      return false;
   }
   else
   {
      for (CShearData2::ShearZoneConstIterator its = pShearData->ShearZones.begin(); its != pShearData->ShearZones.end(); its++)
      {
         // Make sure there are vertical bars, and at least as many horiz int bars
         if (its->VertBarSize==WBFL::Materials::Rebar::Size::bsNone ||
             its->nVertBars <= 0                ||
             its->nHorzInterfaceBars < its->nVertBars)
         {
            return false;
         }
      }
   }

   return true;
}
Float64 CBridgeAgentImp::GetPrimaryHorizInterfaceBarSpacing(const pgsPointOfInterest& poi) const
{
   Float64 spacing = 0.0;

   const CShearData2* pShearData = GetShearData(poi.GetSegmentKey());

   // Horizontal legs in primary zones
   const CShearZoneData2* pShearZoneData = GetPrimaryShearZoneDataAtPoi(poi, pShearData);
   if (pShearZoneData != nullptr && pShearZoneData->VertBarSize != WBFL::Materials::Rebar::Size::bsNone && 0.0 < pShearZoneData->nHorzInterfaceBars)
   {
      spacing = pShearZoneData->BarSpacing;
   }

   return spacing;
}

Float64 CBridgeAgentImp::GetPrimaryHorizInterfaceBarCount(const pgsPointOfInterest& poi) const
{
   Float64 cnt = 0.0;

   const CShearData2* pShearData = GetShearData(poi.GetSegmentKey());

   // Horizontal legs in primary zones
   const CShearZoneData2* pShearZoneData = GetPrimaryShearZoneDataAtPoi(poi, pShearData);
   if (pShearZoneData != nullptr && pShearZoneData->VertBarSize != WBFL::Materials::Rebar::Size::bsNone)
   {
      cnt = pShearZoneData->nHorzInterfaceBars;
   }

   return cnt;
}

Float64 CBridgeAgentImp::GetAdditionalHorizInterfaceBarSpacing(const pgsPointOfInterest& poi) const
{
   Float64 spacing = 0.0;

   const CShearData2* pShearData = GetShearData(poi.GetSegmentKey());

   // Additional horizontal bars
   const CHorizontalInterfaceZoneData* pHIZoneData = GetHorizInterfaceShearZoneDataAtPoi( poi, pShearData );
   if ( pHIZoneData->BarSize != WBFL::Materials::Rebar::Size::bsNone )
   {
      spacing = pHIZoneData->BarSpacing;
   }

   return spacing;
}

Float64 CBridgeAgentImp::GetAdditionalHorizInterfaceBarCount(const pgsPointOfInterest& poi) const
{
   Float64 cnt = 0.0;

   const CShearData2* pShearData = GetShearData(poi.GetSegmentKey());

   // Additional horizontal bars
   const CHorizontalInterfaceZoneData* pHIZoneData = GetHorizInterfaceShearZoneDataAtPoi( poi,pShearData );
   if (pHIZoneData && pHIZoneData->BarSize != WBFL::Materials::Rebar::Size::bsNone )
   {
      cnt = pHIZoneData->nBars;
   }

   return cnt;
}

Float64 CBridgeAgentImp::GetPrimaryHorizInterfaceAvs(const pgsPointOfInterest& poi, WBFL::Materials::Rebar::Size* pSize, Float64* pSingleBarArea, Float64* pCount, Float64* pSpacing) const
{
   Float64 avs(0.0);
   Float64 Abar(0.0);
   Float64 nBars(0.0);
   Float64 spacing(0.0);

   const CShearData2* pShearData = GetShearData(poi.GetSegmentKey());
   
   // First get avs from primary bar zone
   const CShearZoneData2* pShearZoneData = GetPrimaryShearZoneDataAtPoi(poi,pShearData);
   if (pShearZoneData == nullptr)
   {
      *pSize = WBFL::Materials::Rebar::Size::bsNone;
      *pSingleBarArea = 0.0;
      *pCount = 0;
      *pSpacing = Float64_Max;
      return 0.0;
   }

   WBFL::Materials::Rebar::Size barSize = pShearZoneData->VertBarSize;

   if ( barSize != WBFL::Materials::Rebar::Size::bsNone && !IsZero(pShearZoneData->BarSpacing) && 0.0 < pShearZoneData->nHorzInterfaceBars )
   {
      lrfdRebarPool* prp = lrfdRebarPool::GetInstance();
      const auto* pbar = prp->GetRebar(pShearData->ShearBarType,pShearData->ShearBarGrade,barSize);

      Abar    = pbar->GetNominalArea();
      nBars   = pShearZoneData->nHorzInterfaceBars;
      spacing = pShearZoneData->BarSpacing;

      if (0.0 < spacing)
      {
         avs =   nBars * Abar / spacing;
      }
   }

   *pSize          = barSize;
   *pSingleBarArea = Abar;
   *pCount         = nBars;
   *pSpacing       = spacing;

   return avs;
}

Float64 CBridgeAgentImp::GetAdditionalHorizInterfaceAvs(const pgsPointOfInterest& poi, WBFL::Materials::Rebar::Size* pSize, Float64* pSingleBarArea, Float64* pCount, Float64* pSpacing) const
{
   Float64 avs(0.0);
   Float64 Abar(0.0);
   Float64 nBars(0.0);
   Float64 spacing(0.0);
   WBFL::Materials::Rebar::Size barSize;

   const CShearData2* pShearData = GetShearData(poi.GetSegmentKey());
   
   const CHorizontalInterfaceZoneData* pHIZoneData = GetHorizInterfaceShearZoneDataAtPoi( poi, pShearData );

   if (pHIZoneData)
   {
      barSize = pHIZoneData->BarSize;

      if (barSize != WBFL::Materials::Rebar::Size::bsNone && !IsZero(pHIZoneData->BarSpacing) && 0.0 < pHIZoneData->nBars)
      {
         lrfdRebarPool* prp = lrfdRebarPool::GetInstance();
         const auto* pbar = prp->GetRebar(pShearData->ShearBarType, pShearData->ShearBarGrade, barSize);

         Abar = pbar->GetNominalArea();
         nBars = pHIZoneData->nBars;
         spacing = pHIZoneData->BarSpacing;

         if (0.0 < spacing)
         {
            avs = nBars * Abar / spacing;
         }
      }
   }
   else
   {
      barSize = WBFL::Materials::Rebar::Size::bsNone;
      Abar = 0;
      nBars = 0;
      spacing = 0;
   }

   *pSize          = barSize;
   *pSingleBarArea = Abar;
   *pCount         = nBars;
   *pSpacing       = spacing;

   return avs;
}

Float64 CBridgeAgentImp::GetSplittingAv(const CSegmentKey& segmentKey,Float64 start,Float64 end) const
{
   ATLASSERT(end>start);

   Float64 Av = 0.0;

   const CShearData2* pShearData = GetShearData(segmentKey);

   // Get component from primary bars
   if (pShearData->bUsePrimaryForSplitting)
   {
      Av += GetPrimarySplittingAv( segmentKey, start, end, pShearData);
   }

   // Component from additional splitting bars
   if (pShearData->SplittingBarSize != WBFL::Materials::Rebar::Size::bsNone && pShearData->nSplittingBars)
   {
      Float64 spacing = pShearData->SplittingBarSpacing;
      Float64 length = 0.0;
      if (spacing <= 0.0)
      {
         ATLASSERT(false); // UI should block this
      }
      else
      {
         // determine how much additional bars is in our start/end region
         Float64 zone_length = pShearData->SplittingZoneLength;
         // left end first
         if (start < zone_length)
         {
            Float64 zend = Min(end, zone_length);
            length = zend-start;
         }
         else
         {
            // try right end
            Float64 segment_length = GetSegmentLength(segmentKey);
            if (segment_length <= end)
            {
               Float64 zstart = Max(segment_length-zone_length, start);
               length = end-zstart;
            }
         }

         if (0.0 < length)
         {
            // We have bars in region. multiply av/s * length
            lrfdRebarPool* prp = lrfdRebarPool::GetInstance();
            const auto* pbar = prp->GetRebar(pShearData->ShearBarType, pShearData->ShearBarGrade, pShearData->SplittingBarSize);

            Float64 Abar = pbar->GetNominalArea();
            Float64 avs  = pShearData->nSplittingBars * Abar / spacing;

            Av += avs * length;
         }
      }
   }

   return Av;
}

Float64 CBridgeAgentImp::GetPrimarySplittingAv(const CSegmentKey& segmentKey,Float64 start,Float64 end, const CShearData2* pShearData) const
{
   if (!pShearData->bUsePrimaryForSplitting)
   {
      ATLASSERT(false); // shouldn't be called for this case
      return 0.0;
   }

   // Get total amount of splitting steel between start and end
   Float64 Av = 0;

   ZoneIndexType nbrZones = GetPrimaryZoneCount(segmentKey);
   for ( ZoneIndexType zone = 0; zone < nbrZones; zone++ )
   {
      Float64 zoneStart, zoneEnd;
      GetPrimaryZoneBounds(segmentKey, zone, &zoneStart, &zoneEnd);

      Float64 length; // length of zone which falls within the range

      // zoneStart                zoneEnd
      //   |-----------------------|
      //       zone is here (1) zoneStart                zoneEnd
      //                           |-----------------------|
      //                                 or here (2)    zoneStart                zoneEnd
      //                                                   |-----------------------|
      //                                                           here (3)
      //                |=============================================|
      //             start                 Range                     end
      //      zoneStart                                                   zoneEnd
      //        |-------------------------------------------------------------|
      //                       (4) zone is larger than range 

      if ( start <= zoneStart && zoneEnd <= end )
      {
         // Case 2 - entire zone is in the range
         length = zoneEnd - zoneStart;
      }
      else if ( zoneStart < start && end < zoneEnd )
      {
         // Case 4
         length = end - start;
      }
      else if ( zoneStart < start && InRange(start,zoneEnd,end) )
      {
         // Case 1
         length = zoneEnd - start;
      }
      else if ( InRange(start,zoneStart,end) && end < zoneEnd )
      {
         // Case 3
         length = end - zoneStart;
      }
      else
      {
         continue; // This zone doesn't touch the range at all... go back to the start of the loop
      }

      // We are in a zone - determine Av/S and multiply by length
      ZoneIndexType idx = GetPrimaryZoneIndex(segmentKey, pShearData, zone);

      const CShearZoneData2& shearZoneData = pShearData->ShearZones[idx];

      WBFL::Materials::Rebar::Size barSize = shearZoneData.VertBarSize; // splitting is same as vert bars
      if ( barSize != WBFL::Materials::Rebar::Size::bsNone && !IsZero(shearZoneData.BarSpacing) )
      {
         lrfdRebarPool* prp = lrfdRebarPool::GetInstance();
         const auto* pbar = prp->GetRebar(pShearData->ShearBarType,pShearData->ShearBarGrade,barSize);

         Float64 Abar   = pbar->GetNominalArea();

         // area of stirrups per unit length for this zone
         // (assume stirrups are smeared out along zone)
         Float64 avs = shearZoneData.nVertBars * Abar / shearZoneData.BarSpacing;

         Av += avs * length;
      }
   }

   return Av;
}

void CBridgeAgentImp::GetStartConfinementBarInfo(const CSegmentKey& segmentKey, Float64 requiredZoneLength, WBFL::Materials::Rebar::Size* pSize, Float64* pProvidedZoneLength, Float64* pSpacing) const
{
   ZoneIndexType nbrZones = GetPrimaryZoneCount(segmentKey);
   if (nbrZones == 0)
   {
      *pSize = WBFL::Materials::Rebar::Size::bsNone;
      *pProvidedZoneLength = 0.0;
      *pSpacing = Float64_Max;
      return;
   }

   const CShearData2* pShearData = GetShearData(segmentKey);

   // First get data from primary zones - use min bar size and max spacing from zones in required region
   Float64 primSpc(-1), primZonL(-1);
   WBFL::Materials::Rebar::Size primSize(WBFL::Materials::Rebar::Size::bsNone);

   Float64 ezloc;

   // walk from left to right on girder
   for ( ZoneIndexType zone = 0; zone < nbrZones; zone++ )
   {
      Float64 zoneStart;
      GetPrimaryZoneBounds(segmentKey, zone, &zoneStart, &ezloc);

      ZoneIndexType idx = GetPrimaryZoneIndex(segmentKey, pShearData, zone);

      const CShearZoneData2& shearZoneData = pShearData->ShearZones[idx];

      if (shearZoneData.ConfinementBarSize != WBFL::Materials::Rebar::Size::bsNone)
      {
         primSize = Min(primSize, shearZoneData.ConfinementBarSize);
         primSpc  = Max(primSpc,  shearZoneData.BarSpacing);

         primZonL = ezloc;
      }

      if (IsGT(requiredZoneLength,ezloc))
      {
         break; // actual zone length exceeds required - we are done
      }
   }

   // Next get additional confinement bar info
   Float64 addlSpc, addlZonL;
   WBFL::Materials::Rebar::Size addlSize;
   GetAddConfinementBarInfo(segmentKey, &addlSize, &addlZonL, &addlSpc);

   // Use either primary bars or additional bars. Choose by which has addequate zone length, smallest spacing, largest bars
   ChooseConfinementBars(requiredZoneLength, primSpc, primZonL, primSize, addlSpc, addlZonL, addlSize,
                         pSize, pProvidedZoneLength, pSpacing);
}


void CBridgeAgentImp::GetEndConfinementBarInfo( const CSegmentKey& segmentKey, Float64 requiredZoneLength, WBFL::Materials::Rebar::Size* pSize, Float64* pProvidedZoneLength, Float64* pSpacing) const
{
   ZoneIndexType nbrZones = GetPrimaryZoneCount(segmentKey);
   if (nbrZones == 0)
   {
      *pSize = WBFL::Materials::Rebar::Size::bsNone;
      *pProvidedZoneLength = 0.0;
      *pSpacing = Float64_Max;
      return;
   }

   const CShearData2* pShearData = GetShearData(segmentKey);

   Float64 segment_length = GetSegmentLength(segmentKey);

   // First get data from primary zones - use min bar size and max spacing from zones in required region
   Float64 primSpc(-1), primZonL(-1);
   WBFL::Materials::Rebar::Size primSize(WBFL::Materials::Rebar::Size::bsNone);

   Float64 ezloc;
   // walk from right to left on girder
   for ( ZoneIndexType zone = nbrZones-1; zone>=0; zone-- )
   {
      Float64 zoneStart, zoneEnd;
      GetPrimaryZoneBounds(segmentKey, zone, &zoneStart, &zoneEnd);

      ezloc = segment_length - zoneStart;

      ZoneIndexType idx = GetPrimaryZoneIndex(segmentKey, pShearData, zone);

      const CShearZoneData2* pShearZoneData = &pShearData->ShearZones[idx];

      if (pShearZoneData->ConfinementBarSize != WBFL::Materials::Rebar::Size::bsNone)
      {
         primSize = Min(primSize, pShearZoneData->ConfinementBarSize);
         primSpc  = Max(primSpc, pShearZoneData->BarSpacing);

         primZonL = ezloc;
      }

      if (IsGT(requiredZoneLength,ezloc))
      {
         break; // actual zone length exceeds required - we are done
      }
   }

   // Next get additional confinement bar info
   Float64 addlSpc, addlZonL;
   WBFL::Materials::Rebar::Size addlSize;
   GetAddConfinementBarInfo(segmentKey, &addlSize, &addlZonL, &addlSpc);

   // Use either primary bars or additional bars. Choose by which has addequate zone length, smallest spacing, largest bars
   ChooseConfinementBars(requiredZoneLength, primSpc, primZonL, primSize, addlSpc, addlZonL, addlSize,
                         pSize, pProvidedZoneLength, pSpacing);
}

bool CBridgeAgentImp::AreStirrupZoneLengthsCombatible(const CGirderKey& girderKey) const
{
   SegmentIndexType nSegments = GetSegmentCount(girderKey);
   for ( SegmentIndexType segIdx = 0; segIdx < nSegments; segIdx++ )
   {
      CSegmentKey segmentKey(girderKey,segIdx);
      const CShearData2* pShearData = GetShearData(segmentKey);

      ZoneIndexType squishyZoneIdx = INVALID_INDEX;
      if ( pShearData->bAreZonesSymmetrical )
      {
         // if zones are symmetrical, the last zone input is the "squishy" zone
         squishyZoneIdx = pShearData->ShearZones.size()-1;
      }


      ZoneIndexType nZones = GetPrimaryZoneCount(segmentKey);
      for (ZoneIndexType zoneIdx = 0; zoneIdx < nZones; zoneIdx++ )
      {
         Float64 zoneStart, zoneEnd;
         GetPrimaryZoneBounds(segmentKey, zoneIdx, &zoneStart, &zoneEnd);
         Float64 zoneLength = zoneEnd-zoneStart;

         WBFL::Materials::Rebar::Size barSize;
         Float64 spacing;
         Float64 nStirrups;
         GetPrimaryVertStirrupBarInfo(segmentKey,zoneIdx,&barSize,&nStirrups,&spacing);

         if (barSize != WBFL::Materials::Rebar::Size::bsNone && IsGT(0.0,spacing))
         {
            // If spacings fit within 1%, then pass. Otherwise fail
            Float64 nFSpaces = zoneLength / spacing;
            Int32 nSpaces = (Int32)nFSpaces;
            Float64 remainder = nFSpaces - nSpaces;

            if ( zoneIdx != squishyZoneIdx && 
                 !IsZero(remainder, 0.01) && 
                 !IsEqual(remainder, 1.0, 0.01) )
            {
               return false;
            }
         }
      }
   } // next segment

   return true;
}

// private:

void CBridgeAgentImp::InvalidateStirrupData()
{
   m_ShearData.clear();
}

const CShearData2* CBridgeAgentImp::GetShearData(const CSegmentKey& segmentKey) const
{
   ShearDataIterator found;
   found = m_ShearData.find( segmentKey );
   if ( found == m_ShearData.end() )
   {
	   GET_IFACE2(m_pBroker,IShear,pShear);
	   const CShearData2* pShearData = pShear->GetSegmentShearData(segmentKey);
      std::pair<ShearDataIterator,bool> insit = m_ShearData.insert( std::make_pair(segmentKey, *pShearData ) );
      ATLASSERT( insit.second );
      return &(*insit.first).second;
   }
   else
   {
      ATLASSERT( found != m_ShearData.end() );
      return &(*found).second;
   }
}

ZoneIndexType CBridgeAgentImp::GetPrimaryZoneIndex(const CSegmentKey& segmentKey, const CShearData2* pShearData, ZoneIndexType zone) const
{
   // mapping so that we only need to store half of the zones
   ZoneIndexType nZones = GetPrimaryZoneCount(segmentKey); 
   ATLASSERT(zone < nZones);
   if (pShearData->bAreZonesSymmetrical)
   {
      ZoneIndexType nz2 = (nZones+1)/2;
      if (zone < nz2)
      {
         return zone;
      }
      else
      {
         return nZones-zone-1;
      }
   }
   else
   {
      // mapping is 1:1 for non-sym
      return zone;
   }
}

ZoneIndexType CBridgeAgentImp::GetHorizInterfaceZoneIndex(const CSegmentKey& segmentKey, const CShearData2* pShearData, ZoneIndexType zone) const
{
   // mapping so that we only need to store half of the zones
   ZoneIndexType nZones = GetHorizInterfaceZoneCount(segmentKey, pShearData); 
   ATLASSERT(zone < nZones);
   if (pShearData->bAreZonesSymmetrical)
   {
      ZoneIndexType nz2 = (nZones+1)/2;
      if (zone < nz2)
      {
         return zone;
      }
      else
      {
         return nZones-zone-1;
      }
   }
   else
   {
      // mapping is 1:1 for non-sym
      return zone;
   }
}

ZoneIndexType CBridgeAgentImp::GetPrimaryShearZoneIndexAtPoi(const pgsPointOfInterest& poi, const CShearData2* pShearData) const
{
   // NOTE: The logic here is identical to GetHorizInterfaceShearZoneIndexAtPoi
   //       If you fix a bug here, you need to fix it there also

   const CSegmentKey& segmentKey = poi.GetSegmentKey();

   ZoneIndexType nz = GetPrimaryZoneCount(segmentKey);
   if (nz == 0)
   {
      return INVALID_INDEX;
   }

   Float64 location, length, left_bearing_location, right_bearing_location;
   CClosureKey closureKey;
   if ( IsInClosureJoint(poi,&closureKey) )
   {
      length = GetClosureJointLength(closureKey);
      if ( poi.GetDistFromStart() < 0 )
      {
         // poi is beyond the CL of the closure so it is measured in segment coordinates for the
         // segment that comes after the closure. location is the distance from the start
         // face of the closure

         // CL Closure -+
         //             |   Xpoi < 0
         //             |  |<--->|
         // ----+       |  |     +-----------
         //     |       |  *poi  |
         // ----+       |  |     +-----------
         //     | location |     |
         //     |<-------->|     |
         //     |    length      |
         //     |<-------------->|

         location = length + poi.GetDistFromStart();
      }
      else
      {
         // poi is before the CL Closure
         location = poi.GetDistFromStart() - GetSegmentLength(closureKey);
      }
      left_bearing_location  = 0;
      right_bearing_location = 0;
   }
   else if ( poi.HasAttribute(POI_BOUNDARY_PIER) || poi.GetDistFromStart() < 0 )
   {
      length = 0;
      location = 0;
      left_bearing_location = 0;
      right_bearing_location = 0;
   }
   else
   {
      length = GetSegmentLength(segmentKey);
      location = poi.GetDistFromStart();
      left_bearing_location  = GetSegmentStartBearingOffset(segmentKey);
      right_bearing_location = length - GetSegmentEndBearingOffset(segmentKey);
   }

   // use template function to do heavy work
   ZoneIndexType zone =  GetZoneIndexAtLocation(location, length, left_bearing_location, right_bearing_location, pShearData->bAreZonesSymmetrical, 
                                                pShearData->ShearZones.begin(), pShearData->ShearZones.end(), 
                                                pShearData->ShearZones.size());

   return zone;
}

const CShearZoneData2* CBridgeAgentImp::GetPrimaryShearZoneDataAtPoi(const pgsPointOfInterest& poi, const CShearData2* pShearData) const
{
   ZoneIndexType idx = GetPrimaryShearZoneIndexAtPoi(poi,pShearData);
   if (idx == INVALID_INDEX)
   {
      return nullptr;
   }
   else
   {
      return &pShearData->ShearZones[idx];
   }
}

ZoneIndexType CBridgeAgentImp::GetHorizInterfaceShearZoneIndexAtPoi(const pgsPointOfInterest& poi, const CShearData2* pShearData) const
{
   // NOTE: The logic here is identical to GetPrimaryShearZoneAtPoi
   //       If you fix a bug here, you need to fix it there also

   const CSegmentKey& segmentKey = poi.GetSegmentKey();

   ZoneIndexType nz = GetHorizInterfaceZoneCount(segmentKey,pShearData);
   if (nz == 0)
   {
      return INVALID_INDEX;
   }

   Float64 location, length, left_bearing_location, right_bearing_location;
   CClosureKey closureKey;
   if ( IsInClosureJoint(poi,&closureKey) )
   {
      length = GetClosureJointLength(closureKey);
      location = poi.GetDistFromStart() - GetSegmentLength(closureKey);
      left_bearing_location  = 0;
      right_bearing_location = 0;
   }
   else if ( poi.HasAttribute(POI_BOUNDARY_PIER) || poi.GetDistFromStart() < 0 )
   {
      length = 0;
      location = 0;
      left_bearing_location = 0;
      right_bearing_location = 0;
   }
   else
   {
      length = GetSegmentLength(segmentKey);
      location = poi.GetDistFromStart();
      left_bearing_location  = GetSegmentStartBearingOffset(segmentKey);
      right_bearing_location = length - GetSegmentEndBearingOffset(segmentKey);
   }

   // use template function to do heavy work
   ZoneIndexType zone =  GetZoneIndexAtLocation(location, length, left_bearing_location, right_bearing_location, pShearData->bAreZonesSymmetrical, 
                                                pShearData->HorizontalInterfaceZones.begin(), pShearData->HorizontalInterfaceZones.end(), 
                                                pShearData->HorizontalInterfaceZones.size());


   return zone;
}

const CHorizontalInterfaceZoneData* CBridgeAgentImp::GetHorizInterfaceShearZoneDataAtPoi(const pgsPointOfInterest& poi, const CShearData2* pShearData) const
{
   ZoneIndexType idx = GetHorizInterfaceShearZoneIndexAtPoi(poi,pShearData);
   if ( idx == INVALID_INDEX )
   {
      return nullptr;
   }
   return &pShearData->HorizontalInterfaceZones[idx];
}

/////////////////////////////////////////////////////////////////////////
// IStrandGeometry
//
WBFL::Geometry::Point2d CBridgeAgentImp::GetStrandCG(IntervalIndexType intervalIdx, const pgsPointOfInterest& poi, bool bIncTemp, const GDRCONFIG* pConfig) const
{
   // computes the geometric centroid multiple strand groups (permanent or all strands)
   std::array<Float64, 3> strand_area
   {
      GetStrandArea(poi,intervalIdx,pgsTypes::Straight,pConfig),
      GetStrandArea(poi,intervalIdx,pgsTypes::Harped,pConfig),
      bIncTemp ? GetStrandArea(poi,intervalIdx,pgsTypes::Temporary,pConfig) : 0.0
   };

   std::array<WBFL::Geometry::Point2d, 3> strand_cg
   {
      GetStrandCG(intervalIdx, poi, pgsTypes::Straight, pConfig),
      GetStrandCG(intervalIdx, poi, pgsTypes::Harped, pConfig),
      bIncTemp ? GetStrandCG(intervalIdx, poi, pgsTypes::Temporary, pConfig) : WBFL::Geometry::Point2d(0,0)
   };

   // cg = Sum(strand_cg * strand_area)/Sum(strand_area);
   Float64 A = std::accumulate(strand_area.begin(), strand_area.end(), 0.0);
   WBFL::Geometry::Point2d cg = IsZero(A) ? WBFL::Geometry::Point2d(0,0) : std::inner_product(strand_cg.begin(), strand_cg.end(), strand_area.begin(), WBFL::Geometry::Point2d(0, 0)) / A;
   return cg;
}

WBFL::Geometry::Point2d CBridgeAgentImp::GetStrandCG(IntervalIndexType intervalIdx, const pgsPointOfInterest& poi, pgsTypes::StrandType strandType, const GDRCONFIG* pConfig) const
{
   // this method computes the CG for a particular strand type... for a combined type like permanent, call the other version of this method excluding temporary strands
   if(strandType == pgsTypes::Permanent)
      return GetStrandCG(intervalIdx,poi,false/*no temporary strands*/, pConfig);

   VALIDATE(GIRDER);

   WBFL::Geometry::Point2d cg;

   // If the strands are off the segment, not yet installed, or been removed (in the case of temporary strands), they aren't
   // available so we'll use (0,0) as a default CG.
   if (!AreStrandsEngaged(intervalIdx, poi, strandType,pConfig))
   {
      return cg;
   }

   CComPtr<IPrecastGirder> girder;
   GetGirder(poi, &girder);

   Float64 Xpoi = poi.GetDistFromStart();
   const CSegmentKey& segmentKey = poi.GetSegmentKey();

   CComPtr<IStrandModel> strandModel;
   girder->get_StrandModel(&strandModel);

   CComPtr<IPoint2dCollection> points;
   if (pConfig)
   {
      CComQIPtr<IStrandGridModel> strandGridModel(strandModel);
      ATLASSERT(strandGridModel); // if pConfig is supplied we are designing.... design only supports a strand grid model

      // get the strand grid locations that are filled with strands
      CIndexArrayWrapper strand_fill(pConfig->PrestressConfig.GetStrandFill(strandType));

      if (strandType == pgsTypes::Harped)
      {
         // Use CStrandMoverSwapper to swap out girder's strand mover and harping offset limits temporarily and configure the strand mover with
         // the parameters in pConfig. CStrandMoverSwapper is an automatic object that does a rollback all of the changes when it goes out of scope.
         IntervalIndexType releaseIntervalIdx = GetPrestressReleaseInterval(segmentKey);
         Float64 Hg = GetHg(releaseIntervalIdx, poi);

         GET_IFACE(IBridgeDescription, pIBridgeDesc);
         CStrandMoverSwapper swapper(segmentKey, Hg, pConfig->PrestressConfig, this, strandGridModel, pIBridgeDesc);

         // for the provided strand grid fill, get the coordinates of the strands
         strandGridModel->GetStrandPositionsEx((StrandType)strandType, Xpoi, &strand_fill, &points);
      }
      else
      {
         // for the provided strand grid fill, get the coordinates of the strands
         strandGridModel->GetStrandPositionsEx((StrandType)strandType, Xpoi, &strand_fill, &points);
      }
   }
   else
   {
      // get the coordinates of the strands
      strandModel->GetStrandPositions((StrandType)strandType, Xpoi, &points);
   }

   StrandIndexType nStrands;
   points->get_Count(&nStrands);

   if (0 < nStrands)
   {
      Float64 cg_x = 0.0;
      Float64 cg_y = 0.0;
      StrandIndexType nDebonded = 0;
      for (StrandIndexType strandIdx = 0; strandIdx < nStrands; strandIdx++)
      {
         if (IsStrandDebonded(poi, strandIdx, strandType, pConfig))
         {
            // if a strand id debonded at this location, it doesn't contribute to the CG.
            nDebonded++; // keep track of number of debonded strands that are encountered
         }
         else
         {
            CComPtr<IPoint2d> point;
            points->get_Item(strandIdx, &point);
            Float64 x, y;
            point->Location(&x, &y);

            cg_x += x;
            cg_y += y;
         }
      }

      nStrands -= nDebonded;
      ATLASSERT(0 <= nStrands);
      cg.X() = (nStrands == 0) ? 0 : cg_x / nStrands;
      cg.Y() = (nStrands == 0) ? 0 : cg_y / nStrands;
   }

   GET_IFACE(ISegmentData, pSegmentData);
   const CStrandData* pStrands = pSegmentData->GetStrandData(segmentKey);
   if (!HasAsymmetricGirders() && IsGridBasedStrandModel(pStrands->GetStrandDefinitionType()))
   {
      // direct stand input can be asymmetric - can't call HasAsymmetricPrestressing because that causes recursion with this metho
      // don't have asymmetric effects, cg is on CL at X = 0
      ATLASSERT(IsZero(cg.X()));
      cg.X() = 0;
   }

   return cg;
}

WBFL::Geometry::Point2d CBridgeAgentImp::GetEccentricity(IntervalIndexType intervalIdx, const pgsPointOfInterest& poi, bool bIncTemp, const GDRCONFIG* pConfig) const
{
   pgsTypes::SectionPropertyType spType = (GetSectionPropertiesMode() == pgsTypes::spmGross ? pgsTypes::sptGross : pgsTypes::sptTransformed);
   return GetEccentricity(spType, intervalIdx, poi, bIncTemp, pConfig);
}

WBFL::Geometry::Point2d CBridgeAgentImp::GetEccentricity(IntervalIndexType intervalIdx, const pgsPointOfInterest& poi, pgsTypes::StrandType strandType, const GDRCONFIG* pConfig) const
{
   pgsTypes::SectionPropertyType spType = (GetSectionPropertiesMode() == pgsTypes::spmGross ? pgsTypes::sptGross : pgsTypes::sptTransformed);
   return GetEccentricity(spType, intervalIdx, poi, strandType, pConfig);
}

WBFL::Geometry::Point2d CBridgeAgentImp::GetEccentricity(pgsTypes::SectionPropertyType spType, IntervalIndexType intervalIdx, const pgsPointOfInterest& poi, bool bIncTemp, const GDRCONFIG* pConfig) const
{
   // computes the geometric eccentricity multiple strand groups (permanent or all strands)
   std::array<WBFL::Geometry::Point2d, 3> ecc
   {
      GetEccentricity(spType, intervalIdx, poi, pgsTypes::Straight, pConfig),
      GetEccentricity(spType, intervalIdx, poi, pgsTypes::Harped,   pConfig),
      bIncTemp ? GetEccentricity(spType, intervalIdx, poi, pgsTypes::Temporary, pConfig) : WBFL::Geometry::Point2d(0,0)
   };

   std::array<Float64, 3> Aps
   {
      GetStrandArea(poi,intervalIdx,pgsTypes::Straight,pConfig),
      GetStrandArea(poi,intervalIdx,pgsTypes::Harped,pConfig),
      bIncTemp ? GetStrandArea(poi,intervalIdx,pgsTypes::Temporary,pConfig) : 0.0
   };

   Float64 A = std::accumulate(Aps.begin(), Aps.end(), 0.0);
   WBFL::Geometry::Point2d e = IsZero(A) ? WBFL::Geometry::Point2d(0, 0) : std::inner_product(ecc.begin(), ecc.end(), Aps.begin(), WBFL::Geometry::Point2d(0,0)) / A;
   return e;
}

WBFL::Geometry::Point2d CBridgeAgentImp::GetEccentricity(pgsTypes::SectionPropertyType spType, IntervalIndexType intervalIdx, const pgsPointOfInterest& poi, pgsTypes::StrandType strandType, const GDRCONFIG* pConfig) const
{
   // this method computes the eccentricity for a particular strand type... for a combined type like permanent, call the other version of this method excluding temporary strands
   if (strandType == pgsTypes::Permanent)
      return GetEccentricity(spType, intervalIdx, poi, false/*exclude temporary strands*/, pConfig);

   WBFL::Geometry::Point2d ecc(0, 0);
   if (!AreStrandsEngaged(intervalIdx,poi,strandType,pConfig))
   {
      // not strands, no eccentricity
      return ecc;
   }

   auto cg = GetStrandCG(intervalIdx, poi, strandType, pConfig);

   const SectProp& props = GetSectionProperties(intervalIdx, poi, spType);
   Float64 Yt;
   props.ShapeProps->get_Ytop(&Yt);

   // (0,0) is at top center of section
   if (HasAsymmetricGirders())
   {
      Float64 Xl, Xr;
      props.ShapeProps->get_Xleft(&Xl);
      props.ShapeProps->get_Xright(&Xr);
      ecc.X() = -((Xl + Xr) / 2 - Xl + cg.X()); // greater than 0 means cg of strands is to the left of the cg of the section
   }
   ecc.Y() = -(Yt + cg.Y()); // greater than 0 means cg of strands is below the cg of the section

   return ecc;
}

void CBridgeAgentImp::GetStrandProfile(const CSegmentKey& segmentKey,pgsTypes::StrandType strandType, StrandIndexType strandIdx, IPoint2dCollection** ppProfilePoints) const
{
   ATLASSERT(strandType != pgsTypes::Permanent);
   VALIDATE(GIRDER);
   CComPtr<IPrecastGirder> girder;
   GetGirder(segmentKey, &girder);

   CComPtr<IStrandModel> strandModel;
   girder->get_StrandModel(&strandModel);

   strandModel->GetStrandProfile((StrandType)strandType, strandIdx, ppProfilePoints);
}

void CBridgeAgentImp::GetStrandProfile(const CPrecastSegmentData* pSegment, const CStrandData* pStrands, pgsTypes::StrandType strandType, StrandIndexType strandIdx, IPoint2dCollection** ppProfilePoints) const
{
   // This method gives a strand profile for "what-if" cases
   ATLASSERT(strandType != pgsTypes::Permanent);
   ATLASSERT(!IsGridBasedStrandModel(pStrands->GetStrandDefinitionType()));

   CComPtr<IPoint2dCollection> profile;
   profile.CoCreateInstance(CLSID_Point2dCollection);
   const CSegmentKey& segmentKey(pSegment->GetSegmentKey());

   if (pStrands == nullptr)
   {
      // if trial strand data isn't provided, use the strand data assigned to the segment
      pStrands = &(pSegment->Strands);
   }

   Float64 Lg = GetSegmentLength(segmentKey);

   const CStrandRow* pStrandRow;
   pStrands->GetStrandRow(strandType, strandIdx, &pStrandRow);

   std::array<Float64, 4> Xhp, Y;
   ResolveStrandRowElevations(pSegment, pStrands, *pStrandRow, Xhp, Y); // gets Y in Girder Section Coordinates (measured from top of girder)

   if (strandType == pgsTypes::Straight || strandType == pgsTypes::Temporary)
   {
      bool bChordProfile = IsZero(pSegment->Precamber) ? true : false; // if true, strands are a straight line between 2 points
      if (strandType == pgsTypes::Temporary && pStrands->GetTemporaryStrandUsage() == pgsTypes::ttsPretensioned)
      {
         bChordProfile = true;
      }

      if (bChordProfile)
      {
         // the strand profile is a straight line between 2 points
         CComPtr<IPoint2d> pnt;
         pnt.CoCreateInstance(CLSID_Point2d);
         Float64 x = ConvertSegmentCoordinateToSegmentPathCoordinate(segmentKey, 0.0);
         x = ConvertSegmentPathCoordinateToGirderPathCoordinate(segmentKey, x); // segment profiles are in girder path coordinates, so give strand profiles in the same system
         pnt->Move(x, Y[ZoneBreakType::Start]);
         profile->Add(pnt);

         pnt.Release();
         pnt.CoCreateInstance(CLSID_Point2d);
         x = ConvertSegmentCoordinateToSegmentPathCoordinate(segmentKey, Lg);
         x = ConvertSegmentPathCoordinateToGirderPathCoordinate(segmentKey, x);
         pnt->Move(x, Y[ZoneBreakType::End]);
         profile->Add(pnt);
      }
      else
      {
         // the strand profile follows the curvature of the girder

         // Y is relative to the top of the girder based on Girder Section Coordinates
         // Girder Section Coordinates is a cross section coordinate system. For a profile
         // the elevation of this coordinate system can change at each location due to precamber.
         // Adjust Y for precamber

         CComPtr<IPoint2d> pnt;
         for (int i = 0; i < 11; i++)
         {
            Float64 x = i*Lg / 10.0;
            Float64 y = ::LinInterp(x, Y[ZoneBreakType::Start], Y[ZoneBreakType::End], Lg);
            Float64 precamber = GetPrecamber(pSegment, x);
            y += precamber;

            x = ConvertSegmentCoordinateToSegmentPathCoordinate(segmentKey, x);
            x = ConvertSegmentPathCoordinateToGirderPathCoordinate(segmentKey, x);

            pnt.Release();
            pnt.CoCreateInstance(CLSID_Point2d);
            pnt->Move(x, y);
            profile->Add(pnt);
         }
      }
   }
   else
   {
      ATLASSERT(strandType == pgsTypes::Harped);
      Float64 thickening = 0;
      if (pSegment->TopFlangeThickeningType == pgsTypes::tftEnds)
      {
         thickening = pSegment->TopFlangeThickening;
      }

      CComPtr<IPoint2d> pnt;
      pnt.CoCreateInstance(CLSID_Point2d);
      Float64 x = ConvertSegmentCoordinateToSegmentPathCoordinate(segmentKey, 0.0);
      x = ConvertSegmentPathCoordinateToGirderPathCoordinate(segmentKey, x); // segment profiles are in girder path coordinates, so give strand profiles in the same system

      Float64 y = Y[ZoneBreakType::Start];
      Float64 precamber = GetPrecamber(pSegment, 0.0);
      y += precamber;

      Float64 tft = GetTopFlangeThickening(pSegment, 0);
      y += tft - thickening;

      pnt->Move(x, y);
      profile->Add(pnt);

      for (int i = 0; i < 4; i++)
      {
         pnt.Release();
         pnt.CoCreateInstance(CLSID_Point2d);

         // put X into Girder Path Coordinates because the segment profile is in this system
         Float64 x = ConvertSegmentCoordinateToSegmentPathCoordinate(segmentKey, Xhp[i]);
         x = ConvertSegmentPathCoordinateToGirderPathCoordinate(segmentKey, x);

         // Y is relative to the top of the girder based on Girder Section Coordinates
         // Girder Section Coordinates is a cross section coordinate system. For a profile
         // the elevation of this coordinate system can change at each location due to precamber
         // and top flange thickening. Adjust Y for these items
         Float64 precamber = GetPrecamber(pSegment, Xhp[i]);
         Y[i] += precamber;

         Float64 tft = GetTopFlangeThickening(pSegment, Xhp[i]);
         Y[i] += tft - thickening;

         pnt->Move(x, Y[i]);
         profile->Add(pnt);
      }

      pnt.Release();
      pnt.CoCreateInstance(CLSID_Point2d);
      x = ConvertSegmentCoordinateToSegmentPathCoordinate(segmentKey, Lg);
      x = ConvertSegmentPathCoordinateToGirderPathCoordinate(segmentKey, x);

      y = Y[ZoneBreakType::End];
      precamber = GetPrecamber(pSegment, Lg);
      y += precamber;

      tft = GetTopFlangeThickening(pSegment, Lg);
      y += tft - thickening;

      pnt->Move(x, y);
      profile->Add(pnt);
   }
   profile.CopyTo(ppProfilePoints);
}

void CBridgeAgentImp::GetStrandCGProfile(const CSegmentKey& segmentKey, bool bIncTemp, IPoint2dCollection** ppProfilePoints) const
{
   VALIDATE(GIRDER);
   CComPtr<IPrecastGirder> girder;
   GetGirder(segmentKey, &girder);

   CComPtr<IStrandModel> strandModel;
   girder->get_StrandModel(&strandModel);

   strandModel->GetStrandCGProfile(bIncTemp ? VARIANT_TRUE : VARIANT_FALSE, ppProfilePoints);
}

bool CBridgeAgentImp::AreStrandsEngaged(IntervalIndexType intervalIdx, const pgsPointOfInterest& poi, pgsTypes::StrandType strandType, const GDRCONFIG* pConfig) const
{
   const CSegmentKey& segmentKey = poi.GetSegmentKey();
   if (GetStrandCount(segmentKey, strandType, pConfig) == 0)
      return false; // there aren't any strands

   IntervalIndexType releaseIntervalIdx = GetPrestressReleaseInterval(segmentKey);
   if (strandType == pgsTypes::Temporary)
   {
      IntervalIndexType tsIntallationIntervalIdx = GetTemporaryStrandInstallationInterval(segmentKey);
      IntervalIndexType tsRemovalIntervalIdx = GetTemporaryStrandRemovalInterval(segmentKey); // NOTE: Temporary strands are still present at the start of the removal interval (they are gone at the middle and end)
      if (intervalIdx < releaseIntervalIdx || // interval is before release so strands aren't in the segment yet
         (tsIntallationIntervalIdx == INVALID_INDEX || intervalIdx < tsIntallationIntervalIdx) || // if installation interval is INVALID_INDEX there aren't any temp strands or this interval is before the temp strands are installed
         (tsRemovalIntervalIdx == INVALID_INDEX || tsRemovalIntervalIdx < intervalIdx) || // if removal interval is INVALID_INDEX there aren't any temp strnads or this interval is after the temp strands are removed
         IsOffSegment(poi) // poi is not on the segment
         )
      {
         return false;
      }
   }
   else
   {
      // if the strands aren't released yet, or if the poi isn't in the girder, then there isn't an eccentricty with respect to the girder cross section
      if (intervalIdx < releaseIntervalIdx || IsOffSegment(poi))
      {
         return false;
      }
   }

   return true;
}

Float64 CBridgeAgentImp::GetMaxStrandSlope(const CSegmentKey& segmentKey) const
{
   PoiList vPoi;
   GetPointsOfInterest(segmentKey, POI_HARPINGPOINT, &vPoi);
   if (vPoi.size() == 0)
   {
      // No harping points
      ATLASSERT(GetStrandCount(segmentKey, pgsTypes::Harped) == 0);
      return 0;
   }

   Float64 maxSlope = 0; // magnitude of max slope
   for( const pgsPointOfInterest& poi : vPoi)
   {
      Float64 slope = GetMaxStrandSlope(poi);

      // compare magnitudes of slope
      if (fabs(maxSlope) < fabs(slope))
      {
         maxSlope = slope; // retain the sign
      }
   }

   return maxSlope;
}

Float64 CBridgeAgentImp::GetMaxStrandSlope(const pgsPointOfInterest& poi,const GDRCONFIG* pConfig) const
{
   if ( IsOffSegment(poi) )
   {
      return Float64_Max;
   }

   VALIDATE( GIRDER );

   const CSegmentKey& segmentKey = poi.GetSegmentKey();

   // If adjustable strands are straight, we need not go further
   if (pConfig)
   {
      if (pConfig->PrestressConfig.AdjustableStrandType == pgsTypes::asStraight)
      {
         return Float64_Max;
      }
   }
   else
   {
      GET_IFACE(IBridgeDescription, pIBridgeDesc);
      const CBridgeDescription2* pBridgeDesc = pIBridgeDesc->GetBridgeDescription();
      const CGirderGroupData* pGroup = pBridgeDesc->GetGirderGroup(segmentKey.groupIndex);
      const CSplicedGirderData* pGirder = pGroup->GetGirder(segmentKey.girderIndex);
      const CPrecastSegmentData* pSegment = pGirder->GetSegment(segmentKey.segmentIndex);
      pgsTypes::AdjustableStrandType adjType = pSegment->Strands.GetAdjustableStrandType();
      if (adjType == pgsTypes::asStraight)
      {
         return Float64_Max;
      }
   }

   CComPtr<IPrecastGirder> girder;
   GetGirder(poi,&girder);
   CComPtr<IStrandModel> strandModel;
   girder->get_StrandModel(&strandModel);

   Float64 slope;
   if (pConfig)
   {
      // use continuous interface to compute
      CComQIPtr<IStrandGridModel> strandGridModel(strandModel);

      StrandIndexType Nh = GetStrandCount(segmentKey, pgsTypes::Harped, pConfig);

      CComPtr<IIndexArray> fill;
      m_StrandFillers[segmentKey].ComputeHarpedStrandFill(strandGridModel, Nh, &fill);

      strandGridModel->ComputeMaxHarpedStrandSlopeEx(poi.GetDistFromStart(), fill, pConfig->PrestressConfig.EndOffset[pgsTypes::metStart], pConfig->PrestressConfig.HpOffset[pgsTypes::metStart], pConfig->PrestressConfig.HpOffset[pgsTypes::metEnd], pConfig->PrestressConfig.EndOffset[pgsTypes::metEnd], &slope);
   }
   else
   {
      strandModel->ComputeMaxHarpedStrandSlope(poi.GetDistFromStart(), &slope);
   }

   return slope;
}

Float64 CBridgeAgentImp::GetAvgStrandSlope(const pgsPointOfInterest& poi,const GDRCONFIG* pConfig) const
{
   if ( IsOffSegment(poi) )
   {
      return Float64_Max;
   }

   VALIDATE( GIRDER );

   const CSegmentKey& segmentKey = poi.GetSegmentKey();

   // If adjustable strands are straight, we need not go further
   if (pConfig)
   {
      if (pConfig->PrestressConfig.AdjustableStrandType == pgsTypes::asStraight)
      {
         return Float64_Max;
      }
   }
   else
   {
      GET_IFACE(IBridgeDescription, pIBridgeDesc);
      const CBridgeDescription2* pBridgeDesc = pIBridgeDesc->GetBridgeDescription();
      const CGirderGroupData* pGroup = pBridgeDesc->GetGirderGroup(segmentKey.groupIndex);
      const CSplicedGirderData* pGirder = pGroup->GetGirder(segmentKey.girderIndex);
      const CPrecastSegmentData* pSegment = pGirder->GetSegment(segmentKey.segmentIndex);
      pgsTypes::AdjustableStrandType adjType = pSegment->Strands.GetAdjustableStrandType();
      if (adjType == pgsTypes::asStraight)
      {
         return Float64_Max;
      }
   }

   CComPtr<IPrecastGirder> girder;
   GetGirder(poi,&girder);
   CComPtr<IStrandModel> strandModel;
   girder->get_StrandModel(&strandModel);

   Float64 slope;
   if (pConfig)
   {
      CComQIPtr<IStrandGridModel> strandGridModel(strandModel);

      StrandIndexType Nh = GetStrandCount(segmentKey, pgsTypes::Harped, pConfig);

      CComPtr<IIndexArray> fill;
      m_StrandFillers[segmentKey].ComputeHarpedStrandFill(strandGridModel, Nh, &fill);

      strandGridModel->ComputeAvgHarpedStrandSlopeEx(poi.GetDistFromStart(), fill, pConfig->PrestressConfig.EndOffset[pgsTypes::metStart], pConfig->PrestressConfig.HpOffset[pgsTypes::metStart], pConfig->PrestressConfig.HpOffset[pgsTypes::metEnd], pConfig->PrestressConfig.EndOffset[pgsTypes::metEnd], &slope);
   }
   else
   {
      strandModel->ComputeAvgHarpedStrandSlope(poi.GetDistFromStart(), &slope);
   }

   return slope;
}

Float64 CBridgeAgentImp::GetSuperstructureDepth(PierIndexType pierIdx) const
{
   // The overall superstructure depth is taken to be the depth of the deepest
   // girder in the cross section plus the slab offset

   GET_IFACE(IBridgeDescription,pIBridgeDesc);
   const CBridgeDescription2* pBridgeDesc = pIBridgeDesc->GetBridgeDescription();
   const CPierData2* pPier = pBridgeDesc->GetPier(pierIdx);
   Float64 Dmax = 0;
   if ( pPier->IsBoundaryPier() || (pPier->IsInteriorPier() && !::IsSegmentContinuousOverPier(pPier->GetSegmentConnectionType())))
   {
      ATLASSERT(pPier->HasSlabOffset());
      bool isHaunchDirectInput = pBridgeDesc->GetHaunchInputDepthType() != pgsTypes::hidACamber;

      // There are segments on each side of the pier (unless the pier is an abutment)
      const CGirderGroupData* pBackGroup  = pPier->GetGirderGroup(pgsTypes::Back);
      if ( pBackGroup )
      {
         GirderIndexType nGirders = pBackGroup->GetGirderCount();
         for ( GirderIndexType gdrIdx = 0; gdrIdx < nGirders; gdrIdx++ )
         {
            CGirderKey girderKey(pBackGroup->GetIndex(), gdrIdx);
            pgsPointOfInterest poi = GetPierPointOfInterest(girderKey, pierIdx); // this is the poi at the pier line, it isn't on the segment
            const CSegmentKey& segmentKey(poi.GetSegmentKey());

            // we need a poi on the segment to get the segment height
            //PoiList vPoi;
            //GetPointsOfInterest(segmentKey, POI_ERECTED_SEGMENT | POI_10L, &vPoi);
            //ATLASSERT(vPoi.size() == 1 && segmentKey == vPoi.front().get().GetSegmentKey());
            //const pgsPointOfInterest& poi(vPoi.front());
            // this method is getting called during POI validation so it causes recursion.. use a dummy POI
            Float64 Ls = GetSegmentLength(segmentKey);
            Float64 brgOffset = GetSegmentStartBearingOffset(segmentKey);
            Float64 endDist = GetSegmentStartEndDistance(segmentKey);
            pgsPointOfInterest segmentEndPoi(segmentKey, Ls - brgOffset + endDist);

            IntervalIndexType releaseIntervalIdx = GetPrestressReleaseInterval(segmentKey);
            Float64 Hg = GetHg(releaseIntervalIdx, segmentEndPoi);

            Float64 slabOffset;
            if (isHaunchDirectInput)
            {
               Float64 deckDepth = GetGrossSlabDepth(segmentEndPoi);
               Float64 haunchDepth = GetStructuralHaunchDepth(segmentEndPoi,pgsTypes::hspDetailedDescription); // Detailed description in this call will get direct input
               slabOffset = deckDepth + haunchDepth;
            }
            else
            {
            SegmentIndexType nSegments = pBackGroup->GetGirder(gdrIdx)->GetSegmentCount();
               slabOffset = pBackGroup->GetGirder(gdrIdx)->GetSegment(nSegments - 1)->GetSlabOffset(pgsTypes::metEnd);
            }

            Dmax = Max(Dmax,Hg+slabOffset);
         }
      }

      const CGirderGroupData* pAheadGroup = pPier->GetGirderGroup(pgsTypes::Ahead);
      if ( pAheadGroup )
      {
         GirderIndexType nGirders = pAheadGroup->GetGirderCount();
         for ( GirderIndexType gdrIdx = 0; gdrIdx < nGirders; gdrIdx++ )
         {
            CGirderKey girderKey(pAheadGroup->GetIndex(), gdrIdx);
            pgsPointOfInterest poi = GetPierPointOfInterest(girderKey, pierIdx); // this is the poi at the pier line, it isn't on the segment
            const CSegmentKey& segmentKey(poi.GetSegmentKey());

            // we need a poi on the segment to get the segment height
            //PoiList vPoi;
            //GetPointsOfInterest(segmentKey, POI_ERECTED_SEGMENT | POI_0L, &vPoi);
            //ATLASSERT(vPoi.size() == 1 && segmentKey == vPoi.front().get().GetSegmentKey());
            //const pgsPointOfInterest& poi(vPoi.front());
            // this method is getting called during POI validation so it causes recursion.. use a dummy POI

            Float64 brgOffset = GetSegmentStartBearingOffset(segmentKey);
            Float64 endDist = GetSegmentStartEndDistance(segmentKey);
            pgsPointOfInterest segmentEndPoi(segmentKey, brgOffset - endDist);

            IntervalIndexType releaseIntervalIdx = GetPrestressReleaseInterval(segmentKey);
            Float64 Hg = GetHg(releaseIntervalIdx, segmentEndPoi);

            Float64 slabOffset;
            if (isHaunchDirectInput)
            {
               Float64 deckDepth = GetGrossSlabDepth(segmentEndPoi);
               Float64 haunchDepth = GetStructuralHaunchDepth(segmentEndPoi,pgsTypes::hspDetailedDescription); // Detailed description in this call will get direct input
               slabOffset = deckDepth + haunchDepth;
            }
            else
            {
               slabOffset = pAheadGroup->GetGirder(gdrIdx)->GetSegment(0)->GetSlabOffset(pgsTypes::metStart);
            }

            Dmax = Max(Dmax,Hg+slabOffset);
         }
      }
   }
   else
   {
      // Segment is continuous over the pier so there isn't a slab offset
      // at the pier
      IntervalIndexType gceInterval = GetGeometryControlInterval();
      Float64 overlay_depth = GetOverlayDepth(gceInterval);

      ATLASSERT(!pPier->HasSlabOffset());
      GirderIndexType nGirders = GetGirderCountBySpan(pierIdx);
      for ( GirderIndexType gdrIdx = 0; gdrIdx < nGirders; gdrIdx++ )
      {
         CGirderKey girderKey(pPier->GetGirderGroup(pgsTypes::Back)->GetIndex(), gdrIdx);
         pgsPointOfInterest poi = GetPierPointOfInterest(girderKey, pierIdx);
         const CSegmentKey& segmentKey(poi.GetSegmentKey());

         IntervalIndexType releaseIntervalIdx = GetPrestressReleaseInterval(segmentKey);
         Float64 Hg = GetHg(releaseIntervalIdx, poi);

         Float64 profile_elev = GetProfileChordElevation(poi);
         Float64 chord_elev = GetTopGirderChordElevation(poi);

         Float64 haunch_depth = profile_elev - overlay_depth - chord_elev;

         Dmax = Max(Dmax,Hg+haunch_depth);
      }
   }
   return Dmax;
}

Float64 CBridgeAgentImp::GetApsBottomHalf(const pgsPointOfInterest& poi,DevelopmentAdjustmentType devAdjust, const GDRCONFIG* pConfig) const
{
   return GetApsInHalfDepth(poi, devAdjust, true, pConfig );
}

StrandIndexType CBridgeAgentImp::GetNumStrandsBottomHalf(const pgsPointOfInterest & poi, pgsTypes::StrandType strandType, const GDRCONFIG * pConfig) const
{
   VALIDATE( GIRDER );

   StrandIndexType nStrands = 0;
   if ( !IsOnSegment(poi) )
   {
      return nStrands;
   }
 
   IntervalIndexType releaseIntervalIdx = GetPrestressReleaseInterval(poi.GetSegmentKey());
   Float64 Hg = GetHg(releaseIntervalIdx,poi);

   Float64 half_depth_elevation = GetHalfElevation(poi); // y=0 at top of girder... measured in Girder Section Coordinates
   half_depth_elevation += Hg; // now measured up from bottom of girder

   const CSegmentKey& segmentKey = poi.GetSegmentKey();

   CComPtr<IPrecastGirder> girder;
   GetGirder(segmentKey,&girder);

   Float64 dist_from_start = poi.GetDistFromStart();

   CComPtr<IStrandModel> strandModel;
   girder->get_StrandModel(&strandModel);
   CComQIPtr<IStrandGridModel> strandGridModel(strandModel);

   // Straight strands 
   if (pgsTypes::Straight == strandType || pgsTypes::Permanent == strandType)
   {
      CComPtr<IPoint2dCollection> strand_points;
      if (pConfig)
      {
         CIndexArrayWrapper strand_fill(pConfig->PrestressConfig.GetStrandFill(pgsTypes::Straight));
         strandGridModel->GetStrandPositionsEx(Straight, dist_from_start, &strand_fill, &strand_points);
      }
      else
      {
         strandModel->GetStrandPositions(Straight, dist_from_start, &strand_points);
      }

      StrandIndexType Ns;
      strand_points->get_Count(&Ns);

      for (StrandIndexType strandIdx = 0; strandIdx < Ns; strandIdx++)
      {
         CComPtr<IPoint2d> strand_point;
         strand_points->get_Item(strandIdx, &strand_point);

         Float64 y;
         strand_point->get_Y(&y); // measured in Girder Section Coordinates
         y += Hg; // now measured up from bottom

         if (y <= half_depth_elevation)
         {
            nStrands++;
         }
      }
   }

   // harped strands
   if (pgsTypes::Harped == strandType || pgsTypes::Permanent == strandType)
   {
      CComPtr<IPoint2dCollection> strand_points;
      if (pConfig)
      {
         CIndexArrayWrapper strand_fill(pConfig->PrestressConfig.GetStrandFill(pgsTypes::Harped));
         // Use CStrandMoverSwapper to temporarily swap out girder's strand mover and harping offset limits
         //  for design
         IntervalIndexType releaseIntervalIdx = GetPrestressReleaseInterval(segmentKey);
         Float64 Hg = GetHg(releaseIntervalIdx, poi);

         GET_IFACE(IBridgeDescription, pIBridgeDesc);
         CStrandMoverSwapper swapper(segmentKey, Hg, pConfig->PrestressConfig, this, strandGridModel, pIBridgeDesc);
         strandGridModel->GetStrandPositionsEx(Harped, dist_from_start, &strand_fill, &strand_points);
      }
      else
      {
         strandModel->GetStrandPositions(Harped, dist_from_start, &strand_points);
      }

      StrandIndexType Nh;
      strand_points->get_Count(&Nh);
      for (StrandIndexType strandIdx = 0; strandIdx < Nh; strandIdx++)
      {
         CComPtr<IPoint2d> strand_point;
         strand_points->get_Item(strandIdx, &strand_point);

         Float64 y;
         strand_point->get_Y(&y); // measured in Girder Section Coordinates
         y += Hg; // now measured up from bottom

         if (y <= half_depth_elevation)
         {
            nStrands++;
         }
      }
   }

   return nStrands;
}

Float64 CBridgeAgentImp::GetApsTopHalf(const pgsPointOfInterest& poi,DevelopmentAdjustmentType devAdjust,const GDRCONFIG* pConfig) const
{
   return GetApsInHalfDepth(poi, devAdjust, false, pConfig );
}

ConfigStrandFillVector CBridgeAgentImp::ComputeStrandFill(const CSegmentKey& segmentKey,pgsTypes::StrandType type,StrandIndexType Ns) const
{
   VALIDATE( GIRDER );
   CComPtr<IPrecastGirder> girder;
   GetGirder(segmentKey,&girder);

   CComPtr<IStrandModel> strandModel;
   girder->get_StrandModel(&strandModel);
   CComQIPtr<IStrandGridModel> strandGridModel(strandModel);

   CContinuousStrandFiller* pFiller = GetContinuousStrandFiller(segmentKey);

   // Get fill in COM format
   CComPtr<IIndexArray> indexarr;
   switch( type )
   {
   case pgsTypes::Straight:
      pFiller->ComputeStraightStrandFill(strandGridModel, Ns, &indexarr);
      break;

   case pgsTypes::Harped:
      pFiller->ComputeHarpedStrandFill(strandGridModel, Ns, &indexarr);
      break;

   case pgsTypes::Temporary:
      pFiller->ComputeTemporaryStrandFill(strandGridModel, Ns, &indexarr);
      break;

   default:
      ATLASSERT(false); // should never get here
   }

   // Convert to ConfigStrandFillVector
   ConfigStrandFillVector Vec;
   IndexArray2ConfigStrandFillVec(indexarr, Vec);

   return Vec;
}

ConfigStrandFillVector CBridgeAgentImp::ComputeStrandFill(LPCTSTR strGirderName,pgsTypes::StrandType type,StrandIndexType Ns) const
{
   GET_IFACE(ILibrary,pLib);
   const GirderLibraryEntry* pGdrEntry = pLib->GetGirderEntry(strGirderName);

   CStrandFiller filler;
   filler.Init(pGdrEntry);

   // The position of the strands in the strand grid doesn't matter
   // for this method. Just use dummy values.
   Float64 Hg = 0;

   // Get fill in COM format
   CComPtr<IIndexArray> indexarr;
   switch( type )
   {
   case pgsTypes::Straight:
      {
         CComPtr<IStrandGrid> startGrid, endGrid;
         startGrid.CoCreateInstance(CLSID_StrandGrid);
         endGrid.CoCreateInstance(CLSID_StrandGrid);
         pGdrEntry->ConfigureStraightStrandGrid(Hg,Hg,startGrid,endGrid);

         CComQIPtr<IStrandGridFiller> gridFiller(startGrid);
         filler.ComputeStraightStrandFill(gridFiller, Ns, &indexarr);
      }
      break;

   case pgsTypes::Harped:
      {
         CComPtr<IStrandGrid> startGrid, startHPGrid, endHPGrid, endGrid;
         startGrid.CoCreateInstance(CLSID_StrandGrid);
         startHPGrid.CoCreateInstance(CLSID_StrandGrid);
         endHPGrid.CoCreateInstance(CLSID_StrandGrid);
         endGrid.CoCreateInstance(CLSID_StrandGrid);
         pGdrEntry->ConfigureHarpedStrandGrids(Hg,Hg,Hg,Hg,startGrid,startHPGrid,endHPGrid,endGrid);

         CComQIPtr<IStrandGridFiller> endGridFiller(startGrid), hpGridFiller(startHPGrid);
         filler.ComputeHarpedStrandFill(pGdrEntry->OddNumberOfHarpedStrands(),endGridFiller, hpGridFiller, Ns, &indexarr);
      }
      break;

   case pgsTypes::Temporary:
      {
         CComPtr<IStrandGrid> startGrid, endGrid;
         startGrid.CoCreateInstance(CLSID_StrandGrid);
         endGrid.CoCreateInstance(CLSID_StrandGrid);
         pGdrEntry->ConfigureTemporaryStrandGrid(Hg,Hg,startGrid,endGrid);

         CComQIPtr<IStrandGridFiller> gridFiller(startGrid);
         filler.ComputeTemporaryStrandFill(gridFiller, Ns, &indexarr);
      }
      break;

   default:
      ATLASSERT(false); // should never get here
   }

   // Convert IIndexArray to ConfigStrandFillVector
   ConfigStrandFillVector Vec;
   IndexArray2ConfigStrandFillVec(indexarr, Vec);

   return Vec;
}

GridIndexType CBridgeAgentImp::SequentialFillToGridFill(LPCTSTR strGirderName,pgsTypes::StrandType type,StrandIndexType StrandNo) const
{
   GET_IFACE(ILibrary,pLib);
   const GirderLibraryEntry* pGdrEntry = pLib->GetGirderEntry(strGirderName);

   // The position of the strands in the strand grid doesn't matter
   // for this method. Just use dummy values.
   Float64 Hg = 0;

   // Get fill in COM format
   StrandIndexType gridIdx(INVALID_INDEX);
   switch( type )
   {
   case pgsTypes::Straight:
      {
         CComPtr<IStrandGrid> startGrid, endGrid;
         startGrid.CoCreateInstance(CLSID_StrandGrid);
         endGrid.CoCreateInstance(CLSID_StrandGrid);
         pGdrEntry->ConfigureStraightStrandGrid(Hg,Hg,startGrid,endGrid);

         CComQIPtr<IStrandGridFiller> gridFiller(startGrid);

         CComPtr<IIndexArray> maxFill;
         gridFiller->GetMaxStrandFill(&maxFill); // sequential fill fills max from start

         gridFiller->StrandIndexToGridIndexEx(maxFill, StrandNo, &gridIdx);
      }
      break;

   case pgsTypes::Harped:
      {
         CComPtr<IStrandGrid> startGrid, startHPGrid, endHPGrid, endGrid;
         startGrid.CoCreateInstance(CLSID_StrandGrid);
         startHPGrid.CoCreateInstance(CLSID_StrandGrid);
         endHPGrid.CoCreateInstance(CLSID_StrandGrid);
         endGrid.CoCreateInstance(CLSID_StrandGrid);
         pGdrEntry->ConfigureHarpedStrandGrids(Hg,Hg,Hg,Hg,startGrid,startHPGrid,endHPGrid,endGrid);

         CComQIPtr<IStrandGridFiller> endGridFiller(startGrid);

         CComPtr<IIndexArray> maxFill;
         endGridFiller->GetMaxStrandFill(&maxFill); // sequential fill fills max from start

         endGridFiller->StrandIndexToGridIndexEx(maxFill, StrandNo, &gridIdx);
      }
      break;

   case pgsTypes::Temporary:
      {
         CComPtr<IStrandGrid> startGrid, endGrid;
         startGrid.CoCreateInstance(CLSID_StrandGrid);
         endGrid.CoCreateInstance(CLSID_StrandGrid);
         pGdrEntry->ConfigureTemporaryStrandGrid(Hg,Hg,startGrid,endGrid);

         CComQIPtr<IStrandGridFiller> gridFiller(startGrid);

         CComPtr<IIndexArray> maxFill;
         gridFiller->GetMaxStrandFill(&maxFill); // sequential fill fills max from start

         gridFiller->StrandIndexToGridIndexEx(maxFill, StrandNo, &gridIdx);
      }
      break;

   default:
      ATLASSERT(false); // should never get here
   }

   return gridIdx;
}

void CBridgeAgentImp::GridFillToSequentialFill(LPCTSTR strGirderName,pgsTypes::StrandType type,GridIndexType gridIdx, StrandIndexType* pStrandNo1, StrandIndexType* pStrandNo2) const
{
   GET_IFACE(ILibrary,pLib);
   const GirderLibraryEntry* pGdrEntry = pLib->GetGirderEntry(strGirderName);

   // The position of the strands in the strand grid doesn't matter
   // for this method. Just use dummy values.
   Float64 Hg = 0;

   // Get fill in COM format
   HRESULT hr;
   switch( type )
   {
   case pgsTypes::Straight:
      {
         CComPtr<IStrandGrid> startGrid, endGrid;
         startGrid.CoCreateInstance(CLSID_StrandGrid);
         endGrid.CoCreateInstance(CLSID_StrandGrid);
         pGdrEntry->ConfigureStraightStrandGrid(Hg,Hg,startGrid,endGrid);

         CComQIPtr<IStrandGridFiller> gridFiller(startGrid);
         hr = gridFiller->GridIndexToStrandIndex(gridIdx, pStrandNo1, pStrandNo2);
         ATLASSERT(SUCCEEDED(hr));
      }
      break;

   case pgsTypes::Harped:
      {
         CComPtr<IStrandGrid> startGrid, startHPGrid, endHPGrid, endGrid;
         startGrid.CoCreateInstance(CLSID_StrandGrid);
         startHPGrid.CoCreateInstance(CLSID_StrandGrid);
         endHPGrid.CoCreateInstance(CLSID_StrandGrid);
         endGrid.CoCreateInstance(CLSID_StrandGrid);
         pGdrEntry->ConfigureHarpedStrandGrids(Hg,Hg,Hg,Hg,startGrid,startHPGrid,endHPGrid,endGrid);

         CComQIPtr<IStrandGridFiller> endGridFiller(startGrid);
         hr = endGridFiller->GridIndexToStrandIndex(gridIdx, pStrandNo1, pStrandNo2);
         ATLASSERT(SUCCEEDED(hr));
      }
      break;

   case pgsTypes::Temporary:
      {
         CComPtr<IStrandGrid> startGrid, endGrid;
         startGrid.CoCreateInstance(CLSID_StrandGrid);
         endGrid.CoCreateInstance(CLSID_StrandGrid);
         pGdrEntry->ConfigureTemporaryStrandGrid(Hg,Hg,startGrid,endGrid);

         CComQIPtr<IStrandGridFiller> gridFiller(startGrid);
         hr = gridFiller->GridIndexToStrandIndex(gridIdx, pStrandNo1, pStrandNo2);
         ATLASSERT(SUCCEEDED(hr));
      }
      break;

   default:
      ATLASSERT(false); // should never get here
   }
}

void CBridgeAgentImp::GridPositionToStrandPosition(const CSegmentKey& segmentKey, pgsTypes::StrandType strandType, GridIndexType gridIdx, StrandIndexType* pStrandNo1, StrandIndexType* pStrandNo2) const
{
   ATLASSERT(strandType != pgsTypes::Permanent);

   CComPtr<IPrecastGirder> girder;
   GetGirder(segmentKey, &girder);

   CComPtr<IIndexArray> fill;
   ConfigStrandFillVector fillVec;

   CComPtr<IStrandModel> strandModel;
   girder->get_StrandModel(&strandModel);

   CComQIPtr<IStrandGridModel> strandGridModel(strandModel);
   ATLASSERT(strandGridModel);
   strandGridModel->get_StrandFill((StrandType)strandType,&fill);
   IndexArray2ConfigStrandFillVec(fill, fillVec);

   ConfigStrandFillTool fillTool(fillVec);
   fillTool.GridIndexToStrandPositionIndex(gridIdx, pStrandNo1, pStrandNo2);
}

StrandIndexType CBridgeAgentImp::GetStrandCount(const CSegmentKey& segmentKey,pgsTypes::StrandType strandType, const GDRCONFIG* pConfig) const
{
   VALIDATE(GIRDER);
   StrandIndexType nStrands(0);
   if (pConfig == nullptr)
   {
      CComPtr<IPrecastGirder> girder;
      GetGirder(segmentKey, &girder);

      CComPtr<IStrandModel> strandModel;
      girder->get_StrandModel(&strandModel);

      if (strandType == pgsTypes::Permanent)
      {
         StrandIndexType nh, ns;
         strandModel->GetStrandCount(Straight,&ns);
         strandModel->GetStrandCount(Harped,&nh);
         nStrands = ns + nh;
      }
      else
      {
         strandModel->GetStrandCount((StrandType)strandType, &nStrands);
      }
   }
   else
   {
      nStrands = pConfig->PrestressConfig.GetStrandCount(strandType);
   }

   return nStrands;
}

std::pair<StrandIndexType, StrandIndexType> CBridgeAgentImp::GetStrandCount(const pgsPointOfInterest& poi, IntervalIndexType intervalIdx, pgsTypes::StrandType strandType, const GDRCONFIG* pConfig) const
{
   ATLASSERT(strandType != pgsTypes::Permanent); // can't be permanent

   const CSegmentKey& segmentKey(poi.GetSegmentKey());
   if (intervalIdx < GetStressStrandInterval(segmentKey) // strands aren't stressed so they aren't even in play yet
      || 
      (strandType == pgsTypes::Temporary && GetTemporaryStrandRemovalInterval(segmentKey) < intervalIdx)) // strand are temporary and they have been removed
   {
      return std::make_pair(0, 0); 
   }

   auto strand_count(std::make_pair((StrandIndexType)0, (StrandIndexType)0));
   StrandIndexType nStrands = GetStrandCount(segmentKey, strandType, pConfig); // total strand count
   StrandIndexType nDebondTotal = GetNumDebondedStrands(segmentKey, strandType, pgsTypes::dbetEither, pConfig);


   // count the number of strands that are debonded at this location
   StrandIndexType nDebondedAtPoi = 0;
   if (HasDebonding(segmentKey, pConfig))
   {
      for (StrandIndexType strandIdx = 0; strandIdx < nStrands; strandIdx++)
      {
         if (IsStrandDebonded(poi, strandIdx, strandType, pConfig))
         {
            nDebondedAtPoi++;
         }
      }
   }

   ATLASSERT(nDebondTotal <= nStrands); // can't debond more than the total number of strands
   strand_count.first += (nStrands - nDebondedAtPoi); // number of strands at this section
   strand_count.second += nDebondTotal - nDebondedAtPoi; // number of debonded strands that are bonded at this section

   return strand_count;
}

StrandIndexType CBridgeAgentImp::GetMaxStrands(const CSegmentKey& segmentKey,pgsTypes::StrandType type) const
{
   VALIDATE(GIRDER);
   CComPtr<IPrecastGirder> girder;
   GetGirder(segmentKey,&girder);

   CComPtr<IStrandModel> strandModel;
   girder->get_StrandModel(&strandModel);
   CComQIPtr<IStrandGridModel> strandGridModel(strandModel);

   StrandIndexType nStrands = MAX_INDEX;
   if (strandGridModel)
   {
      StrandIndexType Ns, Nh;
      switch (type)
      {
      case pgsTypes::Permanent:
         strandGridModel->GetMaxStrands(Straight, &Ns);
         strandGridModel->GetMaxStrands(Harped, &Nh);
         nStrands = Ns + Nh;
         break;

      case pgsTypes::Straight:
         strandGridModel->GetMaxStrands(Straight, &nStrands);
         break;

      case pgsTypes::Harped:
         strandGridModel->GetMaxStrands(Harped, &nStrands);
         break;

      case pgsTypes::Temporary:
         strandGridModel->GetMaxStrands(Temporary, &nStrands);
         break;

      default:
         ATLASSERT(false); // should never get here
      }
   }

   return nStrands;
}

StrandIndexType CBridgeAgentImp::GetMaxStrands(LPCTSTR strGirderName,pgsTypes::StrandType type) const
{
   GET_IFACE(ILibrary,pLib);
   const GirderLibraryEntry* pGirderEntry = pLib->GetGirderEntry( strGirderName );

   ATLASSERT(pGirderEntry != nullptr);
   if ( pGirderEntry == nullptr )
   {
      return 0;
   }

   StrandIndexType Ns, Nh;
   StrandIndexType nStrands;
   switch( type )
   {
   case pgsTypes::Permanent:
      Ns = pGirderEntry->GetMaxStraightStrands();
      Nh = pGirderEntry->GetMaxHarpedStrands();
      nStrands = Ns + Nh;
      break;

   case pgsTypes::Straight:
      nStrands = pGirderEntry->GetMaxStraightStrands();
      break;

   case pgsTypes::Harped:
      nStrands = pGirderEntry->GetMaxHarpedStrands();
      break;

   case pgsTypes::Temporary:
      nStrands = pGirderEntry->GetMaxTemporaryStrands();
      break;

   default:
      ATLASSERT(false); // should never get here
   }

   return nStrands;
}

Float64 CBridgeAgentImp::GetStrandArea(const pgsPointOfInterest& poi,IntervalIndexType intervalIdx,pgsTypes::StrandType strandType,const GDRCONFIG* pConfig) const
{
   const CSegmentKey& segmentKey(poi.GetSegmentKey());
   if ( intervalIdx < GetStressStrandInterval(segmentKey) )
   {
      return 0; // strands aren't stressed so they aren't even in play yet
   }

   std::vector<pgsTypes::StrandType> vStrandTypes;
   if (strandType == pgsTypes::Permanent)
   {
      vStrandTypes.push_back(pgsTypes::Straight);
      vStrandTypes.push_back(pgsTypes::Harped);
   }
   else
   {
      vStrandTypes.push_back(strandType);
   }

   Float64 Aps = 0;
   for (auto type : vStrandTypes)
   {
      auto strand_count = GetStrandCount(poi, intervalIdx, type, pConfig);

      const auto* pStrand = GetStrandMaterial(segmentKey, type);
      Float64 aps = pStrand->GetNominalArea();
      Aps += aps*strand_count.first;
   }
   return Aps;
}

Float64 CBridgeAgentImp::GetPjack(const CSegmentKey& segmentKey,pgsTypes::StrandType strandType, const GDRCONFIG* pConfig) const
{
   Float64 Pj = 0;
   if (GetStrandCount(segmentKey, strandType, pConfig) == 0)
   {
      return 0;
   }

   if (pConfig)
   {
      if ( strandType == pgsTypes::Permanent )
      {
         Pj = pConfig->PrestressConfig.Pjack[pgsTypes::Straight] + pConfig->PrestressConfig.Pjack[pgsTypes::Harped];
      }
      else
      {
         Pj = pConfig->PrestressConfig.Pjack[strandType];
      }
   }
   else
   {
      GET_IFACE(IBridgeDescription, pBridgeDesc);
      const CPrecastSegmentData* pSegment = pBridgeDesc->GetPrecastSegmentData(segmentKey);
      if (strandType == pgsTypes::Permanent)
      {
         if (pSegment->Strands.GetStrandDefinitionType() == pgsTypes::sdtTotal)
         {
            Pj = pSegment->Strands.GetPjack(pgsTypes::Permanent);
         }
         else
         {
            Pj = pSegment->Strands.GetPjack(pgsTypes::Straight) + pSegment->Strands.GetPjack(pgsTypes::Harped);
         }
      }
      else
      {
         Pj = pSegment->Strands.GetPjack(strandType);
      }
   }
   return Pj;
}

Float64 CBridgeAgentImp::GetPjack(const CSegmentKey& segmentKey,bool bIncTemp) const
{
   Float64 Pj = GetPjack(segmentKey,pgsTypes::Permanent);
   if ( bIncTemp )
   {
      Pj += GetPjack(segmentKey,pgsTypes::Temporary);
   }

   return Pj;
}

Float64 CBridgeAgentImp::GetJackingStress(const CSegmentKey& segmentKey, pgsTypes::StrandType strandType, const GDRCONFIG* pConfig) const
{
   Float64 fpj = 0;
   if (strandType == pgsTypes::Permanent)
   {
      Float64 PjS = GetPjack(segmentKey, pgsTypes::Straight, pConfig);
      Float64 PjH = GetPjack(segmentKey, pgsTypes::Harped, pConfig);
      StrandIndexType Ns = GetStrandCount(segmentKey, pgsTypes::Straight, pConfig);
      StrandIndexType Nh = GetStrandCount(segmentKey, pgsTypes::Harped, pConfig);

      GET_IFACE(ISegmentData, pSegmentData);
      const auto* pStraightStrand = pSegmentData->GetStrandMaterial(segmentKey, pgsTypes::Straight);
      const auto* pHarpedStrand = pSegmentData->GetStrandMaterial(segmentKey, pgsTypes::Harped);
      Float64 aps_s = pStraightStrand->GetNominalArea();
      Float64 aps_h = pHarpedStrand->GetNominalArea();

      Float64 Aps_s = aps_s*Ns;
      Float64 Aps_h = aps_h*Nh;
      Float64 Aps = Aps_s + Aps_h;
      fpj = IsZero(Aps) ? 0.0 : (PjS + PjH) / Aps;
   }
   else
   {
      Float64 Pj = GetPjack(segmentKey, strandType, pConfig);
      StrandIndexType N = GetStrandCount(segmentKey, strandType, pConfig);
      GET_IFACE(ISegmentData, pSegmentData);
      const auto* pStrand = pSegmentData->GetStrandMaterial(segmentKey, strandType);
      Float64 aps = pStrand->GetNominalArea();
      Float64 Aps = aps*N;
      fpj = IsZero(Aps) ? 0.0 : Pj / Aps;
   }

   return fpj;
}

bool CBridgeAgentImp::GetAreHarpedStrandsForcedStraight(const CSegmentKey& segmentKey) const
{
   GET_IFACE(IBridgeDescription,pIBridgeDesc);
   const CBridgeDescription2* pBridgeDesc = pIBridgeDesc->GetBridgeDescription();
   const CGirderGroupData* pGroup = pBridgeDesc->GetGirderGroup(segmentKey.groupIndex);
   const CSplicedGirderData* pGirder = pGroup->GetGirder(segmentKey.girderIndex);
   const CPrecastSegmentData* pSegment = pGirder->GetSegment(segmentKey.segmentIndex);
   return pSegment->Strands.GetAdjustableStrandType() == pgsTypes::asStraight ? true : false;
}

void CBridgeAgentImp::GetHarpedStrandControlHeights(const CSegmentKey& segmentKey,Float64* pHgStart,Float64* pHgHp1,Float64* pHgHp2,Float64* pHgEnd) const
{
   GET_IFACE(IBridgeDescription,pIBridgeDesc);
   const CBridgeDescription2* pBridgeDesc = pIBridgeDesc->GetBridgeDescription();
   const CGirderGroupData* pGroup = pBridgeDesc->GetGirderGroup(segmentKey.groupIndex);
   const CSplicedGirderData* pGirder = pGroup->GetGirder(segmentKey.girderIndex);
   const CPrecastSegmentData* pSegment = pGirder->GetSegment(segmentKey.segmentIndex);

   PoiList vPoi;
   GetPointsOfInterest(segmentKey,POI_START_FACE,&vPoi);
   ATLASSERT(vPoi.size() == 1);
   pgsPointOfInterest poiStart(vPoi.front());

   vPoi.clear();
   GetPointsOfInterest(segmentKey,POI_END_FACE,&vPoi);
   ATLASSERT(vPoi.size() == 1);
   pgsPointOfInterest poiEnd(vPoi.front());

   vPoi.clear();
   GetPointsOfInterest(segmentKey,POI_HARPINGPOINT,&vPoi);
   pgsPointOfInterest poiHp1, poiHp2;
   if ( 0 < vPoi.size() )
   {
      ATLASSERT( vPoi.size() < 3 );
      poiHp1 = vPoi.front();
      poiHp2 = vPoi.back();
   }
   else
   {
      // no harp points
      poiHp1 = poiStart;
      poiHp2 = poiEnd;
   }

   *pHgStart = GetOverallHeight(poiStart);
   *pHgHp1   = GetOverallHeight(poiHp1);
   *pHgHp2   = GetOverallHeight(poiHp2);
   *pHgEnd   = GetOverallHeight(poiEnd);
}

Float64 CBridgeAgentImp::GetSplittingZoneHeight(const pgsPointOfInterest& poi) const
{
   CComPtr<IGirderSection> girder_section;
   HRESULT hr = GetGirderSection(poi, &girder_section);
   ATLASSERT(SUCCEEDED(hr));
   if (FAILED(hr))
   {
      return 0;
   }

   CComQIPtr<IPrestressedGirderSection> psg_section(girder_section);

   Float64 splitting_zone_height;
   psg_section->get_SplittingZoneDimension(&splitting_zone_height);

   return splitting_zone_height;
}

pgsTypes::SplittingDirection CBridgeAgentImp::GetSplittingDirection(const CGirderKey& girderKey) const
{
   CSegmentKey segmentKey(girderKey,0);

   CComPtr<IGirderSection> girder_section;
   pgsPointOfInterest poi = GetPointOfInterest(segmentKey,0.00);
   ATLASSERT(poi.GetID() != INVALID_ID);
   HRESULT hr = GetGirderSection(poi, &girder_section);
   ATLASSERT(SUCCEEDED(hr));
   if (FAILED(hr))
   {
      return pgsTypes::sdVertical;
   }

   CComQIPtr<IPrestressedGirderSection> psg_section(girder_section);
   SplittingDirection splitDir;
   psg_section->get_SplittingDirection(&splitDir);

   return (splitDir == sdVertical ? pgsTypes::sdVertical : pgsTypes::sdHorizontal);
}

void CBridgeAgentImp::GetHarpStrandOffsets(const CSegmentKey& segmentKey,pgsTypes::MemberEndType endType,Float64* pOffsetEnd,Float64* pOffsetHp) const
{
   VALIDATE( GIRDER );

   CComPtr<IPrecastGirder> girder;
   GetGirder(segmentKey,&girder);

   CComPtr<IStrandModel> strandModel;
   girder->get_StrandModel(&strandModel);
   CComQIPtr<IStrandGridModel> strandGridModel(strandModel);

   strandGridModel->get_HarpedStrandAdjustmentEnd((EndType)endType,pOffsetEnd);
   strandGridModel->get_HarpedStrandAdjustmentHP((EndType)endType,pOffsetHp);
}

void CBridgeAgentImp::GetHarpedEndOffsetBounds(const CSegmentKey& segmentKey,pgsTypes::MemberEndType endType,Float64* DownwardOffset, Float64* UpwardOffset) const
{
   VALIDATE( GIRDER );

   CComPtr<IPrecastGirder> girder;
   GetGirder(segmentKey,&girder);

   CComPtr<IStrandModel> strandModel;
   girder->get_StrandModel(&strandModel);
   CComQIPtr<IStrandGridModel> strandGridModel(strandModel);

   HRESULT hr = strandGridModel->GetHarpedEndAdjustmentBounds((EndType)endType,DownwardOffset, UpwardOffset);
   ATLASSERT(SUCCEEDED(hr));
}

void CBridgeAgentImp::GetHarpedEndOffsetBoundsEx(const CSegmentKey& segmentKey,pgsTypes::MemberEndType endType,StrandIndexType Nh, Float64* DownwardOffset, Float64* UpwardOffset) const
{
   VALIDATE( GIRDER );

   if (Nh == 0)
   {
      *DownwardOffset = 0.0;
      *UpwardOffset = 0.0;
   }
   else
   {
      CComPtr<IPrecastGirder> girder;
      GetGirder(segmentKey,&girder);

      CComPtr<IStrandModel> strandModel;
      girder->get_StrandModel(&strandModel);
      CComQIPtr<IStrandGridModel> strandGridModel(strandModel);

      // use continuous interface to compute
      CComPtr<IIndexArray> fill;
      m_StrandFillers[segmentKey].ComputeHarpedStrandFill(strandGridModel, Nh, &fill);

      HRESULT hr = strandGridModel->GetHarpedEndAdjustmentBoundsEx((EndType)endType,fill,DownwardOffset, UpwardOffset);
      ATLASSERT(SUCCEEDED(hr));
   }
}

void CBridgeAgentImp::GetHarpedEndOffsetBoundsEx(LPCTSTR strGirderName,pgsTypes::MemberEndType endType, pgsTypes::AdjustableStrandType adjType, Float64 HgStart, Float64 HgHp1, Float64 HgHp2, Float64 HgEnd, const ConfigStrandFillVector& rHarpedFillArray, Float64* DownwardOffset, Float64* UpwardOffset) const
{
#pragma Reminder("REVIEW - this is implemented in CPrecastGirder also - why have duplicate code")
   if ( !AreStrandsInConfigFillVec(rHarpedFillArray) )
   {
      // no strands, just return
      *DownwardOffset = 0.0;
      *UpwardOffset = 0.0;
      return;
   }

   // Set up strand grid filler
   GET_IFACE(ILibrary,pLib);
   const GirderLibraryEntry* pGdrEntry = pLib->GetGirderEntry(strGirderName);

   CComPtr<IStrandGrid> startGrid, startHPGrid, endHPGrid, endGrid;
   startGrid.CoCreateInstance(CLSID_StrandGrid);
   startHPGrid.CoCreateInstance(CLSID_StrandGrid);
   endHPGrid.CoCreateInstance(CLSID_StrandGrid);
   endGrid.CoCreateInstance(CLSID_StrandGrid);
   pGdrEntry->ConfigureHarpedStrandGrids(HgStart,HgHp1,HgHp2,HgEnd,startGrid,startHPGrid,endHPGrid,endGrid);

   CComQIPtr<IStrandGridFiller> startGridFiller(endType == pgsTypes::metStart ? startGrid : endGrid);

   // Use wrapper to convert strand fill to IIndexArray
   CIndexArrayWrapper fill(rHarpedFillArray);

   // get adjusted top and bottom bounds
   Float64 top, bottom;
   HRESULT hr = startGridFiller->get_FilledGridBoundsEx(&fill,&bottom,&top);
   ATLASSERT(SUCCEEDED(hr));

   Float64 dx,dy;
   hr = startGridFiller->GetStrandAdjustment(&dx,&dy);
   ATLASSERT(SUCCEEDED(hr));

   if (IsZero(bottom) && IsZero(top))
   {
      // no strands exist so we cannot adjust them
      *DownwardOffset = 0.0;
      *UpwardOffset   = 0.0;
   }
   else
   {
      bottom -= dy;
      top    -= dy;

      // get max locations of strands
      Float64 bottom_min, top_max;
      CComPtr<IStrandMover> strandMover;
      CreateStrandMover(strGirderName,(endType == pgsTypes::metStart ? HgStart : HgEnd),adjType,&strandMover);
      hr = strandMover->get_EndStrandElevationBoundaries((EndType)endType,&bottom_min, &top_max);
      ATLASSERT(SUCCEEDED(hr));

      *DownwardOffset = bottom_min - bottom;
      *DownwardOffset = IsZero(*DownwardOffset) ? 0.0 : *DownwardOffset;

      *UpwardOffset   = top_max - top;
      *UpwardOffset   = IsZero(*UpwardOffset)   ? 0.0 : *UpwardOffset;

      // if these fire, strands cannot be adjusted within section bounds. this should be caught at library entry time.
      ATLASSERT(*DownwardOffset < 1.0e-06);
      ATLASSERT(*UpwardOffset > -1.0e-06);
   }
}

void CBridgeAgentImp::GetHarpedHpOffsetBounds(const CSegmentKey& segmentKey,pgsTypes::MemberEndType endType,Float64* DownwardOffset, Float64* UpwardOffset) const
{
   VALIDATE( GIRDER );

   CComPtr<IPrecastGirder> girder;
   GetGirder(segmentKey,&girder);

   CComPtr<IStrandModel> strandModel;
   girder->get_StrandModel(&strandModel);
   CComQIPtr<IStrandGridModel> strandGridModel(strandModel);

   HRESULT hr = strandGridModel->GetHarpedHpAdjustmentBounds((EndType)endType,DownwardOffset, UpwardOffset);
   ATLASSERT(SUCCEEDED(hr));
}

void CBridgeAgentImp::GetHarpedHpOffsetBoundsEx(const CSegmentKey& segmentKey,pgsTypes::MemberEndType endType,StrandIndexType Nh, Float64* DownwardOffset, Float64* UpwardOffset) const
{
   VALIDATE( GIRDER );

   if (Nh == 0)
   {
      *DownwardOffset = 0.0;
      *UpwardOffset = 0.0;
   }
   else
   {
      CComPtr<IPrecastGirder> girder;
      GetGirder(segmentKey,&girder);

      CComPtr<IStrandModel> strandModel;
      girder->get_StrandModel(&strandModel);
      CComQIPtr<IStrandGridModel> strandGridModel(strandModel);

      // use continuous interface to compute
      CComPtr<IIndexArray> fill;
      m_StrandFillers[segmentKey].ComputeHarpedStrandFill(strandGridModel, Nh, &fill);

      HRESULT hr = strandGridModel->GetHarpedHpAdjustmentBoundsEx((EndType)endType,fill,DownwardOffset, UpwardOffset);
      ATLASSERT(SUCCEEDED(hr));
   }
}

void CBridgeAgentImp::GetHarpedHpOffsetBoundsEx(LPCTSTR strGirderName, pgsTypes::MemberEndType endType, pgsTypes::AdjustableStrandType adjType, Float64 HgStart, Float64 HgHp1, Float64 HgHp2, Float64 HgEnd, const ConfigStrandFillVector& rHarpedFillArray, Float64* DownwardOffset, Float64* UpwardOffset) const
{
#pragma Reminder("REVIEW - this is implemented in CPrecastGirder also - why have duplicate code")
   if ( !AreStrandsInConfigFillVec(rHarpedFillArray) )
   {
      *DownwardOffset = 0.0;
      *UpwardOffset = 0.0;
      return;
   }

   GET_IFACE(ILibrary,pLib);
   const GirderLibraryEntry* pGdrEntry = pLib->GetGirderEntry(strGirderName);

   CComPtr<IStrandGrid> startGrid, startHPGrid, endHPGrid, endGrid;
   startGrid.CoCreateInstance(CLSID_StrandGrid);
   startHPGrid.CoCreateInstance(CLSID_StrandGrid);
   endHPGrid.CoCreateInstance(CLSID_StrandGrid);
   endGrid.CoCreateInstance(CLSID_StrandGrid);
   pGdrEntry->ConfigureHarpedStrandGrids(HgStart,HgHp1,HgHp2,HgEnd,startGrid,startHPGrid,endHPGrid,endGrid);

   CComQIPtr<IStrandGridFiller> startGridFiller(endType == pgsTypes::metStart ? startGrid : endGrid);
   CComQIPtr<IStrandGridFiller> hpGridFiller(endType == pgsTypes::metStart ? startHPGrid : endHPGrid);

   // Use wrapper to convert strand fill to IIndexArray
   CIndexArrayWrapper fill(rHarpedFillArray);

   // get adjusted top and bottom bounds
   Float64 top, bottom;
   HRESULT hr = hpGridFiller->get_FilledGridBoundsEx(&fill,&bottom,&top);
   ATLASSERT(SUCCEEDED(hr));

   Float64 dx,dy;
   hr = hpGridFiller->GetStrandAdjustment(&dx,&dy);
   ATLASSERT(SUCCEEDED(hr));

   if (IsZero(bottom) && IsZero(top) )
   {
      // no strands exist so we cannot adjust them
      *DownwardOffset = 0.0;
      *UpwardOffset   = 0.0;
   }
   else
   {
      bottom -= dy;
      top    -= dy;

      // get max locations of strands
      Float64 bottom_min, top_max;
      CComPtr<IStrandMover> strandMover;
      CreateStrandMover(strGirderName,(endType == pgsTypes::metStart ? HgHp1 : HgHp2),adjType,&strandMover);
      hr = strandMover->get_HpStrandElevationBoundaries((EndType)endType,&bottom_min, &top_max);
      ATLASSERT(SUCCEEDED(hr));

      *DownwardOffset = bottom_min - bottom;
      *DownwardOffset = IsZero(*DownwardOffset) ? 0.0 : *DownwardOffset;

      *UpwardOffset   = top_max - top;
      *UpwardOffset   = IsZero(*UpwardOffset)   ? 0.0 : *UpwardOffset;

      // if these fire, strands cannot be adjusted within section bounds. this should be caught at library entry time.
      ATLASSERT(*DownwardOffset<1.0e-06);
      ATLASSERT(*UpwardOffset>-1.0e-06);
   }
}

Float64 CBridgeAgentImp::GetHarpedEndOffsetIncrement(const CSegmentKey& segmentKey) const
{
   VALIDATE( GIRDER );

   Float64 increment = 0;
   CComPtr<IPrecastGirder> girder;
   GetGirder(segmentKey,&girder);

   CComPtr<IStrandModel> strandModel;
   girder->get_StrandModel(&strandModel);
   CComQIPtr<IStrandGridModel> strandGridModel(strandModel);
   if (strandGridModel)
   {
      HRESULT hr = strandGridModel->get_HarpedEndAdjustmentIncrement(&increment);
      ATLASSERT(SUCCEEDED(hr));
   }
#if defined _DEBUG
   else
   {
      CComQIPtr<IStrandPointModel> strandPointModel(strandModel);
      ATLASSERT(strandPointModel);
      ATLASSERT(false); // using a strand point model... probably shouldn't be calling this method in the first place
   }
#endif

   return increment;
}

Float64 CBridgeAgentImp::GetHarpedEndOffsetIncrement(LPCTSTR strGirderName, pgsTypes::AdjustableStrandType adjType ) const
{
   GET_IFACE(ILibrary,pLib);
   const GirderLibraryEntry* pGirderEntry = pLib->GetGirderEntry(strGirderName);
   Float64 end_increment;
   if (adjType == pgsTypes::asStraight)
   {
      end_increment  = pGirderEntry->IsVerticalAdjustmentAllowedStraight()  ?  pGirderEntry->GetStraightStrandIncrement()  : -1.0;
   }
   else
   {
      end_increment  =pGirderEntry->IsVerticalAdjustmentAllowedEnd() ?  pGirderEntry->GetEndStrandIncrement() : -1.0;
   }

   return end_increment;
}

Float64 CBridgeAgentImp::GetHarpedHpOffsetIncrement(const CSegmentKey& segmentKey) const
{
   VALIDATE( GIRDER );

   Float64 increment = 0;

   CComPtr<IPrecastGirder> girder;
   GetGirder(segmentKey,&girder);

   CComPtr<IStrandModel> strandModel;
   girder->get_StrandModel(&strandModel);
   CComQIPtr<IStrandGridModel> strandGridModel(strandModel);

   if (strandGridModel)
   {
      HRESULT hr = strandGridModel->get_HarpedHpAdjustmentIncrement(&increment);
      ATLASSERT(SUCCEEDED(hr));
   }
#if defined _DEBUG
   else
   {
      CComQIPtr<IStrandPointModel> strandPointModel(strandModel);
      ATLASSERT(strandPointModel);
      ATLASSERT(false); // using a strand point model... probably shouldn't be calling this method in the first place
   }
#endif

   return increment;
}

Float64 CBridgeAgentImp::GetHarpedHpOffsetIncrement(LPCTSTR strGirderName,pgsTypes::AdjustableStrandType adjType) const
{
   GET_IFACE(ILibrary,pLib);
   const GirderLibraryEntry* pGirderEntry = pLib->GetGirderEntry(strGirderName);
   Float64 hp_increment;
   if (adjType == pgsTypes::asStraight)
   {
      hp_increment  = pGirderEntry->IsVerticalAdjustmentAllowedStraight()  ?  pGirderEntry->GetStraightStrandIncrement()  : -1.0;
   }
   else
   {
      hp_increment = pGirderEntry->IsVerticalAdjustmentAllowedHP()  ?  pGirderEntry->GetHPStrandIncrement()  : -1.0;
   }

   return hp_increment;
}

void CBridgeAgentImp::GetHarpingPointLocations(const CSegmentKey& segmentKey, Float64* lhp, Float64* rhp) const
{
   VALIDATE(GIRDER);

   CComPtr<IPrecastGirder> girder;
   GetGirder(segmentKey, &girder);

   CComPtr<IStrandModel> strandModel;
   girder->get_StrandModel(&strandModel);
   strandModel->GetHarpingPointLocations(lhp, rhp);
}

void CBridgeAgentImp::GetHarpingPointLocations(const CSegmentKey& segmentKey,Float64* pX1,Float64* pX2,Float64* pX3,Float64* pX4) const
{
   VALIDATE( GIRDER );

   CComPtr<IPrecastGirder> girder;
   GetGirder(segmentKey,&girder);

   CComPtr<IStrandModel> strandModel;
   girder->get_StrandModel(&strandModel);
   strandModel->GetHarpingPointLocations(pX2, pX3);
   strandModel->GetEndHarpingPointLocations(pX1, pX4);
}

void CBridgeAgentImp::GetHighestHarpedStrandLocationEnds(const CSegmentKey& segmentKey,Float64* pElevation) const
{
   // determine distance from bottom of girder to highest harped strand at end of girder 
   // to compute the txdot ibns TO value
   VALIDATE( GIRDER );

   CComPtr<IPrecastGirder> girder;
   GetGirder(segmentKey,&girder);

   CComPtr<IStrandModel> strandModel;
   girder->get_StrandModel(&strandModel);

   CComPtr<IRect2d> boxStart;
   HRESULT hr = strandModel->HarpedEndStrandBoundingBox(etStart,&boxStart);
   ATLASSERT(SUCCEEDED(hr));

   Float64 startTop;
   boxStart->get_Top(&startTop);

   CComPtr<IRect2d> boxEnd;
   hr = strandModel->HarpedEndStrandBoundingBox(etEnd,&boxEnd);
   ATLASSERT(SUCCEEDED(hr));

   Float64 endTop;
   boxEnd->get_Top(&endTop);

   *pElevation = Max(startTop,endTop);
}

void CBridgeAgentImp::GetHighestHarpedStrandLocationHPs(const CSegmentKey& segmentKey,Float64* pElevation) const
{
   // determine distance from bottom of girder to highest harped strand at end of girder 
   // to compute the txdot ibns TO CL value
   VALIDATE( GIRDER );

   CComPtr<IPrecastGirder> girder;
   GetGirder(segmentKey,&girder);

   CComPtr<IStrandModel> strandModel;
   girder->get_StrandModel(&strandModel);

   CComPtr<IRect2d> boxStart;
   HRESULT hr = strandModel->HarpedHpStrandBoundingBox(etStart,&boxStart);
   ATLASSERT(SUCCEEDED(hr));

   Float64 startTop;
   boxStart->get_Top(&startTop);

   CComPtr<IRect2d> boxEnd;
   hr = strandModel->HarpedHpStrandBoundingBox(etEnd,&boxEnd);
   ATLASSERT(SUCCEEDED(hr));

   Float64 endTop;
   boxEnd->get_Top(&endTop);

   *pElevation = Max(startTop,endTop);
}

IndexType CBridgeAgentImp::GetNumHarpPoints(const CSegmentKey& segmentKey) const
{
   CComPtr<IPrecastGirder> girder;
   GetGirder(segmentKey, &girder);

   CComPtr<IStrandModel> strandModel;
   girder->get_StrandModel(&strandModel);

   CComQIPtr<IStrandGridModel> strandGridModel(strandModel);
   if (strandGridModel)
   {
      StrandIndexType maxHarped;
      strandGridModel->GetMaxStrands(Harped, &maxHarped);

      if (maxHarped == 0)
      {
         return 0;
      }
   }

   Float64 lhp, rhp;
   GetHarpingPointLocations(segmentKey, &lhp, &rhp);

   if (IsEqual(lhp,rhp))
   {
      return 1;
   }
   else
   {
      return 2;
   }
}

StrandIndexType CBridgeAgentImp::GetNextNumStrands(const CSegmentKey& segmentKey,pgsTypes::StrandType strandType,StrandIndexType curNum) const
{
   ATLASSERT(strandType != pgsTypes::Permanent);

   StrandIndexType ns;
   switch(strandType)
   {
   case pgsTypes::Straight:
      ns = GetNextNumStraightStrands(segmentKey,curNum);
      break;

   case pgsTypes::Harped:
      ns = GetNextNumHarpedStrands(segmentKey,curNum);
      break;

   case pgsTypes::Temporary:
      ns = GetNextNumTempStrands(segmentKey,curNum);
      break;

   default:
      ATLASSERT(false); // should never get here
   }

   return ns;
}
StrandIndexType CBridgeAgentImp::GetNextNumStrands(LPCTSTR strGirderName,pgsTypes::StrandType strandType,StrandIndexType curNum) const
{
   ATLASSERT(strandType != pgsTypes::Permanent);

   StrandIndexType ns;
   switch(strandType)
   {
   case pgsTypes::Straight:
      ns = GetNextNumStraightStrands(strGirderName,curNum);
      break;

   case pgsTypes::Harped:
      ns = GetNextNumHarpedStrands(strGirderName,curNum);
      break;

   case pgsTypes::Temporary:
      ns = GetNextNumTempStrands(strGirderName,curNum);
      break;

   default:
      ATLASSERT(false); // should never get here
   }

   return ns;
}


StrandIndexType CBridgeAgentImp::GetPrevNumStrands(const CSegmentKey& segmentKey,pgsTypes::StrandType strandType,StrandIndexType curNum) const
{
   ATLASSERT(strandType != pgsTypes::Permanent);
   
   VALIDATE( GIRDER );

   StrandIndexType ns;
   if (curNum==0)
   {
      ns = 0;
   }
   else
   {
      switch(strandType)
      {
      case pgsTypes::Straight:
         ns = GetPrevNumStraightStrands(segmentKey,curNum);
         break;

      case pgsTypes::Harped:
         ns = GetPrevNumHarpedStrands(segmentKey,curNum);
         break;

      case pgsTypes::Temporary:
         ns = GetPrevNumTempStrands(segmentKey,curNum);
         break;

      default:
         ATLASSERT(false); // should never get here
      }
   }

   return ns;
}

StrandIndexType CBridgeAgentImp::GetPrevNumStrands(LPCTSTR strGirderName,pgsTypes::StrandType strandType,StrandIndexType curNum) const
{
   ATLASSERT(strandType != pgsTypes::Permanent);

   if ( curNum == 0 )
   {
      return 0;
   }

   StrandIndexType ns;
   switch(strandType)
   {
   case pgsTypes::Straight:
      ns = GetPrevNumStraightStrands(strGirderName,curNum);
      break;

   case pgsTypes::Harped:
      ns = GetPrevNumHarpedStrands(strGirderName,curNum);
      break;

   case pgsTypes::Temporary:
      ns = GetPrevNumTempStrands(strGirderName,curNum);
      break;

   default:
      ATLASSERT(false); // should never get here
   }

   return ns;
}

StrandIndexType CBridgeAgentImp::GetNumExtendedStrands(const CSegmentKey& segmentKey,pgsTypes::MemberEndType endType,pgsTypes::StrandType strandType) const
{
   ATLASSERT(strandType != pgsTypes::Permanent);

   StrandIndexType nExtended = 0;

   GET_IFACE(IBridgeDescription, pIBridgeDesc);
   const auto* pSegment = pIBridgeDesc->GetPrecastSegmentData(segmentKey);
   if (pSegment->Strands.GetStrandDefinitionType() == pgsTypes::sdtDirectStrandInput)
   {
      const auto& strandRows = pSegment->Strands.GetStrandRows();
      for (const auto& strandRow : strandRows)
      {
         if (strandRow.m_bIsExtendedStrand[endType])
         {
            nExtended++;
         }
      }
   }
   else
   {
      GDRCONFIG config = GetSegmentConfiguration(segmentKey);
      nExtended = config.PrestressConfig.GetExtendedStrands(strandType, endType).size();
   }

   return nExtended;

}

bool CBridgeAgentImp::IsExtendedStrand(const CSegmentKey& segmentKey,pgsTypes::MemberEndType endType,StrandIndexType strandIdx,pgsTypes::StrandType strandType,const GDRCONFIG* pConfig) const
{
   ATLASSERT(strandType != pgsTypes::Permanent);

   GET_IFACE(IBridgeDescription, pIBridgeDesc);
   const auto* pSegment = pIBridgeDesc->GetPrecastSegmentData(segmentKey);
   if (pSegment->Strands.GetStrandDefinitionType() == pgsTypes::sdtDirectStrandInput)
   {
      ATLASSERT(pConfig == nullptr);
      const auto& strandRows = pSegment->Strands.GetStrandRows();
      const auto& strandRow = strandRows[strandIdx];
      if (strandRow.m_bIsExtendedStrand[endType])
      {
         return true;
      }
   }
   else
   {
      const GDRCONFIG& config(pConfig == nullptr ? GetSegmentConfiguration(segmentKey) : *pConfig);
      if (config.PrestressConfig.GetExtendedStrands(strandType, endType).size() == 0)
      {
         return false;
      }

      const std::vector<StrandIndexType>& extStrands = config.PrestressConfig.GetExtendedStrands(strandType, endType);
      std::vector<StrandIndexType>::const_iterator iter(extStrands.begin());
      std::vector<StrandIndexType>::const_iterator endIter(extStrands.end());
      for (; iter != endIter; iter++)
      {
         if (*iter == strandIdx)
         {
            return true;
         }
      }
   }

   return false;
}

bool CBridgeAgentImp::IsExtendedStrand(const pgsPointOfInterest& poi,StrandIndexType strandIdx,pgsTypes::StrandType strandType,const GDRCONFIG* pConfig) const
{
   Float64 Lg = GetSegmentLength(poi.GetSegmentKey());
   pgsTypes::MemberEndType end = (poi.GetDistFromStart() < Lg/2 ? pgsTypes::metStart : pgsTypes::metEnd);
   return IsExtendedStrand(poi.GetSegmentKey(),end,strandIdx,strandType,pConfig);
}

bool CBridgeAgentImp::IsStrandDebonded(const CSegmentKey& segmentKey,StrandIndexType strandIdx,pgsTypes::StrandType strandType,const GDRCONFIG* pConfig,Float64* pStart,Float64* pEnd) const
{
   ATLASSERT(strandType != pgsTypes::Permanent);

   VALIDATE( GIRDER );

   CComPtr<IPrecastGirder> girder;
   GetGirder(segmentKey,&girder);

   Float64 length = GetSegmentLength(segmentKey);

   bool bDebonded = false;
   *pStart = 0.0;
   *pEnd   = length;

   GET_IFACE(IBridgeDescription, pIBridgeDesc);
   const auto* pSegment = pIBridgeDesc->GetPrecastSegmentData(segmentKey);
   if (pSegment->Strands.GetStrandDefinitionType() == pgsTypes::sdtDirectStrandInput)
   {
      ATLASSERT(pConfig == nullptr);
      const auto& strandRows = pSegment->Strands.GetStrandRows();
      const auto& strandRow = strandRows[strandIdx];
      if (strandRow.m_bIsDebonded[etStart] || strandRow.m_bIsDebonded[etEnd])
      {
         if (strandRow.m_bIsDebonded[etStart])
         {
            *pStart = strandRow.m_DebondLength[etStart];
         }

         if (strandRow.m_bIsDebonded[etEnd])
         {
            *pEnd = length - strandRow.m_DebondLength[etEnd];
         }
         bDebonded = true;
      }
   }
   else
   {
      const GDRCONFIG& config(pConfig == nullptr ? GetSegmentConfiguration(segmentKey) : *pConfig);
      for(const auto& di : config.PrestressConfig.Debond[strandType])
      {
         if (strandIdx == di.strandIdx)
         {
            *pStart = di.DebondLength[pgsTypes::metStart];
            *pEnd = length - di.DebondLength[pgsTypes::metEnd];
            bDebonded = true;
            break;
         }
      }
   }

   if ( bDebonded && (length < *pStart) )
   {
      *pStart = length;
   }

   if ( bDebonded && (length < *pEnd) )
   {
      *pEnd = length;
   }

   // if not debonded, bond starts at 0 and ends at the other end of the girder
   if ( !bDebonded )
   {
      *pStart = 0;
      *pEnd = length;
   }

   return bDebonded;
}

//-----------------------------------------------------------------------------
bool CBridgeAgentImp::IsStrandDebonded(const pgsPointOfInterest& poi, StrandIndexType strandIdx, pgsTypes::StrandType strandType,const GDRCONFIG* pConfig) const
{
   ATLASSERT(strandType != pgsTypes::Permanent);

   VALIDATE( GIRDER );

   const CSegmentKey& segmentKey = poi.GetSegmentKey();

   Float64 debond_left, debond_right;
   if ( !IsStrandDebonded(segmentKey,strandIdx,strandType,pConfig,&debond_left,&debond_right) )
   {
      // this strand is not at all debonded
      return false;
   }

   Float64 location = poi.GetDistFromStart();

   if ( !IsZero(debond_left) && ::IsLT(location, debond_left))
   {
      // there is debonding on the left, and the poi is before bonding begins
      return true;
   }

   Float64 length = GetSegmentLength(segmentKey);

   if ( !IsEqual(debond_right,length) && ::IsLT(debond_right,location) )
   {
      // there is debonding on the right and the poi is after the point where bonding ends
      return true;
   }

   return false;
}

//-----------------------------------------------------------------------------
StrandIndexType CBridgeAgentImp::GetNumDebondedStrands(const CSegmentKey& segmentKey, pgsTypes::StrandType strandType, pgsTypes::DebondMemberEndType end, const GDRCONFIG* pConfig) const
{
   // This method assumes harped strands can't be debonded

   if (pConfig)
   {
      if (strandType == pgsTypes::Permanent)
      {
         strandType = pgsTypes::Straight;
      }

      if (end == pgsTypes::dbetEither)
      {
         return pConfig->PrestressConfig.Debond[strandType].size();
      }
      else
      {
         StrandIndexType nDebondedStrands = 0;
         for (const auto& debondInfo : pConfig->PrestressConfig.Debond[strandType])
         {
            if (!IsZero(debondInfo.DebondLength[end == pgsTypes::dbetStart ? pgsTypes::metStart : pgsTypes::metEnd]))
            {
               nDebondedStrands++;
            }
         }
         return nDebondedStrands;
      }
   }
      
   VALIDATE( GIRDER );

   // this method assumes only straight strands can be debonded

   StrandIndexType nDebondedStrands = 0;
   HRESULT hr;
   switch( strandType )
   {
   case pgsTypes::Permanent: // drop through
   case pgsTypes::Straight:
      {
         // translate into wbfl lingo
         CComPtr<IPrecastGirder> girder;
         GetGirder(segmentKey, &girder);

         CComPtr<IStrandModel> strandModel;
         girder->get_StrandModel(&strandModel);

         WDebondLocationType loc = (end == pgsTypes::dbetStart ? wdblLeft : (end == pgsTypes::dbetEnd ? wdblRight : wdblEither));
         hr = strandModel->GetStraightStrandDebondCount(loc, &nDebondedStrands);
         break;
      }

   case pgsTypes::Harped: // drop through

   case pgsTypes::Temporary:
               // Assumed only bonded for the end 10'... PS force is constant through the debonded section
               // this is different than strands debonded at the ends and bonded in the middle
               // Treat this strand as bonded
      break;

   default:
      ATLASSERT(false); // should never get here
   }

   return nDebondedStrands;
}

//-----------------------------------------------------------------------------
RowIndexType CBridgeAgentImp::GetNumRowsWithStrand(const pgsPointOfInterest& poi,pgsTypes::StrandType strandType ) const
{
   ATLASSERT(strandType != pgsTypes::Permanent);

   VALIDATE( GIRDER );

   RowIndexType nRows = 0;

   Float64 Xpoi = poi.GetDistFromStart();

   CComPtr<IPrecastGirder> girder;
   GetGirder(poi,&girder);

   CComPtr<IStrandModel> strandModel;
   girder->get_StrandModel(&strandModel);

   HRESULT hr = strandModel->GetStrandRowCount((StrandType)strandType,Xpoi, &nRows);

   return nRows;
}

//-----------------------------------------------------------------------------
StrandIndexType CBridgeAgentImp::GetNumStrandInRow(const pgsPointOfInterest& poi, RowIndexType rowIdx, pgsTypes::StrandType strandType ) const
{
   ATLASSERT(strandType != pgsTypes::Permanent);

   VALIDATE( GIRDER );

   Float64 Xpoi = poi.GetDistFromStart();

   CComPtr<IPrecastGirder> girder;
   GetGirder(poi, &girder);

   CComPtr<IStrandModel> strandModel;
   girder->get_StrandModel(&strandModel);

   StrandIndexType cStrands = 0;
   HRESULT hr = strandModel->GetNumStrandsInRow((StrandType)strandType, Xpoi, rowIdx, &cStrands);

   return cStrands;
}

std::vector<StrandIndexType> CBridgeAgentImp::GetStrandsInRow(const pgsPointOfInterest& poi, RowIndexType rowIdx, pgsTypes::StrandType strandType ) const
{
   ATLASSERT(strandType != pgsTypes::Permanent);

   VALIDATE( GIRDER );

   std::vector<StrandIndexType> strandIdxs;

   CComPtr<IPrecastGirder> girder;
   GetGirder(poi,&girder);

   CComPtr<IStrandModel> strandModel;
   girder->get_StrandModel(&strandModel);

   CComPtr<IIndexArray> idxArray;
   strandModel->GetStrandsInRow((StrandType)strandType, poi.GetDistFromStart(), rowIdx, &idxArray);

   CollectionIndexType nItems;
   idxArray->get_Count(&nItems);
   for ( CollectionIndexType i = 0; i < nItems; i++ )
   {
      StrandIndexType strandIdx;
      idxArray->get_Item(i,&strandIdx);
      strandIdxs.push_back(strandIdx);
   }

   return strandIdxs;
}

//-----------------------------------------------------------------------------
StrandIndexType CBridgeAgentImp::GetNumDebondedStrandsInRow(const pgsPointOfInterest& poi, RowIndexType rowIdx, pgsTypes::StrandType strandType ) const
{
   ATLASSERT(strandType != pgsTypes::Permanent);

   VALIDATE( GIRDER );

   const CSegmentKey& segmentKey(poi.GetSegmentKey());

   CComPtr<IPrecastGirder> girder;
   GetGirder(segmentKey,&girder);

   CComPtr<IStrandModel> strandModel;
   girder->get_StrandModel(&strandModel);

   StrandIndexType nDebondedStrands = 0;
   HRESULT hr;
   switch( strandType )
   {
   case pgsTypes::Straight:
      hr = strandModel->get_StraightStrandDebondInRow(poi.GetDistFromStart(),rowIdx,&nDebondedStrands);
      break;

   case pgsTypes::Harped:
   case pgsTypes::Temporary:
      hr = S_FALSE; // Assumed only bonded for the end 10'... PS force is constant through the debonded section
                    // this is different than strands debonded at the ends and bonded in the middle
                    // Treat this strand as bonded
      break;

   default:
      ATLASSERT(false); // should never get here
   }

   return nDebondedStrands;
}

//-----------------------------------------------------------------------------
bool CBridgeAgentImp::IsExteriorStrandDebondedInRow(const pgsPointOfInterest& poi, RowIndexType rowIdx, pgsTypes::StrandType strandType) const
{
   ATLASSERT(strandType != pgsTypes::Permanent);

   VALIDATE( GIRDER );

   const CSegmentKey& segmentKey(poi.GetSegmentKey());

   CComPtr<IPrecastGirder> girder;
   GetGirder(segmentKey,&girder);

   CComPtr<IStrandModel> strandModel;
   girder->get_StrandModel(&strandModel);

   VARIANT_BOOL bExteriorDebonded = VARIANT_FALSE;
   HRESULT hr;
   switch( strandType )
   {
   case pgsTypes::Straight:
      hr = strandModel->IsExteriorStraightStrandDebondedInRow(poi.GetDistFromStart(), rowIdx,&bExteriorDebonded);
      break;

   case pgsTypes::Harped:
   case pgsTypes::Temporary:
      hr = S_FALSE; // Assumed only bonded for the end 10'... PS force is constant through the debonded section
                    // this is different than strands debonded at the ends and bonded in the middle
                    // Treat this strand as bonded
      break;

   default:
      ATLASSERT(false); // should never get here
   }

   return bExteriorDebonded == VARIANT_FALSE ? false : true;
}

bool CBridgeAgentImp::IsExteriorWebStrandDebondedInRow(const pgsPointOfInterest& poi, WebIndexType webIdx, RowIndexType rowIdx, pgsTypes::StrandType strandType) const
{
   VALIDATE(GIRDER);

   const CSegmentKey& segmentKey(poi.GetSegmentKey());

   ATLASSERT(strandType != pgsTypes::Permanent);

   // LRFD 9th Edition, 5.9.4.3.3 - Item K - multiple-webs and no bottom flange
   WebIndexType nWebs = GetWebCount(segmentKey);
   ATLASSERT(lrfdVersionMgr::NinthEdition2020 <= lrfdVersionMgr::GetVersion());
   ATLASSERT(1 < nWebs);
   ATLASSERT(0 == GetBottomFlangeCount(segmentKey));


   CComPtr<IPrecastGirder> girder;
   GetGirder(segmentKey, &girder);

   CComPtr<IStrandModel> strandModel;
   girder->get_StrandModel(&strandModel);

   if (strandType != pgsTypes::Straight)
   {
      // only straight strands can be debonded
      return false;
   }

   ATLASSERT(strandType == pgsTypes::Straight);
   CComPtr<IIndexArray> arrStrands;
   strandModel->GetStrandsInRow(Straight, poi.GetDistFromStart(), rowIdx, &arrStrands);

   // find the exterior strands in each web
   Float64 Xweb = GetWebLocation(poi, webIdx);
   Float64 Tweb = GetWebThickness(poi, webIdx);
   Float64 XwebMin = Xweb - Tweb / 2; // left side of web
   Float64 XwebMax = Xweb + Tweb / 2; // right side of web

   Float64 Xmin = Float64_Max; // position of left most strand in web
   Float64 Xmax = -Float64_Max; // position of right most strand in web
   const int Debonded = 0;
   const int Bonded = 1;
   int XminState = Bonded; // bond state of left most strand in web
   int XmaxState = Bonded; // bond state of right most strand in web

   CComPtr<IPoint2dCollection> pntStrands;
   strandModel->GetStrandPositions(Straight, poi.GetDistFromStart(), &pntStrands);

   // loop over all strands in web
   IndexType nItems;
   arrStrands->get_Count(&nItems);
   for (IndexType itemIdx = 0; itemIdx < nItems; itemIdx++)
   {
      StrandIndexType strandIdx;
      arrStrands->get_Item(itemIdx, &strandIdx);

      CComPtr<IPoint2d> pnt;
      pntStrands->get_Item(strandIdx, &pnt);

      Float64 Xstrand;
      pnt->get_X(&Xstrand);

      if (InRange(XwebMin, Xstrand, XwebMax))
      {
         // strand is in this web;
         if (Xstrand < Xmin)
         {
            Xmin = Xstrand;
            XminState = IsStrandDebonded(poi, strandIdx, pgsTypes::Straight) ? Debonded : Bonded;
         }

         if (Xmax < Xstrand)
         {
            Xmax = Xstrand;
            XmaxState = IsStrandDebonded(poi, strandIdx, pgsTypes::Straight) ? Debonded : Bonded;
         }
      }
   }

   ATLASSERT(InRange(XwebMin, Xmin, XwebMax));
   ATLASSERT(InRange(XwebMin, Xmax, XwebMax));

   return XminState == Debonded || XmaxState == Debonded ? true : false;
}

Float64 CBridgeAgentImp::GetUnadjustedStrandRowElevation(const pgsPointOfInterest & poi, RowIndexType rowIdx, pgsTypes::StrandType strandType) const
{
   ATLASSERT(strandType != pgsTypes::Permanent);

   VALIDATE( GIRDER );

   const CSegmentKey& segmentKey(poi.GetSegmentKey());

   CComPtr<IPrecastGirder> girder;
   GetGirder(segmentKey,&girder);

   CComPtr<IStrandModel> strandModel;
   girder->get_StrandModel(&strandModel);

   Float64 elevation;
   strandModel->GetUnadjustedStrandRowElevation((StrandType)strandType, poi.GetDistFromStart(), rowIdx, &elevation);

   return elevation;
}

//-----------------------------------------------------------------------------
Float64 CBridgeAgentImp::GetDebondSection(const CSegmentKey& segmentKey,pgsTypes::MemberEndType endType,SectionIndexType sectionIdx,pgsTypes::StrandType strandType) const
{
   ATLASSERT(strandType != pgsTypes::Permanent);

   VALIDATE( GIRDER );

   CComPtr<IPrecastGirder> girder;
   GetGirder(segmentKey,&girder);

   CComPtr<IStrandModel> strandModel;
   girder->get_StrandModel(&strandModel);

   CComPtr<IDblArray> arrLeft, arrRight;
   if (FAILED(strandModel->GetDebondingLocations((StrandType)strandType, &arrLeft, &arrRight)))
   {
      return 0;
   }

   Float64 location;
   if ( endType == pgsTypes::metStart )
   {
      // left end
      arrLeft->get_Item(sectionIdx,&location);
   }
   else
   {
      // right
      arrRight->get_Item(sectionIdx,&location);

      // measure section location from the left end
      // so all return values are consistent
      Float64 gdr_length = GetSegmentLength(segmentKey);
      location = gdr_length - location;
   }

   return location;
}

//-----------------------------------------------------------------------------
SectionIndexType CBridgeAgentImp::GetNumDebondSections(const CSegmentKey& segmentKey,pgsTypes::MemberEndType endType,pgsTypes::StrandType strandType) const
{
   ATLASSERT(strandType != pgsTypes::Permanent);

   VALIDATE( GIRDER );

   CComPtr<IPrecastGirder> girder;
   GetGirder(segmentKey,&girder);

   CComPtr<IStrandModel> strandModel;
   girder->get_StrandModel(&strandModel);

   CComPtr<IDblArray> arrLeft, arrRight;
   if (FAILED(strandModel->GetDebondingLocations((StrandType)strandType,&arrLeft, &arrRight)))
   {
      return 0;
   }

   CollectionIndexType c1;
   if ( endType == pgsTypes::metStart )
   {
      arrLeft->get_Count(&c1);
   }
   else
   {
      arrRight->get_Count(&c1);
   }

   ASSERT(c1 <= Uint16_Max); // make sure there is no loss of data
   return Uint16(c1);
}

//-----------------------------------------------------------------------------
StrandIndexType CBridgeAgentImp::GetNumDebondedStrandsAtSection(const CSegmentKey& segmentKey,pgsTypes::MemberEndType endType,SectionIndexType sectionIdx,pgsTypes::StrandType strandType) const
{
   ATLASSERT(strandType != pgsTypes::Permanent);

   VALIDATE( GIRDER );

   CComPtr<IPrecastGirder> girder;
   GetGirder(segmentKey,&girder);

   CComPtr<IStrandModel> strandModel;
   girder->get_StrandModel(&strandModel);

   CComPtr<IIndexArray> strands;
   HRESULT hr = strandModel->GetDebondedStrandsAtSection((EndType)endType, (StrandType)strandType, sectionIdx, &strands);
   ATLASSERT(SUCCEEDED(hr));

   StrandIndexType nStrands;
   strands->get_Count(&nStrands);

   return nStrands;
}

//-----------------------------------------------------------------------------
StrandIndexType CBridgeAgentImp::GetNumBondedStrandsAtSection(const CSegmentKey& segmentKey,pgsTypes::MemberEndType endType,SectionIndexType sectionIdx,pgsTypes::StrandType strandType) const
{
   ATLASSERT(strandType != pgsTypes::Permanent);

   VALIDATE( GIRDER );

   CComPtr<IPrecastGirder> girder;
   GetGirder(segmentKey,&girder);

   CComPtr<IStrandModel> strandModel;
   girder->get_StrandModel(&strandModel);

   StrandIndexType nStrands = GetStrandCount(segmentKey,strandType);

   std::array<CComPtr<IDblArray>,2> sectionLocations;
   if (FAILED(strandModel->GetDebondingLocations((StrandType)strandType, &sectionLocations[etStart], &sectionLocations[etEnd])))
   {
      return 0;
   }

   // all strands are straight from here on
   StrandIndexType nDebondedStrands = 0;
   CollectionIndexType nSections;
   sectionLocations[endType]->get_Count(&nSections);
   ATLASSERT(sectionIdx < nSections);

   // how many strands are debonded at this section and all the ones after it?
   for (CollectionIndexType idx = sectionIdx; idx < nSections; idx++)
   {
      CComPtr<IIndexArray> strands;
      HRESULT hr = strandModel->GetDebondedStrandsAtSection((EndType)endType, (StrandType)strandType, idx, &strands);
      ATLASSERT(SUCCEEDED(hr));

      CollectionIndexType nDebondedStrandsAtSection;
      strands->get_Count(&nDebondedStrandsAtSection);

      nDebondedStrands += nDebondedStrandsAtSection;
   }

   ATLASSERT(nDebondedStrands <= nStrands);

   return nStrands - nDebondedStrands;
}

std::vector<StrandIndexType> CBridgeAgentImp::GetDebondedStrandsAtSection(const CSegmentKey& segmentKey,pgsTypes::MemberEndType endType,SectionIndexType sectionIdx,pgsTypes::StrandType strandType) const
{
   ATLASSERT(strandType != pgsTypes::Permanent);

   VALIDATE(GIRDER);

   CComPtr<IPrecastGirder> girder;
   GetGirder(segmentKey, &girder);

   CComPtr<IStrandModel> strandModel;
   girder->get_StrandModel(&strandModel);

   CComPtr<IIndexArray> strands;
   HRESULT hr = strandModel->GetDebondedStrandsAtSection((EndType)endType, (StrandType)strandType, sectionIdx, &strands);
   ATLASSERT(SUCCEEDED(hr));

   IndexType cStrands;
   strands->get_Count(&cStrands);

   std::vector<StrandIndexType> debondedStrands;
   debondedStrands.reserve(cStrands);
   for (IndexType i = 0; i < cStrands; i++)
   {
      StrandIndexType strandIdx;
      strands->get_Item(i, &strandIdx);
      debondedStrands.push_back(strandIdx);
   }

   return debondedStrands;
}

//-----------------------------------------------------------------------------
bool CBridgeAgentImp::CanDebondStrands(const CSegmentKey& segmentKey,pgsTypes::StrandType strandType) const
{
   ATLASSERT(strandType != pgsTypes::Permanent);

   VALIDATE( BRIDGE );

   if ( strandType == pgsTypes::Harped || strandType == pgsTypes::Temporary )
   {
      return false;
   }

   const GirderLibraryEntry* pGirderEntry = GetGirderLibraryEntry(segmentKey);

   return pGirderEntry->CanDebondStraightStrands();
}

bool CBridgeAgentImp::CanDebondStrands(LPCTSTR strGirderName,pgsTypes::StrandType strandType) const
{
   ATLASSERT(strandType != pgsTypes::Permanent);

   if ( strandType == pgsTypes::Harped || strandType == pgsTypes::Temporary )
   {
      return false;
   }

   GET_IFACE(ILibrary,pLib);
   const GirderLibraryEntry* pGirderEntry = pLib->GetGirderEntry( strGirderName );

   return pGirderEntry->CanDebondStraightStrands();
}

//-----------------------------------------------------------------------------
void CBridgeAgentImp::ListDebondableStrands(const CSegmentKey& segmentKey,const ConfigStrandFillVector& rFillArray,pgsTypes::StrandType strandType, IIndexArray** list) const
{
   ATLASSERT(strandType != pgsTypes::Permanent);

   GET_IFACE(IBridgeDescription,pIBridgeDesc);
   const CBridgeDescription2* pBridgeDesc = pIBridgeDesc->GetBridgeDescription();
   const CGirderGroupData*    pGroup      = pBridgeDesc->GetGirderGroup(segmentKey.groupIndex);
   const CSplicedGirderData*  pGirder     = pGroup->GetGirder(segmentKey.girderIndex);

   ListDebondableStrands(pGirder->GetGirderName(),rFillArray,strandType,list);
}

void CBridgeAgentImp::ListDebondableStrands(LPCTSTR strGirderName,const ConfigStrandFillVector& rFillArray,pgsTypes::StrandType strandType, IIndexArray** list) const
{
   ATLASSERT(strandType != pgsTypes::Permanent);

   CComPtr<IIndexArray> debondableStrands;  // array index = strand index, value = {0 means can't debond, 1 means can debond}
   debondableStrands.CoCreateInstance(CLSID_IndexArray);
   ATLASSERT(debondableStrands);

   GET_IFACE(ILibrary,pLib);
   const GirderLibraryEntry* pGirderEntry = pLib->GetGirderEntry( strGirderName );

   if ( strandType == pgsTypes::Straight)
   {
      ConfigStrandFillConstIterator it = rFillArray.begin();
      ConfigStrandFillConstIterator itend = rFillArray.end();

      GridIndexType gridIdx = 0;
      while(it != itend)
      {
         StrandIndexType nfill = *it;
         if (0 < nfill)
         {
            Float64 start_x, start_y, end_x, end_y;
            bool can_debond;
            pGirderEntry->GetStraightStrandCoordinates(gridIdx, &start_x, &start_y, &end_x, &end_y, &can_debond);

            debondableStrands->Add(can_debond?1:0);

            // have two strands?
            if (nfill==2)
            {
               ATLASSERT(0 < start_x && 0 < end_x);
               debondableStrands->Add(can_debond?1:0);
            }
         }

         gridIdx++;
         it++;
      }
   }
   else
   {
      // temp and harped. Redim zeros array
      debondableStrands->ReDim( PRESTRESSCONFIG::CountStrandsInFill(rFillArray) );
   }

   debondableStrands.CopyTo(list);
}

//-----------------------------------------------------------------------------
std::vector<RowIndexType> CBridgeAgentImp::GetRowsWithDebonding(const CSegmentKey& segmentKey, pgsTypes::StrandType strandType, const GDRCONFIG* pConfig) const
{
   ATLASSERT(strandType != pgsTypes::Permanent);

   std::vector<RowIndexType> vRows;
   if (strandType == pgsTypes::Straight)
   {
      CComPtr<IPrecastGirder> girder;
      GetGirder(segmentKey, &girder);

      CComPtr<IStrandModel> strandModel;
      girder->get_StrandModel(&strandModel);

      GET_IFACE(IBridgeDescription, pIBridgeDesc);
      const CPrecastSegmentData* pSegment = pIBridgeDesc->GetPrecastSegmentData(segmentKey);
      CStrandConfigSwapper swapper(pSegment, girder, pConfig);

      CComPtr<IIndexArray> array;
      strandModel->GetStraightStrandDebondedRows(0.0,&array);

      CComPtr<IEnumIndexArray> enum_array;
      array->get__EnumElements(&enum_array);
      IndexType rowIdx;
      while(enum_array->Next(1, &rowIdx, nullptr) != S_FALSE)
      {
         vRows.push_back(rowIdx);
      }
   }

   return vRows;
}

IndexType CBridgeAgentImp::GetDebondConfigurationCountByRow(const CSegmentKey& segmentKey, pgsTypes::StrandType strandType, RowIndexType rowIdx, const GDRCONFIG* pConfig) const
{
   ATLASSERT(strandType != pgsTypes::Permanent);

   IndexType nConfigs = 0;
   if (strandType == pgsTypes::Straight)
   {
      CComPtr<IPrecastGirder> girder;
      GetGirder(segmentKey, &girder);

      CComPtr<IStrandModel> strandModel;
      girder->get_StrandModel(&strandModel);

      GET_IFACE(IBridgeDescription, pIBridgeDesc);
      const CPrecastSegmentData* pSegment = pIBridgeDesc->GetPrecastSegmentData(segmentKey);
      CStrandConfigSwapper swapper(pSegment, girder, pConfig);

      strandModel->GetStraightStrandDebondedConfigurationCountByRow(0.0, rowIdx, &nConfigs);
   }

   return nConfigs;
}

void CBridgeAgentImp::GetDebondConfigurationByRow(const CSegmentKey& segmentKey, pgsTypes::StrandType strandType, RowIndexType rowIdx, IndexType configIdx, const GDRCONFIG* pConfig, Float64* pXstart, Float64* pLstrand, Float64* pCgX, Float64* pCgY, StrandIndexType* pnStrands) const
{
   ATLASSERT(strandType != pgsTypes::Permanent);

   if (strandType == pgsTypes::Straight)
   {
      CComPtr<IPrecastGirder> girder;
      GetGirder(segmentKey, &girder);

      CComPtr<IStrandModel> strandModel;
      girder->get_StrandModel(&strandModel);

      GET_IFACE(IBridgeDescription, pIBridgeDesc);
      const CPrecastSegmentData* pSegment = pIBridgeDesc->GetPrecastSegmentData(segmentKey);
      CStrandConfigSwapper swapper(pSegment, girder, pConfig);

      strandModel->GetStraightStrandDebondConfigurationByRow(0.0, rowIdx, configIdx, pXstart, pLstrand, pCgX, pCgY, pnStrands);
   }
   else
   {
      *pXstart = 0;
      *pLstrand = 0;
      *pCgX = 0;
      *pCgY = 0;
      *pnStrands = 0;
   }
}

std::vector<CComPtr<IRect2d>> CBridgeAgentImp::GetWebWidthProjectionsForDebonding(const CSegmentKey& segmentKey, pgsTypes::MemberEndType endType, Float64* pFraDebonded, Float64* pBottomFlangeToWebWidthRatio) const
{
   PoiList vPoi;
   GetPointsOfInterest(segmentKey, POI_RELEASED_SEGMENT | (endType == pgsTypes::metStart ? POI_0L : POI_10L), &vPoi);
   ATLASSERT(vPoi.size() == 1);

   *pFraDebonded = -1; // -1 indicates invalid value
   *pBottomFlangeToWebWidthRatio = -1; // -1 indicates invalid value

   const pgsPointOfInterest& poi(vPoi.front());
   CComPtr<IGirderSection> girder_section;
   HRESULT hr = GetGirderSection(poi, &girder_section);
   ATLASSERT(SUCCEEDED(hr));
   if (FAILED(hr))
   {
      return std::vector<CComPtr<IRect2d>>();
   }

   IndexType nWebs = GetWebCount(segmentKey);
   IndexType nFlanges = GetBottomFlangeCount(segmentKey);
   if (nWebs == 1 && nFlanges == 1)
   {
      // this is a single web flanged section (9th Edition, LRFD 5.9.4.3.3, Item I)
      // We need to check the debonding ratio to see if the web width projection applies
      StrandIndexType nStrands = GetStrandCount(segmentKey, pgsTypes::Permanent);
      StrandIndexType nDebonded = GetNumDebondedStrands(segmentKey, pgsTypes::Permanent, pgsTypes::dbetEither);
      Float64 fra = (nStrands == 0 ? 0 : (Float64)nDebonded / (Float64)nStrands);
      *pFraDebonded = fra;
      
      // also need to check the bottom flange to web width ratio
      Float64 bf = GetBottomFlangeWidth(poi);
      Float64 bw = GetBottomFlangeThickness(poi, 0);
      Float64 ratio = bf / bw;
      *pBottomFlangeToWebWidthRatio = ratio;

      if (::IsLE(fra,0.25) && ::IsLE(ratio,4.0))
      {
         // 9th Edition, LRFD 5.9.4.3.3, Item I
         // 25% or fewer of the strands are debonded and the bottom flange to web width
         // ratio does not exceed 4... strands may be debonded in the web width projectio
         return std::vector<CComPtr<IRect2d>>();
      }
   }

   CComQIPtr<IPrestressedGirderSection> psg_section(girder_section);

   std::vector<CComPtr<IRect2d>> vRegions;
   CComPtr<IUnkArray> arrUnk;
   hr = psg_section->GetWebWidthProjectionsForDebonding(&arrUnk);
   if (SUCCEEDED(hr) && arrUnk)
   {
      CComPtr<IEnumUnkArray> enumElements;
      arrUnk->get__EnumElements(&enumElements);
      CComPtr<IUnknown> unk;
      while (enumElements->Next(1, &unk, nullptr) != S_FALSE)
      {
         CComQIPtr<IRect2d> rect(unk);
         vRegions.push_back(rect);
         unk.Release();
      };
   }

   return vRegions;
}

//-----------------------------------------------------------------------------
bool CBridgeAgentImp::HasDebonding(const CSegmentKey& segmentKey, const GDRCONFIG* pConfig) const
{
   std::array<StrandIndexType, 3> Ndb;
   Ndb[pgsTypes::Straight]  = GetNumDebondedStrands(segmentKey, pgsTypes::Straight,  pgsTypes::dbetEither, pConfig);
   Ndb[pgsTypes::Harped]    = GetNumDebondedStrands(segmentKey, pgsTypes::Harped,    pgsTypes::dbetEither, pConfig);
   Ndb[pgsTypes::Temporary] = GetNumDebondedStrands(segmentKey, pgsTypes::Temporary, pgsTypes::dbetEither, pConfig);

   return ( Ndb[pgsTypes::Straight] == 0 && Ndb[pgsTypes::Harped] == 0 && Ndb[pgsTypes::Temporary] == 0 ? false : true);
}

bool CBridgeAgentImp::IsDebondingSymmetric(const CSegmentKey& segmentKey, const GDRCONFIG* pConfig) const
{
   std::array<StrandIndexType, 3> Ndb;
   Ndb[pgsTypes::Straight]  = GetNumDebondedStrands(segmentKey, pgsTypes::Straight,  pgsTypes::dbetEither, pConfig);
   Ndb[pgsTypes::Harped]    = GetNumDebondedStrands(segmentKey, pgsTypes::Harped,    pgsTypes::dbetEither, pConfig);
   Ndb[pgsTypes::Temporary] = GetNumDebondedStrands(segmentKey, pgsTypes::Temporary, pgsTypes::dbetEither, pConfig);

   // if there are no debonded strands then get the heck outta here
   if ( Ndb[pgsTypes::Straight] == 0 && Ndb[pgsTypes::Harped] == 0 && Ndb[pgsTypes::Temporary] )
   {
      return true;
   }

   Float64 length = GetSegmentLength(segmentKey);

   // check the debonding to see if it is symmetric
   for ( int i = 0; i < 3; i++ )
   {
      StrandIndexType nDebonded = Ndb[i];
      if ( nDebonded == 0 )
      {
         continue;
      }

      pgsTypes::StrandType strandType = (pgsTypes::StrandType)(i);

      StrandIndexType n = GetStrandCount(segmentKey,strandType, pConfig);
      for ( StrandIndexType strandIdx = 0; strandIdx < n; strandIdx++ )
      {
         Float64 start, end;

         bool bIsDebonded = IsStrandDebonded(segmentKey,strandIdx,strandType,pConfig,&start,&end);
         if ( bIsDebonded && !IsEqual(start,length-end) )
         {
            return false;
         }
      }
   }

   return true;
}

RowIndexType CBridgeAgentImp::GetNumRowsWithStrand(const pgsPointOfInterest& poi,StrandIndexType nStrands,pgsTypes::StrandType strandType ) const
{
   ATLASSERT(strandType != pgsTypes::Permanent);

   VALIDATE( GIRDER );

   const CSegmentKey& segmentKey(poi.GetSegmentKey());
   Float64 Xpoi = poi.GetDistFromStart();

   CComPtr<IPrecastGirder> girder;
   GetGirder(segmentKey,&girder);

   CComPtr<IStrandModel> strandModel;
   girder->get_StrandModel(&strandModel);
   CComQIPtr<IStrandGridModel> strandGridModel(strandModel);

   CComPtr<IIndexArray> oldFill;
   CComPtr<IIndexArray> fill;

   RowIndexType nRows = 0;
   HRESULT hr;
   switch( strandType )
   {
   case pgsTypes::Straight:
      m_StrandFillers[segmentKey].ComputeStraightStrandFill(strandGridModel, nStrands, &fill);
      strandGridModel->get_StrandFill(Straight,&oldFill);
      strandGridModel->putref_StrandFill(Straight,fill);
      hr = strandModel->GetStrandRowCount(Straight,Xpoi,&nRows);
      strandGridModel->putref_StrandFill(Straight,oldFill);
      break;

   case pgsTypes::Harped:
      m_StrandFillers[segmentKey].ComputeHarpedStrandFill(strandGridModel, nStrands, &fill);
      strandGridModel->get_StrandFill(Harped,&oldFill);
      strandGridModel->putref_StrandFill(Harped,fill);
      hr = strandModel->GetStrandRowCount(Harped,Xpoi,&nRows);
      strandGridModel->putref_StrandFill(Harped,oldFill);
      break;

   case pgsTypes::Temporary:
      hr = S_FALSE; // Assumed only bonded for the end 10'... PS force is constant through the debonded section
                    // this is different than strands debonded at the ends and bonded in the middle
                    // Treat this strand as bonded
      break;

   default:
      ATLASSERT(false); // should never get here
   }

   return nRows;
}

StrandIndexType CBridgeAgentImp::GetNumStrandInRow(const pgsPointOfInterest& poi,StrandIndexType nStrands,RowIndexType rowIdx,pgsTypes::StrandType strandType ) const
{
   ATLASSERT(strandType != pgsTypes::Permanent);

   VALIDATE( GIRDER );

   const CSegmentKey& segmentKey(poi.GetSegmentKey());
   Float64 Xpoi = poi.GetDistFromStart();

   CComPtr<IPrecastGirder> girder;
   GetGirder(segmentKey,&girder);

   CComPtr<IStrandModel> strandModel;
   girder->get_StrandModel(&strandModel);
   CComQIPtr<IStrandGridModel> strandGridModel(strandModel);

   CComPtr<IIndexArray> oldFill;
   CComPtr<IIndexArray> fill;

   StrandIndexType cStrands = 0;
   HRESULT hr;
   switch( strandType )
   {
   case pgsTypes::Straight:
      m_StrandFillers[segmentKey].ComputeStraightStrandFill(strandGridModel, nStrands, &fill);
      strandGridModel->get_StrandFill(Straight,&oldFill);
      strandGridModel->putref_StrandFill(Straight,fill);
      hr = strandModel->GetNumStrandsInRow(Straight,Xpoi,rowIdx,&cStrands);
      strandGridModel->putref_StrandFill(Straight,oldFill);
      break;

   case pgsTypes::Harped:
      m_StrandFillers[segmentKey].ComputeHarpedStrandFill(strandGridModel, nStrands, &fill);
      strandGridModel->get_StrandFill(Harped,&oldFill);
      strandGridModel->putref_StrandFill(Harped,fill);
      hr = strandModel->GetNumStrandsInRow(Harped,Xpoi,rowIdx,&cStrands);
      strandGridModel->putref_StrandFill(Harped,oldFill);
      break;

   case pgsTypes::Temporary:
      hr = S_FALSE; // Assumed only bonded for the end 10'... PS force is constant through the debonded section
                    // this is different than strands debonded at the ends and bonded in the middle
                    // Treat this strand as bonded
      break;

   default:
      ATLASSERT(false); // should never get here
   }

   return cStrands;
}

std::vector<StrandIndexType> CBridgeAgentImp::GetStrandsInRow(const pgsPointOfInterest& poi,StrandIndexType nStrands,RowIndexType rowIdx, pgsTypes::StrandType strandType ) const
{
   ATLASSERT(strandType != pgsTypes::Permanent);

   std::vector<StrandIndexType> strandIdxs;
   if ( strandType == pgsTypes::Temporary )
   {
      ATLASSERT(false); // shouldn't get here
      return strandIdxs;
   }

   VALIDATE( GIRDER );

   const CSegmentKey& segmentKey(poi.GetSegmentKey());
   Float64 Xpoi = poi.GetDistFromStart();

   CComPtr<IPrecastGirder> girder;
   GetGirder(segmentKey,&girder);

   CComPtr<IStrandModel> strandModel;
   girder->get_StrandModel(&strandModel);
   CComQIPtr<IStrandGridModel> strandGridModel(strandModel);

   CComPtr<IIndexArray> oldFill;
   CComPtr<IIndexArray> fill;
   CComPtr<IIndexArray> array;

   if ( strandType == pgsTypes::Straight )
   {
      m_StrandFillers[segmentKey].ComputeStraightStrandFill(strandGridModel, nStrands, &fill);
      strandGridModel->get_StrandFill(Straight,&oldFill);
      strandGridModel->putref_StrandFill(Straight,fill);
      strandGridModel->GetStrandsInRow(Straight,Xpoi,rowIdx,&array);
      strandGridModel->putref_StrandFill(Straight,oldFill);
   }
   else
   {
      m_StrandFillers[segmentKey].ComputeHarpedStrandFill(strandGridModel, nStrands, &fill);
      strandGridModel->get_StrandFill(Harped,&oldFill);
      strandGridModel->putref_StrandFill(Harped,fill);
      strandGridModel->GetStrandsInRow(Harped,Xpoi,rowIdx,&array);
      strandGridModel->putref_StrandFill(Harped,oldFill);
   }

   CollectionIndexType nItems;

   array->get_Count(&nItems);
   for ( CollectionIndexType i = 0; i < nItems; i++ )
   {
      StrandIndexType strandIdx;
      array->get_Item(i,&strandIdx);
      strandIdxs.push_back(strandIdx);
   }

   return strandIdxs;
}

//-----------------------------------------------------------------------------
void CBridgeAgentImp::GetStrandPosition(const pgsPointOfInterest& poi, StrandIndexType strandIdx,pgsTypes::StrandType strandType, IPoint2d** ppPoint) const
{
   ATLASSERT(strandType != pgsTypes::Permanent);

   CComPtr<IPoint2dCollection> points;
   GetStrandPositions(poi, strandType,&points);
   points->get_Item(strandIdx,ppPoint);
}

void CBridgeAgentImp::GetStrandPositions(const pgsPointOfInterest& poi, pgsTypes::StrandType strandType, IPoint2dCollection** ppPoints) const
{
   ATLASSERT(strandType != pgsTypes::Permanent);

   VALIDATE( GIRDER );
   CComPtr<IPrecastGirder> girder;
   GetGirder(poi,&girder);

   Float64 Xpoi = poi.GetDistFromStart();
   Float64 Ls = GetSegmentLength(poi.GetSegmentKey());
   Float64 Xg = ::ForceIntoRange(0.0,Xpoi,Ls);

   CComPtr<IStrandModel> strandModel;
   girder->get_StrandModel(&strandModel);

   HRESULT hr = strandModel->GetStrandPositions((StrandType)strandType, Xg, ppPoints);
   ATLASSERT(SUCCEEDED(hr));
}

void CBridgeAgentImp::GetStrandPositionsEx(const pgsPointOfInterest& poi,const PRESTRESSCONFIG& rconfig, pgsTypes::StrandType strandType, IPoint2dCollection** ppPoints) const
{
   ATLASSERT(strandType != pgsTypes::Permanent);

   VALIDATE( GIRDER );
   CComPtr<IPrecastGirder> girder;
   GetGirder(poi,&girder);

   const CSegmentKey& segmentKey(poi.GetSegmentKey());
   Float64 Xpoi = poi.GetDistFromStart();
   Float64 Ls = GetSegmentLength(segmentKey);
   Float64 Xg = ::ForceIntoRange(0.0,Xpoi,Ls);

   CComPtr<IStrandModel> strandModel;
   girder->get_StrandModel(&strandModel);
   CComQIPtr<IStrandGridModel> strandGridModel(strandModel);

   CIndexArrayWrapper fill(rconfig.GetStrandFill(strandType));

   HRESULT hr = S_OK;
   switch(strandType)
   {
   case pgsTypes::Straight:
      hr = strandGridModel->GetStrandPositionsEx(Straight,Xg,&fill,ppPoints);
      break;

   case pgsTypes::Harped:
      // Use CStrandMoverSwapper to temporarily swap out girder's strand mover and harping offset limits
      //  for design
      {
         IntervalIndexType releaseIntervalIdx = GetPrestressReleaseInterval(segmentKey);
         Float64 Hg = GetHg(releaseIntervalIdx,poi);

         GET_IFACE(IBridgeDescription,pIBridgeDesc);
         CStrandMoverSwapper swapper(segmentKey, Hg, rconfig, this, strandGridModel, pIBridgeDesc);

         hr = strandGridModel->GetStrandPositionsEx(Harped, Xg, &fill,ppPoints);
      }
      break;

   case pgsTypes::Temporary:
      hr = strandGridModel->GetStrandPositionsEx(Temporary, Xg, &fill,ppPoints);
      break;

   default:
      ATLASSERT(false); // shouldn't get here
   }

#ifdef _DEBUG
   CollectionIndexType np;
   (*ppPoints)->get_Count(&np);
   ATLASSERT(np==rconfig.GetStrandCount(strandType));
#endif

   ATLASSERT(SUCCEEDED(hr));
}

void CBridgeAgentImp::GetStrandPositionEx(const pgsPointOfInterest& poi, StrandIndexType strandIdx,pgsTypes::StrandType strandType, const PRESTRESSCONFIG& rconfig,IPoint2d** ppPoint) const
{
   CComPtr<IPoint2dCollection> points;
   GetStrandPositionsEx(poi,rconfig,strandType,&points);
   points->get_Item(strandIdx,ppPoint);
}

void CBridgeAgentImp::GetStrandPositionsEx(LPCTSTR strGirderName,Float64 HgStart,Float64 HgHp1,Float64 HgHp2,Float64 HgEnd,const PRESTRESSCONFIG& rconfig,
                                           pgsTypes::StrandType strandType,pgsTypes::MemberEndType endType,
                                           IPoint2dCollection** ppPoints) const
{
   ATLASSERT(strandType != pgsTypes::Permanent);

   GET_IFACE(ILibrary,pLib);
   const GirderLibraryEntry* pGdrEntry = pLib->GetGirderEntry(strGirderName);

   CComPtr<IStrandGrid> startGrid, endGrid;
   startGrid.CoCreateInstance(CLSID_StrandGrid);
   endGrid.CoCreateInstance(CLSID_StrandGrid);

   CComQIPtr<IStrandGridFiller> gridFiller(startGrid);

   CIndexArrayWrapper fill(rconfig.GetStrandFill(strandType));

   HRESULT hr = S_OK;
   switch(strandType)
   {
   case pgsTypes::Straight:
      pGdrEntry->ConfigureStraightStrandGrid(HgStart,HgEnd,startGrid,endGrid);
      gridFiller->GetStrandPositionsEx(&fill,ppPoints);
      break;

   case pgsTypes::Harped:
      {
      CComPtr<IStrandGrid> startHPGrid, endHPGrid;
      startHPGrid.CoCreateInstance(CLSID_StrandGrid);
      endHPGrid.CoCreateInstance(CLSID_StrandGrid);
      pGdrEntry->ConfigureHarpedStrandGrids(HgStart,HgHp1,HgHp2,HgEnd,startGrid,startHPGrid,endHPGrid,endGrid);
      CComQIPtr<IStrandGridFiller> hpGridFiller(endType == pgsTypes::metStart ? startHPGrid : endHPGrid);
      gridFiller->GetStrandPositionsEx(&fill,ppPoints);
      }
      break;

   case pgsTypes::Temporary:
      pGdrEntry->ConfigureTemporaryStrandGrid(HgStart,HgEnd,startGrid,endGrid);
      gridFiller->GetStrandPositionsEx(&fill,ppPoints);
      break;

   default:
      ATLASSERT(false); // is there a new strand type?
   }

   ATLASSERT(SUCCEEDED(hr));
}

Float64 CBridgeAgentImp::ComputeAbsoluteHarpedOffsetEnd(const CSegmentKey& segmentKey, pgsTypes::MemberEndType endType, const ConfigStrandFillVector& rHarpedFillArray, HarpedStrandOffsetType measurementType, Float64 offset) const
{
   // returns the offset value measured from the original strand locations defined in the girder library
   // Up is positive
   Float64 HgStart, HgHp1, HgHp2, HgEnd;
   GetHarpedStrandControlHeights(segmentKey, &HgStart, &HgHp1, &HgHp2, &HgEnd);

   GET_IFACE(IBridgeDescription, pIBridgeDesc);
   const CSplicedGirderData* pGirder = pIBridgeDesc->GetGirder(segmentKey);
   const CPrecastSegmentData* pSegment = pGirder->GetSegment(segmentKey.segmentIndex);

   pgsTypes::AdjustableStrandType adjType = pSegment->Strands.GetAdjustableStrandType();
   Float64 absOffset = ComputeAbsoluteHarpedOffsetEnd(pGirder->GetGirderName(), endType, adjType, HgStart, HgHp1, HgHp2, HgEnd, rHarpedFillArray, measurementType, offset);

#if defined _DEBUG
   CComPtr<IPrecastGirder> girder;
   GetGirder(segmentKey, &girder);

   CComPtr<IStrandModel> strandModel;
   girder->get_StrandModel(&strandModel);
   CComQIPtr<IStrandGridModel> strandGridModel(strandModel);
   if (strandGridModel)
   {
      Float64 increment; // if less than zero, strands cannot be adjusted
      strandGridModel->get_HarpedEndAdjustmentIncrement(&increment);

      Float64 Hg = (endType == pgsTypes::metStart ? HgStart : HgEnd);

      Float64 result = 0;
      if (AreStrandsInConfigFillVec(rHarpedFillArray))
      {
         if (measurementType == hsoLEGACY)
         {
            // legacy end offset moved top strand to highest location in strand grid and then measured down
            CComPtr<IStrandGrid> grid;
            strandGridModel->get_HarpedStrandGridEnd((EndType)endType, &grid);

            CComPtr<IRect2d> grid_box;
            grid->GridBoundingBox(&grid_box);

            Float64 grid_bottom, grid_top;
            grid_box->get_Bottom(&grid_bottom);
            grid_box->get_Top(&grid_top);

            CIndexArrayWrapper fill(rHarpedFillArray);

            Float64 fill_top, fill_bottom;
            strandGridModel->GetHarpedEndFilledGridBoundsEx((EndType)endType, &fill, &fill_bottom, &fill_top);

            Float64 vert_adjust;
            strandGridModel->get_HarpedStrandAdjustmentEnd((EndType)endType, &vert_adjust);

            result = grid_top - (fill_top - vert_adjust) - offset;
         }
         else if (measurementType == hsoCGFROMTOP || measurementType == hsoCGFROMBOTTOM || measurementType == hsoECCENTRICITY)
         {
            // compute adjusted cg location
            CIndexArrayWrapper fill(rHarpedFillArray);

            Float64 Lsegment = GetSegmentLength(segmentKey);
            Float64 Xg = (endType == pgsTypes::metStart ? 0.0 : Lsegment);

            CComPtr<IPoint2dCollection> points;
            strandGridModel->GetStrandPositionsEx(Harped, Xg, &fill, &points);

            Float64 cg = 0.0;

            CollectionIndexType nStrands;
            points->get_Count(&nStrands);
            ATLASSERT(CountStrandsInConfigFillVec(rHarpedFillArray) == nStrands);
            for (CollectionIndexType strandIdx = 0; strandIdx < nStrands; strandIdx++)
            {
               CComPtr<IPoint2d> point;
               points->get_Item(strandIdx, &point);
               Float64 y;
               point->get_Y(&y);

               cg += y;
            }

            cg = cg / (Float64)nStrands;

            // compute unadjusted location of cg
            Float64 vert_adjust;
            strandGridModel->get_HarpedStrandAdjustmentEnd((EndType)endType, &vert_adjust);

            cg -= vert_adjust;

            if (measurementType == hsoCGFROMTOP)
            {
               Float64 dist = -cg;
               result = dist - offset;

            }
            else if (measurementType == hsoCGFROMBOTTOM)
            {
               // top is a Y=0.0
               result = offset - (Hg + cg);
            }
            else if (measurementType == hsoECCENTRICITY)
            {
               IntervalIndexType releaseIntervalIdx = GetPrestressReleaseInterval(segmentKey);
               Float64 Yb = GetY(releaseIntervalIdx, pgsPointOfInterest(segmentKey, 0.0), pgsTypes::BottomGirder);
               Float64 ecc = Yb - (Hg + cg);

               result = ecc - offset;
            }
            else
            {
               ATLASSERT(false);
            }
         }
         else if (measurementType == hsoTOP2TOP || measurementType == hsoTOP2BOTTOM)
         {
            // get strand grid positions that are filled by Nh strands
            CIndexArrayWrapper fill(rHarpedFillArray);

            // fill_top is the top of the strand positions that are actually filled
            // adjusted by the harped strand adjustment
            Float64 fill_top, fill_bottom;
            strandGridModel->GetHarpedEndFilledGridBoundsEx((EndType)endType, &fill, &fill_bottom, &fill_top);

            // get the harped strand adjustment so its effect can be removed
            Float64 vert_adjust;
            strandGridModel->get_HarpedStrandAdjustmentEnd((EndType)endType, &vert_adjust);

            // elevation of the top of the strand grid without an offset
            Float64 toploc = fill_top - vert_adjust;

            if (measurementType == hsoTOP2TOP)
            {
               Float64 height;
               strandGridModel->get_TopElevation(&height);

               // distance from the top of the girder to the top of the strands before offset
               Float64 dist = height - toploc;

               // distance from the top of the girder to the top of the strands after offset
               result = dist - offset;
            }
            else  // measurementType==hsoTOP2BOTTOM
            {
               ATLASSERT(measurementType == hsoTOP2BOTTOM);
               result = offset - (Hg + toploc);
            }
         }
         else if (measurementType == hsoBOTTOM2BOTTOM)
         {
            CIndexArrayWrapper fill(rHarpedFillArray);

            Float64 fill_top, fill_bottom;
            strandGridModel->GetHarpedEndFilledGridBoundsEx((EndType)endType, &fill, &fill_bottom, &fill_top);

            Float64 vert_adjust;
            strandGridModel->get_HarpedStrandAdjustmentEnd((EndType)endType, &vert_adjust);

            Float64 botloc = fill_bottom - vert_adjust;

            result = offset - (Hg + botloc);
         }
         else
         {
            ATLASSERT(false);
         }
      }

      ATLASSERT(IsEqual(result, absOffset));
   }
#endif // _DEBUG
   return absOffset;
}

Float64 CBridgeAgentImp::ComputeAbsoluteHarpedOffsetEnd(LPCTSTR strGirderName,pgsTypes::MemberEndType endType,pgsTypes::AdjustableStrandType adjType,Float64 HgStart,Float64 HgHp1,Float64 HgHp2,Float64 HgEnd,const ConfigStrandFillVector& rHarpedFillArray, HarpedStrandOffsetType measurementType, Float64 offset) const
{
   // returns the offset value measured from the original strand locations defined in the girder library
   // Up is positive
   if ( !AreStrandsInConfigFillVec(rHarpedFillArray) )
   {
      return 0.0;
   }

   Float64 Hg = (endType == pgsTypes::metStart ? HgStart : HgEnd);

   CComPtr<IStrandMover> pStrandMover;
   CreateStrandMover(strGirderName,Hg,adjType,&pStrandMover);

   CComPtr<IStrandGrid> startGrid, startHPGrid, endHPGrid, endGrid;
   startGrid.CoCreateInstance(CLSID_StrandGrid);
   startHPGrid.CoCreateInstance(CLSID_StrandGrid);
   endHPGrid.CoCreateInstance(CLSID_StrandGrid);
   endGrid.CoCreateInstance(CLSID_StrandGrid);

   GET_IFACE(ILibrary,pLib);
   const GirderLibraryEntry* pGdrEntry = pLib->GetGirderEntry(strGirderName);
   pGdrEntry->ConfigureHarpedStrandGrids(HgStart,HgHp1,HgHp2,HgEnd,startGrid,startHPGrid,endHPGrid,endGrid);

   CIndexArrayWrapper fill(rHarpedFillArray);

   Float64 absOffset = 0;
   if (measurementType==hsoLEGACY)
   {
      // legacy end offset moved top strand to highest location in strand grid and then measured down
      CComPtr<IRect2d> grid_box;
      if ( endType == pgsTypes::metStart )
      {
         startGrid->GridBoundingBox(&grid_box);
      }
      else
      {
         endGrid->GridBoundingBox(&grid_box);
      }

      Float64 grid_bottom, grid_top;
      grid_box->get_Bottom(&grid_bottom);
      grid_box->get_Top(&grid_top);

      CComQIPtr<IStrandGridFiller> startGridFiller(endType == pgsTypes::metStart ? startGrid : endGrid);
      CComQIPtr<IStrandGridFiller> hpGridFiller(endType == pgsTypes::metStart ? startHPGrid : endHPGrid);

      Float64 fill_top, fill_bottom;
      startGridFiller->get_FilledGridBoundsEx(&fill, &fill_bottom, &fill_top);

      Float64 dx,dy;
      startGridFiller->GetStrandAdjustment(&dx,&dy);

      absOffset = grid_top - (fill_top - dy) - offset;
   }
   else if (measurementType==hsoCGFROMTOP || measurementType==hsoCGFROMBOTTOM || measurementType==hsoECCENTRICITY)
   {
      // compute adjusted cg location
      CComQIPtr<IStrandGridFiller> startGridFiller(endType == pgsTypes::metStart ? startGrid : endGrid);
      CComQIPtr<IStrandGridFiller> hpGridFiller(endType == pgsTypes::metStart ? startHPGrid : endHPGrid);

      CComPtr<IPoint2dCollection> points;
      startGridFiller->GetStrandPositionsEx(&fill,&points);

      Float64 cg=0.0;

      CollectionIndexType nStrands;
      points->get_Count(&nStrands);
      ATLASSERT(CountStrandsInConfigFillVec(rHarpedFillArray) == nStrands);
      for (CollectionIndexType strandIdx = 0; strandIdx < nStrands; strandIdx++)
      {
         CComPtr<IPoint2d> point;
         points->get_Item(strandIdx,&point);
         Float64 y;
         point->get_Y(&y);

         cg += y;
      }

      cg = cg / (Float64)nStrands;

      // compute unadjusted location of cg
      Float64 dx, dy;
      startGridFiller->GetStrandAdjustment(&dx,&dy);

      cg -= dy;

      if (measurementType==hsoCGFROMTOP)
      {
         Float64 dist = -cg;
         absOffset  = dist - offset;
      }
      else if ( measurementType==hsoCGFROMBOTTOM)
      {
         // top is a Y=0.0
         absOffset =  offset - (Hg+cg);
      }
      else if (measurementType==hsoECCENTRICITY)
      {
         CComPtr<IBeamFactory> factory;
         pGdrEntry->GetBeamFactory(&factory);

         CComPtr<IGirderSection> gdrSection;
         factory->CreateGirderSection(m_pBroker,INVALID_ID,pGdrEntry->GetDimensions(),-1,-1,&gdrSection);

         CComQIPtr<IShape> shape(gdrSection);
         CComPtr<IShapeProperties> props;
         shape->get_ShapeProperties(&props);
         Float64 Yb;
         props->get_Ybottom(&Yb);

         Float64 ecc = Yb - (Hg+cg);

         absOffset = ecc - offset;
      }
   }
   else if (measurementType==hsoTOP2TOP || measurementType==hsoTOP2BOTTOM)
   {
      // get strand grid positions that are filled by Nh strands
      CComQIPtr<IStrandGridFiller> startGridFiller(endType == pgsTypes::metStart ? startGrid : endGrid);
      
      // fill_top is the top of the strand positions that are actually filled
      // adjusted by the harped strand adjustment
      Float64 fill_top, fill_bottom;
      startGridFiller->get_FilledGridBoundsEx(&fill, &fill_bottom, &fill_top);

      // get the harped strand adjustment so its effect can be removed
      Float64 dx,dy;
      startGridFiller->GetStrandAdjustment(&dx,&dy);

      // elevation of the top of the strand grid without an offset
      Float64 toploc = fill_top - dy;

      if (measurementType==hsoTOP2TOP)
      {
         Float64 height;
         pStrandMover->get_TopElevation(&height);

         // distance from the top of the girder to the top of the strands before offset
         Float64 dist = height - toploc;

         // distance from the top of the girder to the top of the strands after offset
         absOffset  = dist - offset;
      }
      else  // measurementType==hsoTOP2BOTTOM
      {
         ATLASSERT(measurementType == hsoTOP2BOTTOM);
         absOffset =  offset - (Hg+toploc);
      }
   }
   else if (measurementType==hsoBOTTOM2BOTTOM)
   {
      CComQIPtr<IStrandGridFiller> startGridFiller(endType == pgsTypes::metStart ? startGrid : endGrid);

      Float64 fill_top, fill_bottom;
      startGridFiller->get_FilledGridBoundsEx(&fill,&fill_bottom,&fill_top);

      Float64 dx,dy;
      startGridFiller->GetStrandAdjustment(&dx,&dy);

      Float64 botloc = fill_bottom - dy;

      absOffset =  offset - (Hg+botloc);
   }
   else
   {
      ATLASSERT(false);
   }

   return absOffset;
}

Float64 CBridgeAgentImp::ComputeAbsoluteHarpedOffsetHp(const CSegmentKey& segmentKey, pgsTypes::MemberEndType endType, const ConfigStrandFillVector& rHarpedFillArray, HarpedStrandOffsetType measurementType, Float64 offset) const
{
   // returns the offset value measured from the original strand locations defined in the girder library
   // Up is positive
   Float64 HgStart, HgHp1, HgHp2, HgEnd;
   GetHarpedStrandControlHeights(segmentKey, &HgStart, &HgHp1, &HgHp2, &HgEnd);

   GET_IFACE(IBridgeDescription, pIBridgeDesc);
   const CSplicedGirderData* pGirder = pIBridgeDesc->GetGirder(segmentKey);
   const CPrecastSegmentData* pSegment = pGirder->GetSegment(segmentKey.segmentIndex);

   pgsTypes::AdjustableStrandType adjType = pSegment->Strands.GetAdjustableStrandType();
   Float64 absOffset = ComputeAbsoluteHarpedOffsetHp(pGirder->GetGirderName(), endType, adjType, HgStart, HgHp1, HgHp2, HgEnd, rHarpedFillArray, measurementType, offset);

#if defined _DEBUG

   //   VALIDATE( GIRDER );
   CComPtr<IPrecastGirder> girder;
   GetGirder(segmentKey, &girder);

   CComPtr<IStrandModel> strandModel;
   girder->get_StrandModel(&strandModel);
   CComQIPtr<IStrandGridModel> strandGridModel(strandModel);
   if (strandGridModel)
   {
      Float64 increment; // if less than zero, strands cannot be adjusted
      strandGridModel->get_HarpedHpAdjustmentIncrement(&increment);

      Float64 Hg = (endType == pgsTypes::metStart ? HgHp1 : HgHp2);

      Float64 result = 0;
      if (AreStrandsInConfigFillVec(rHarpedFillArray))
      {
         if (measurementType == hsoLEGACY)
         {
            result = offset;
         }
         else if (measurementType == hsoCGFROMTOP || measurementType == hsoCGFROMBOTTOM || measurementType == hsoECCENTRICITY)
         {
            // compute adjusted cg location
            CIndexArrayWrapper fill(rHarpedFillArray);

            Float64 HP1, HP2;
            GetHarpingPointLocations(segmentKey, &HP1, &HP2);

            CComPtr<IPoint2dCollection> points;
            strandGridModel->GetStrandPositionsEx(Harped, (endType == pgsTypes::metStart ? HP1 : HP2), &fill, &points);

            Float64 cg = 0.0;

            CollectionIndexType nStrands;
            points->get_Count(&nStrands);
            ATLASSERT(CountStrandsInConfigFillVec(rHarpedFillArray) == nStrands);
            for (CollectionIndexType strandIdx = 0; strandIdx < nStrands; strandIdx++)
            {
               CComPtr<IPoint2d> point;
               points->get_Item(strandIdx, &point);
               Float64 y;
               point->get_Y(&y);

               cg += y;
            }

            cg = cg / (Float64)nStrands;

            // compute unadjusted location of cg
            Float64 vert_adjust;
            strandGridModel->get_HarpedStrandAdjustmentHP((EndType)endType, &vert_adjust);

            cg -= vert_adjust;

            if (measurementType == hsoCGFROMTOP)
            {
               Float64 height;
               strandGridModel->get_TopElevation(&height);

               Float64 dist = height - cg;
               result = dist - offset;

            }
            else if (measurementType == hsoCGFROMBOTTOM)
            {
               // top is a Y=0.0
               result = offset - (Hg + cg);
            }
            else if (measurementType == hsoECCENTRICITY)
            {
               IntervalIndexType releaseIntervalIdx = GetPrestressReleaseInterval(segmentKey);
               Float64 Yb = GetY(releaseIntervalIdx, pgsPointOfInterest(segmentKey, 0.0), pgsTypes::BottomGirder);
               Float64 ecc = Yb - (Hg + cg);

               result = ecc - offset;
            }
            else
            {
               ATLASSERT(false);
            }
         }
         else if (measurementType == hsoTOP2TOP || measurementType == hsoTOP2BOTTOM)
         {
            // get location of highest strand at zero offset
            CIndexArrayWrapper fill(rHarpedFillArray);

            Float64 fill_top, fill_bottom;
            strandGridModel->GetHarpedHpFilledGridBoundsEx((EndType)endType, &fill, &fill_bottom, &fill_top);

            Float64 vert_adjust;
            strandGridModel->get_HarpedStrandAdjustmentHP((EndType)endType, &vert_adjust);

            Float64 toploc = fill_top - vert_adjust;

            if (measurementType == hsoTOP2TOP)
            {
               Float64 height;
               strandGridModel->get_TopElevation(&height);

               Float64 dist = height - toploc;
               result = dist - offset;
            }
            else  // measurementType==hsoTOP2BOTTOM
            {
               ATLASSERT(measurementType == hsoTOP2BOTTOM);
               result = offset - (Hg + toploc);
            }
         }
         else if (measurementType == hsoBOTTOM2BOTTOM)
         {
            CIndexArrayWrapper fill(rHarpedFillArray);

            Float64 fill_top, fill_bottom;
            strandGridModel->GetHarpedHpFilledGridBoundsEx((EndType)endType, &fill, &fill_bottom, &fill_top);

            Float64 vert_adjust;
            strandGridModel->get_HarpedStrandAdjustmentHP((EndType)endType, &vert_adjust);

            Float64 botloc = fill_bottom - vert_adjust;

            result = offset - (Hg + botloc);
         }
         else
         {
            ATLASSERT(false);
         }
      }

      result = IsZero(result) ? 0.0 : result;
      ATLASSERT(IsEqual(result, absOffset));
   }
#endif // __DEBUG

   return absOffset;
}

Float64 CBridgeAgentImp::ComputeAbsoluteHarpedOffsetHp(LPCTSTR strGirderName,pgsTypes::MemberEndType endType,pgsTypes::AdjustableStrandType adjType,Float64 HgStart,Float64 HgHp1,Float64 HgHp2,Float64 HgEnd,const ConfigStrandFillVector& rHarpedFillArray, HarpedStrandOffsetType measurementType, Float64 offset) const
{
   // returns the offset value measured from the original strand locations defined in the girder library
   // Up is positive
   if ( !AreStrandsInConfigFillVec(rHarpedFillArray) )
   {
      return 0;
   }

   Float64 Hg = (endType == pgsTypes::metStart ? HgHp1 : HgHp2);

   CComPtr<IStrandMover> pStrandMover;
   CreateStrandMover(strGirderName,Hg,adjType,&pStrandMover);

   CComPtr<IStrandGrid> startGrid, startHPGrid, endHPGrid, endGrid;
   startGrid.CoCreateInstance(CLSID_StrandGrid);
   startHPGrid.CoCreateInstance(CLSID_StrandGrid);
   endHPGrid.CoCreateInstance(CLSID_StrandGrid);
   endGrid.CoCreateInstance(CLSID_StrandGrid);

   GET_IFACE(ILibrary,pLib);
   const GirderLibraryEntry* pGdrEntry = pLib->GetGirderEntry(strGirderName);
   pGdrEntry->ConfigureHarpedStrandGrids(HgStart,HgHp1,HgHp2,HgEnd,startGrid,startHPGrid,endHPGrid,endGrid);

   Float64 absOffset = 0;
   if (measurementType==hsoLEGACY)
   {
      absOffset = offset;
   }
   else if (measurementType==hsoCGFROMTOP || measurementType==hsoCGFROMBOTTOM || measurementType==hsoECCENTRICITY)
   {
      // compute adjusted cg location
      CComQIPtr<IStrandGridFiller> hpGridFiller(endType == pgsTypes::metStart ? startHPGrid : endHPGrid);

      CIndexArrayWrapper fill(rHarpedFillArray);

      CComPtr<IIndexArray> hp_fill;
      CComQIPtr<IStrandGridFiller> startGridFiller(endType == pgsTypes::metStart ? startGrid : endGrid);
      ComputeHpFill(pGdrEntry, startGridFiller, &fill, &hp_fill);

      CComPtr<IPoint2dCollection> points;
      hpGridFiller->GetStrandPositionsEx(hp_fill,&points);

      Float64 cg=0.0;

      CollectionIndexType nStrands;
      points->get_Count(&nStrands);
      ATLASSERT(CountStrandsInConfigFillVec(rHarpedFillArray) == nStrands);
      for (CollectionIndexType strandIdx = 0; strandIdx < nStrands; strandIdx++)
      {
         CComPtr<IPoint2d> point;
         points->get_Item(strandIdx,&point);
         Float64 y;
         point->get_Y(&y);

         cg += y;
      }

      cg = cg / (Float64)nStrands;

      // compute unadjusted location of cg
      Float64 dx,dy;
      hpGridFiller->GetStrandAdjustment(&dx,&dy);

      cg -= dy;

      if (measurementType==hsoCGFROMTOP)
      {
         Float64 height;
         pStrandMover->get_TopElevation(&height);

         Float64 dist = height - cg;
         absOffset  = dist - offset;

      }
      else if ( measurementType==hsoCGFROMBOTTOM)
      {
         // top is a Y=0.0
         absOffset =  offset - (Hg+cg);
      }
      else if (measurementType==hsoECCENTRICITY)
      {
         CComPtr<IBeamFactory> factory;
         pGdrEntry->GetBeamFactory(&factory);

         CComPtr<IGirderSection> gdrSection;
         factory->CreateGirderSection(m_pBroker,INVALID_ID,pGdrEntry->GetDimensions(),-1,-1,&gdrSection);

         CComQIPtr<IShape> shape(gdrSection);
         CComPtr<IShapeProperties> props;
         shape->get_ShapeProperties(&props);
         Float64 Yb;
         props->get_Ybottom(&Yb);

         Float64 ecc = Yb - (Hg+cg);

         absOffset = ecc - offset;
      }
      else
      {
         ATLASSERT(false);
      }
   }
   else if (measurementType==hsoTOP2TOP || measurementType==hsoTOP2BOTTOM)
   {
      // get location of highest strand at zero offset
      CComQIPtr<IStrandGridFiller> hpGridFiller(endType == pgsTypes::metStart ? startHPGrid : endHPGrid);

      CIndexArrayWrapper fill(rHarpedFillArray);

      Float64 fill_top, fill_bottom;
      hpGridFiller->get_FilledGridBoundsEx(&fill,&fill_bottom,&fill_top);

      Float64 dx,dy;
      hpGridFiller->GetStrandAdjustment(&dx,&dy);

      Float64 toploc = fill_top - dy;

      if (measurementType==hsoTOP2TOP)
      {
         Float64 height;
         pStrandMover->get_TopElevation(&height);

         Float64 dist = height - toploc;
         absOffset  = dist - offset;
      }
      else  // measurementType==hsoTOP2BOTTOM
      {
         ATLASSERT(measurementType == hsoTOP2BOTTOM);
         absOffset =  offset - (Hg+toploc);
      }
   }
   else if (measurementType==hsoBOTTOM2BOTTOM)
   {
      CComQIPtr<IStrandGridFiller> hpGridFiller(endType == pgsTypes::metStart ? startHPGrid : endHPGrid);

      CIndexArrayWrapper fill(rHarpedFillArray);

      Float64 fill_top, fill_bottom;
      hpGridFiller->get_FilledGridBoundsEx(&fill,&fill_bottom,&fill_top);

      Float64 dx,dy;
      hpGridFiller->GetStrandAdjustment(&dx,&dy);

      Float64 botloc = fill_bottom - dy;

      absOffset =  offset - (Hg+botloc);
   }
   else
   {
      ATLASSERT(false);
   }

   absOffset = IsZero(absOffset) ? 0.0 : absOffset;
   return absOffset;
}

Float64 CBridgeAgentImp::ComputeHarpedOffsetFromAbsoluteEnd(const CSegmentKey& segmentKey, pgsTypes::MemberEndType endType,const ConfigStrandFillVector& rHarpedFillArray, HarpedStrandOffsetType measurementType, Float64 absoluteOffset) const
{
   // all we really need to know is the distance and direction between the coords, compute absolute
   // from zero
   Float64 absol = ComputeAbsoluteHarpedOffsetEnd(segmentKey, endType, rHarpedFillArray, measurementType, 0.0);

   Float64 offset = 0.0;
   // direction depends if meassured from bottom up or top down
   if (measurementType==hsoLEGACY || measurementType==hsoCGFROMTOP || measurementType==hsoTOP2TOP
      || measurementType==hsoECCENTRICITY)
   {
      offset = absol - absoluteOffset ;
   }
   else if (measurementType==hsoCGFROMBOTTOM || measurementType==hsoTOP2BOTTOM || 
            measurementType==hsoBOTTOM2BOTTOM)
   {
      offset = absoluteOffset - absol;
   }
   else
   {
      ATLASSERT(false); 
   }

   return offset;
}

Float64 CBridgeAgentImp::ComputeHarpedOffsetFromAbsoluteEnd(LPCTSTR strGirderName,pgsTypes::MemberEndType endType,pgsTypes::AdjustableStrandType adjType,Float64 HgStart,Float64 HgHp1,Float64 HgHp2,Float64 HgEnd,const ConfigStrandFillVector& rHarpedFillArray, HarpedStrandOffsetType measurementType, Float64 absoluteOffset) const
{
   // all we really need to know is the distance and direction between the coords, compute absolute
   // from zero
   Float64 absol = ComputeAbsoluteHarpedOffsetEnd(strGirderName, endType, adjType, HgStart, HgHp1, HgHp2, HgEnd, rHarpedFillArray, measurementType, 0.0);

   Float64 offset = 0.0;
   // direction depends if meassured from bottom up or top down
   if (measurementType==hsoLEGACY || measurementType==hsoCGFROMTOP || measurementType==hsoTOP2TOP
      || measurementType==hsoECCENTRICITY)
   {
      offset = absol - absoluteOffset ;
   }
   else if (measurementType==hsoCGFROMBOTTOM || measurementType==hsoTOP2BOTTOM || 
            measurementType==hsoBOTTOM2BOTTOM)
   {
      offset = absoluteOffset - absol;
   }
   else
   {
      ATLASSERT(false); 
   }

   return offset;
}

Float64 CBridgeAgentImp::ComputeHarpedOffsetFromAbsoluteHp(const CSegmentKey& segmentKey, pgsTypes::MemberEndType endType,const ConfigStrandFillVector& rHarpedFillArray, HarpedStrandOffsetType measurementType, Float64 absoluteOffset) const
{
   Float64 absol = ComputeAbsoluteHarpedOffsetHp(segmentKey, endType, rHarpedFillArray, measurementType, 0.0);

   Float64 off = 0.0;
   // direction depends if meassured from bottom up or top down
   if (measurementType==hsoCGFROMTOP || measurementType==hsoTOP2TOP || measurementType==hsoECCENTRICITY)
   {
      off = absol - absoluteOffset ;
   }
   else if (measurementType==hsoLEGACY || measurementType==hsoCGFROMBOTTOM || measurementType==hsoTOP2BOTTOM || 
            measurementType==hsoBOTTOM2BOTTOM )
   {
      off = absoluteOffset - absol;
   }
   else
   {
      ATLASSERT(false);
   }

   return off;
}

Float64 CBridgeAgentImp::ComputeHarpedOffsetFromAbsoluteHp(LPCTSTR strGirderName,pgsTypes::MemberEndType endType,pgsTypes::AdjustableStrandType adjType,Float64 HgStart,Float64 HgHp1,Float64 HgHp2,Float64 HgEnd,const ConfigStrandFillVector& rHarpedFillArray, HarpedStrandOffsetType measurementType, Float64 absoluteOffset) const
{
   Float64 absol = ComputeAbsoluteHarpedOffsetHp(strGirderName, endType, adjType, HgStart, HgHp1, HgHp2, HgEnd, rHarpedFillArray, measurementType, 0.0);

   Float64 off = 0.0;
   // direction depends if meassured from bottom up or top down
   if (measurementType==hsoCGFROMTOP || measurementType==hsoTOP2TOP || measurementType==hsoECCENTRICITY)
   {
      off = absol - absoluteOffset ;
   }
   else if (measurementType==hsoLEGACY || measurementType==hsoCGFROMBOTTOM || measurementType==hsoTOP2BOTTOM || 
            measurementType==hsoBOTTOM2BOTTOM )
   {
      off = absoluteOffset - absol;
   }
   else
   {
      ATLASSERT(false);
   }

   return off;
}

void CBridgeAgentImp::ComputeValidHarpedOffsetForMeasurementTypeEnd(const CSegmentKey& segmentKey, pgsTypes::MemberEndType endType, const ConfigStrandFillVector& rHarpedFillArray, HarpedStrandOffsetType measurementType, Float64* lowRange, Float64* highRange) const
{
   CComPtr<IPrecastGirder> girder;
   GetGirder(segmentKey, &girder);

   CComPtr<IStrandModel> strandModel;
   girder->get_StrandModel(&strandModel);
   CComQIPtr<IStrandGridModel> strandGridModel(strandModel);

   CIndexArrayWrapper fill(rHarpedFillArray);

   Float64 absDown, absUp;
   HRESULT hr = strandGridModel->GetHarpedEndAdjustmentBoundsEx((EndType)endType, &fill, &absDown, &absUp);
   ATLASSERT(SUCCEEDED(hr));

   Float64 offDown = ComputeHarpedOffsetFromAbsoluteEnd(segmentKey, endType, rHarpedFillArray, measurementType, absDown);
   Float64 offUp =   ComputeHarpedOffsetFromAbsoluteEnd(segmentKey, endType, rHarpedFillArray, measurementType, absUp);

   *lowRange = offDown;
   *highRange = offUp;
}

void CBridgeAgentImp::ComputeValidHarpedOffsetForMeasurementTypeEnd(LPCTSTR strGirderName,pgsTypes::MemberEndType endType,pgsTypes::AdjustableStrandType adjType,Float64 HgStart,Float64 HgHp1,Float64 HgHp2,Float64 HgEnd,const ConfigStrandFillVector& rHarpedFillArray,HarpedStrandOffsetType measurementType, Float64* lowRange, Float64* highRange) const
{
   Float64 absDown, absUp;
   GetHarpedEndOffsetBoundsEx(strGirderName, endType, adjType, HgStart, HgHp1, HgHp2, HgEnd,rHarpedFillArray, &absDown,&absUp);

   Float64 offDown = ComputeHarpedOffsetFromAbsoluteEnd(strGirderName, endType, adjType, HgStart, HgHp1, HgHp2, HgEnd,  rHarpedFillArray, measurementType, absDown);
   Float64 offUp =   ComputeHarpedOffsetFromAbsoluteEnd(strGirderName, endType, adjType, HgStart, HgHp1, HgHp2, HgEnd,  rHarpedFillArray, measurementType, absUp);

   *lowRange = offDown;
   *highRange = offUp;
}

void CBridgeAgentImp::ComputeValidHarpedOffsetForMeasurementTypeHp(const CSegmentKey& segmentKey,pgsTypes::MemberEndType endType,const ConfigStrandFillVector& rHarpedFillArray, HarpedStrandOffsetType measurementType, Float64* lowRange, Float64* highRange) const
{
   CComPtr<IPrecastGirder> girder;
   GetGirder(segmentKey, &girder);

   CComPtr<IStrandModel> strandModel;
   girder->get_StrandModel(&strandModel);
   CComQIPtr<IStrandGridModel> strandGridModel(strandModel);

   CIndexArrayWrapper fill(rHarpedFillArray);

   Float64 absDown, absUp;
   HRESULT hr = strandGridModel->GetHarpedHpAdjustmentBoundsEx((EndType)endType,&fill, &absDown, &absUp);
   ATLASSERT(SUCCEEDED(hr));

   Float64 offDown = ComputeHarpedOffsetFromAbsoluteHp(segmentKey, endType, rHarpedFillArray, measurementType, absDown);
   Float64 offUp   = ComputeHarpedOffsetFromAbsoluteHp(segmentKey, endType, rHarpedFillArray, measurementType, absUp);

   *lowRange = offDown;
   *highRange = offUp;
}

void CBridgeAgentImp::ComputeValidHarpedOffsetForMeasurementTypeHp(LPCTSTR strGirderName,pgsTypes::MemberEndType endType,pgsTypes::AdjustableStrandType adjType,Float64 HgStart,Float64 HgHp1,Float64 HgHp2,Float64 HgEnd,const ConfigStrandFillVector& rHarpedFillArray, HarpedStrandOffsetType measurementType, Float64* lowRange, Float64* highRange) const
{
   Float64 absDown, absUp;
   GetHarpedHpOffsetBoundsEx(strGirderName, endType, adjType, HgStart, HgHp1, HgHp2, HgEnd,rHarpedFillArray, &absDown,&absUp);

   Float64 offDown = ComputeHarpedOffsetFromAbsoluteHp(strGirderName, endType, adjType, HgStart, HgHp1, HgHp2, HgEnd,  rHarpedFillArray, measurementType, absDown);
   Float64 offUp =   ComputeHarpedOffsetFromAbsoluteHp(strGirderName, endType, adjType, HgStart, HgHp1, HgHp2, HgEnd,  rHarpedFillArray, measurementType, absUp);

   *lowRange = offDown;
   *highRange = offUp;
}

Float64 CBridgeAgentImp::ConvertHarpedOffsetEnd(const CSegmentKey& segmentKey,pgsTypes::MemberEndType endType,const ConfigStrandFillVector& rHarpedFillArray, HarpedStrandOffsetType fromMeasurementType, Float64 offset, HarpedStrandOffsetType toMeasurementType) const
{
   Float64 abs_offset = ComputeAbsoluteHarpedOffsetEnd(segmentKey,endType,rHarpedFillArray,fromMeasurementType,offset);
   Float64 result = ComputeHarpedOffsetFromAbsoluteEnd(segmentKey,endType,rHarpedFillArray,toMeasurementType,abs_offset);
   return result;
}

Float64 CBridgeAgentImp::ConvertHarpedOffsetEnd(LPCTSTR strGirderName,pgsTypes::MemberEndType endType,pgsTypes::AdjustableStrandType adjType,Float64 HgStart,Float64 HgHp1,Float64 HgHp2,Float64 HgEnd,const ConfigStrandFillVector& rHarpedFillArray, HarpedStrandOffsetType fromMeasurementType, Float64 offset, HarpedStrandOffsetType toMeasurementType) const
{
   Float64 abs_offset = ComputeAbsoluteHarpedOffsetEnd(strGirderName, endType, adjType, HgStart, HgHp1, HgHp2, HgEnd,rHarpedFillArray,fromMeasurementType,offset);
   Float64 result = ComputeHarpedOffsetFromAbsoluteEnd(strGirderName, endType, adjType, HgStart, HgHp1, HgHp2, HgEnd,rHarpedFillArray,toMeasurementType,abs_offset);
   return result;
}

Float64 CBridgeAgentImp::ConvertHarpedOffsetHp(const CSegmentKey& segmentKey,pgsTypes::MemberEndType endType,const ConfigStrandFillVector& rHarpedFillArray, HarpedStrandOffsetType fromMeasurementType, Float64 offset, HarpedStrandOffsetType toMeasurementType) const
{
   Float64 abs_offset = ComputeAbsoluteHarpedOffsetHp(segmentKey,endType,rHarpedFillArray,fromMeasurementType,offset);
   Float64 result = ComputeHarpedOffsetFromAbsoluteHp(segmentKey,endType,rHarpedFillArray,toMeasurementType,abs_offset);
   return result;
}

Float64 CBridgeAgentImp::ConvertHarpedOffsetHp(LPCTSTR strGirderName,pgsTypes::MemberEndType endType,pgsTypes::AdjustableStrandType adjType,Float64 HgStart,Float64 HgHp1,Float64 HgHp2,Float64 HgEnd,const ConfigStrandFillVector& rHarpedFillArray, HarpedStrandOffsetType fromMeasurementType, Float64 offset, HarpedStrandOffsetType toMeasurementType) const
{
   Float64 abs_offset = ComputeAbsoluteHarpedOffsetHp(strGirderName, endType, adjType, HgStart, HgHp1, HgHp2, HgEnd,rHarpedFillArray,fromMeasurementType,offset);
   Float64 result = ComputeHarpedOffsetFromAbsoluteHp(strGirderName, endType, adjType, HgStart, HgHp1, HgHp2, HgEnd,rHarpedFillArray,toMeasurementType,abs_offset);
   return result;
}

pgsTypes::TTSUsage CBridgeAgentImp::GetTemporaryStrandUsage(const CSegmentKey& segmentKey, const GDRCONFIG* pConfig) const
{
   GET_IFACE(ISegmentData, pSegmentData);
   const CStrandData* pStrands = pSegmentData->GetStrandData(segmentKey);

   pgsTypes::TTSUsage tempStrandUsage = (pConfig == nullptr ? pStrands->GetTemporaryStrandUsage() : pConfig->PrestressConfig.TempStrandUsage);
   return tempStrandUsage;
}

void CBridgeAgentImp::ResolveSegmentVariation(const CPrecastSegmentData* pSegment, std::array<Float64, 4>& Xhp) const
{
   const CSegmentKey& segmentKey(pSegment->GetSegmentKey());
   Float64 Ls = GetSegmentLength(segmentKey);

   Float64 Lcp1 = 0;
   if (pSegment->GetClosureJoint(pgsTypes::metStart))
   {
      Lcp1 = GetClosureJointLength(pSegment->GetClosureJoint(pgsTypes::metStart)->GetClosureKey()) / 2;
   }

   Float64 Lcp2 = 0;
   if (pSegment->GetClosureJoint(pgsTypes::metEnd))
   {
      Lcp2 = GetClosureJointLength(pSegment->GetClosureJoint(pgsTypes::metEnd)->GetClosureKey()) / 2;
   }

   Float64 left_prismatic_length = pSegment->GetVariationLength(pgsTypes::sztLeftPrismatic);
   Float64 left_taper_length = pSegment->GetVariationLength(pgsTypes::sztLeftTapered);
   Float64 right_taper_length = pSegment->GetVariationLength(pgsTypes::sztRightTapered);
   Float64 right_prismatic_length = pSegment->GetVariationLength(pgsTypes::sztRightPrismatic);

   // deal with fractional measure (fraction measures are < 0)
   if (left_prismatic_length < 0)
   {
      ATLASSERT(-1.0 <= left_prismatic_length && left_prismatic_length <= 0.0);
      left_prismatic_length *= -Ls;
   }

   if (left_taper_length < 0)
   {
      ATLASSERT(-1.0 <= left_taper_length && left_taper_length <= 0.0);
      left_taper_length *= -Ls;
   }

   if (right_taper_length < 0)
   {
      ATLASSERT(-1.0 <= right_taper_length && right_taper_length <= 0.0);
      right_taper_length *= -Ls;
   }

   if (right_prismatic_length < 0)
   {
      ATLASSERT(-1.0 <= right_prismatic_length && right_prismatic_length <= 0.0);
      right_prismatic_length *= -Ls;
   }

   // the prismatic lengths include the closure joint
   // remove the closure joint length so we are working in Segment Coordinates
   left_prismatic_length -= Lcp1;
   left_prismatic_length = IsZero(left_prismatic_length) ? 0 : left_prismatic_length;

   right_prismatic_length -= Lcp2;
   right_prismatic_length = IsZero(right_prismatic_length) ? 0 : right_prismatic_length;

   pgsTypes::SegmentVariationType variation = pSegment->GetVariationType();
   if (variation == pgsTypes::svtLinear || variation == pgsTypes::svtParabolic)
   {
      Float64 left_prismatic_height = pSegment->GetVariationHeight(pgsTypes::sztLeftPrismatic);
      Float64 left_taper_height = pSegment->GetVariationHeight(pgsTypes::sztLeftTapered);
      Float64 right_taper_height = pSegment->GetVariationHeight(pgsTypes::sztRightTapered);
      Float64 right_prismatic_height = pSegment->GetVariationHeight(pgsTypes::sztRightPrismatic);

      if (left_prismatic_height <= right_prismatic_height)
      {
         Xhp[ZoneBreakType::Start] = left_prismatic_length;
         Xhp[ZoneBreakType::LeftBreak] = Ls - (right_prismatic_length + right_taper_length);
         Xhp[ZoneBreakType::RightBreak] = Ls - (right_prismatic_length + right_taper_length);
         Xhp[ZoneBreakType::End] = Ls - right_prismatic_length;
      }
      else
      {
         Xhp[ZoneBreakType::Start] = left_prismatic_length;
         Xhp[ZoneBreakType::LeftBreak] = left_prismatic_length + left_taper_length;
         Xhp[ZoneBreakType::RightBreak] = left_prismatic_length + left_taper_length;
         Xhp[ZoneBreakType::End] = Ls - right_prismatic_length;
      }
   }
   else
   {
      Xhp[ZoneBreakType::Start] = left_prismatic_length;
      Xhp[ZoneBreakType::LeftBreak] = left_prismatic_length + left_taper_length;
      Xhp[ZoneBreakType::RightBreak] = Ls - (right_prismatic_length + right_taper_length);
      Xhp[ZoneBreakType::End] = Ls - right_prismatic_length;
   }
}

void CBridgeAgentImp::ResolveHarpPointLocations(const CPrecastSegmentData* pSegment, const CStrandData* pStrands, std::array<Float64, 4>& Xhp) const
{
   // gets the harping point locations, in absolute measure, from the left end of the girder
   const CSegmentKey& segmentKey(pSegment->GetSegmentKey());
   Float64 Ls = GetSegmentLength(segmentKey);

   StrandIndexType nHarpedStrands = 0;
   Float64 Xstart, Xlhp, Xrhp, Xend;
   if (pStrands)
   {
      pStrands->GetHarpPoints(&Xstart, &Xlhp, &Xrhp, &Xend);
      nHarpedStrands = pStrands->GetStrandCount(pgsTypes::Harped);
   }
   else
   {
      pSegment->Strands.GetHarpPoints(&Xstart, &Xlhp, &Xrhp, &Xend);
      nHarpedStrands = pSegment->Strands.GetStrandCount(pgsTypes::Harped);
   }

   if (0 < nHarpedStrands)
   {
      if (Xstart < 0)
      {
         Xstart *= -Ls;
         Xstart = IsZero(Xstart) ? 0.0 : Xstart;
      }

      if (Xlhp < 0)
      {
         Xlhp *= -Ls;
         Xlhp = IsZero(Xlhp) ? 0.0 : Xlhp;
      }

      if (Xrhp < 0)
      {
         Xrhp *= -Ls;
         Xrhp = IsZero(Xrhp) ? 0.0 : Xrhp;
      }

      if (Xend < 0)
      {
         Xend *= -Ls;
         Xend = IsZero(Xend) ? 0.0 : Xend;
      }
   }
   else
   {
      Xstart = 0;
      Xlhp = 0;
      Xrhp = Ls;
      Xend = Ls;
   }

   Xhp[ZoneBreakType::Start] = ::ForceIntoRange(0.0, Xstart, Ls);
   Xhp[ZoneBreakType::LeftBreak] = ::ForceIntoRange(0.0, Xlhp, Ls);
   Xhp[ZoneBreakType::RightBreak] = ::ForceIntoRange(0.0, Xrhp, Ls);
   Xhp[ZoneBreakType::End] = ::ForceIntoRange(0.0, Xend, Ls);
}

void CBridgeAgentImp::ResolveStrandRowElevations(const CPrecastSegmentData* pSegment, const CStrandData* pStrands, const CStrandRow& strandRow, std::array<Float64, 4>& Xhp, std::array<Float64, 4>& Y) const
{
   // if we have a variable depth segment and this strand row is for "straight" strands (straight or temporary) and the strands are measured from the bottom of the girder
   // then Xhp is the segment depth change points, otherwise, Xhp are harp point locations

   bool bMeasuredFromBottom = false;
   if (strandRow.m_StrandType == pgsTypes::Straight || strandRow.m_StrandType == pgsTypes::Temporary)
   {
      bMeasuredFromBottom = (strandRow.m_Face[ZoneBreakType::Start] == pgsTypes::BottomFace || strandRow.m_Face[ZoneBreakType::End] == pgsTypes::BottomFace) ? true : false;
   }

   // Xhp is measured from the left end of the girder
   if (
      pSegment->GetVariationType() == pgsTypes::svtNone ||
      strandRow.m_StrandType == pgsTypes::Harped ||
      ((strandRow.m_StrandType == pgsTypes::Straight || strandRow.m_StrandType == pgsTypes::Temporary) && !bMeasuredFromBottom)
      )
   {
      ResolveHarpPointLocations(pSegment, pStrands, Xhp);
   }
   else
   {
      ResolveSegmentVariation(pSegment, Xhp);
   }

   for (int i = 0; i < 4; i++)
   {
      Y[i] = strandRow.m_Y[i];

      if (strandRow.m_Face[i] == pgsTypes::TopFace)
      {
         // measured down from top of girder... this is negative in Girder Section Coordinates
         Y[i] *= -1;
      }
      else
      {
         // adjust to be measured from top of girder
         Float64 Hg = GetSegmentHeight(pSegment, Xhp[i]);
         Y[i] -= Hg;
      }
   }
}

/////////////////////////////////////////////////////////////////////////
// IPointOfInterest
void CBridgeAgentImp::GetPointsOfInterest(const CSegmentKey& segmentKey,PoiList* pPoiList) const
{
   VALIDATE_POINTS_OF_INTEREST(segmentKey);
   m_pPoiMgr->GetPointsOfInterest(segmentKey,pPoiList);
}

void CBridgeAgentImp::GetPointsOfInterest(Float64 station,IDirection* pDirection,std::vector<pgsPointOfInterest>* pvPoi) const
{
#pragma Reminder("UPDATE - this can be made faster")
   // this method is using a brute force search. There are faster ways to do this.
   std::vector<pgsPointOfInterest> vPoi;
   GroupIndexType nGroups = GetGirderGroupCount();
   for ( GroupIndexType grpIdx = 0; grpIdx < nGroups; grpIdx++ )
   {
      GirderIndexType nGirders = GetGirderCount(grpIdx);
      for ( GirderIndexType gdrIdx = 0; gdrIdx < nGirders; gdrIdx++ )
      {
         SegmentIndexType nSegments = GetSegmentCount(grpIdx,gdrIdx);
         for ( SegmentIndexType segIdx = 0; segIdx < nSegments; segIdx++ )
         {
            CSegmentKey segmentKey(grpIdx,gdrIdx,segIdx);
            pgsPointOfInterest poi;
            if ( GetPointOfInterest(segmentKey,station,pDirection,&poi) )
            {
               pvPoi->push_back(poi);
            }
         }
      }
   }
}

void CBridgeAgentImp::GetPointsOfInterest(const CSegmentKey& segmentKey,PoiAttributeType attrib,PoiList* pPoiList,Uint32 mode) const
{
   VALIDATE_POINTS_OF_INTEREST(segmentKey);
   m_pPoiMgr->GetPointsOfInterest(segmentKey,attrib,mode,pPoiList);
}

void CBridgeAgentImp::GetPointsOfInterest(const CSpanKey& spanKey,PoiList* pPoiList) const
{
   return GetPointsOfInterest(spanKey,POI_SPAN,pPoiList);
}

void CBridgeAgentImp::GetPointsOfInterest(const CSpanKey& spanKey,PoiAttributeType attrib,PoiList* pPoiList,Uint32 mode) const
{
   VALIDATE_POINTS_OF_INTEREST(CGirderKey(ALL_GROUPS,spanKey.girderIndex));
   GroupIndexType grpIdx = (spanKey.spanIndex == ALL_SPANS ? ALL_GROUPS : GetGirderGroupIndex(spanKey.spanIndex));
   m_pPoiMgr->GetPointsOfInterest(CSegmentKey(grpIdx,spanKey.girderIndex,ALL_SEGMENTS),attrib,mode,pPoiList);
   pPoiList->erase(std::remove_if(std::begin(*pPoiList),std::end(*pPoiList),PoiNotInSpan(this,spanKey)),std::end(*pPoiList));
}

void CBridgeAgentImp::MergePoiLists(const PoiList& list1, const PoiList& list2,PoiList* pPoiList) const
{
   m_pPoiMgr->MergePoiLists(list1, list2,pPoiList);
}

void CBridgeAgentImp::SortPoiList(PoiList* pPoiList) const
{
   m_pPoiMgr->SortPoiList(pPoiList);
}

const pgsPointOfInterest& CBridgeAgentImp::GetPointOfInterest(PoiIDType poiID) const
{
   VALIDATE_POINTS_OF_INTEREST(CGirderKey(ALL_GROUPS,ALL_GIRDERS));
   return m_pPoiMgr->GetPointOfInterest(poiID);
}

pgsPointOfInterest CBridgeAgentImp::GetPointOfInterest(const CSegmentKey& segmentKey,Float64 Xpoi) const
{
   // This validate is commented out because it causes problems with validating the bridge model
   // The main validate calls this method which calls ValidatePointsOfInterest which calls the main validate
   // ... recursion ==> CRASH
   //ValidatePointsOfInterest(segmentKey);

   return m_pPoiMgr->GetPointOfInterest(segmentKey,Xpoi);
}

bool CBridgeAgentImp::GetPointOfInterest(const CSegmentKey& segmentKey,Float64 station,IDirection* pDirection,pgsPointOfInterest* pPoi) const
{
   VALIDATE( GIRDER );
   CComPtr<IPoint2d> pntOnSegment;
   GirderIDType ssmbrID = ::GetSuperstructureMemberID(segmentKey);
   HRESULT hr = m_BridgeGeometryTool->GirderPathPoint(m_Bridge,ssmbrID,segmentKey.segmentIndex,CComVariant(station),CComVariant(pDirection),VARIANT_FALSE,&pntOnSegment);
   if ( FAILED(hr) )
   {
      // Point wasn't found
      return false;
   }
   
   CComPtr<IPoint2d> pntPier1, pntEnd1, pntBrg1, pntBrg2, pntEnd2, pntPier2;
   GetSegmentEndPoints(segmentKey,pgsTypes::pcLocal,&pntPier1,&pntEnd1,&pntBrg1,&pntBrg2,&pntEnd2,&pntPier2);

   Float64 Xpoi;
   pntEnd1->DistanceEx(pntOnSegment,&Xpoi);

   *pPoi = GetPointOfInterest(segmentKey, Xpoi);

   return true;
}

bool CBridgeAgentImp::GetPointOfInterest(const CGirderKey& girderKey,Float64 station,IDirection* pDirection,bool bProjectSegmentEnds,pgsPointOfInterest* pPoi) const
{
   VALIDATE( GIRDER );

   VARIANT_BOOL vbProject(bProjectSegmentEnds ? VARIANT_TRUE : VARIANT_FALSE);

   GirderIDType ssmbrID = ::GetSuperstructureMemberID(girderKey);
   SegmentIndexType nSegments = GetSegmentCount(girderKey);
   std::vector<SegmentIndexType> vSegments;
   std::vector<CComPtr<IPoint2d>> vPoints;
   for ( SegmentIndexType segIdx = 0; segIdx < nSegments; segIdx++ )
   {

      CComPtr<IPoint2d> pntOnSegment;
      HRESULT hr = m_BridgeGeometryTool->GirderPathPoint(m_Bridge,ssmbrID,segIdx,CComVariant(station),CComVariant(pDirection),vbProject,&pntOnSegment);
      if ( SUCCEEDED(hr) )
      {
         if ( vbProject == VARIANT_FALSE )
         {
            // we found the exact point
            CSegmentKey segmentKey(girderKey,segIdx);
            CComPtr<IPoint2d> pntPier1, pntEnd1, pntBrg1, pntBrg2, pntEnd2, pntPier2;
            GetSegmentEndPoints(segmentKey,pgsTypes::pcLocal,&pntPier1,&pntEnd1,&pntBrg1,&pntBrg2,&pntEnd2,&pntPier2);

            Float64 Xpoi;
            pntEnd1->DistanceEx(pntOnSegment,&Xpoi);

            *pPoi = pgsPointOfInterest(segmentKey,Xpoi);
            return true;
         }
         else
         {
            vSegments.push_back(segIdx);
            vPoints.push_back(pntOnSegment);
         }
      }
   }

   if ( vSegments.size() == 0 )
   {
      ATLASSERT(bProjectSegmentEnds == false); // not projecting segment ends and no intersections found.... 
      return false;
   }

   Float64 Xpoi = DBL_MAX;
   pgsPointOfInterest poi;
   std::vector<SegmentIndexType>::iterator segIter(vSegments.begin());
   std::vector<SegmentIndexType>::iterator segIterEnd(vSegments.end());
   std::vector<CComPtr<IPoint2d>>::iterator pntIter(vPoints.begin());
   for ( ; segIter != segIterEnd; segIter++, pntIter++ )
   {
      CSegmentKey segmentKey(girderKey,*segIter);
      CComPtr<IPoint2d> pntPier1, pntEnd1, pntBrg1, pntBrg2, pntEnd2, pntPier2;
      GetSegmentEndPoints(segmentKey,pgsTypes::pcLocal,&pntPier1,&pntEnd1,&pntBrg1,&pntBrg2,&pntEnd2,&pntPier2);
      
      Float64 dist1;
      pntEnd1->DistanceEx(*pntIter,&dist1);

      Float64 dist2;
      pntEnd2->DistanceEx(*pntIter,&dist2);

      if ( dist1 < dist2 )
      {
         // point is closer to the start of the segment
         if ( dist1 < Xpoi )
         {
            Xpoi = dist1;
            PoiList vPoi;
            GetPointsOfInterest(segmentKey, POI_START_FACE, &vPoi);
            ATLASSERT(vPoi.size() == 1);
            poi = vPoi.front();
         }
      }
      else
      {
         // point is closer to the end of the segment
         if ( dist1 < Xpoi )
         {
            Xpoi = dist1;
            PoiList vPoi;
            GetPointsOfInterest(segmentKey, POI_END_FACE, &vPoi);
            ATLASSERT(vPoi.size() == 1);
            poi = vPoi.front();
         }
      }
   }
   *pPoi = poi;
   return true;
}

const pgsPointOfInterest& CBridgeAgentImp::GetNearestPointOfInterest(const CSegmentKey& segmentKey,Float64 Xpoi) const
{
   VALIDATE_POINTS_OF_INTEREST(segmentKey);
   return m_pPoiMgr->GetNearestPointOfInterest(segmentKey,Xpoi);
}

const pgsPointOfInterest& CBridgeAgentImp::GetPrevPointOfInterest(PoiIDType poiID,PoiAttributeType attrib,Uint32 mode) const
{
   ATLASSERT(poiID != INVALID_ID);
   // assumes the POIs are already validated.... if they weren't we would have a valid poiID
   return m_pPoiMgr->GetPrevPointOfInterest(poiID,attrib,mode == POIFIND_OR ? POIMGR_OR : POIMGR_AND);
}

const pgsPointOfInterest& CBridgeAgentImp::GetNextPointOfInterest(PoiIDType poiID,PoiAttributeType attrib,Uint32 mode) const
{
   ATLASSERT(poiID != INVALID_ID);
   // assumes the POIs are already validated.... if they weren't we would have a valid poiID
   return m_pPoiMgr->GetNextPointOfInterest(poiID,attrib,mode == POIFIND_OR ? POIMGR_OR : POIMGR_AND);
}

void CBridgeAgentImp::GetCriticalSections(pgsTypes::LimitState limitState,const CGirderKey& girderKey,PoiList* pPoiList) const
{
   ASSERT_GIRDER_KEY(girderKey);
   GET_IFACE(ILibrary,pLib);
   GET_IFACE(ISpecification,pSpec);
   const SpecLibraryEntry* pSpecEntry = pLib->GetSpecEntry( pSpec->GetSpecification().c_str() );

   // LRFD 2004 and later, critical section is only a function of dv, which comes from the calculation of Mu,
   // so critical section is not a function of the limit state. We will work with the Strength I limit state
   if ( lrfdVersionMgr::ThirdEdition2004 <= pSpecEntry->GetSpecificationType() )
   {
      limitState = pgsTypes::StrengthI;
   }

   IndexType idx = LimitStateToShearIndex(limitState);
   std::set<CGirderKey>::iterator found;
   found = m_CriticalSectionState[idx].find( girderKey );
   if ( found == m_CriticalSectionState[idx].end() )
   {
      // Critical sections not previously computed.
      // Do it now.
      GET_IFACE(IShearCapacity,pShearCap);
      const std::vector<CRITSECTDETAILS>& vCSDetails(pShearCap->GetCriticalSectionDetails(limitState,girderKey));

      std::vector<CRITSECTDETAILS>::const_iterator iter(vCSDetails.begin());
      std::vector<CRITSECTDETAILS>::const_iterator end(vCSDetails.end());
      for ( ; iter != end; iter++ )
      {
         const CRITSECTDETAILS& csDetails(*iter);
         VERIFY(m_pPoiMgr->AddPointOfInterest(csDetails.GetPointOfInterest()) != INVALID_ID);
      }

      m_CriticalSectionState[idx].insert( girderKey );
   }

   m_pPoiMgr->GetPointsOfInterest(CSegmentKey(girderKey,ALL_SEGMENTS),(IsStrengthILimitState(limitState) ? POI_CRITSECTSHEAR1 : POI_CRITSECTSHEAR2),POIMGR_OR,pPoiList);
}

void CBridgeAgentImp::GetCriticalSections(pgsTypes::LimitState limitState,const CGirderKey& girderKey,const GDRCONFIG& config,std::vector<pgsPointOfInterest>* pvPoi) const
{
   PoiAttributeType attrib = (IsStrengthILimitState(limitState) ? POI_CRITSECTSHEAR1 : POI_CRITSECTSHEAR2);

   GET_IFACE(IShearCapacity,pShearCap);
   std::vector<Float64> vcsLoc(pShearCap->GetCriticalSections(limitState,girderKey,&config));
   std::vector<Float64>::iterator iter(vcsLoc.begin());
   std::vector<Float64>::iterator end(vcsLoc.end());
   for ( ; iter != end; iter++ )
   {
      Float64 Xg = *iter;
      pgsPointOfInterest poi = ConvertGirderCoordinateToPoi(girderKey,Xg);
      poi.SetNonReferencedAttributes(attrib);
      pvPoi->push_back(poi);
   }
}

pgsPointOfInterest CBridgeAgentImp::GetPierPointOfInterest(const CGirderKey& girderKey,PierIndexType pierIdx) const
{
   ASSERT_GIRDER_KEY(girderKey);

   // Gets the POI at a pier. If this is the first or last pier, get the CL Bearing POI.

   Float64 Xgp;
   VERIFY(GetPierLocation(girderKey,pierIdx,&Xgp) );
   return ConvertGirderPathCoordinateToPoi(girderKey,Xgp);
}

pgsPointOfInterest CBridgeAgentImp::GetTemporarySupportPointOfInterest(const CGirderKey& girderKey,SupportIndexType tsIdx) const
{
   ASSERT_GIRDER_KEY(girderKey);

   Float64 Xgp = GetTemporarySupportLocation(tsIdx,girderKey.girderIndex);
   return ConvertGirderPathCoordinateToPoi(girderKey,Xgp);
}

pgsPointOfInterest CBridgeAgentImp::ConvertSpanPointToPoi(const CSpanKey& spanKey,Float64 Xspan) const
{
   // convert spanIdx and Xspan to girder coordinates, Xg
   GroupIndexType grpIdx = GetGirderGroupIndex(spanKey.spanIndex);
   GirderIndexType gdrIdx = spanKey.girderIndex;
   Float64 brgOffset = GetSegmentStartBearingOffset(CSegmentKey(grpIdx,gdrIdx,0));
   Float64 endDist   = GetSegmentStartEndDistance(CSegmentKey(grpIdx,gdrIdx,0));
   Float64 endOffset = brgOffset - endDist;
   endOffset = IsZero(endOffset) ? 0 : endOffset;
   SpanIndexType startSpanIdx = GetGirderGroupStartSpan(grpIdx);

   PierIndexType pierIdx = (PierIndexType)spanKey.spanIndex; // index of pier at start of span
   bool bIsContinuous;
   if (IsInteriorPier(pierIdx) )
   {
      bIsContinuous = true;
   }
   else
   {
      pgsTypes::BoundaryConditionType connectionType = GetBoundaryConditionType(pierIdx);
      bIsContinuous = IsContinuousBoundaryCondition(connectionType);
   }

   // For the first span, the span coordinate system begins at the CL Bearing which is
   // at girder coordinate Xg = endDist
   //
   // .---- Back of Pavement Seat (Abutment Reference Line)
   // |
   // |<---------->|--- Bearing Offset
   // |        |<->|--- End Distance
   // |        +-----------------------/
   // |        |   * Xg = End Distance \
   // |        +-----------------------/
   // |            ^
   //              |
   //              +----- CL Bearing (Xspan = 0, Xg = End Distance)

   // For other all spans, the start of the span coordinate is at the CL Pier if the 
   // pier connection is continuous otherwise it is at the CL Bearing.
   // For continuous pier connections, the girder coordinate for this location is Xg = -endOffset.
   // For all others, Xg = endDist;
   //
   //                       |<---------->|--- Bearing Offset
   //         End Offset ---|<------>|<->|--- End Distance
   // /------------+        |        +-----------------------/
   // \  Span i-1  |        |        |    Span i             \
   // /------------+        |        +-----------------------/
   //                       ^            ^
   //                       |            |
   //                       |            +----- CL Bearing (Xspan = 0, Xg = End Distance) (for non-continuous piers)
   //                       |
   //                       +----- CL Bearing (Xspan = 0, Xg = -(End Offset)) (for continuous piers)

   Float64 Xg = (startSpanIdx == 0 || !bIsContinuous || IsInteriorPier(pierIdx)) ? endDist : -endOffset;

   for ( SpanIndexType spanIdx = startSpanIdx; spanIdx < spanKey.spanIndex; spanIdx++ )
   {
      Float64 Ls = GetSpanLength(spanIdx,gdrIdx);
      Xg += Ls;
   }
   Xg += Xspan;

   // now convert the girder coordinate to a POI
   pgsPointOfInterest poi = ConvertGirderCoordinateToPoi(CGirderKey(grpIdx,gdrIdx),Xg);

   // if the POI is at a span boundary
   if ( poi.IsTenthPoint(POI_SPAN) == 11 )
   {
      // poi is at the end of a span... make sure the poi we want isn't
      // at the start of the next span
      CSpanKey mySpanKey;
      Float64 myXspan;
      ConvertPoiToSpanPoint(poi,&mySpanKey,&myXspan);
      if ( mySpanKey.spanIndex != spanKey.spanIndex )
      {
         // the poi we want is in another span
         poi = ConvertGirderCoordinateToPoi(CGirderKey(grpIdx,gdrIdx),Xg+0.001);
#if defined _DEBUG
         CSpanKey mySpanKey;
         Float64 myXspan;
         ConvertPoiToSpanPoint(poi,&mySpanKey,&myXspan);
         ATLASSERT(mySpanKey.spanIndex == spanKey.spanIndex);
#endif
         poi.SetDistFromStart(poi.GetDistFromStart()-0.001);
      }
   }

#if defined CHECK_POI_CONVERSIONS
   static bool bTesting = false;
   if ( !bTesting )
   {
      bTesting = true;
      CSpanKey testSpanKey;
      Float64 testXspan;
      ConvertPoiToSpanPoint(poi,&testSpanKey,&testXspan);
      SpanIndexType testSpanIdx = testSpanKey.spanIndex;
      if ( testSpanIdx == spanKey.spanIndex-1 )
      {
         // input span location is at the start of a span... poi is at the end of the previous span
         // this puts the test results at the end of the previous span and it is the same location
         // as the input location
         ATLASSERT(IsZero(Xspan)); // input should be at the start of the span
         ATLASSERT(IsEqual(testXspan,GetSpanLength(testSpanIdx,gdrIdx))); // should be at the end of the test span
      }
      else if ( spanKey.spanIndex == testSpanIdx-1 )
      {
         // input span location is at the end of a span... poi is at the start of the next span
         // this points the test results at the start of the next span and it is the same location
         // as the input location
         ATLASSERT(IsEqual(Xspan,GetSpanLength(spanKey))); // should be at the end of the span
         ATLASSERT(IsZero(testXspan)); // should be at the start of the next span
      }
      else
      {
         ATLASSERT(testSpanIdx == spanKey.spanIndex && IsEqual(testXspan,Xspan,0.001));
      }
      bTesting = false;
   }
#endif
   return poi;
}

void CBridgeAgentImp::ConvertPoiToSpanPoint(const pgsPointOfInterest& poi,CSpanKey* pSpanKey,Float64* pXspan) const
{
   if ( poi.HasSpanPoint() )
   {
      pSpanKey->girderIndex = poi.GetSegmentKey().girderIndex;
      poi.GetSpanPoint(&pSpanKey->spanIndex,pXspan);
   }
   else
   {
      Float64 XgPoi = ConvertPoiToGirderCoordinate(poi);

      const CSegmentKey& segmentKey(poi.GetSegmentKey());
      CGirderKey girderKey(segmentKey);
      pSpanKey->girderIndex = segmentKey.girderIndex;

      SpanIndexType startSpanIdx, endSpanIdx;
      GetGirderGroupSpans(segmentKey.groupIndex,&startSpanIdx,&endSpanIdx);

      Float64 brgOffset = GetSegmentStartBearingOffset(CSegmentKey(girderKey,0));
      Float64 endDist   = GetSegmentStartEndDistance(CSegmentKey(girderKey,0));
      Float64 endOffset = brgOffset - endDist;
      endOffset = IsZero(endOffset) ? 0 : endOffset;

      PierIndexType startPierIdx = (PierIndexType)(startSpanIdx); // index of pier at start of span
      pgsTypes::BoundaryConditionType connectionType = GetBoundaryConditionType(startPierIdx);
      bool bIsContinuous = !(connectionType == pgsTypes::bctHinge || connectionType == pgsTypes::bctRoller);

      pSpanKey->spanIndex = INVALID_INDEX;
      Float64 XgStartSpan = (startSpanIdx == 0 || !bIsContinuous ? endDist : -endOffset);
      if ( XgPoi < XgStartSpan )
      {
         // poi is before the start of the span
         pSpanKey->spanIndex = startSpanIdx;
         *pXspan = XgPoi - XgStartSpan;
      }
      else
      {
         for ( SpanIndexType spanIdx = startSpanIdx; spanIdx <= endSpanIdx; spanIdx++ )
         {
            Float64 Lspan = GetSpanLength(spanIdx,segmentKey.girderIndex);
            Float64 XgEndSpan = XgStartSpan + Lspan;
            if ( ::InRange(XgStartSpan,XgPoi,XgEndSpan) )
            {
               // we found the span that contains the poi
               pSpanKey->spanIndex = spanIdx;
               *pXspan = XgPoi - XgStartSpan;
               break;
            }
            XgStartSpan = XgEndSpan; // start of next span is end of this span
         }

         if ( pSpanKey->spanIndex == INVALID_INDEX )
         {
            // XgPoi is beyond the end of the last span
            // XgStartSpan is the start of the next span which is the end of the last span... which is what we want
            pSpanKey->spanIndex = endSpanIdx;

            // Xspan is (XgPoi - XgStartSpan) which is the distance from the end of the last span to the poi
            // plus the length of the span which makes the value be the distance from the start of the last span
            *pXspan = XgPoi - XgStartSpan + GetSpanLength(endSpanIdx,segmentKey.girderIndex);
         }
      }

      if ( poi.GetID() != INVALID_ID )
      {
         pgsPointOfInterest* pPoi = const_cast<pgsPointOfInterest*>(&poi);
         pPoi->SetSpanPoint(pSpanKey->spanIndex,*pXspan);
      }
   }

#if defined CHECK_POI_CONVERSIONS
   static bool bTesting = false;
   if ( !bTesting )
   {
      bTesting = true;
      pgsPointOfInterest testPoi = ConvertSpanPointToPoi(*pSpanKey,*pXspan);
      ATLASSERT(poi.AtSamePlace(testPoi));
      bTesting = false;
   }
#endif
}

void CBridgeAgentImp::ConvertSpanPointToSegmentCoordiante(const CSpanKey& spanKey,Float64 Xspan,CSegmentKey* pSegmentKey,Float64* pXs) const
{
   pgsPointOfInterest poi = ConvertSpanPointToPoi(spanKey,Xspan);
   *pSegmentKey = poi.GetSegmentKey();
   *pXs = poi.GetDistFromStart();
}

void CBridgeAgentImp::ConvertSegmentCoordinateToSpanPoint(const CSegmentKey& segmentKey,Float64 Xs,CSpanKey* pSpanKey,Float64* pXspan) const
{
   ConvertPoiToSpanPoint(pgsPointOfInterest(segmentKey,Xs),pSpanKey,pXspan);
}

void CBridgeAgentImp::ConvertSpanPointToSegmentPathCoordiante(const CSpanKey& spanKey,Float64 Xspan,CSegmentKey* pSegmentKey,Float64* pXsp) const
{
   Float64 Xs;
   ConvertSpanPointToSegmentCoordiante(spanKey,Xspan,pSegmentKey,&Xs);
   Float64 brgOffset = GetSegmentStartBearingOffset(*pSegmentKey);
   Float64 endDist   = GetSegmentStartEndDistance(*pSegmentKey);
   Float64 end_offset = brgOffset - endDist;
   Float64 Xsp = Xs + end_offset;
   *pXsp = Xsp;
}

void CBridgeAgentImp::ConvertSegmentPathCoordinateToSpanPoint(const CSegmentKey& segmentKey,Float64 Xsp,CSpanKey* pSpanKey,Float64* pXspan) const
{
   Float64 Xs = ConvertSegmentPathCoordinateToSegmentCoordinate(segmentKey,Xsp);
   ConvertSegmentCoordinateToSpanPoint(segmentKey,Xs,pSpanKey,pXspan);
}

void CBridgeAgentImp::GetPointsOfInterestInRange(Float64 xLeft,const pgsPointOfInterest& poi,Float64 xRight,PoiList* pPoiList) const
{
   VALIDATE_POINTS_OF_INTEREST(poi.GetSegmentKey());

   Float64 xMin = poi.GetDistFromStart() - xLeft;
   Float64 xMax = poi.GetDistFromStart() + xRight;

   m_pPoiMgr->GetPointsOfInterestInRange(poi.GetSegmentKey(),xMin,xMax,pPoiList);
}

PierIndexType CBridgeAgentImp::GetPier(const pgsPointOfInterest& poi) const
{
   Uint16 tenthPt = poi.IsTenthPoint(POI_SPAN);
   if (tenthPt == 1 || tenthPt == 11 || poi.HasAttribute(POI_BOUNDARY_PIER))
   {
      // boundary pier POIs are always at the end of a group so we want the end pier
      const CSegmentKey& segmentKey = poi.GetSegmentKey();
      GroupIndexType grpIdx = segmentKey.groupIndex;
      PierIndexType pierIdx = (tenthPt == 11 || poi.HasAttribute(POI_BOUNDARY_PIER) ? GetGirderGroupEndPier(grpIdx) : GetGirderGroupStartPier(grpIdx));
      return pierIdx;
   }
   else
   {
      const CSegmentKey& segmentKey = poi.GetSegmentKey();
      Float64 Xpoi = poi.GetDistFromStart();
      Float64 Lg = GetGirderLength(segmentKey);
      if (Xpoi < 0 || Lg < Xpoi )
      {
         PierIndexType startPierIdx, endPierIdx;
         GetGirderGroupPiers(segmentKey.groupIndex, &startPierIdx, &endPierIdx);
         if (Xpoi < 0)
         {
            return startPierIdx;
         }
         else
         {
            return endPierIdx;
         }
      }
      return INVALID_INDEX;
   }
}

void CBridgeAgentImp::GetDuctRange(const CGirderKey& girderKey, DuctIndexType ductIdx, const pgsPointOfInterest** ppStartPoi, const pgsPointOfInterest** ppEndPoi) const
{
	VALIDATE_POINTS_OF_INTEREST(girderKey);
	PoiIDType startPoiID, endPoiID;
	m_pPoiMgr->GetDuctBoundary(girderKey, ductIdx, &startPoiID, &endPoiID);
	*ppStartPoi = &GetPointOfInterest(startPoiID);
	*ppEndPoi = &GetPointOfInterest(endPoiID);
}

void CBridgeAgentImp::GroupBySegment(const PoiList& vPoi, std::list<PoiList>* pList) const
{
   if ( vPoi.size() == 0 )
   {
      return;
   }

   CSegmentKey currentSegmentKey = vPoi.front().get().GetSegmentKey();
   PoiList vPoiThisSegment;
   for ( const pgsPointOfInterest& poi : vPoi)
   {
      const CSegmentKey& thisSegmentKey(poi.GetSegmentKey());
      if ( !thisSegmentKey.IsEqual(currentSegmentKey) )
      {
         // a new segment was encountered

         // save the vector of POI into the list
         pList->push_back(vPoiThisSegment);

         // clear it so we start fresh for the next segment
         vPoiThisSegment.clear();

         // next segment
         currentSegmentKey = thisSegmentKey;
      }
      vPoiThisSegment.push_back(poi);
   }

   pList->push_back(vPoiThisSegment);
}

void CBridgeAgentImp::GroupByGirder(const PoiList& vPoi,std::list<PoiList>* pList) const
{
   if ( vPoi.size() == 0 )
   {
      return;
   }

   CGirderKey currentGirderKey = vPoi.front().get().GetSegmentKey();
   PoiList vPoiThisGirder;
   for ( const pgsPointOfInterest& poi : vPoi)
   {
      CGirderKey thisGirderKey(poi.GetSegmentKey());
      if ( !thisGirderKey.IsEqual(currentGirderKey) )
      {
         // a new girder was encountered

         // save the vector of POI into the list
         pList->push_back(vPoiThisGirder);

         // clear it so we start fresh for the next girder
         vPoiThisGirder.clear();

         // next girder
         currentGirderKey = thisGirderKey;
      }
      vPoiThisGirder.push_back(poi);
   }

   pList->push_back(vPoiThisGirder);
}

void CBridgeAgentImp::GetSegmentKeys(const PoiList& vPoi, std::vector<CSegmentKey>* pvSegments) const
{
   for(const pgsPointOfInterest& poi : vPoi)
   {
      pvSegments->push_back(poi.GetSegmentKey());
   }
   pvSegments->erase(std::unique(std::begin(*pvSegments),std::end(*pvSegments)),std::end(*pvSegments));
}

void CBridgeAgentImp::GetSegmentKeys(const PoiList& vPoi,const CGirderKey& girderKey, std::vector<CSegmentKey>* pvSegments) const
{
   for(const pgsPointOfInterest& poi : vPoi)
   {
      if ( CGirderKey(poi.GetSegmentKey()) == girderKey )
      {
         pvSegments->push_back(poi.GetSegmentKey());
      }
   }
   pvSegments->erase(std::unique(std::begin(*pvSegments), std::end(*pvSegments)), std::end(*pvSegments));
}

void CBridgeAgentImp::GetGirderKeys(const PoiList& vPoi, std::vector<CGirderKey>* pvGirders) const
{
   std::vector<CSegmentKey> vSegmentKeys;
   GetSegmentKeys(vPoi,&vSegmentKeys);
   pvGirders->insert(std::begin(*pvGirders),std::begin(vSegmentKeys),std::end(vSegmentKeys));
   pvGirders->erase(std::unique(std::begin(*pvGirders),std::end(*pvGirders)),std::end(*pvGirders));
}

Float64 CBridgeAgentImp::ConvertPoiToSegmentPathCoordinate(const pgsPointOfInterest& poi) const
{
   Float64 Xsp = 0;
   if ( poi.HasSegmentPathCoordinate() )
   {
#if defined CHECK_POI_CONVERSIONS
      // force manual computation to verify the dimension in the poi is correct
      pgsPointOfInterest testPoi(poi.GetSegmentKey(),poi.GetDistFromStart());
      Float64 XspTest = ConvertPoiToSegmentPathCoordinate(testPoi);
      ATLASSERT(IsEqual(XspTest,poi.GetSegmentPathCoordinate()));
#endif
      Xsp = poi.GetSegmentPathCoordinate();
   }
   else
   {
      Xsp = ConvertSegmentCoordinateToSegmentPathCoordinate(poi.GetSegmentKey(),poi.GetDistFromStart());
      if ( poi.GetID() != INVALID_ID )
      {
         pgsPointOfInterest* pPoi = const_cast<pgsPointOfInterest*>(&poi);
         pPoi->SetSegmentPathCoordinate(Xsp);
      }
   }

#if defined CHECK_POI_CONVERSIONS
   static bool bTesting = false;
   if ( !bTesting )
   {
      bTesting = true;
      pgsPointOfInterest testPoi = ConvertSegmentPathCoordinateToPoi(poi.GetSegmentKey(),Xsp);
      ATLASSERT(poi.AtSamePlace(testPoi));
      bTesting = false;
   }
#endif

   return Xsp;
}

pgsPointOfInterest CBridgeAgentImp::ConvertSegmentPathCoordinateToPoi(const CSegmentKey& segmentKey,Float64 Xsp) const
{
   Float64 Xs = ConvertSegmentPathCoordinateToSegmentCoordinate(segmentKey,Xsp);
   pgsPointOfInterest poi = GetPointOfInterest(segmentKey,Xs);

#if defined CHECK_POI_CONVERSIONS
   static bool bTesting = false;
   if ( !bTesting )
   {
      bTesting = true;
      Float64 testXsp = ConvertPoiToSegmentPathCoordinate(poi);
      ATLASSERT(IsEqual(testXsp,Xsp));
      bTesting = false;
   }
#endif

   return poi;
}

Float64 CBridgeAgentImp::ConvertSegmentCoordinateToSegmentPathCoordinate(const CSegmentKey& segmentKey,Float64 Xs) const
{
   // We want to measure from the left face of the segment
   // |<------- Xsp ----->>
   // |<-- brg offset->|
   // |   |<-end dist->|
   // |<->|-- add this distance (start_offset) to Xs to get Xsp
   // |   |<--- Xs -------->>
   // |   |
   // |   +---------------------------------------/
   // |   |         Segment i                     \
   // |   +---------------------------------------/
   Float64 brg_offset = GetSegmentStartBearingOffset(segmentKey);
   Float64 end_dist   = GetSegmentStartEndDistance(segmentKey);
   Float64 start_offset = brg_offset - end_dist;
   Float64 Xsp = Xs + start_offset;


#if defined CHECK_POI_CONVERSIONS
   static bool bTesting = false;
   if ( !bTesting )
   {
      bTesting = true;
      Float64 testXs = ConvertSegmentPathCoordinateToSegmentCoordinate(segmentKey,Xsp);
      ATLASSERT(IsEqual(testXs,Xs));
      bTesting = false;
   }
#endif

   return Xsp;
}

Float64 CBridgeAgentImp::ConvertSegmentPathCoordinateToSegmentCoordinate(const CSegmentKey& segmentKey,Float64 Xsp) const
{
   // We want to measure from the left face of the segment
   // |<------- Xsp ----->>
   // |<-- brg offset->|
   // |   |<-end dist->|
   // |<->|-- subtract this distance (start_offset) from Xsp to get Xs
   // |   |<--- Xs -------->>
   // |   |
   // |   +---------------------------------------/
   // |   |         Segment i                     \
   // |   +---------------------------------------/

   Float64 brg_offset = GetSegmentStartBearingOffset(segmentKey);
   Float64 end_dist   = GetSegmentStartEndDistance(segmentKey);
   Float64 start_offset = brg_offset - end_dist;
   Float64 Xs = Xsp - start_offset;

#if defined CHECK_POI_CONVERSIONS
   static bool bTesting = false;
   if ( !bTesting )
   {
      bTesting = true;
      Float64 testXsp = ConvertSegmentCoordinateToSegmentPathCoordinate(segmentKey,Xs);
      ATLASSERT(IsEqual(testXsp,Xsp));
      bTesting = false;
   }
#endif

   return Xs;
}

Float64 CBridgeAgentImp::ConvertSegmentCoordinateToGirderCoordinate(const CSegmentKey& segmentKey,Float64 Xs) const
{
   pgsPointOfInterest poi(segmentKey,Xs);
   Float64 Xg = ConvertPoiToGirderCoordinate(poi);

   return Xg;
}

//void CBridgeAgentImp::ConvertGirderCoordinateToSegmentCoordinate(const CGirderKey& girderKey,Float64 Xg,CSegmentKey* pSegmentKey,Float64* pXs) const
//{
//}

Float64 CBridgeAgentImp::ConvertSegmentPathCoordinateToGirderPathCoordinate(const CSegmentKey& segmentKey,Float64 Xsp) const
{
   pgsPointOfInterest poi = ConvertSegmentPathCoordinateToPoi(segmentKey,Xsp);
   return ConvertPoiToGirderPathCoordinate(poi);
}

Float64 CBridgeAgentImp::ConvertSegmentCoordinateToGirderlineCoordinate(const CSegmentKey& segmentKey,Float64 Xs) const
{
   pgsPointOfInterest poi(segmentKey,Xs);
   return ConvertPoiToGirderlineCoordinate(poi);
}

Float64 CBridgeAgentImp::ConvertPoiToGirderPathCoordinate(const pgsPointOfInterest& poi) const
{
   const CSegmentKey& segmentKey = poi.GetSegmentKey();

   // must be a real segment
   ASSERT_SEGMENT_KEY(segmentKey);

   GroupIndexType  grpIdx = segmentKey.groupIndex;
   GirderIndexType gdrIdx = segmentKey.girderIndex;

   // Sum the layout length of the segment from the start of the girder, up to, but not including
   // the segment we are interested in
   Float64 Xgp = 0; // distance along the girder measured from the CL Pier at the start of the girder
   if ( poi.HasGirderPathCoordinate() )
   {
      Xgp = poi.GetGirderPathCoordinate();

#if defined CHECK_POI_CONVERSIONS
      pgsPointOfInterest testPoi;
      testPoi.SetLocation(poi.GetSegmentKey(),poi.GetDistFromStart());
      Float64 XgpTest = ConvertPoiToGirderPathCoordinate(testPoi);
      ATLASSERT(IsEqual(Xgp,XgpTest));
#endif
   }
   else
   {
      for ( SegmentIndexType segIdx = 0; segIdx < segmentKey.segmentIndex; segIdx++ )
      {
         CSegmentKey thisSegmentKey(grpIdx,gdrIdx,segIdx);

         // CL Pier - CL Pier length of the segment centerline
         Float64 L = GetSegmentLayoutLength(thisSegmentKey);

         Xgp += L;
      }
      
      // add the distance from the start of the segment to the poi
      Float64 Xsp = ConvertPoiToSegmentPathCoordinate(poi);
      Xgp += Xsp;

      if ( poi.GetID() != INVALID_ID )
      {
         pgsPointOfInterest* pPoi = const_cast<pgsPointOfInterest*>(&poi);
         pPoi->SetGirderPathCoordinate(Xgp);
      }
   }

#if defined CHECK_POI_CONVERSIONS
   static bool bTesting = false;
   if ( !bTesting )
   {
      bTesting = true;
      pgsPointOfInterest testPoi = ConvertGirderPathCoordinateToPoi(poi.GetSegmentKey(),Xgp);
      ATLASSERT(poi.AtSamePlace(testPoi));
      bTesting = false;
   }
#endif

   return Xgp;
}

pgsPointOfInterest CBridgeAgentImp::ConvertGirderPathCoordinateToPoi(const CGirderKey& girderKey,Float64 Xgp) const
{
   Float64 Xg = ConvertGirderPathCoordinateToGirderCoordinate(girderKey,Xgp);
   pgsPointOfInterest poi = ConvertGirderCoordinateToPoi(girderKey,Xg);

#if defined CHECK_POI_CONVERSIONS
   static bool bTesting = false;
   if ( !bTesting )
   {
      bTesting = true;
      Float64 testXgp = ConvertPoiToGirderPathCoordinate(poi);
      ATLASSERT(IsEqual(Xgp,testXgp));
      bTesting = false;
   }
#endif

   return poi;
}

pgsPointOfInterest CBridgeAgentImp::ConvertGirderCoordinateToPoi(const CGirderKey& girderKey,Float64 Xg) const
{
   pgsPointOfInterest poi;

   Float64 Lg = GetGirderLength(girderKey);
   if ( Xg < 0 )
   {
      // before the start of the girder
      CSegmentKey segmentKey(girderKey,0);
      poi = pgsPointOfInterest(segmentKey,Xg);
   }
   else if ( Lg < Xg )
   {
      // after the end of the girder
      SegmentIndexType nSegments = GetSegmentCount(girderKey);
      CSegmentKey segmentKey(girderKey,nSegments-1);
      Float64 Ls = GetSegmentLength(segmentKey);
      Float64 Xs = Ls + Xg - Lg;
      poi = pgsPointOfInterest(segmentKey,Xs);
   }
   else
   {
      // somewhere within the girder
      Float64 running_distance = 0;
      GroupIndexType nGroups = GetGirderGroupCount();
      SegmentIndexType nSegments = GetSegmentCount(girderKey);
      for ( SegmentIndexType segIdx = 0; segIdx < nSegments; segIdx++ )
      {
         CSegmentKey segmentKey(girderKey,segIdx);
         Float64 segmentLength = GetSegmentLayoutLength(segmentKey);

         // if this is the first segment, remove the start offset distance so that segmentLength
         // is measured on the same basis as Xg
         if ( segIdx == 0 )
         {
            Float64 brgOffset = GetSegmentStartBearingOffset(segmentKey);
            Float64 endDist   = GetSegmentStartEndDistance(segmentKey);
            Float64 offset_dist = brgOffset - endDist;
            offset_dist = IsZero(offset_dist) ? 0 : offset_dist;
            segmentLength -= offset_dist;
         }
         
         // if this is the last segment, remove the end offset distance so that we
         // don't go beyond the end of the girder
         if ( segIdx == nSegments-1 )
         {
            Float64 brgOffset = GetSegmentEndBearingOffset(segmentKey);
            Float64 endDist   = GetSegmentEndEndDistance(segmentKey);
            Float64 offset_dist = brgOffset - endDist;
            offset_dist = IsZero(offset_dist) ? 0 : offset_dist;
            segmentLength -= offset_dist;
         }

         if ( ::IsLE(running_distance,Xg) && ::IsLE(Xg,running_distance+segmentLength) )
         {
            // the POI occurs in this segment
            
            Float64 Xpoi = Xg - running_distance; // this is the distance from the
            // CLPier/CLTempSupport to the POI (basically a segment coordinate unless this is in
            // the first segment, then Xpoi is measured from the start face of the segment)
            if (segIdx != 0) 
            {
               // if this is not the first segment, adjust Xpoi so that it is measured from the start
               // face of the segment
               Float64 brgOffset = GetSegmentStartBearingOffset(segmentKey);
               Float64 endDist   = GetSegmentStartEndDistance(segmentKey);
               Float64 offset_dist = brgOffset - endDist;
               offset_dist = IsZero(offset_dist) ? 0 : offset_dist;
               Xpoi -= offset_dist;
               segmentLength -= offset_dist;
            }

            Xpoi = IsZero(Xpoi) ? 0 : Xpoi;
            Xpoi = IsEqual(Xpoi,segmentLength) ? segmentLength : Xpoi;

            // Gets the actual POI at this location, or returns a temporary poi if not found
            poi = GetPointOfInterest(segmentKey,Xpoi);
            ATLASSERT(IsEqual(poi.GetDistFromStart(),Xpoi));
            break;
         }
         else
         {
            running_distance += segmentLength;
         }
      }
   }

   ATLASSERT(poi.GetSegmentKey() != CSegmentKey());// should have found it or you are asking for a POI that is off the bridge

#if defined CHECK_POI_CONVERSIONS
   static bool bTesting = false;
   if ( !bTesting )
   {
      bTesting = true;
      Float64 testXg = ConvertPoiToGirderCoordinate(poi);
      ATLASSERT(IsEqual(Xg,testXg));
      bTesting = false;
   }
#endif
   return poi;
}

Float64 CBridgeAgentImp::ConvertPoiToGirderCoordinate(const pgsPointOfInterest& poi) const
{
   Float64 Xg = 0;
   if ( poi.HasGirderCoordinate() )
   {
      Xg = poi.GetGirderCoordinate();

#if defined CHECK_POI_CONVERSIONS
      pgsPointOfInterest testPoi;
      testPoi.SetLocation(poi.GetSegmentKey(),poi.GetDistFromStart());
      Float64 XgTest = ConvertPoiToGirderCoordinate(testPoi);
      ATLASSERT(IsEqual(Xg,XgTest));
#endif
   }
   else
   {
      Float64 Xgp = ConvertPoiToGirderPathCoordinate(poi);

      // We want to measure from the left face of the girder so adjust for the connection geometry

      // |<------- Xgp ----->>
      // |<-- brg offset->|
      // |   |<-end dist->|
      // |<->|-- deduct this distance (start_offset) from Xgp to get Xg
      // |   |<--- Xg -------->>
      // |   |
      // |   +---------------------------------------/
      // |   |          Segment 0                    \
      // |   +---------------------------------------/
      CSegmentKey segmentKey(poi.GetSegmentKey());
      CSegmentKey firstSegmentKey(segmentKey.groupIndex,segmentKey.girderIndex,0);
      Float64 brgOffset = GetSegmentStartBearingOffset(firstSegmentKey);
      Float64 endDist   = GetSegmentStartEndDistance(firstSegmentKey);
      Float64 start_offset = brgOffset - endDist;
      start_offset = IsZero(start_offset) ? 0 : start_offset;

      Xg = Xgp - start_offset;

      if ( poi.GetID() != INVALID_ID )
      {
         pgsPointOfInterest* pPoi = const_cast<pgsPointOfInterest*>(&poi);
         pPoi->SetGirderCoordinate(Xg);
      }
   }

#if defined CHECK_POI_CONVERSIONS
   static bool bTesting = false;
   if ( !bTesting )
   {
      bTesting = true;
      pgsPointOfInterest testPoi = ConvertGirderCoordinateToPoi(poi.GetSegmentKey(),Xg);
      ATLASSERT(poi.AtSamePlace(testPoi));
      bTesting = false;
   }
#endif

   return Xg;
}

Float64 CBridgeAgentImp::ConvertGirderCoordinateToGirderPathCoordinate(const CGirderKey& girderKey,Float64 Xg) const
{
   // |<------- Xgp ----->>
   // |<-- brg offset->|
   // |   |<-end dist->|
   // |<->|-- add this distance (start_offset) to Xg to get Xgp
   // |   |<--- Xg -------->>
   // |   |
   // |   +---------------------------------------/
   // |   |          Segment 0                    \
   // |   +---------------------------------------/

   CSegmentKey segmentKey(girderKey,0);
   Float64 brgOffset = GetSegmentStartBearingOffset(segmentKey);
   Float64 endDist   = GetSegmentStartEndDistance(segmentKey);
   Float64 offset_dist = brgOffset - endDist;
   offset_dist = IsZero(offset_dist) ? 0 : offset_dist;
   Float64 Xgp = Xg + offset_dist;
   return Xgp;
}

Float64 CBridgeAgentImp::ConvertGirderPathCoordinateToGirderCoordinate(const CGirderKey& girderKey,Float64 Xgp) const
{
   // |<------- Xgp ----->>
   // |<-- brg offset->|
   // |   |<-end dist->|
   // |<->|-- deduct this distance (start_offset) from Xgp to get Xg
   // |   |<--- Xg -------->>
   // |   |
   // |   +---------------------------------------/
   // |   |          Segment 0                    \
   // |   +---------------------------------------/

   GirderIndexType gdrIdx = Min(girderKey.girderIndex,GetGirderCount(girderKey.groupIndex)-1);
   CSegmentKey segmentKey(girderKey.groupIndex,gdrIdx,0);
   Float64 brgOffset = GetSegmentStartBearingOffset(segmentKey);
   Float64 endDist   = GetSegmentStartEndDistance(segmentKey);
   Float64 offset_dist = brgOffset - endDist;
   offset_dist = IsZero(offset_dist) ? 0 : offset_dist;
   Float64 Xg = Xgp - offset_dist;
   return Xg;
}

Float64 CBridgeAgentImp::ConvertGirderPathCoordinateToGirderlineCoordinate(const CGirderKey& girderKey, Float64 Xgp) const
{
   pgsPointOfInterest poi = ConvertGirderPathCoordinateToPoi(girderKey, Xgp);
   return ConvertPoiToGirderlineCoordinate(poi);
}

Float64 CBridgeAgentImp::ConvertPoiToGirderlineCoordinate(const pgsPointOfInterest& poi) const
{
   if (poi.HasGirderlineCoordinate())
   {
#if defined CHECK_POI_CONVERSIONS
      // force manual computation to verify the dimension in the poi is correct
      pgsPointOfInterest testPoi(poi.GetSegmentKey(), poi.GetDistFromStart());
      Float64 XglTest = ConvertPoiToGirderlineCoordinate(testPoi);
      ATLASSERT(IsEqual(XglTest, poi.GetGirderlineCoordinate()));
#endif
      return poi.GetGirderlineCoordinate();
   }

   Float64 Xgl = 0;
   const CSegmentKey& segmentKey(poi.GetSegmentKey());
   if ( segmentKey.groupIndex == 0 )
   {
      Xgl = ConvertPoiToGirderCoordinate(poi);
   }
   else
   {
      Float64 Xgp = ConvertPoiToGirderPathCoordinate(poi);
      Float64 sum_girder_layout_length = 0; // sum of girder length from start of bridge up to but not including the group
      // this poi is in
      for (GroupIndexType grpIdx = 0; grpIdx < segmentKey.groupIndex; grpIdx++)
      {
         CGirderKey girderKey(grpIdx, segmentKey.girderIndex);
         girderKey.girderIndex = Min(girderKey.girderIndex, GetGirderCount(grpIdx) - 1);
         Float64 girder_layout_length = GetGirderLayoutLength(girderKey);
         sum_girder_layout_length += girder_layout_length;
      }

      // sum_girder_layout_length is measured from CL Pier 0, we want it measured from the start face of the girder
      CSegmentKey segKey(0, Min(segmentKey.girderIndex, GetGirderCount(0) - 1), 0);
      Float64 brg_offset = GetSegmentStartBearingOffset(segKey);
      Float64 end_dist = GetSegmentStartEndDistance(segKey);
      Float64 start_offset = brg_offset - end_dist; // distance from CL Pier 0 to start face of girder
      sum_girder_layout_length -= start_offset;

      Xgl = Xgp + sum_girder_layout_length;
   }

   if (poi.GetID() != INVALID_ID)
   {
      pgsPointOfInterest* pPoi = const_cast<pgsPointOfInterest*>(&poi);
      pPoi->SetGirderlineCoordinate(Xgl);
   }
   return Xgl;
}

pgsPointOfInterest CBridgeAgentImp::ConvertGirderlineCoordinateToPoi(GirderIndexType gdrIdx,Float64 Xgl) const
{
   // It will be easier to find which group Xgl is located in if we
   // convert it to a measurement from the Pier line at abutment 0.
   CSegmentKey segmentKey(0, Min(GetGirderCount(0) - 1, gdrIdx), 0);
   Float64 brg_offset = GetSegmentStartBearingOffset(segmentKey);
   Float64 end_dist   = GetSegmentStartEndDistance(segmentKey);
   Float64 start_offset = brg_offset - end_dist;
   Float64 X = Xgl + start_offset;

   GroupIndexType grpIdx = 0;
   Float64 Xstart = 0; // distance from Pier 0 to start of current group
   if ( X < 0 )
   {
      grpIdx = 0;
   }
   else
   {
      // Search for the group where the point under consideration occurs
      GroupIndexType nGroups = GetGirderGroupCount();
      Float64 Xend   = 0; // distance from Pier 0 to end of current group
      for ( grpIdx = 0; grpIdx < nGroups; grpIdx++ )
      {
         GirderIndexType thisGdrIdx = Min(gdrIdx, GetGirderCount(grpIdx) - 1);
         CGirderKey girderKey(grpIdx,thisGdrIdx);
         Xend += GetGirderLayoutLength(girderKey); // update end of current group

         if (grpIdx == nGroups - 1)
         {
            // deal with the last sgment extending beyond the last pier line
            SegmentIndexType nSegments = GetSegmentCount(girderKey);
            CSegmentKey segmentKey(girderKey,nSegments-1);
            Float64 brg_offset = GetSegmentEndBearingOffset(segmentKey);
            Float64 end_dist = GetSegmentEndEndDistance(segmentKey);
            Float64 end_offset = brg_offset - end_dist;
            if (end_offset < 0)
            {
               Xend -= end_offset;
            }
         }

         // is target point in this group?
         if ( ::InRange(Xstart,X,Xend) )
         {
            // we found the group
            break;
         }

         Xstart = Xend; // next group starts where current group ends
      }

      if ( nGroups <= grpIdx )
      {
         ATLASSERT(false); // if this fires, the group wasn't found
         grpIdx = nGroups - 1; // use the last group
      }
   }

   Float64 Xgp = X - Xstart;
   CGirderKey girderKey(grpIdx,Min(GetGirderCount(grpIdx)-1,gdrIdx));
   return ConvertGirderPathCoordinateToPoi(girderKey,Xgp);
}

Float64 CBridgeAgentImp::ConvertRouteToBridgeLineCoordinate(Float64 station) const
{
   VALIDATE( BRIDGE );
   CComPtr<IPierCollection> piers;
   m_Bridge->get_Piers(&piers);

   CComPtr<IBridgePier> pier;
   piers->get_Item(0,&pier);

   CComPtr<IStation> objStation;
   pier->get_Station(&objStation);

   Float64 sta_value;
   objStation->get_Value(&sta_value);

   Float64 dist = station - sta_value;

   return dist;
}

Float64 CBridgeAgentImp::ConvertBridgeLineToRouteCoordinate(Float64 Xb) const
{
   Float64 station = GetPierStation(0);
   Float64 Xr = station + Xb;
   return Xr;
}

Float64 CBridgeAgentImp::ConvertPoiToBridgeLineCoordinate(const pgsPointOfInterest& poi) const
{
   Float64 station,offset;
   GetStationAndOffset(poi,&station,&offset);
   return ConvertRouteToBridgeLineCoordinate(station);
}

PoiAttributeType g_TargetAttribute;
PoiAttributeType g_ExceptionAttribute;
bool RemovePOI(const pgsPointOfInterest& poi)
{
   return poi.HasAttribute(g_TargetAttribute) && !poi.HasAttribute(g_ExceptionAttribute);
}

void CBridgeAgentImp::RemovePointsOfInterest(PoiList& vPoi,PoiAttributeType targetAttribute,PoiAttributeType exceptionAttribute) const
{
   g_TargetAttribute = targetAttribute;
   g_ExceptionAttribute  = exceptionAttribute;
   auto new_end = std::remove_if(std::begin(vPoi),std::end(vPoi),RemovePOI);
   if (std::begin(vPoi) != new_end)
   {
      // NOTE: We can't use vPoi.resize(std::distance(std::start(vPoi),new_end)) because reference_wrappers cannot be default constructed
      // best solution I can think of is to create a new, smaller list, and copy
      PoiList newList(std::begin(vPoi), new_end);
      vPoi = newList;
   }
}

bool CBridgeAgentImp::IsInClosureJoint(const pgsPointOfInterest& poi,CClosureKey* pClosureKey) const
{
   CSegmentKey segmentKey(poi.GetSegmentKey());

   if (IsOnSegment(poi))
   {
      *pClosureKey = CClosureKey(INVALID_INDEX, INVALID_INDEX, INVALID_INDEX);
      return false;
   }

   Float64 Xpoi = poi.GetDistFromStart();

   bool bAdjustSegmentIndex = false;
   if ( Xpoi < 0 && 0 < segmentKey.segmentIndex )
   {
      // POI is before the start of this segment so the closure pour
      // test has to be based on the previous segment
      segmentKey.segmentIndex--; // adjust the segment index
      bAdjustSegmentIndex = true;
   }

   const CClosureKey& closureKey(segmentKey);
   Float64 Lc = (segmentKey.segmentIndex == GetSegmentCount(segmentKey)-1 ? 0 : GetClosureJointLength(closureKey));
   Float64 Ls = GetSegmentLength(segmentKey);

   if ( Xpoi < 0 && bAdjustSegmentIndex )
   {
      // POI location needs to be adjusted because we switched to the previous segment
      // Xpoi is located from the start of the previous segment
      //
      //                               CL Closure Joint
      //                               :
      //                               : |<->| Xpoi < 0
      // +-------------------------+   : *   +-----------------------------\
      // |                         |   :     |                             /
      // +-------------------------+   :     +-----------------------------\
      // |    Adjusted Xpoi              |   |
      // |<----------------------------->|   |
      // |          Ls             |  Lc     |
      // |<----------------------->|<------->|

      Xpoi = Ls + Lc + Xpoi;
   }

#if defined _DEBUG
   if ( poi.HasAttribute(POI_CLOSURE) )
   {
      Float64 left, right;
      GetClosureJointSize(closureKey,&left,&right);
      ATLASSERT(::IsEqual(Ls+left,Xpoi,0.001));
   }
#endif


   // NOTE: don't use <= , ::InRange(), or ::LE() because if Xpoi is exactly
   // at the interface between the segment and the closure, we consider this
   // being in the segment.
   bool bIsInClosure = (Ls < Xpoi && Xpoi < Ls+Lc) ? true : false;
   if ( bIsInClosure )
   {
      *pClosureKey = closureKey;
   }
   else
   {
      *pClosureKey = CClosureKey(INVALID_INDEX,INVALID_INDEX,INVALID_INDEX);
   }

   return bIsInClosure;
}

bool CBridgeAgentImp::IsOnSegment(const pgsPointOfInterest& poi) const
{
   const CSegmentKey& segmentKey(poi.GetSegmentKey());
   Float64 Ls = GetSegmentLength(segmentKey);
   Float64 Xpoi = poi.GetDistFromStart();
   return ::InRange(0.0,Xpoi,Ls) ? true : false;
}

bool CBridgeAgentImp::IsOffSegment(const pgsPointOfInterest& poi) const
{
   return !IsOnSegment(poi);
}

bool CBridgeAgentImp::IsOnGirder(const pgsPointOfInterest& poi) const
{
   const CGirderKey& girderKey(poi.GetSegmentKey());
   Float64 Lg = GetGirderLength(girderKey);
   Float64 Xg = ConvertPoiToGirderCoordinate(poi);
   return ::InRange(0.0,Xg,Lg) ? true : false;
}

bool CBridgeAgentImp::IsInBoundaryPierDiaphragm(const pgsPointOfInterest& poi) const
{
   return !IsOnGirder(poi);
}

bool CBridgeAgentImp::IsInCriticalSectionZone(const pgsPointOfInterest& poi,pgsTypes::LimitState limitState) const
{
   PoiAttributeType csAttribute;
   
   GET_IFACE(ILibrary, pLib);
   GET_IFACE(ISpecification,pSpec);
   const SpecLibraryEntry* pSpecEntry = pLib->GetSpecEntry( pSpec->GetSpecification().c_str() );

   // LRFD 2004 and later, critical section is only a function of dv, which comes from the calculation of Mu,
   // so critical section is not a function of the limit state. We will work with the Strength I limit state
   if ( lrfdVersionMgr::ThirdEdition2004 <= pSpecEntry->GetSpecificationType() )
   {
      csAttribute = POI_CRITSECTSHEAR1;
   }
   else
   {
      ATLASSERT(IsStrengthLimitState(limitState));
      csAttribute = (IsStrengthILimitState(limitState) ? POI_CRITSECTSHEAR1 : POI_CRITSECTSHEAR2);
   }

   if ( poi.HasAttribute(csAttribute) )
   {
      // this may seem backwards... may seem like true should be returned, but false is correct.
      // The intent of this method is to determine of a poi is located such that shear requirements
      // are applicable. Returning true means that the poi is located somewhere between the face of
      // support and the CS and the shear requirements are not applicable. Shear requirements
      // are applicable at the CS so we return false here so this poi doesn't get ignored
      return false;
   }

   const CSegmentKey& segmentKey(poi.GetSegmentKey());

   PoiList vPoi;
   GetCriticalSections(limitState, segmentKey,&vPoi);
   ATLASSERT( 2 <= vPoi.size() );

   Float64 Xgl = ConvertPoiToGirderlineCoordinate(poi);

   //
   // The critical section for shear locations alternate along the length of the girder
   // Critical sections are near supports and not in the center portion of spans.
   //
   // The vector of critical section POI contains the CS locations that occur
   // at the boundary of the CS zones.
   // We will walk the vector zone by zone to see if the subject POI is between
   // two CS zone boundaries
   //
   // Yes      No          Yes         No      Yes       No      Yes   Yes/No In/Out of critical section zone
   // |---|-----------|------------|-------|----------|--------|----|  Beam with critical section zone boundaries
   // O                      ^                  ^                   O  Supports
   // ^   ^           ^                                                Critical section zones (illustrated)
   // |   |           |
   //                 ^            ^
   //                 |            |
   //                              ^       ^
   //                              |       | ... etc
   //
   // The first check, the poi will not be in a CS zone. The second check, the poi will be
   // in a CS zone... and so on. The in/out of a CS zone alternates.

   bool bIsInCSZone = false;
   auto iter(std::begin(vPoi));
   ATLASSERT((*iter).get().HasAttribute(csAttribute));
   Float64 Xprev = ConvertPoiToGirderlineCoordinate(*iter++);
   auto endIter(std::end(vPoi));
   for ( ; iter != endIter; iter++, bIsInCSZone = !bIsInCSZone )
   {
      const pgsPointOfInterest& nextPoi(*iter);
      ATLASSERT(nextPoi.HasAttribute(csAttribute));
      Float64 Xnext = ConvertPoiToGirderlineCoordinate(nextPoi);
      if ( ::InRange(Xprev,Xgl,Xnext) )
      {
         return bIsInCSZone;
      }

      Xprev = Xnext;
   }

   // if we got this far, the poi is either near the start of the end of the girder in which
   // case it is in a critical section zone.
   return true;
}

template <class T>
IndexType PoiToDeckCastingRegion(T* pSlab, const pgsPointOfInterest& poi)
{
   CComPtr<ICastingRegions> regions;
   pSlab->get_CastingRegions(&regions);

   const auto& segmentKey(poi.GetSegmentKey());
   GirderIDType ssmbrID = ::GetSuperstructureMemberID(segmentKey);
   SegmentIndexType segIdx = segmentKey.segmentIndex;
   Float64 Xs = poi.GetDistFromStart();
   SectionBias sectionBias = GetSectionBias(poi);
   IndexType regionIdx;
   CComPtr<ICastingRegion> region;
   HRESULT hr = regions->FindRegionEx(ssmbrID, segIdx, Xs, sectionBias, &regionIdx, &region);
   if (FAILED(hr))
   {
      return INVALID_INDEX;
   }

   return regionIdx;
}

IndexType CBridgeAgentImp::GetDeckCastingRegion(const pgsPointOfInterest& poi) const
{
   if (poi.HasDeckCastingRegion())
   {
      return poi.GetDeckCastingRegion();
   }

   VALIDATE(BRIDGE);
   CComPtr<IBridgeDeck> deck;
   m_Bridge->get_Deck(&deck);
   CComQIPtr<ICastSlab> castSlab(deck);
   CComQIPtr<IPrecastSlab> precastSlab(deck);
   CComQIPtr<IOverlaySlab> overlaySlab(deck);
   IndexType deckCastingRegionIdx;
   if (castSlab)
   {
      deckCastingRegionIdx = PoiToDeckCastingRegion<ICastSlab>(castSlab, poi);
   }
   else if (precastSlab)
   {
      deckCastingRegionIdx = PoiToDeckCastingRegion<IPrecastSlab>(precastSlab, poi);
   }
   else if (overlaySlab)
   {
      deckCastingRegionIdx = 0;
   }
   else
   {
      deckCastingRegionIdx = INVALID_INDEX;
   }

   if (poi.GetID() != INVALID_ID)
   {
      pgsPointOfInterest* pPoi = const_cast<pgsPointOfInterest*>(&poi);
      pPoi->SetDeckCastingRegion(deckCastingRegionIdx);
   }

   return deckCastingRegionIdx;
}

/////////////////////////////////////////////////////////////////////////
// ISectionProperties
//
pgsTypes::SectionPropertyMode CBridgeAgentImp::GetSectionPropertiesMode() const
{
   GET_IFACE(ILibrary, pLib);
   GET_IFACE(ISpecification, pSpec);
   const SpecLibraryEntry* pSpecEntry = pLib->GetSpecEntry(pSpec->GetSpecification().c_str());
   pgsTypes::SectionPropertyMode sectPropMode = pSpecEntry->GetSectionPropertyMode();
   return sectPropMode;
}

pgsTypes::HaunchAnalysisSectionPropertiesType CBridgeAgentImp::GetHaunchAnalysisSectionPropertiesType()const 
{
      GET_IFACE(ILibrary, pLib);
      GET_IFACE(ISpecification, pSpec);
      const SpecLibraryEntry* pSpecEntry = pLib->GetSpecEntry(pSpec->GetSpecification().c_str());
      return pSpecEntry->GetHaunchAnalysisSectionPropertiesType();
}

std::vector<WBFL::Geometry::Point2d> CBridgeAgentImp::GetStressPoints(IntervalIndexType intervalIdx, const pgsPointOfInterest& poi, pgsTypes::StressLocation location, const GDRCONFIG* pConfig) const
{
   std::vector<WBFL::Geometry::Point2d> vPoints;

   bool bIsCompositeDeck = IsCompositeDeck();
   if (IsDeckStressLocation(location))
   {
      IndexType deckCastingRegionIdx = GetDeckCastingRegion(poi);
      IntervalIndexType compositeDeckIntervalIdx = GetCompositeDeckInterval(deckCastingRegionIdx);
      if (!bIsCompositeDeck || intervalIdx < compositeDeckIntervalIdx)
      {
         return vPoints;
      }
   }

   const CSegmentKey& segmentKey = poi.GetSegmentKey();

   Float64 E;
   if (pConfig)
   {
      bool bEcChanged;
      E = GetSegmentEc(segmentKey, intervalIdx, pConfig->fc, &bEcChanged);

      // if the "trial" girder strength is the same as the real girder strength
      // don't do a bunch of extra work. Return the properties for the real girder
      if (!bEcChanged)
      {
         return GetStressPoints(intervalIdx,poi,location);
      }
   }

   pgsTypes::SectionPropertyType sectPropType = GetSectionPropertiesType();

   CComPtr<IShapeProperties> sprops;
   CComPtr<ISection> section;

   IndexType gdr_idx, slab_idx;
   if (pConfig)
   {
      GetShapeProperties(sectPropType, intervalIdx, poi, E, &sprops);
      HRESULT hr = CreateSection(intervalIdx, poi, sectPropType, pgsTypes::scGirder, &gdr_idx, &slab_idx, &section);
      ATLASSERT(SUCCEEDED(hr));
   }
   else
   {
      const SectProp& props = GetSectionProperties(intervalIdx, poi, sectPropType);
      gdr_idx = props.GirderShapeIndex;
      slab_idx = props.SlabShapeIndex;
      sprops = props.ShapeProps;
      section = props.Section;
   }

   if (section == nullptr)
   {
      // this can happen if the POI is in a pier and there isn't continuity
      return vPoints;
   }

   bool bHasAsymmetricGirders = HasAsymmetricGirders();


   IntervalIndexType erectionIntervalIdx = GetErectSegmentInterval(segmentKey);

   if (bHasAsymmetricGirders && intervalIdx <= erectionIntervalIdx)
   {
      // at this point, the stress location must be for the girder
      ATLASSERT(IsGirderStressLocation(location));

      CComQIPtr<ICompositeSectionEx> compSection(section);
      CComPtr<ICompositeSectionItemEx> item;
      compSection->get_Item(gdr_idx, &item);
      CComPtr<IShape> shape;
      item->get_Shape(&shape);

      CComQIPtr<IAsymmetricSection> asymmetric(shape);

      CComPtr<IPoint2d> pntCG;
      sprops->get_Centroid(&pntCG);

      Float64 xcg, ycg;
      pntCG->Location(&xcg, &ycg);

      CComPtr<IPoint2dCollection> points;
      asymmetric->GetStressPoints(location == pgsTypes::TopGirder ? spTop : spBottom, &points);
      CComPtr<IEnumPoint2d> enumPoints;
      points->get__Enum(&enumPoints);
      CComPtr<IPoint2d> pnt;
      while (enumPoints->Next(1, &pnt, nullptr) != S_FALSE)
      {
         Float64 x, y;
         pnt->Offset(-xcg, -ycg); // convert to centroidal/stress point coordinate system
         pnt->Location(&x, &y);

         vPoints.emplace_back(x, y);

         pnt.Release();
      }
   }
   else
   {
      Float64 x = 0;
      Float64 y = (pConfig ? GetY(intervalIdx, poi, location, pConfig->fc) : GetY(intervalIdx, poi, location));
      if (location == pgsTypes::BottomGirder)
      {
         y *= -1;
      }
      vPoints.emplace_back(x, y);
   }

   return vPoints;
}

void CBridgeAgentImp::GetStressCoefficients(IntervalIndexType intervalIdx, const pgsPointOfInterest& poi, pgsTypes::StressLocation location, const GDRCONFIG* pConfig, Float64* pCa, Float64 *pCbx,Float64* pCby, IndexType* pControllingStressPointIndex) const
{
   bool bIsCompositeDeck = IsCompositeDeck();
   if (IsDeckStressLocation(location))
   {
      IndexType deckCastingRegionIdx = GetDeckCastingRegion(poi);
      IntervalIndexType compositeDeckIntervalIdx = GetCompositeDeckInterval(deckCastingRegionIdx);
      if (!bIsCompositeDeck || intervalIdx < compositeDeckIntervalIdx)
      {
         // if the deck is not composite or this is an interval before 
         // the composite deck becomes composite, the deck can't take any
         // load so use zero values to stresses come out zero.
         *pCa = 0;
         *pCbx = 0;
         *pCby = 0;

         if (pControllingStressPointIndex)
         {
            *pControllingStressPointIndex = INVALID_INDEX;
         }
         return;
      }
   }

   const CSegmentKey& segmentKey = poi.GetSegmentKey();

   Float64 E;
   if (pConfig)
   {
      bool bEcChanged;
      E = GetSegmentEc(segmentKey, intervalIdx, pConfig->fc, &bEcChanged);

      // if the "trial" girder strength is the same as the real girder strength
      // don't do a bunch of extra work. Return the properties for the real girder
      if (!bEcChanged)
      {
         GetStressCoefficients(intervalIdx, poi, location, nullptr, pCa, pCbx, pCby, pControllingStressPointIndex);
         return;
      }
   }

   pgsTypes::SectionPropertyType sectPropType = GetSectionPropertiesType();

   CComPtr<IShapeProperties> sprops;
   CComPtr<ISection> section;

   IndexType gdr_idx, slab_idx;
   if (pConfig)
   {
      GetShapeProperties(sectPropType, intervalIdx, poi, E, &sprops);
      HRESULT hr = CreateSection(intervalIdx, poi, sectPropType, pgsTypes::scGirder, &gdr_idx, &slab_idx, &section);
      ATLASSERT(SUCCEEDED(hr));
   }
   else
   {
      const SectProp& props = GetSectionProperties(intervalIdx, poi, sectPropType);
      gdr_idx = props.GirderShapeIndex;
      slab_idx = props.SlabShapeIndex;
      sprops = props.ShapeProps;
      section = props.Section;
   }

   if (section == nullptr)
   {
      // this can happen if the POI is in a pier and there isn't continuity
      *pCa = 0.0;
      *pCbx = 0.0;
      *pCby = 0.0;
      if (pControllingStressPointIndex)
      {
         *pControllingStressPointIndex = INVALID_INDEX;
      }
      return;
   }

   Float64 A, Ixx, Iyy, Ixy(0);
   sprops->get_Area(&A);
   sprops->get_Ixx(&Ixx);
   sprops->get_Iyy(&Iyy);

   bool bHasAsymmetricGirders = HasAsymmetricGirders();
   if (bHasAsymmetricGirders)
   {
      sprops->get_Ixy(&Ixy);
   }

   IntervalIndexType erectionIntervalIdx = GetErectSegmentInterval(poi.GetSegmentKey());
   if (erectionIntervalIdx < intervalIdx)
   {
      // assume full lateral bracing after erection which results in
      // standard uni-axial bending about the X-axis
      Ixy = 0;
   }

   *pCa = IsZero(A) ? 0 : 1/A;

   Float64 D = (Ixx*Iyy - Ixy*Ixy);

   CComQIPtr<ICompositeSectionEx> compSection(section);
   CComPtr<ICompositeSectionItemEx> item;
   compSection->get_Item(gdr_idx, &item);
   CComPtr<IShape> shape;
   item->get_Shape(&shape);

   if (bHasAsymmetricGirders && intervalIdx <= erectionIntervalIdx)
   {
      // at this point, the stress location must be for the girder
      ATLASSERT(IsGirderStressLocation(location));

      CComQIPtr<IAsymmetricSection> asymmetric(shape);

      Float64 CbxMin = Float64_Max;
      Float64 CbxMax = -Float64_Max;

      Float64 CbyMin = Float64_Max;
      Float64 CbyMax = -Float64_Max;

      // stress points are in bridge section coordinates... need to convert to centroidal coordinates
      // Centroid is also in bridge section coordinates... to convert, all we have to do is subtract
      // the stress point coordinated from the centroid

      CComPtr<IPoint2d> pntCG;
      sprops->get_Centroid(&pntCG);

      Float64 xcg, ycg;
      pntCG->Location(&xcg, &ycg);

      CComPtr<IPoint2dCollection> points;
      asymmetric->GetStressPoints(location == pgsTypes::TopGirder ? spTop : spBottom, &points);

      IndexType idx = 0;
      IndexType minIdx, maxIdx;
      CComPtr<IEnumPoint2d> enumPoints;
      points->get__Enum(&enumPoints);
      CComPtr<IPoint2d> pnt;
      while (enumPoints->Next(1, &pnt, nullptr) != S_FALSE)
      {
         Float64 x, y;
         pnt->Offset(-xcg, -ycg); // convert to centroidal/stress point coordinate system
         pnt->Location(&x, &y);

         // bending about the x-axis is dominant. The only way we get bending about the y-axis is from prestressing
         // that is offset from the y-axis a slight amount. Get the min/max stress coefficient based on
         // bending about the x-axis and then retain the corresponding y-axis bending stress coefficient

         // f(x,y) = (MyIxx + MxIxy)x/(IxxIyy-Ixy^2) - (MxIyy + MyIxy)y/(IxxIyy-Ixy^2)
         Float64 cbx = (Ixy*x - Iyy*y) / D; // Mx != 0, My = 0
         Float64 cby = (Ixx*x - Ixy*y) / D; // Mx = 0, My != 0
         if (cbx < CbxMin)
         {
            CbxMin = cbx;
            CbyMin = cby;
            minIdx = idx;
         }

         if (CbxMax < cbx)
         {
            CbxMax = cbx;
            CbyMax = cby;
            maxIdx = idx;
         }

         pnt.Release();
         idx++;
      }

      *pCbx = location == pgsTypes::BottomGirder ? CbxMax : CbxMin;
      *pCby = location == pgsTypes::BottomGirder ? CbyMax : CbyMin;
      if (pControllingStressPointIndex)
      {
         *pControllingStressPointIndex = (location == pgsTypes::BottomGirder ? maxIdx : minIdx);
      }
   }
   else
   {
      Float64 x = 0;
      Float64 y = (pConfig ? GetY(intervalIdx,poi,location,pConfig->fc) : GetY(intervalIdx, poi, location));
      if (location == pgsTypes::BottomGirder)
      {
         y *= -1;
      }

      *pCbx = -y/Ixx;
      *pCby = 0;
      if (pControllingStressPointIndex)
      {
         *pControllingStressPointIndex = 0;
      }
   }


   // if we are getting stresses in the deck, need to adjust the stress coefficients
   // by the Deck/Girder modular ratio
   if (IsDeckStressLocation(location) && IsStructuralDeck(GetDeckType()))
   {
      Float64 Eg;
      if (pConfig)
      {
         bool bEcChanged;
         Eg = GetSegmentEc(segmentKey, intervalIdx, pConfig->fc, &bEcChanged);
      }
      else
      {
         Eg = GetSegmentEc(segmentKey, intervalIdx);
      }

      IndexType deckCastingRegionIdx = GetDeckCastingRegion(poi);

      Float64 Ed = GetDeckEc(deckCastingRegionIdx,intervalIdx);

      Float64 n = Ed / Eg; // NOTE: this is opposite the modular ratio used with S because stress is M/S or Cb*M... this is sort of like Cb = 1/S 
      *pCa *= n;
      *pCbx *= n;
   }
}

Float64 CBridgeAgentImp::GetHg(IntervalIndexType intervalIdx,const pgsPointOfInterest& poi) const
{
   // Height of the girder is invariant to the section property type. The height will
   // always be the same for gross and transformed properties.
   pgsTypes::SectionPropertyType sectPropType = GetSectionPropertiesType();
   return GetHg(sectPropType,intervalIdx, poi);
}

Float64 CBridgeAgentImp::GetAg(IntervalIndexType intervalIdx,const pgsPointOfInterest& poi) const
{
   pgsTypes::SectionPropertyType sectPropType = GetSectionPropertiesType();
   return GetAg(sectPropType,intervalIdx,poi);
}

void CBridgeAgentImp::GetCentroid(IntervalIndexType intervalIdx, const pgsPointOfInterest& poi, IPoint2d** ppCG) const
{
   pgsTypes::SectionPropertyType sectPropType = GetSectionPropertiesType();
   GetCentroid(sectPropType, intervalIdx, poi, ppCG);
}

Float64 CBridgeAgentImp::GetIxx(IntervalIndexType intervalIdx,const pgsPointOfInterest& poi) const
{
   pgsTypes::SectionPropertyType sectPropType = GetSectionPropertiesType();
   return GetIxx(sectPropType,intervalIdx,poi);
}

Float64 CBridgeAgentImp::GetIyy(IntervalIndexType intervalIdx, const pgsPointOfInterest& poi) const
{
   pgsTypes::SectionPropertyType sectPropType = GetSectionPropertiesType();
   return GetIyy(sectPropType, intervalIdx, poi);
}

Float64 CBridgeAgentImp::GetIxy(IntervalIndexType intervalIdx, const pgsPointOfInterest& poi) const
{
   pgsTypes::SectionPropertyType sectPropType = GetSectionPropertiesType();
   return GetIxy(sectPropType, intervalIdx, poi);
}

Float64 CBridgeAgentImp::GetXleft(IntervalIndexType intervalIdx, const pgsPointOfInterest& poi) const
{
   pgsTypes::SectionPropertyType sectPropType = GetSectionPropertiesType();
   return GetXleft(sectPropType, intervalIdx, poi);
}

Float64 CBridgeAgentImp::GetXright(IntervalIndexType intervalIdx, const pgsPointOfInterest& poi) const
{
   pgsTypes::SectionPropertyType sectPropType = GetSectionPropertiesType();
   return GetXright(sectPropType, intervalIdx, poi);
}

Float64 CBridgeAgentImp::GetY(IntervalIndexType intervalIdx, const pgsPointOfInterest& poi, pgsTypes::StressLocation location) const
{
   pgsTypes::SectionPropertyType sectPropType = GetSectionPropertiesType();
   return GetY(sectPropType, intervalIdx, poi, location);
}

Float64 CBridgeAgentImp::GetS(IntervalIndexType intervalIdx, const pgsPointOfInterest& poi, pgsTypes::StressLocation location) const
{
   pgsTypes::SectionPropertyType sectPropType = GetSectionPropertiesType();
   return GetS(sectPropType, intervalIdx, poi, location);
}

Float64 CBridgeAgentImp::GetKt(IntervalIndexType intervalIdx,const pgsPointOfInterest& poi) const
{
   pgsTypes::SectionPropertyType sectPropType = GetSectionPropertiesType();
   return GetKt(sectPropType,intervalIdx,poi);
}

Float64 CBridgeAgentImp::GetKb(IntervalIndexType intervalIdx,const pgsPointOfInterest& poi) const
{
   pgsTypes::SectionPropertyType sectPropType = GetSectionPropertiesType();
   return GetKb(sectPropType,intervalIdx,poi);
}

Float64 CBridgeAgentImp::GetEIx(IntervalIndexType intervalIdx,const pgsPointOfInterest& poi) const
{
   pgsTypes::SectionPropertyType sectPropType = GetSectionPropertiesType();
   return GetEIx(sectPropType,intervalIdx,poi);
}

Float64 CBridgeAgentImp::GetAg(IntervalIndexType intervalIdx,const pgsPointOfInterest& poi,Float64 fcgdr) const
{
   pgsTypes::SectionPropertyType sectPropType = GetSectionPropertiesType();
   return GetAg(sectPropType,intervalIdx,poi,fcgdr);
}

Float64 CBridgeAgentImp::GetIxx(IntervalIndexType intervalIdx,const pgsPointOfInterest& poi,Float64 fcgdr) const
{
   pgsTypes::SectionPropertyType sectPropType = GetSectionPropertiesType();
   return GetIxx(sectPropType,intervalIdx,poi,fcgdr);
}

Float64 CBridgeAgentImp::GetIyy(IntervalIndexType intervalIdx, const pgsPointOfInterest& poi, Float64 fcgdr) const
{
   pgsTypes::SectionPropertyType sectPropType = GetSectionPropertiesType();
   return GetIyy(sectPropType, intervalIdx, poi, fcgdr);
}

Float64 CBridgeAgentImp::GetIxy(IntervalIndexType intervalIdx, const pgsPointOfInterest& poi, Float64 fcgdr) const
{
   pgsTypes::SectionPropertyType sectPropType = GetSectionPropertiesType();
   return GetIxy(sectPropType, intervalIdx, poi, fcgdr);
}

Float64 CBridgeAgentImp::GetY(IntervalIndexType intervalIdx,const pgsPointOfInterest& poi,pgsTypes::StressLocation location,Float64 fcgdr) const
{
   pgsTypes::SectionPropertyType sectPropType = GetSectionPropertiesType();
   return GetY(sectPropType,intervalIdx,poi,location,fcgdr);
}

Float64 CBridgeAgentImp::GetS(IntervalIndexType intervalIdx,const pgsPointOfInterest& poi,pgsTypes::StressLocation location,Float64 fcgdr) const
{
   pgsTypes::SectionPropertyType sectPropType = GetSectionPropertiesType();
   return GetS(sectPropType,intervalIdx,poi,location,fcgdr);
}

Float64 CBridgeAgentImp::GetHg(pgsTypes::SectionPropertyType sectPropType, IntervalIndexType intervalIdx, const pgsPointOfInterest& poi) const
{
   const SectProp& props = GetSectionProperties(intervalIdx, poi, sectPropType);

   Float64 Yb;
   props.ShapeProps->get_Ybottom(&Yb);

   Float64 Yt;

   IndexType deckCastingRegionIdx = GetDeckCastingRegion(poi);

   IntervalIndexType compositeDeckIntervalIdx = GetCompositeDeckInterval(deckCastingRegionIdx);
   if (intervalIdx < compositeDeckIntervalIdx)
   {
      // use YtopGirder instead of get_Ytop because we want the nominal/analytical height of the girder that is used for
      // things like shear depth and bearing seat elevations, etc. get_Ytop gives the Ytop for the overall bounding box
      // YtopGirder will usually give the same value, however for girders with transversely sloped top flanges, such as
      // deck bulb tees, Y at CL Web can be a little shorter than Y at flange tips.
      Yt = props.YtopGirder;
   }
   else
   {
      props.ShapeProps->get_Ytop(&Yt);
   }

   return Yt+Yb;
}

Float64 CBridgeAgentImp::GetAg(pgsTypes::SectionPropertyType spType,IntervalIndexType intervalIdx,const pgsPointOfInterest& poi) const
{
   const SectProp& props = GetSectionProperties(intervalIdx,poi,spType);
   Float64 area;
   props.ShapeProps->get_Area(&area);
   return area;
}

void CBridgeAgentImp::GetCentroid(pgsTypes::SectionPropertyType spType, IntervalIndexType intervalIdx, const pgsPointOfInterest& poi, IPoint2d** ppCG) const
{
   const SectProp& props = GetSectionProperties(intervalIdx, poi, spType);
   props.ShapeProps->get_Centroid(ppCG);
}

Float64 CBridgeAgentImp::GetIxx(pgsTypes::SectionPropertyType spType,IntervalIndexType intervalIdx,const pgsPointOfInterest& poi) const
{
   const SectProp& props = GetSectionProperties(intervalIdx,poi,spType);
   Float64 ixx;
   props.ShapeProps->get_Ixx(&ixx);
   return ixx;
}

Float64 CBridgeAgentImp::GetIyy(pgsTypes::SectionPropertyType spType, IntervalIndexType intervalIdx, const pgsPointOfInterest& poi) const
{
   const SectProp& props = GetSectionProperties(intervalIdx, poi, spType);
   Float64 iyy;
   props.ShapeProps->get_Iyy(&iyy);
   return iyy;
}

Float64 CBridgeAgentImp::GetIxy(pgsTypes::SectionPropertyType spType, IntervalIndexType intervalIdx, const pgsPointOfInterest& poi) const
{
   if (HasAsymmetricGirders())
   {
      const SectProp& props = GetSectionProperties(intervalIdx, poi, spType);
      Float64 ixy;
      props.ShapeProps->get_Ixy(&ixy);
      return ixy;
   }
   else
   {
      // take Ixy to be zero if we are ignoring asymmetry
      return 0.0;
   }
}

Float64 CBridgeAgentImp::GetXleft(pgsTypes::SectionPropertyType spType, IntervalIndexType intervalIdx, const pgsPointOfInterest& poi) const
{
   const SectProp& props = GetSectionProperties(intervalIdx, poi, spType);
   if (HasAsymmetricGirders())
   {
      Float64 Xl;
      props.ShapeProps->get_Xleft(&Xl);
      return Xl;
   }
   else
   {
      if (props.Section)
      {
         CComPtr<IRect2d> box;
         props.Section->get_BoundingBox(&box);
         Float64 w;
         box->get_Width(&w);
         return w / 2;
      }
      else
      {
         return 0;
      }
   }
}

Float64 CBridgeAgentImp::GetXright(pgsTypes::SectionPropertyType spType, IntervalIndexType intervalIdx, const pgsPointOfInterest& poi) const
{
   const SectProp& props = GetSectionProperties(intervalIdx, poi, spType);
   if (HasAsymmetricGirders())
   {
      Float64 Xr;
      props.ShapeProps->get_Xright(&Xr);
      return Xr;
   }
   else
   {
      if (props.Section)
      {
         CComPtr<IRect2d> box;
         props.Section->get_BoundingBox(&box);
         Float64 w;
         box->get_Width(&w);
         return w / 2;
      }
      else
      {
         return 0;
      }
   }
}

Float64 CBridgeAgentImp::GetY(pgsTypes::SectionPropertyType spType,IntervalIndexType intervalIdx,const pgsPointOfInterest& poi,pgsTypes::StressLocation location) const
{
   const SectProp& props = GetSectionProperties(intervalIdx,poi,spType);

   Float64 Y;
   switch (location )
   {
   case pgsTypes::TopGirder:
   case pgsTypes::BottomDeck:
      // top of girder and bottom of deck are at the same location
      Y = props.YtopGirder;
      break;

   case pgsTypes::BottomGirder:
      props.ShapeProps->get_Ybottom(&Y);
      break;

   case pgsTypes::TopDeck:
      {
         IndexType deckCastingRegionIdx = GetDeckCastingRegion(poi);
         IntervalIndexType compositeDeckIntervalIdx = GetCompositeDeckInterval(deckCastingRegionIdx);
         if (IsStructuralDeck(GetDeckType()) && compositeDeckIntervalIdx <= intervalIdx && IsCompositeDeck() )
         {
            props.ShapeProps->get_Ytop(&Y);
         }
         else
         {
            Y = props.YtopGirder;
         }
      }
   }

   return Y;
}

Float64 CBridgeAgentImp::GetS(pgsTypes::SectionPropertyType spType,IntervalIndexType intervalIdx,const pgsPointOfInterest& poi,pgsTypes::StressLocation location) const
{
   Float64 Ix = GetIxx(spType,intervalIdx,poi);
   Float64 Y  = GetY(spType,intervalIdx,poi,location);
   
   Float64 S = (IsZero(Y) ? 0 : Ix/Y);

   const CSegmentKey& segmentKey(poi.GetSegmentKey());

   // S is negative above the neutral axis that way
   // M/S results in compression top for positive moment (compression is < 0)
   if ( location != pgsTypes::BottomGirder )
   {
      S *= -1;
   }

   if (IsStructuralDeck(GetDeckType()) && IsDeckStressLocation(location) )
   {
      // make S in terms of the deck material
      IndexType deckCastingRegionIdx = GetDeckCastingRegion(poi);
      IntervalIndexType compositeDeckInterval = m_IntervalManager.GetCompositeDeckInterval(deckCastingRegionIdx);
      if ( compositeDeckInterval <= intervalIdx && IsCompositeDeck() ) // and the deck is composite with the section
      {
         GET_IFACE(ILossParameters, pLossParams);
         bool bIsTimeStepAnalysis = (pLossParams->GetLossMethod() == pgsTypes::TIME_STEP ? true : false);

         CClosureKey closureKey;
         bool bIsInClosureJoint = IsInClosureJoint(poi, &closureKey);
         bool bIsOnSegment = IsOnSegment(poi);
         bool bIsInBoundaryPierDiaphragm = IsInBoundaryPierDiaphragm(poi);

         Float64 Eg;
         if (bIsOnSegment)
         {
            Eg = (bIsTimeStepAnalysis ? GetSegmentAgeAdjustedEc(segmentKey, intervalIdx) : GetSegmentEc(segmentKey, intervalIdx));
         }
         else if (bIsInClosureJoint)
         {
            Eg = (bIsTimeStepAnalysis ? GetClosureJointAgeAdjustedEc(closureKey, intervalIdx) : GetClosureJointEc(closureKey, intervalIdx));
         }
         else if (bIsInBoundaryPierDiaphragm)
         {
            Eg = (bIsTimeStepAnalysis ? GetDeckAgeAdjustedEc(deckCastingRegionIdx,intervalIdx) : GetDeckEc(deckCastingRegionIdx,intervalIdx));
         }

         Float64 Ed = (bIsTimeStepAnalysis ? GetDeckAgeAdjustedEc(deckCastingRegionIdx,intervalIdx) : GetDeckEc(deckCastingRegionIdx,intervalIdx));

         Float64 n = Eg / Ed;
         S *= n;
      }
      else
      {
         // deck isn't composite yet, 
         S = 0;
      }
   }

   return S;
}

Float64 CBridgeAgentImp::GetKt(pgsTypes::SectionPropertyType spType,IntervalIndexType intervalIdx,const pgsPointOfInterest& poi) const
{
   Float64 Sb = fabs(GetS(spType,intervalIdx,poi,pgsTypes::BottomGirder));
   Float64 A  = GetAg(spType,intervalIdx,poi);
   Float64 Kt = IsZero(A) ? 0 : Sb/A ;
   return Kt;
}

Float64 CBridgeAgentImp::GetKb(pgsTypes::SectionPropertyType spType,IntervalIndexType intervalIdx,const pgsPointOfInterest& poi) const
{
   pgsTypes::StressLocation topLocation = pgsTypes::TopGirder;
   IndexType deckCastingRegionIdx = GetDeckCastingRegion(poi);
   IntervalIndexType compositeDeckIntervalIdx = GetCompositeDeckInterval(deckCastingRegionIdx);
   if ( IsStructuralDeck(GetDeckType()) && compositeDeckIntervalIdx <= intervalIdx && IsCompositeDeck() )
   {
      pgsTypes::TopDeck;
   }

   Float64 St = fabs(GetS(spType,intervalIdx,poi,topLocation));
   Float64 A  = GetAg(spType,intervalIdx,poi);
   Float64 Kb = IsZero(A) ? 0 : St/A ;
   return Kb;
}

Float64 CBridgeAgentImp::GetEIx(pgsTypes::SectionPropertyType spType,IntervalIndexType intervalIdx,const pgsPointOfInterest& poi) const
{
   const SectProp& props = GetSectionProperties(intervalIdx,poi,spType);

   Float64 EIx;
   props.ElasticProps->get_EIxx(&EIx);
   return EIx;
}

Float64 CBridgeAgentImp::GetAg(pgsTypes::SectionPropertyType spType,IntervalIndexType intervalIdx,const pgsPointOfInterest& poi,Float64 fcgdr) const
{
   const CSegmentKey& segmentKey = poi.GetSegmentKey();

   bool bEcChanged;
   Float64 E = GetSegmentEc(segmentKey,intervalIdx,fcgdr,&bEcChanged);

   // if the "trial" girder strength is the same as the real girder strength
   // don't do a bunch of extra work. Return the properties for the real girder
   if ( !bEcChanged )
   {
      return GetAg(spType,intervalIdx,poi);
   }

   CComPtr<IShapeProperties> sprops;
   GetShapeProperties(spType,intervalIdx,poi,E,&sprops);

   Float64 Ag;
   sprops->get_Area(&Ag);
   return Ag;
}

Float64 CBridgeAgentImp::GetIxx(pgsTypes::SectionPropertyType spType,IntervalIndexType intervalIdx,const pgsPointOfInterest& poi,Float64 fcgdr) const
{
   const CSegmentKey& segmentKey = poi.GetSegmentKey();

   // Compute what the secant modulus would be if f'c = fcgdr
   bool bEcChanged;
   Float64 E = GetSegmentEc(segmentKey,intervalIdx,fcgdr,&bEcChanged);

   // if the "trial" girder strength is the same as the real girder strength
   // don't do a bunch of extra work. Return the properties for the real girder
   if ( !bEcChanged )
   {
      return GetIxx(spType,intervalIdx,poi);
   }

   CComPtr<IShapeProperties> sprops;
   GetShapeProperties(spType,intervalIdx,poi,E,&sprops);

   Float64 Ix;
   sprops->get_Ixx(&Ix);
   return Ix;
}

Float64 CBridgeAgentImp::GetIyy(pgsTypes::SectionPropertyType spType, IntervalIndexType intervalIdx, const pgsPointOfInterest& poi, Float64 fcgdr) const
{
   const CSegmentKey& segmentKey = poi.GetSegmentKey();

   bool bEcChanged;
   Float64 E = GetSegmentEc(segmentKey, intervalIdx, fcgdr, &bEcChanged);

   // if the "trial" girder strength is the same as the real girder strength
   // don't do a bunch of extra work. Return the properties for the real girder
   if (!bEcChanged)
   {
      return GetIyy(spType, intervalIdx, poi);
   }

   CComPtr<IShapeProperties> sprops;
   GetShapeProperties(spType, intervalIdx, poi, E, &sprops);

   Float64 Iy;
   sprops->get_Iyy(&Iy);
   return Iy;
}

Float64 CBridgeAgentImp::GetIxy(pgsTypes::SectionPropertyType spType, IntervalIndexType intervalIdx, const pgsPointOfInterest& poi, Float64 fcgdr) const
{
   if (HasAsymmetricGirders())
   {
      const CSegmentKey& segmentKey = poi.GetSegmentKey();

      bool bEcChanged;
      Float64 E = GetSegmentEc(segmentKey, intervalIdx, fcgdr, &bEcChanged);

      // if the "trial" girder strength is the same as the real girder strength
      // don't do a bunch of extra work. Return the properties for the real girder
      if (!bEcChanged)
      {
         return GetIxy(spType, intervalIdx, poi);
      }

      CComPtr<IShapeProperties> sprops;
      GetShapeProperties(spType, intervalIdx, poi, E, &sprops);

      Float64 Ixy;
      sprops->get_Ixy(&Ixy);
      return Ixy;
   }
   else
   {
      // take Ixy to be zero if we are ignoring asymmetry
      return 0.0;
   }

}

Float64 CBridgeAgentImp::GetY(pgsTypes::SectionPropertyType spType,IntervalIndexType intervalIdx,const pgsPointOfInterest& poi,pgsTypes::StressLocation location,Float64 fcgdr) const
{
   const CSegmentKey& segmentKey = poi.GetSegmentKey();

   bool bEcChanged;
   Float64 E = GetSegmentEc(segmentKey,intervalIdx,fcgdr,&bEcChanged);

   // if the "trial" girder strength is the same as the real girder strength
   // don't do a bunch of extra work. Return the properties for the real girder
   if ( !bEcChanged )
   {
      return GetY(spType,intervalIdx,poi,location);
   }

   CComPtr<IShapeProperties> sprops;
   GetShapeProperties(spType,intervalIdx,poi,E,&sprops);

   Float64 Y = ComputeY(intervalIdx,poi,location,sprops);

   return Y;
}

Float64 CBridgeAgentImp::GetS(pgsTypes::SectionPropertyType spType,IntervalIndexType intervalIdx,const pgsPointOfInterest& poi,pgsTypes::StressLocation location,Float64 fcgdr) const
{
   const CSegmentKey& segmentKey = poi.GetSegmentKey();

   bool bEcChanged;
   Float64 E = GetSegmentEc(segmentKey,intervalIdx,fcgdr,&bEcChanged);

   // if the "trial" girder strength is the same as the real girder strength
   // don't do a bunch of extra work. Return the properties for the real girder
   if ( !bEcChanged )
   {
      return GetS(spType,intervalIdx,poi,location);
   }

   CComPtr<IShapeProperties> sprops;
   GetShapeProperties(spType,intervalIdx,poi,E,&sprops);
   Float64 ixx;
   sprops->get_Ixx(&ixx);

   Float64 y = ComputeY(intervalIdx,poi,location,sprops);

   Float64 S = (IsZero(y) ? 0 : ixx/y);

   // S is negative above the neutral axis that way
   // M/S results in compression top for positive moment (compression is < 0)
   if ( location != pgsTypes::BottomGirder )
   {
      S *= -1;
   }

   IndexType deckCastingRegionIdx = GetDeckCastingRegion(poi);

   IntervalIndexType compositeDeckInterval = m_IntervalManager.GetCompositeDeckInterval(deckCastingRegionIdx);
   if ( IsDeckStressLocation(location) && // want S for deck
         IsStructuralDeck(GetDeckType()) && // this is a structural deck
         compositeDeckInterval <= intervalIdx && IsCompositeDeck() // and the deck is composite with the section at this interval
   )
   {
      ATLASSERT(IsOnSegment(poi)); // since we are doing girder design, the poi must be on the segment

      // make S be in terms of deck material
      Float64 Eg = E;
      Float64 Es = GetDeckEc(deckCastingRegionIdx,intervalIdx);

      Float64 n = Eg/Es;
      S *= n;
   }

   return S;
}

Float64 CBridgeAgentImp::GetNetAg(IntervalIndexType intervalIdx,const pgsPointOfInterest& poi) const
{
   const SectProp& props = GetSectionProperties(intervalIdx,poi,pgsTypes::sptNetGirder);
   Float64 area;
   props.ShapeProps->get_Area(&area);
   return area;
}

Float64 CBridgeAgentImp::GetNetIxx(IntervalIndexType intervalIdx, const pgsPointOfInterest& poi) const
{
   const SectProp& props = GetSectionProperties(intervalIdx, poi, pgsTypes::sptNetGirder);
   Float64 ixx;
   props.ShapeProps->get_Ixx(&ixx);
   return ixx;
}

Float64 CBridgeAgentImp::GetNetIyy(IntervalIndexType intervalIdx, const pgsPointOfInterest& poi) const
{
   const SectProp& props = GetSectionProperties(intervalIdx, poi, pgsTypes::sptNetGirder);
   Float64 iyy;
   props.ShapeProps->get_Iyy(&iyy);
   return iyy;
}

Float64 CBridgeAgentImp::GetNetIxy(IntervalIndexType intervalIdx, const pgsPointOfInterest& poi) const
{
   if (HasAsymmetricGirders())
   {
      const SectProp& props = GetSectionProperties(intervalIdx, poi, pgsTypes::sptNetGirder);
      Float64 ixy;
      props.ShapeProps->get_Ixy(&ixy);
      return ixy;
   }
   else
   {
      // take Ixy to be zero if we are ignoring asymmetry
      return 0.0;
   }
}

Float64 CBridgeAgentImp::GetNetYbg(IntervalIndexType intervalIdx,const pgsPointOfInterest& poi) const
{
   const SectProp& props = GetSectionProperties(intervalIdx,poi,pgsTypes::sptNetGirder);
   Float64 yb;
   props.ShapeProps->get_Ybottom(&yb);
   return yb;
}

Float64 CBridgeAgentImp::GetNetYtg(IntervalIndexType intervalIdx,const pgsPointOfInterest& poi) const
{
   const SectProp& props = GetSectionProperties(intervalIdx,poi,pgsTypes::sptNetGirder);
   Float64 yt;
   props.ShapeProps->get_Ytop(&yt);
   return yt;
}

Float64 CBridgeAgentImp::GetNetAd(IntervalIndexType intervalIdx,const pgsPointOfInterest& poi) const
{
   const SectProp& props = GetSectionProperties(intervalIdx,poi,pgsTypes::sptNetDeck);
   Float64 area;
   props.ShapeProps->get_Area(&area);
   return area;
}

Float64 CBridgeAgentImp::GetNetId(IntervalIndexType intervalIdx,const pgsPointOfInterest& poi) const
{
   const SectProp& props = GetSectionProperties(intervalIdx,poi,pgsTypes::sptNetDeck);
   Float64 ixx;
   props.ShapeProps->get_Ixx(&ixx);
   return ixx;
}

Float64 CBridgeAgentImp::GetNetYbd(IntervalIndexType intervalIdx,const pgsPointOfInterest& poi) const
{
   const SectProp& props = GetSectionProperties(intervalIdx,poi,pgsTypes::sptNetDeck);
   Float64 yb;
   props.ShapeProps->get_Ybottom(&yb);
   return yb;
}

Float64 CBridgeAgentImp::GetNetYtd(IntervalIndexType intervalIdx,const pgsPointOfInterest& poi) const
{
   const SectProp& props = GetSectionProperties(intervalIdx,poi,pgsTypes::sptNetDeck);
   Float64 yt;
   props.ShapeProps->get_Ytop(&yt);
   return yt;
}

Float64 CBridgeAgentImp::GetQSlab(IntervalIndexType intervalIdx, const pgsPointOfInterest& poi) const
{
   pgsTypes::SectionPropertyType sectPropType = GetSectionPropertiesType();
   const SectProp& props = GetSectionProperties(intervalIdx,poi,sectPropType);
   return props.Qslab;
}

Float64 CBridgeAgentImp::GetQSlab(IntervalIndexType intervalIdx, const pgsPointOfInterest& poi, Float64 fc) const
{
   Float64 Qslab = GetQSlab(intervalIdx, poi);

#if defined _DEBUG
   GET_IFACE(ILossParameters, pLossParams);
   bool bIsTimeStepAnalysis = (pLossParams->GetLossMethod() == pgsTypes::TIME_STEP ? true : false);
   ATLASSERT(bIsTimeStepAnalysis == false); // this method is for design and we don't do design for time-step analysis
#endif

   const CSegmentKey& segmentKey = poi.GetSegmentKey();
   Float64 Ec = GetSegmentEc(segmentKey, intervalIdx);

   bool bChanged;
   Float64 EcNew = GetSegmentEc(segmentKey, intervalIdx, fc, &bChanged);

   if (bChanged)
   {
      // Q = (Eslab/Egirder)(Aslab)(Moment Arm)
      // We have a different fc for girder so Egirder has changed
      // Multiply by the old Egirder and divide by the new Egirder
      Qslab *= (Ec / EcNew);
   }

   return Qslab;
}

Float64 CBridgeAgentImp::GetQ(IntervalIndexType intervalIdx, const pgsPointOfInterest& poi, Float64 Yclip) const
{
   pgsTypes::SectionPropertyType sectPropType = GetSectionPropertiesType();
   return GetQ(sectPropType, intervalIdx, poi, Yclip);
}

Float64 CBridgeAgentImp::GetQ(pgsTypes::SectionPropertyType spType, IntervalIndexType intervalIdx, const pgsPointOfInterest& poi, Float64 Yclip) const
{
   // Yclip is in girder section coordinate (Y=0 at top of plane girder and negative downwards)
  const SectProp& props = GetSectionProperties(intervalIdx, poi, spType);

  if (!props.Section)
  {
     // no section at location
     return 0.0;
  }

   auto found = props.Q.find(Yclip);
   if (found != props.Q.end())
   {
      return found->second;
   }

   Float64 Q = 0;

   Float64 Ytop = -props.YtopGirder; // negative to put into girder section coordinates

   // create the clipping line
   CComPtr<ILine2d> clipping_line;
   clipping_line.CoCreateInstance(CLSID_Line2d);

   CComPtr<IPoint2d> pnt;
   CComPtr<IVector2d> v;
   clipping_line->GetExplicit(&pnt, &v);

   pnt->put_Y(Yclip); // elevation of clipping line is Yclip

   // the area is clipped away on the left side of the line, the right side area is the clipped shape
   // when Yclip < Ytop, the clipping line is below the CG of the section
   // so we want the line running left to right (direction = 0) so the right side of the line
   // is the "bottom flange" side of the beam... otherwise, we want the line going the opposite
   // direction (direction = M_PI) so the area is the "top flange" side of the beam
   v->put_Direction(Yclip < Ytop ? 0 : M_PI);

   clipping_line->SetExplicit(pnt, v);

   // get MOE for girder
   CComQIPtr<ICompositeSectionEx> compSection(props.Section);
   CComPtr<ICompositeSectionItemEx> gdrSectionItem;
   compSection->get_Item(props.GirderShapeIndex, &gdrSectionItem);
   Float64 Efg_gdr, Ebg_gdr;
   gdrSectionItem->get_Efg(&Efg_gdr);
   gdrSectionItem->get_Ebg(&Ebg_gdr);
   Float64 Egdr = Efg_gdr - Ebg_gdr;

   // clip all the pieces of the composite section
   IndexType nSections;
   compSection->get_Count(&nSections);
   for (IndexType i = 0; i < nSections; i++)
   {
      CComPtr<ICompositeSectionItemEx> sectionItem;
      compSection->get_Item(i, &sectionItem);

      VARIANT_BOOL vbIsStructural;
      sectionItem->get_Structural(&vbIsStructural);

      Float64 Efg, Ebg;
      sectionItem->get_Efg(&Efg);
      sectionItem->get_Ebg(&Ebg);
      Float64 E = Efg - Ebg;

      if (vbIsStructural == VARIANT_TRUE)
      {
         CComPtr<IShape> shape;
         sectionItem->get_Shape(&shape);

         CComPtr<IShape> clipped_shape;
         shape->ClipWithLine(clipping_line, &clipped_shape);

         if (clipped_shape)
         {
            CComPtr<IShapeProperties> shape_props;
            clipped_shape->get_ShapeProperties(&shape_props);

            Float64 clipped_area;
            shape_props->get_Area(&clipped_area);
            clipped_area = IsZero(clipped_area) ? 0 : clipped_area;

            if (0 < clipped_area)
            {
               CComPtr<IPoint2d> cg_clipped_area;
               shape_props->get_Centroid(&cg_clipped_area);

               Float64 Yclipped_area;
               cg_clipped_area->get_Y(&Yclipped_area);

               Q += E*clipped_area*fabs(Ytop - Yclipped_area);
            }
         }
      }
   }

   Q /= Egdr;

   props.Q.emplace(Yclip, Q);

   return Q;
}

Float64 CBridgeAgentImp::GetAcBottomHalf(IntervalIndexType intervalIdx, const pgsPointOfInterest& poi) const
{
   pgsTypes::SectionPropertyType sectPropType = GetSectionPropertiesType();
   const SectProp& props = GetSectionProperties(intervalIdx,poi,sectPropType);
   return props.AcBottomHalf;
}

Float64 CBridgeAgentImp::GetAcTopHalf(IntervalIndexType intervalIdx, const pgsPointOfInterest& poi) const
{
   pgsTypes::SectionPropertyType sectPropType = GetSectionPropertiesType();
   const SectProp& props = GetSectionProperties(intervalIdx,poi,sectPropType);
   return props.AcTopHalf;
}

Float64 CBridgeAgentImp::GetTributaryFlangeWidth(const pgsPointOfInterest& poi) const
{
   Float64 tfw = 0;

   const CSegmentKey& segmentKey = poi.GetSegmentKey();

   if ( IsCompositeDeck() )
   {
      GirderIDType gdrID = GetSuperstructureMemberID(segmentKey);
      Float64 Xs = poi.GetDistFromStart();
      HRESULT hr = m_EffFlangeWidthTool->TributaryFlangeWidthBySegment(m_Bridge,gdrID,segmentKey.segmentIndex,Xs,&tfw);
      ATLASSERT(SUCCEEDED(hr));
   }

   return tfw;
}

Float64 CBridgeAgentImp::GetTributaryFlangeWidthEx(const pgsPointOfInterest& poi, Float64* pLftFw, Float64* pRgtFw) const
{
   Float64 tfw = 0;
   *pLftFw = 0;
   *pRgtFw = 0;

   if ( IsCompositeDeck() )
   {
      const CSegmentKey& segmentKey = poi.GetSegmentKey();

      GirderIDType gdrID = GetSuperstructureMemberID(segmentKey);

      Float64 Xs = poi.GetDistFromStart();
      HRESULT hr = m_EffFlangeWidthTool->TributaryFlangeWidthBySegmentEx(m_Bridge,gdrID,segmentKey.segmentIndex,Xs,pLftFw,pRgtFw,&tfw);
      ATLASSERT(SUCCEEDED(hr));
   }

   return tfw;
}

Float64 CBridgeAgentImp::GetEffectiveFlangeWidth(const pgsPointOfInterest& poi) const
{
   Float64 efw = 0;

   GET_IFACE(ILibrary,       pLib);
   GET_IFACE(ISpecification, pSpec);
   const SpecLibraryEntry* pSpecEntry = pLib->GetSpecEntry( pSpec->GetSpecification().c_str() );

   if ( pSpecEntry->GetEffectiveFlangeWidthMethod() == pgsTypes::efwmLRFD )
   {
      CComQIPtr<IPGSuperEffectiveFlangeWidthTool> eff_tool(m_EffFlangeWidthTool);
      ATLASSERT(eff_tool);
      eff_tool->put_UseTributaryWidth(VARIANT_FALSE);

      if ( IsCompositeDeck() )
      {
         const CSegmentKey& segmentKey = poi.GetSegmentKey();

         GirderIDType gdrID = GetSuperstructureMemberID(segmentKey);
         Float64 Xg = ConvertPoiToGirderCoordinate(poi);
         HRESULT hr = m_EffFlangeWidthTool->EffectiveFlangeWidthBySSMbr(m_Bridge,gdrID,Xg,&efw);
         ATLASSERT(SUCCEEDED(hr));
      }
   }
   else
   {
      CComQIPtr<IPGSuperEffectiveFlangeWidthTool> eff_tool(m_EffFlangeWidthTool);
      ATLASSERT(eff_tool);
      eff_tool->put_UseTributaryWidth(VARIANT_TRUE);

      efw = GetTributaryFlangeWidth(poi);
   }

   return efw;
}

Float64 CBridgeAgentImp::GetEffectiveDeckArea(const pgsPointOfInterest& poi) const
{
    Float64 efw   = GetEffectiveFlangeWidth(poi);
    Float64 tSlab = GetStructuralSlabDepth(poi);

    return efw*tSlab;
}

Float64 CBridgeAgentImp::GetTributaryDeckArea(const pgsPointOfInterest& poi) const
{
    Float64 tfw   = GetTributaryFlangeWidth(poi);
    Float64 tSlab = GetStructuralSlabDepth(poi);

    return tfw*tSlab;
}

Float64 CBridgeAgentImp::GetGrossDeckArea(const pgsPointOfInterest& poi) const
{
    Float64 tfw   = GetTributaryFlangeWidth(poi);
    Float64 tSlab = GetGrossSlabDepth(poi);

    return tfw*tSlab;
}

Float64 CBridgeAgentImp::GetStructuralHaunchDepth(const pgsPointOfInterest & poi, pgsTypes::HaunchAnalysisSectionPropertiesType haunchAType) const
{
   // Section cut tool can do all the work, but no need for the simple options
   if (pgsTypes::hspZeroHaunch == haunchAType)
   {
      return 0.0;
   }
   else
   {
      VALIDATE(BRIDGE);

      if (pgsTypes::hspConstFilletDepth == haunchAType)
      {
         return GetFillet();
      }
      else
      {
         const CSegmentKey& segmentKey = poi.GetSegmentKey();
         Float64 Xs = poi.GetDistFromStart();
         GirderIDType gdrID = GetSuperstructureMemberID(segmentKey);

         Float64 haunchDepth;
         HRESULT hr = m_SectCutTool->GetStructuralHaunchDepth(m_Bridge, gdrID, segmentKey.segmentIndex, Xs, (HaunchDepthMethod)haunchAType, &haunchDepth);
         ATLASSERT(SUCCEEDED(hr));

         return haunchDepth;
      }
   }
}

Float64 CBridgeAgentImp::GetRoadwayToTopGirderChordDistance(const pgsPointOfInterest& poi) const
{
   // camber effects are ignored
   VALIDATE(BRIDGE);

   // top of girder chord elevation is set from roadway surface including overlay if overlay is installed at or before the GCE
   Float64 yc = GetTopGirderChordElevation(poi);

   // get station and offset for poi
   Float64 station,offset;
   GetStationAndOffset(poi,&station,&offset);
   offset = IsZero(offset) ? 0 : offset;

   // top of alignment elevation above girder
   Float64 ya = GetElevation(station,offset);

   return ya - yc;
}

Float64 CBridgeAgentImp::GetTopSlabToTopGirderChordDistance(const pgsPointOfInterest& poi) const
{
   Float64 top_rw = GetRoadwayToTopGirderChordDistance(poi);

   IntervalIndexType gceInterval = GetGeometryControlInterval();

   // Remove temporary support elevation adjustment.
   Float64 ts_adj = GetElevationAdjustment(gceInterval,poi);

   // We place the girder chord the GCE - determine overlay depth at that time. (future overlays are after the GCE)
   Float64 overlay_depth = GetOverlayDepth(gceInterval);

   return top_rw + ts_adj - overlay_depth;
}

Float64 CBridgeAgentImp::GetTopSlabToTopGirderChordDistance(const pgsPointOfInterest& poi, Float64 Astart, Float64 Aend) const
{
   // camber effects are ignored
   VALIDATE( BRIDGE );

   if (GetDeckType() == pgsTypes::sdtNone)
   {
      return 0;
   }

   // top of girder chord elevation. This is adjusted for overlay if it exists
   Float64 yc = GetTopGirderChordElevation(poi, Astart, Aend);

   // get station and offset for poi
   Float64 station,offset;
   GetStationAndOffset(poi,&station,&offset);
   offset = IsZero(offset) ? 0 : offset;

   // top of alignment elevation above girder
   Float64 ya = GetElevation(station,offset);

   // subtract overlay if it exists at the GCE
   IntervalIndexType gceInterval = GetGeometryControlInterval();
   Float64 overlay_depth = GetOverlayDepth(gceInterval);

   return ya - overlay_depth - yc;
}

IndexType CBridgeAgentImp::GetDeckCastingRegionCount() const
{
   GET_IFACE(IBridgeDescription, pIBridgeDesc);
   EventIndexType castDeckEventIdx = pIBridgeDesc->GetTimelineManager()->GetCastDeckEventIndex();
   if (castDeckEventIdx == INVALID_INDEX)
   {
      // there is no deck to cast
      ATLASSERT(pIBridgeDesc->GetDeckDescription()->GetDeckType() == pgsTypes::sdtNone);
      return 0;
   }
   const auto& activity = pIBridgeDesc->GetTimelineManager()->GetEventByIndex(castDeckEventIdx)->GetCastDeckActivity();
   return activity.GetCastingRegionCount();
}

void CBridgeAgentImp::GetDeckCastingRegionLimits(IndexType regionIdx, PierIndexType* pStartPierIdx, Float64* pXstart, PierIndexType* pEndPierIdx, Float64* pXend, CCastingRegion::RegionType* pRegionType, IndexType* pSequenceIdx, const CCastDeckActivity* pActivity) const
{
   if (pActivity == nullptr)
   {
      GET_IFACE(IBridgeDescription, pIBridgeDesc);
      EventIndexType castDeckEventIdx = pIBridgeDesc->GetTimelineManager()->GetCastDeckEventIndex();
      const auto& activity = pIBridgeDesc->GetTimelineManager()->GetEventByIndex(castDeckEventIdx)->GetCastDeckActivity();
      pActivity = &activity;
   }

   const auto& vRegions = pActivity->GetCastingRegions();
   const auto& region = vRegions[regionIdx];
   if (region.m_Type == CCastingRegion::Span)
   {
      if (regionIdx == 0)
      {
         *pStartPierIdx = 0;
         *pXstart = 0;
      }
      else
      {
         const auto& prev_region = vRegions[regionIdx - 1];
         if (prev_region.m_Type == CCastingRegion::Pier)
         {
            *pStartPierIdx = prev_region.m_Index;
            if (prev_region.m_End < 0)
            {
               // fractional measure
               SpanIndexType next_span_idx = (SpanIndexType)(*pStartPierIdx);
               Float64 L = GetSpanLength(next_span_idx);
               *pXstart = -1 * prev_region.m_End * L;
            }
            else
            {
               *pXstart = prev_region.m_End;
            }
         }
         else
         {
            *pStartPierIdx = (PierIndexType)(prev_region.m_Index + 1);
            *pXstart = 0;
         }
      }

      if (regionIdx == vRegions.size() - 1)
      {
         *pEndPierIdx = GetPierCount() - 1;
         *pXend = 0;
      }
      else
      {
         const auto& next_region = vRegions[regionIdx + 1];
         if (next_region.m_Type == CCastingRegion::Pier)
         {
            *pEndPierIdx = next_region.m_Index;
            if (next_region.m_Start < 0)
            {
               // fractional measure
               SpanIndexType prev_span_idx = (SpanIndexType)(*pEndPierIdx - 1);
               Float64 L = GetSpanLength(prev_span_idx);
               *pXend = -1 * next_region.m_Start * L;
            }
            else
            {
               *pXend = next_region.m_Start;
            }
            *pXend *= -1; // make this negative because the region ends before the pier
         }
         else
         {
            *pEndPierIdx = (PierIndexType)next_region.m_Index;
            *pXend = 0;
         }
      }
   }
   else
   {
      // Pier region
      *pStartPierIdx = region.m_Index;
      if (region.m_Start < 0)
      {
         SpanIndexType prev_span_idx = (SpanIndexType)(*pStartPierIdx - 1);
         Float64 L;
         if (prev_span_idx == INVALID_INDEX)
         {
            // this is the first span and it is a cantilever
            CSpanKey spanKey(0, 0); // NOTE: using a dummy girder
            L = GetCantileverLength(spanKey,pgsTypes::metStart);
         }
         else
         {
            L = GetSpanLength(prev_span_idx);
         }
         *pXstart = -1 * region.m_Start * L;
      }
      else
      {
         *pXstart = region.m_Start;
      }
      *pXstart *= -1; // make this negative because the region starts before the pier

      *pEndPierIdx = region.m_Index;
      if (region.m_End < 0)
      {
         SpanIndexType next_span_idx = (SpanIndexType)(*pEndPierIdx);
         Float64 L;
         SpanIndexType nSpans = GetSpanCount();
         if (next_span_idx == nSpans)
         {
            // this is the last span and it is a cantilever
            CSpanKey spanKey(nSpans - 1, 0); // NOTE: using a dummy girder
            L = GetCantileverLength(spanKey, pgsTypes::metEnd);
         }
         else
         {
            L = GetSpanLength(next_span_idx);
         }
         *pXend = -1 * region.m_End * L;
      }
      else
      {
         *pXend = region.m_End;
      }
   }

   *pRegionType = region.m_Type;
   *pSequenceIdx = region.m_SequenceIndex;
}

void CBridgeAgentImp::GetDeckCastingRegionPerimeter(IndexType regionIdx, IndexType nPoints, pgsTypes::PlanCoordinateType pcType, CCastingRegion::RegionType* pRegionType, IndexType* pSequenceIdx, const CCastDeckActivity* pActivity, IPoint2dCollection** ppPoints) const
{
   GetDeckCastingRegionPerimeter(regionIdx, ALL_SPANS, ALL_SPANS, nPoints, pcType, pRegionType, pSequenceIdx, pActivity, ppPoints);
}

void CBridgeAgentImp::GetDeckCastingRegionPerimeter(IndexType regionIdx, SpanIndexType startSpanIdx, SpanIndexType endSpanIdx, IndexType nPoints, pgsTypes::PlanCoordinateType pcType, CCastingRegion::RegionType* pRegionType, IndexType* pSequenceIdx, const CCastDeckActivity* pActivity, IPoint2dCollection** ppPoints) const
{
   PierIndexType startPierIdx, endPierIdx;
   Float64 Xstart, Xend;
   GetDeckCastingRegionLimits(regionIdx, &startPierIdx, &Xstart, &endPierIdx, &Xend, pRegionType, pSequenceIdx, pActivity);
   if (startSpanIdx != ALL_SPANS && startPierIdx < (PierIndexType)startSpanIdx)
   {
      // the start of a span range has been provided and it is after the starting pier for this region
      // constrain the start of the region to the pier at the start of startSpanIdx
      startPierIdx = (PierIndexType)startSpanIdx;
      Xstart = 0;
   }

   if (endSpanIdx != ALL_SPANS && (PierIndexType)(endSpanIdx+1) < endPierIdx)
   {
      // the end of a span range has been provided and it is before the ending pier for this region
      // constrain the end of the region to the pier at the end of endSpanIdx
      endPierIdx = (PierIndexType)(endSpanIdx + 1);
      Xend = 0;
   }

   GetSlabPerimeter(startPierIdx, Xstart, endPierIdx, Xend, nPoints, pcType, pActivity, ppPoints);
}

void CBridgeAgentImp::ReportEffectiveFlangeWidth(const CGirderKey& girderKey,rptChapter* pChapter,IEAFDisplayUnits* pDisplayUnits) const
{
   VALIDATE(BRIDGE);

   GET_IFACE(ILibrary,       pLib);
   GET_IFACE(ISpecification, pSpec);
   const SpecLibraryEntry* pSpecEntry = pLib->GetSpecEntry( pSpec->GetSpecification().c_str() );

   CComQIPtr<IPGSuperEffectiveFlangeWidthTool> eff_tool(m_EffFlangeWidthTool);
   ATLASSERT(eff_tool);
   if ( pSpecEntry->GetEffectiveFlangeWidthMethod() == pgsTypes::efwmLRFD )
   {
      eff_tool->put_UseTributaryWidth(VARIANT_FALSE);
   }
   else
   {
      eff_tool->put_UseTributaryWidth(VARIANT_TRUE);
   }

   CComQIPtr<IReportEffectiveFlangeWidth> report(m_EffFlangeWidthTool);
   report->ReportEffectiveFlangeWidth(m_pBroker,m_Bridge,girderKey,pChapter,pDisplayUnits);
}

Float64 CBridgeAgentImp::GetPerimeter(const pgsPointOfInterest& poi) const
{
   // want the perimeter of the plain girder...
   IntervalIndexType intervalIdx;
   CClosureKey closureKey;
   if ( IsInClosureJoint(poi,&closureKey) )
   {
      intervalIdx = GetCompositeClosureJointInterval(closureKey);
   }
   else
   {
      intervalIdx = GetPrestressReleaseInterval(poi.GetSegmentKey());
   }

   const SectProp& props = GetSectionProperties(intervalIdx,poi,pgsTypes::sptNetGirder);
   return props.Perimeter;
}

void CBridgeAgentImp::GetSegmentVolumeAndSurfaceArea(const CSegmentKey& segmentKey, Float64* pVolume, Float64* pSurfaceArea,int surfaceAreaType) const
{
   CComPtr<ISuperstructureMemberSegment> segment;
   GetSegment(segmentKey, &segment);
   segment->GetVolumeAndSurfaceArea(pVolume,pSurfaceArea);

   // The surface area of internal voids is reduced by 50% per LRFD 5.4.2.3.2
   if (surfaceAreaType == INCLUDE_INTERIOR_SURFACE_AREA || surfaceAreaType == INCLUDE_HALF_INTERIOR_SURFACE_AREA)
   {
      Float64 Sv;
      segment->get_InternalSurfaceAreaOfVoids(&Sv);

      Float64 k = (surfaceAreaType == INCLUDE_HALF_INTERIOR_SURFACE_AREA) ? 0.5 : 1.0;
      *pSurfaceArea += k*Sv;
   }
}

void CBridgeAgentImp::GetClosureJointVolumeAndSurfaceArea(const CClosureKey& closureKey, Float64* pVolume, Float64* pSurfaceArea) const
{
   CComPtr<ISuperstructureMemberSegment> segment;
   GetSegment(closureKey, &segment);

   CComQIPtr<ISplicedGirderSegment> splicedSegment(segment);
   if (splicedSegment)
   {
      // closureKey always refers to the right end of the segment so use etEnd
      splicedSegment->GetClosureJointVolumeAndSurfaceArea(etEnd, pVolume, pSurfaceArea);
   }
   else
   {
      *pVolume = 0;
      *pSurfaceArea = 0;
   }
}

void CBridgeAgentImp::GetDeckVolumeAndSurfaceArea(Float64* pVolume, Float64* pSurfaceArea) const
{
   ValidateDeckParameters();
   *pVolume = m_DeckVolume;
   *pSurfaceArea = m_DeckSurfaceArea;
}

void CBridgeAgentImp::GetBridgeStiffness(Float64 Xb, Float64* pEIxx, Float64* pEIyy, Float64* pEIxy) const
{
   IntervalIndexType lastIntervalIdx = m_IntervalManager.GetIntervalCount() - 1;

   CComPtr<ISection> section;
   m_SectCutTool->CreateBridgeSection(m_Bridge, Xb, sbRight, lastIntervalIdx, bscStructurallyContinuousOnly, &section);

   CComPtr<IElasticProperties> eprops;
   section->get_ElasticProperties(&eprops);

   eprops->get_EIxx(pEIxx);
   eprops->get_EIyy(pEIyy);
   eprops->get_EIxy(pEIxy);
}

Float64 CBridgeAgentImp::GetBridgeEIxx(Float64 Xb) const
{
   Float64 EIxx, EIyy, EIxy;
   GetBridgeStiffness(Xb, &EIxx, &EIyy, &EIxy);
   return EIxx;
}

Float64 CBridgeAgentImp::GetBridgeEIyy(Float64 Xb) const
{
   Float64 EIxx, EIyy, EIxy;
   GetBridgeStiffness(Xb, &EIxx, &EIyy, &EIxy);
   return EIyy;
}

Float64 CBridgeAgentImp::GetBridgeEIxy(Float64 Xb) const
{
   Float64 EIxx, EIyy, EIxy;
   GetBridgeStiffness(Xb, &EIxx, &EIyy, &EIxy);
   return EIxy;
}

Float64 CBridgeAgentImp::GetSegmentWeightPerLength(const CSegmentKey& segmentKey) const
{
   IntervalIndexType releaseIntervalIdx = GetPrestressReleaseInterval(segmentKey);
   Float64 ag = GetAg(pgsTypes::sptGross,releaseIntervalIdx,pgsPointOfInterest(segmentKey,0.00));
   Float64 dens = GetSegmentWeightDensity(segmentKey,releaseIntervalIdx);
   Float64 weight_per_length = ag * dens * WBFL::Units::System::GetGravitationalAcceleration();
   return weight_per_length;
}

Float64 CBridgeAgentImp::GetSegmentWeight(const CSegmentKey& segmentKey) const
{
   CComPtr<ISuperstructureMemberSegment> segment;
   GetSegment(segmentKey, &segment);
   Float64 V, S;
   segment->GetVolumeAndSurfaceArea(&V, &S);

   IntervalIndexType releaseIntervalIdx = m_IntervalManager.GetPrestressReleaseInterval(segmentKey);
   Float64 density = GetSegmentWeightDensity(segmentKey,releaseIntervalIdx);
   Float64 g = WBFL::Units::System::GetGravitationalAcceleration();
   Float64 Wg = V*density*g;
   return Wg;
}

Float64 CBridgeAgentImp::GetSegmentHeightAtPier(const CSegmentKey& segmentKey,PierIndexType pierIdx) const
{
   CComPtr<IPoint2d> pntSupport1,pntEnd1,pntBrg1,pntBrg2,pntEnd2,pntSupport2;
   GetSegmentEndPoints(segmentKey,pgsTypes::pcLocal,&pntSupport1,&pntEnd1,&pntBrg1,&pntBrg2,&pntEnd2,&pntSupport2);

   CComPtr<IPoint2d> pntPier;
   GetSegmentPierIntersection(segmentKey,pierIdx,pgsTypes::pcLocal,&pntPier);

   Float64 dist_from_start;
   pntPier->DistanceEx(pntEnd1,&dist_from_start);

   // make sure we don't go past the end of the segment since we are going to ask for
   // the segment height at the release stage.
   dist_from_start = Min(dist_from_start,GetSegmentLength(segmentKey));

   pgsPointOfInterest poi(segmentKey,dist_from_start);

   return GetHg(GetPrestressReleaseInterval(segmentKey),poi);
}

Float64 CBridgeAgentImp::GetSegmentHeightAtTemporarySupport(const CSegmentKey& segmentKey,SupportIndexType tsIdx) const
{
   CComPtr<IPoint2d> pntSupport1,pntEnd1,pntBrg1,pntBrg2,pntEnd2,pntSupport2;
   GetSegmentEndPoints(segmentKey,pgsTypes::pcLocal,&pntSupport1,&pntEnd1,&pntBrg1,&pntBrg2,&pntEnd2,&pntSupport2);

   CComPtr<IPoint2d> pntTS;
   GetSegmentTempSupportIntersection(segmentKey,tsIdx,pgsTypes::pcLocal,&pntTS);

   Float64 Xpoi;
   pntTS->DistanceEx(pntEnd1,&Xpoi);

   pgsPointOfInterest poi = GetPointOfInterest(segmentKey,Xpoi);

   IntervalIndexType lastIntervalIdx = GetIntervalCount()-1;
   return GetHg(lastIntervalIdx,poi);
}

Float64 CBridgeAgentImp::GetSegmentHeight(const CPrecastSegmentData* pSegment, Float64 Xs) const
{
   const CSegmentKey& segmentKey(pSegment->GetSegmentKey());
   const GirderLibraryEntry* pGirderEntry = GetGirderLibraryEntry(segmentKey);

   CComPtr<IBeamFactory> beamFactory;
   pGirderEntry->GetBeamFactory(&beamFactory);

   return beamFactory->GetSegmentHeight(m_pBroker, pSegment, Xs);
}

bool CBridgeAgentImp::IsStructuralSection(const pgsPointOfInterest& poi, IntervalIndexType intervalIdx) const
{
   // figure out where the poi is located and if the concrete is cured enought to make the section act as a structural member
   CClosureKey closureKey;
   bool bIsInClosureJoint = IsInClosureJoint(poi, &closureKey);
   bool bIsOnSegment = IsOnSegment(poi);
   bool bIsInBoundaryPierDiaphragm = IsInBoundaryPierDiaphragm(poi);

   const CPierData2* pPier = nullptr;
   bool bIntegralBack{ false }, bIntegralAhead{ false };
   if (bIsInBoundaryPierDiaphragm)
   {
      PierIndexType pierIdx = GetPier(poi);
      ATLASSERT(pierIdx != INVALID_INDEX);
      GET_IFACE(IBridgeDescription, pBridge);
      pPier = pBridge->GetPier(pierIdx);
      ATLASSERT(pPier);
      pPier->IsIntegral(&bIntegralBack, &bIntegralAhead);
   }

   const CSegmentKey& segmentKey(poi.GetSegmentKey());
   IntervalIndexType releaseIntervalIdx = GetPrestressReleaseInterval(segmentKey);
   IntervalIndexType compositeIntervalIdx = GetLastCompositeInterval();

   bool bIsSection = true;
   if (
      (bIsInClosureJoint && intervalIdx < GetCompositeClosureJointInterval(closureKey)) // in closure and closure concrete isn't cured yet
      ||                                                             // OR
      (bIsOnSegment && intervalIdx < releaseIntervalIdx) // on segment and segment concrete isn't cured yet
      ||                                                             // OR
      (bIsInBoundaryPierDiaphragm && (intervalIdx < compositeIntervalIdx || (!pPier->IsContinuous() && !(bIntegralBack && bIntegralAhead)))) // in pier diaphragm and concrete isn't cured yet or there isn't a span-to-span connection (continuous or integral)
      )
   {
      bIsSection = false; // this is not a structural section...
   }
   return bIsSection;
}


/////////////////////////////////////////////////////////////////////////
// IShapes
//
void CBridgeAgentImp::GetSegmentShape(IntervalIndexType intervalIdx,const pgsPointOfInterest& poi,bool bOrient,pgsTypes::SectionCoordinateType coordinateType,IShape** ppShape, IndexType* pGirderIndex, IndexType* pSlabIndex) const
{
   CComPtr<ICompositeShape> compShape;
   compShape.CoCreateInstance(CLSID_CompositeShape);

   pgsTypes::SectionPropertyType spType = GetSectionPropertiesType();
   const auto& sprops = GetSectionProperties(intervalIdx, poi, spType);

   CComQIPtr<ICompositeSectionEx> compositeSection(sprops.Section);
   ATLASSERT(compositeSection != nullptr);

   IndexType nItems;
   compositeSection->get_Count(&nItems);
   for (IndexType idx = 0; idx < nItems; idx++)
   {
      CComPtr<ICompositeSectionItemEx> sectionItem;
      compositeSection->get_Item(idx, &sectionItem);
      CComPtr<IShape> shape;
      sectionItem->get_Shape(&shape);
      CComPtr<IShape> clone;
      shape->Clone(&clone);
      compShape->AddShape(clone, (idx == sprops.GirderShapeIndex || idx == sprops.SlabShapeIndex ? VARIANT_FALSE : VARIANT_TRUE));
   }

   // indices into composite section
   if (pGirderIndex != nullptr)
   {
      *pGirderIndex = sprops.GirderShapeIndex;
   }

   if (pSlabIndex != nullptr)
   {
      *pSlabIndex = sprops.SlabShapeIndex;
   }

   
   compShape.QueryInterface(ppShape);

   if (coordinateType == pgsTypes::scBridge)
   {
      CComQIPtr<IXYPosition> position(*ppShape);
      position->Offset(sprops.dx, sprops.dy);
   }

   if (coordinateType == pgsTypes::scCentroid)
   {
      // the request if for the centroidal coordinate system, the section is currently in girder coordinates
      // let's convert
      CComPtr<IPoint2d> pntCG;
      GetCentroid(intervalIdx, poi, &pntCG);

      Float64 cgx(0), cgy(0);
      pntCG->Location(&cgx, &cgy);

      CComQIPtr<IXYPosition> position(*ppShape);
      position->Offset(-cgx,-cgy);
   }

#if defined _DEBUG
   if (coordinateType == pgsTypes::scGirder)
   {
      CComPtr<IShape> shape;

      CComPtr<ICompositeShape> compositeShape;
      (*ppShape)->QueryInterface(&compositeShape);

      if (compositeShape)
      {
         CComPtr<ICompositeShapeItem> item;
         compositeShape->get_Item(0, &item);
         item->get_Shape(&shape);
      }
      else
      {
         shape = *ppShape;
      }

      CComQIPtr<IXYPosition> bare_girder_position(shape);

      CComPtr<IPoint2d> point;
      bare_girder_position->get_LocatorPoint(lpTopCenter, &point);
      Float64 dx, dy;
      point->Location(&dx, &dy);
      ATLASSERT(IsZero(dx));
      ATLASSERT(IsZero(dy));
   }
#endif

   if ( bOrient )
   {
      Float64 orientation = GetOrientation(poi.GetSegmentKey());
      if (!IsZero(orientation))
      {
         Float64 rotation_angle = -orientation;

         // if possible, rotate the girder around its work point
         // if the workpoint isn't available, use the top center
         CComPtr<IPoint2d> pntWorkPoint;
         CComQIPtr<IGirderSection> section(*ppShape);
         if (!section)
         {
            CComQIPtr<ICompositeShape> compShape(*ppShape);
            CComPtr<ICompositeShapeItem> shapeItem;
            compShape->get_Item(0, &shapeItem);
            CComPtr<IShape> gdrShape;
            shapeItem->get_Shape(&gdrShape);
            gdrShape.QueryInterface(&section);

         }

         CComQIPtr<IXYPosition> position(*ppShape);
         if (section)
         {
            section->get_WorkPoint(&pntWorkPoint);
         }
         else
         {
            position->get_LocatorPoint(lpTopCenter, &pntWorkPoint);
         }

         position->RotateEx(pntWorkPoint, rotation_angle);
      }
   }
}

void CBridgeAgentImp::GetSegmentShape(const CPrecastSegmentData* pSegment, Float64 Xs, pgsTypes::SectionBias sectionBias,IShape** ppShape) const
{
   // create a segment shape at the specified location using the parameters defined in pSegment
   const CSegmentKey& segmentKey(pSegment->GetSegmentKey());
   const GirderLibraryEntry* pGirderEntry = GetGirderLibraryEntry(segmentKey);

   CComPtr<IBeamFactory> beamFactory;
   pGirderEntry->GetBeamFactory(&beamFactory);

   beamFactory->CreateSegmentShape(m_pBroker, pSegment, Xs, sectionBias, ppShape);
}

void CBridgeAgentImp::GetSegmentSectionShape(IntervalIndexType intervalIdx, const pgsPointOfInterest& poi, bool bOrient, pgsTypes::SectionCoordinateType csType, IShape** ppShape, IndexType* pGirderIndex, IndexType* pSlabIndex) const
{
   pgsTypes::SectionPropertyType sectPropType = GetSectionPropertiesType();
   SectProp sectProps = GetSectionProperties(intervalIdx, poi, sectPropType);
   if (sectProps.Section == nullptr)
   {
      // if the POI isn't at a location with concrete yet (like at a pier diaphragm before it is cast), the section object is null
      // there isn't a shape to get in this case so set the return value pointer to null and return
      *ppShape = nullptr;

      if (pGirderIndex != nullptr)
      {
         *pGirderIndex = INVALID_INDEX;
      }

      if (pSlabIndex != nullptr)
      {
         *pSlabIndex = INVALID_INDEX;
      }

      return;
   }

   CComQIPtr<ICompositeSectionEx> compositeSection(sectProps.Section);
   ATLASSERT(compositeSection != nullptr);
   CComPtr<ICompositeSectionItemEx> sectionItem;

   compositeSection->get_Item(0, &sectionItem);

   CComPtr<IShape> shape;
   sectionItem->get_Shape(&shape);

   shape->Clone(ppShape);

   // indices into composite section
   if (pGirderIndex != nullptr)
   {
      *pGirderIndex = sectProps.GirderShapeIndex;
   }

   if (pSlabIndex != nullptr)
   {
      *pSlabIndex = sectProps.SlabShapeIndex;
   }


   // Right now, ppShape is in Bridge Section Coordinates
   if (csType == pgsTypes::scGirder || csType == pgsTypes::scCentroid)
   {
      // Convert to Girder Section Coordinates....
      // Move Top Center point of the bare girder to (0,0)
      CComPtr<IShape> shape;

      CComPtr<ICompositeShape> compositeShape;
      (*ppShape)->QueryInterface(&compositeShape);

      if (compositeShape)
      {
         CComPtr<ICompositeShapeItem> item;
         compositeShape->get_Item(0, &item);
         item->get_Shape(&shape);
      }
      else
      {
         shape = *ppShape;
      }

      Float64 cgx(0), cgy(0);
      if (csType == pgsTypes::scCentroid)
      {
         CComPtr<IShapeProperties> shapeProps;
         shape->get_ShapeProperties(&shapeProps);
         CComPtr<IPoint2d> pntCG;
         shapeProps->get_Centroid(&pntCG);
         pntCG->Location(&cgx, &cgy);
      }

      Float64 dx(0), dy(0);
      if (csType == pgsTypes::scGirder)
      {
         CComQIPtr<IXYPosition> bare_girder_position(shape);

         CComPtr<IPoint2d> point;
         bare_girder_position->get_LocatorPoint(lpTopCenter, &point);

         point->Location(&dx, &dy);
      }

      CComQIPtr<IXYPosition> position(*ppShape);
      position->Offset(-cgx-dx, -cgy-dy);

#if defined _DEBUG
      CComPtr<IPoint2d> point;
      CComQIPtr<IXYPosition> bare_girder_position(shape);
      bare_girder_position->get_LocatorPoint(lpTopCenter, &point);
      point->Location(&dx, &dy);
      ATLASSERT(IsZero(dx));
      ATLASSERT(IsZero(dy));
#endif
   }

   if (bOrient)
   {
      Float64 orientation = GetOrientation(poi.GetSegmentKey());

      Float64 rotation_angle = -orientation;

      CComQIPtr<IXYPosition> position(*ppShape);
      CComPtr<IPoint2d> top_center;
      position->get_LocatorPoint(lpTopCenter, &top_center);
      position->RotateEx(top_center, rotation_angle);
   }
}

void CBridgeAgentImp::GetSlabAnalysisShape(IntervalIndexType intervalIdx, const pgsPointOfInterest& poi, Float64 haunchDepth, bool bFollowMatingSurfaceProfile, IShape** ppShape) const
{
   VALIDATE(BRIDGE);

   const CSegmentKey& segmentKey = poi.GetSegmentKey();

   Float64 Xs = poi.GetDistFromStart();
   GirderIDType gdrID = GetSuperstructureMemberID(segmentKey);

   // A section is required to cut our deck mating surface to
   CComPtr<IGirderSection> gdrsection;
   HRESULT hr = GetGirderSection(poi, &gdrsection);
   ATLASSERT(SUCCEEDED(hr));
   if (FAILED(hr))
   {
      return;
   }

   // use tool to cut shape
   SectionBias sectionBias = GetSectionBias(poi);
   CComPtr<IShape> shape;
   hr = m_SectCutTool->CreateDeckAnalysisShape(m_Bridge,gdrsection,gdrID,segmentKey.segmentIndex,Xs,sectionBias,haunchDepth,bFollowMatingSurfaceProfile, intervalIdx,&shape);
   ATLASSERT(SUCCEEDED(hr));

   // move deck to match up with girder coordinates
   CComQIPtr<IShape> gdrshape(gdrsection);
   ATLASSERT(gdrshape);
   CComQIPtr<IXYPosition> bare_girder_position(gdrshape);
   CComPtr<IPoint2d> pntTopCenter;
   bare_girder_position->get_LocatorPoint(lpTopCenter, &pntTopCenter);
   Float64 dx, dy;
   pntTopCenter->Location(&dx, &dy);

   CComQIPtr<IXYPosition> position(shape);
   position->Offset(-dx, -dy);

   shape.CopyTo(ppShape);
}

void CBridgeAgentImp::GetSlabShape(Float64 station,IDirection* pDirection,bool bIncludeHaunch,IShape** ppShape) const
{
   VALIDATE(BRIDGE);

   if ( bIncludeHaunch )
   {
      SectionCutKey key;
      key.station = station;
      if ( pDirection )
      {
         pDirection->get_Value(&key.direction);
      }
      else
      {
         key.direction = 0;
      }
      auto found = m_DeckShapes.find(key);

      if ( found != m_DeckShapes.end() )
      {
         (*ppShape) = found->second;
         (*ppShape)->AddRef();
      }
      else
      {
         HRESULT hr = m_SectCutTool->CreateSlabShape(m_Bridge,station,pDirection,VARIANT_TRUE/*include haunch*/,ppShape);
         ATLASSERT(SUCCEEDED(hr));

         if ( *ppShape )
         {
            m_DeckShapes.insert(std::make_pair(key,CComPtr<IShape>(*ppShape)));
         }
      }
   }
   else
   {
      HRESULT hr = m_SectCutTool->CreateSlabShape(m_Bridge,station,pDirection,VARIANT_FALSE/*exclude haunch*/,ppShape);
      ATLASSERT(SUCCEEDED(hr));
   }
}

void CBridgeAgentImp::GetLeftTrafficBarrierShape(Float64 station,IDirection* pDirection,IShape** ppShape) const
{
   VALIDATE(BRIDGE);
   SectionCutKey key;
   key.station = station;
   if ( pDirection )
   {
      pDirection->get_Value(&key.direction);
   }
   else
   {
      key.direction = 0;
   }
   ShapeContainer::iterator found = m_LeftBarrierShapes.find(key);
   if ( found != m_LeftBarrierShapes.end() )
   {
      found->second->Clone(ppShape);
   }
   else
   {
      CComPtr<IShape> shape;
      HRESULT hr = m_SectCutTool->CreateLeftBarrierShape(m_Bridge,station,pDirection,&shape);

      if ( SUCCEEDED(hr) )
      {
         m_LeftBarrierShapes.insert(std::make_pair(key,CComPtr<IShape>(shape)));
         shape->Clone(ppShape);
      }
   }
}

void CBridgeAgentImp::GetRightTrafficBarrierShape(Float64 station,IDirection* pDirection,IShape** ppShape) const
{
   VALIDATE(BRIDGE);
   SectionCutKey key;
   key.station = station;
   if ( pDirection )
   {
      pDirection->get_Value(&key.direction);
   }
   else
   {
      key.direction = 0;
   }
   ShapeContainer::iterator found = m_RightBarrierShapes.find(key);
   if ( found != m_RightBarrierShapes.end() )
   {
      found->second->Clone(ppShape);
   }
   else
   {
      CComPtr<IShape> shape;
      HRESULT hr = m_SectCutTool->CreateRightBarrierShape(m_Bridge,station,pDirection,&shape);

      if ( SUCCEEDED(hr) )
      {
         m_RightBarrierShapes.insert(std::make_pair(key,CComPtr<IShape>(shape)));
         shape->Clone(ppShape);
      }
   }
}

void CBridgeAgentImp::GetJointShapes(IntervalIndexType intervalIdx,const pgsPointOfInterest& poi, bool bOrient, pgsTypes::SectionCoordinateType coordinateType, IShape** ppLeftJointShape, IShape** ppRightJointShape) const
{
   VALIDATE(BRIDGE);
   ATLASSERT(coordinateType == pgsTypes::scBridge || coordinateType == pgsTypes::scGirder); // csCentroid not supported in this method

   IntervalIndexType compositeJointIntervalIdx = GetCompositeLongitudinalJointInterval();

   GET_IFACE(IBridgeDescription, pIBridgeDesc);
   if (pIBridgeDesc->GetDeckDescription()->TransverseConnectivity == pgsTypes::atcConnectedRelativeDisplacement || intervalIdx < compositeJointIntervalIdx)
   {
      *ppLeftJointShape = nullptr;
      *ppRightJointShape = nullptr;
      return;
   }


   const auto& sprops = GetSectionProperties(intervalIdx, poi, pgsTypes::sptGross);
   CComQIPtr<ICompositeSectionEx> composite(sprops.Section);
   CComPtr<ICompositeSectionItemEx> item;
   composite->get_Item(sprops.GirderShapeIndex, &item);
   CComPtr<IShape> girderShape;
   item->get_Shape(&girderShape);
   CComQIPtr<IJointedSection> jointedSection(girderShape);
   if (jointedSection == nullptr)
   {
      *ppLeftJointShape = nullptr;
      *ppRightJointShape = nullptr;
      return;
   }
   jointedSection->GetJointShapes(ppLeftJointShape,ppRightJointShape);

   if (bOrient || coordinateType == pgsTypes::scBridge)
   {

      CComPtr<ICompositeShape> compositeShape;
      compositeShape.CoCreateInstance(CLSID_CompositeShape);
      if (*ppLeftJointShape)
      {
         compositeShape->AddShape(*ppLeftJointShape, VARIANT_FALSE);
      }

      if (*ppRightJointShape)
      {
         compositeShape->AddShape(*ppRightJointShape, VARIANT_FALSE);
      }

      CComQIPtr<IXYPosition> position(compositeShape);

      if (bOrient)
      {
         Float64 orientation = GetOrientation(poi.GetSegmentKey());
         Float64 rotation_angle = -orientation;
         position->Rotate(0, 0, rotation_angle);
      }

      if (coordinateType == pgsTypes::scBridge)
      {
         // the joints shapes are in girder section coordinates
      // move them to bridge section coordinates
         position->Offset(sprops.dx, sprops.dy);
      }
   }
}

/////////////////////////////////////////////////////////////////////////
// IBarriers
//
Float64 CBridgeAgentImp::GetAtb(pgsTypes::TrafficBarrierOrientation orientation) const
{
   VALIDATE(BRIDGE);

   CComPtr<IShapeProperties> props;
   GetBarrierProperties(orientation,&props);

   if ( props == nullptr )
   {
      return 0;
   }

   Float64 area;
   props->get_Area(&area);

   return area;
}

Float64 CBridgeAgentImp::GetItb(pgsTypes::TrafficBarrierOrientation orientation) const
{
   VALIDATE(BRIDGE);

   CComPtr<IShapeProperties> props;
   GetBarrierProperties(orientation,&props);

   if ( props == nullptr )
   {
      return 0;
   }

   Float64 Ix;
   props->get_Ixx(&Ix);

   return Ix;
}

Float64 CBridgeAgentImp::GetYbtb(pgsTypes::TrafficBarrierOrientation orientation) const
{
   VALIDATE(BRIDGE);

   CComPtr<IShapeProperties> props;
   GetBarrierProperties(orientation,&props);

   if ( props == nullptr )
   {
      return 0;
   }

   Float64 Yb;
   props->get_Ybottom(&Yb);

   return Yb;
}

Float64 CBridgeAgentImp::GetSidewalkWeight(pgsTypes::TrafficBarrierOrientation orientation) const
{
   VALIDATE(BRIDGE);

   GET_IFACE(IBridgeDescription,pIBridgeDesc);
   const CBridgeDescription2* pBridgeDesc = pIBridgeDesc->GetBridgeDescription();

   const CRailingSystem* pRailingSystem = nullptr;
   if ( orientation == pgsTypes::tboLeft )
   {
      pRailingSystem = pBridgeDesc->GetLeftRailingSystem();
   }
   else
   {
      pRailingSystem = pBridgeDesc->GetRightRailingSystem();
   }

   Float64 Wsw = 0;
   if ( pRailingSystem->bUseSidewalk )
   {
      // real dl width of sidwalk
      IntervalIndexType railingSystemIntervalIdx = GetInstallRailingSystemInterval();

      Float64 intEdge, extEdge;
      GetSidewalkDeadLoadEdges(orientation, &intEdge, &extEdge);

      Float64 w = fabs(intEdge-extEdge);
      Float64 tl = pRailingSystem->LeftDepth;
      Float64 tr = pRailingSystem->RightDepth;
      Float64 area = w*(tl + tr)/2;
      Float64 density = GetRailingSystemWeightDensity(orientation,railingSystemIntervalIdx);
      Float64 mpl = area * density; // mass per length
      Float64 g = WBFL::Units::System::GetGravitationalAcceleration();
      Wsw = mpl * g;
   }

   return Wsw;
}

bool CBridgeAgentImp::HasSidewalk(pgsTypes::TrafficBarrierOrientation orientation) const
{
   GET_IFACE(IBridgeDescription,pIBridgeDesc);
   const CBridgeDescription2* pBridgeDesc = pIBridgeDesc->GetBridgeDescription();

   const CRailingSystem* pRailingSystem = nullptr;
   if ( orientation == pgsTypes::tboLeft )
   {
      pRailingSystem = pBridgeDesc->GetLeftRailingSystem();
   }
   else
   {
      pRailingSystem = pBridgeDesc->GetRightRailingSystem();
   }

   return pRailingSystem->bUseSidewalk;
}

Float64 CBridgeAgentImp::GetExteriorBarrierWeight(pgsTypes::TrafficBarrierOrientation orientation) const
{
   GET_IFACE(IBridgeDescription,pIBridgeDesc);
   const CBridgeDescription2* pBridgeDesc = pIBridgeDesc->GetBridgeDescription();

   const CRailingSystem* pRailingSystem = nullptr;
   if ( orientation == pgsTypes::tboLeft )
   {
      pRailingSystem = pBridgeDesc->GetLeftRailingSystem();
   }
   else
   {
      pRailingSystem = pBridgeDesc->GetRightRailingSystem();
   }

   Float64 Wext = 0; // weight of exterior barrier
   if ( pRailingSystem->GetExteriorRailing()->GetWeightMethod() == TrafficBarrierEntry::Compute )
   {
      CComPtr<IPolyShape> polyshape;
      pRailingSystem->GetExteriorRailing()->CreatePolyShape(orientation,&polyshape);

      CComQIPtr<IShape> shape(polyshape);
      CComPtr<IShapeProperties> props;
      shape->get_ShapeProperties(&props);
      Float64 area;
      props->get_Area(&area);

      IntervalIndexType railingSystemIntervalIdx = GetInstallRailingSystemInterval();
      Float64 density = GetRailingSystemWeightDensity(orientation,railingSystemIntervalIdx);

      Float64 mplBarrier = area * density;
      Float64 g = WBFL::Units::System::GetGravitationalAcceleration();
      Wext = mplBarrier * g;
   }
   else
   {
      Wext = pRailingSystem->GetExteriorRailing()->GetWeight();
   }

   return Wext;
}

Float64 CBridgeAgentImp::GetInteriorBarrierWeight(pgsTypes::TrafficBarrierOrientation orientation) const
{
   GET_IFACE(IBridgeDescription,pIBridgeDesc);
   const CBridgeDescription2* pBridgeDesc = pIBridgeDesc->GetBridgeDescription();

   const CRailingSystem* pRailingSystem = nullptr;
   if ( orientation == pgsTypes::tboLeft )
   {
      pRailingSystem = pBridgeDesc->GetLeftRailingSystem();
   }
   else
   {
      pRailingSystem = pBridgeDesc->GetRightRailingSystem();
   }

   Float64 Wint = 0.0; // weight of interior barrier
   if ( pRailingSystem->bUseInteriorRailing )
   {
      if ( pRailingSystem->GetInteriorRailing()->GetWeightMethod() == TrafficBarrierEntry::Compute )
      {
         CComPtr<IPolyShape> polyshape;
         pRailingSystem->GetInteriorRailing()->CreatePolyShape(orientation,&polyshape);

         CComQIPtr<IShape> shape(polyshape);
         CComPtr<IShapeProperties> props;
         shape->get_ShapeProperties(&props);
         Float64 area;
         props->get_Area(&area);

         IntervalIndexType railingSystemIntervalIdx = GetInstallRailingSystemInterval();
         Float64 density = GetRailingSystemWeightDensity(orientation,railingSystemIntervalIdx);
         Float64 mplBarrier = area * density;
         Float64 g = WBFL::Units::System::GetGravitationalAcceleration();
         Wint = mplBarrier * g;
      }
      else
      {
         Wint = pRailingSystem->GetInteriorRailing()->GetWeight();
      }
   }

   return Wint;
}

bool CBridgeAgentImp::HasInteriorBarrier(pgsTypes::TrafficBarrierOrientation orientation) const
{
   GET_IFACE(IBridgeDescription,pIBridgeDesc);
   const CBridgeDescription2* pBridgeDesc = pIBridgeDesc->GetBridgeDescription();

   const CRailingSystem* pRailingSystem = nullptr;
   if ( orientation == pgsTypes::tboLeft )
   {
      pRailingSystem = pBridgeDesc->GetLeftRailingSystem();
   }
   else
   {
      pRailingSystem = pBridgeDesc->GetRightRailingSystem();
   }

   return  pRailingSystem->bUseInteriorRailing;
}

Float64 CBridgeAgentImp::GetExteriorBarrierCgToDeckEdge(pgsTypes::TrafficBarrierOrientation orientation) const
{
   VALIDATE(BRIDGE);

   // Use generic bridge - barriers have been placed properly
   CComPtr<ISidewalkBarrier> pSwBarrier;
   Float64 sign;
   if ( orientation == pgsTypes::tboLeft )
   {
      m_Bridge->get_LeftBarrier(&pSwBarrier);
      sign = 1.0;
   }
   else
   {
      m_Bridge->get_RightBarrier(&pSwBarrier);
      sign = -1.0;
   }

   CComPtr<IBarrier> pBarrier;
   pSwBarrier->get_ExteriorBarrier(&pBarrier);

   CComQIPtr<IShape> shape;
   pBarrier->get_Shape(&shape);

   CComPtr<IShapeProperties> props;
   shape->get_ShapeProperties(&props);

   CComPtr<IPoint2d> cgpoint;
   props->get_Centroid(&cgpoint);

   Float64 xcg;
   cgpoint->get_X(&xcg);

   return xcg*sign;
}

Float64 CBridgeAgentImp::GetInteriorBarrierCgToDeckEdge(pgsTypes::TrafficBarrierOrientation orientation) const
{
   VALIDATE(BRIDGE);

   // Use generic bridge - barriers have been placed properly
   CComPtr<ISidewalkBarrier> pSwBarrier;
   Float64 sign;
   if ( orientation == pgsTypes::tboLeft )
   {
      m_Bridge->get_LeftBarrier(&pSwBarrier);
      sign = 1.0;
   }
   else
   {
      m_Bridge->get_RightBarrier(&pSwBarrier);
      sign = -1.0;
   }

   CComPtr<IBarrier> pBarrier;
   pSwBarrier->get_InteriorBarrier(&pBarrier);

   CComQIPtr<IShape> shape;
   pBarrier->get_Shape(&shape);

   if (shape)
   {
      CComPtr<IShapeProperties> props;
      shape->get_ShapeProperties(&props);

      CComPtr<IPoint2d> cgpoint;
      props->get_Centroid(&cgpoint);

      Float64 xcg;
      cgpoint->get_X(&xcg);

      return xcg*sign;
   }
   else
   {
      ATLASSERT(false); // client should be checking this
      return 0.0;
   }
}

Float64 CBridgeAgentImp::GetInterfaceWidth(pgsTypes::TrafficBarrierOrientation orientation) const
{
   VALIDATE(BRIDGE);

   // This is the offset from the edge of deck to the curb line (basically the connection 
   // width of the barrier)
   CComPtr<ISidewalkBarrier> barrier;

   if ( orientation == pgsTypes::tboLeft )
   {
      m_Bridge->get_LeftBarrier(&barrier);
   }
   else
   {
      m_Bridge->get_RightBarrier(&barrier);
   }

   Float64 offset;
   barrier->get_ExteriorCurbWidth(&offset);
   return offset;
}

void CBridgeAgentImp::GetSidewalkDeadLoadEdges(pgsTypes::TrafficBarrierOrientation orientation, Float64* pintEdge, Float64* pextEdge) const
{
   VALIDATE(BRIDGE);

   CComPtr<ISidewalkBarrier> barrier;
   if ( orientation == pgsTypes::tboLeft )
   {
      m_Bridge->get_LeftBarrier(&barrier);
   }
   else
   {
      m_Bridge->get_RightBarrier(&barrier);
   }

   VARIANT_BOOL has_sw;
   barrier->get_HasSidewalk(&has_sw);

   Float64 width = 0;
   if ( has_sw!=VARIANT_FALSE )
   {
      CComPtr<IShape> swShape;
      barrier->get_SidewalkShape(&swShape);

      // slab extends to int side of int box if it exists
      CComPtr<IRect2d> bbox;
      swShape->get_BoundingBox(&bbox);

      if ( orientation == pgsTypes::tboLeft )
      {
         bbox->get_Left(pextEdge);
         bbox->get_Right(pintEdge);
      }
      else
      {
         bbox->get_Left(pintEdge);
         bbox->get_Right(pextEdge);
      }
   }
   else
   {
      ATLASSERT(false); // client should not call this if no sidewalk
   }
}

void CBridgeAgentImp::GetSidewalkPedLoadEdges(pgsTypes::TrafficBarrierOrientation orientation, Float64* pintEdge, Float64* pextEdge) const
{
   VALIDATE(BRIDGE);

   CComPtr<ISidewalkBarrier> swbarrier;
   if ( orientation == pgsTypes::tboLeft )
   {
      m_Bridge->get_LeftBarrier(&swbarrier);
   }
   else
   {
      m_Bridge->get_RightBarrier(&swbarrier);
   }

   VARIANT_BOOL has_sw;
   swbarrier->get_HasSidewalk(&has_sw);
   if(has_sw!=VARIANT_FALSE)
   {
      CComPtr<IBarrier> extbarrier;
      swbarrier->get_ExteriorBarrier(&extbarrier);

      // Sidewalk width for ped - sidewalk goes from interior edge of exterior barrier to sw width
      CComPtr<IShape> pextbarshape;
      extbarrier->get_Shape(&pextbarshape);
      CComPtr<IRect2d> bbox;
      pextbarshape->get_BoundingBox(&bbox);

      // exterior edge
      if ( orientation == pgsTypes::tboLeft )
      {
         bbox->get_Right(pextEdge);
      }
      else
      {
         bbox->get_Left(pextEdge);
         *pextEdge *= -1.0;
      }

      Float64 width;
      swbarrier->get_SidewalkWidth(&width);

      *pintEdge = *pextEdge + width;
   }
   else
   {
      ATLASSERT(false); // client should not call this if no sidewalk
      *pintEdge = 0.0;
      *pextEdge = 0.0;
   }
}

pgsTypes::TrafficBarrierOrientation CBridgeAgentImp::GetNearestBarrier(const CSegmentKey& segmentKey) const
{
   GirderIndexType nGirders = GetGirderCount(segmentKey.groupIndex);
   if ( segmentKey.girderIndex < nGirders/2 )
   {
      return pgsTypes::tboLeft;
   }
   else
   {
      return pgsTypes::tboRight;
   }
}

////////////////////////////////////////////////////////////////////////
// ISegmentLiftingPointsOfInterest
void CBridgeAgentImp::GetLiftingPointsOfInterest(const CSegmentKey& segmentKey,PoiAttributeType attrib,PoiList* pPoiList,Uint32 mode) const
{
   VALIDATE_POINTS_OF_INTEREST(segmentKey);

   Uint32 mgrMode = (mode == POIFIND_AND ? POIMGR_AND : POIMGR_OR);

   m_pPoiMgr->GetPointsOfInterest(segmentKey,POI_LIFT_SEGMENT | attrib, mgrMode,pPoiList);

   if ( attrib == 0 )
   {
      PoiList vPoi2;
      m_pPoiMgr->GetPointsOfInterest(segmentKey,POI_SECTCHANGE | POI_HARPINGPOINT | POI_PICKPOINT | POI_PSXFER,POIMGR_OR,&vPoi2);
      m_pPoiMgr->MergePoiLists(*pPoiList, vPoi2, pPoiList);
   }
}

void CBridgeAgentImp::GetLiftingDesignPointsOfInterest(const CSegmentKey& segmentKey,Float64 overhang,PoiAttributeType attrib, std::vector<pgsPointOfInterest>* pvPoi,Uint32 mode) const
{
   // Generates points of interest for the supplied overhang.
   pgsPoiMgr poiMgr; // this is a locally scoped poi manager... once this function returns all of the poi's that are managed get destroyed.
   // this is why we return a vector of poi's by value... we are returning copies
   LayoutHandlingPoi(segmentKey,10,overhang,overhang,attrib,POI_PICKPOINT,POI_LIFT_SEGMENT,&poiMgr);

   Uint32 mgrMode = (mode == POIFIND_AND ? POIMGR_AND : POIMGR_OR);
   PoiList vPoiList;
   poiMgr.GetPointsOfInterest(segmentKey, attrib, mgrMode, &vPoiList );

   MakePoiVector(vPoiList,pvPoi);
}

////////////////////////////////////////////////////////////////////////
// ISegmentHaulingPointsOfInterest
void CBridgeAgentImp::GetHaulingPointsOfInterest(const CSegmentKey& segmentKey,PoiAttributeType attrib,PoiList* pPoiList,Uint32 mode) const
{
   VALIDATE_POINTS_OF_INTEREST(segmentKey);

   Uint32 mgrMode = (mode == POIFIND_AND ? POIMGR_AND : POIMGR_OR);

   m_pPoiMgr->GetPointsOfInterest(segmentKey,POI_HAUL_SEGMENT | attrib, mgrMode,pPoiList);

   if ( attrib == 0 )
   {
      PoiList vPoi2;
      m_pPoiMgr->GetPointsOfInterest(segmentKey,POI_SECTCHANGE | POI_HARPINGPOINT | POI_BUNKPOINT | POI_PSXFER,POIMGR_OR,&vPoi2);
      m_pPoiMgr->MergePoiLists(*pPoiList, vPoi2,pPoiList);
   }
}

void CBridgeAgentImp::GetHaulingDesignPointsOfInterest(const CSegmentKey& segmentKey,Uint16 nPnts,Float64 leftOverhang,Float64 rightOverhang,PoiAttributeType attrib, std::vector<pgsPointOfInterest>* pvPoi,Uint32 mode) const
{
   // Generates points of interest for the supplied overhang.
   pgsPoiMgr poiMgr; // this is a locally scoped poi manager... once this function returns all of the poi's that are managed get destroyed.
                     // this is why we return a vector of poi's by value... we are returning copies
   LayoutHandlingPoi(segmentKey,nPnts,leftOverhang,rightOverhang,attrib,POI_BUNKPOINT,POI_HAUL_SEGMENT,&poiMgr);

   // add pois at harping points if harped is possible
   const GirderLibraryEntry* pGirderEntry = GetGirderLibraryEntry(segmentKey);

   StrandIndexType nhMax = pGirderEntry->GetMaxHarpedStrands();
   if ( 0 < nhMax )
   {
      CComPtr<IPrecastGirder> girder;
      GetGirder(segmentKey,&girder);

      CComPtr<IStrandModel> strandModel;
      girder->get_StrandModel(&strandModel);
      CComQIPtr<IStrandGridModel> strandGridModel(strandModel);

      Float64 hp1, hp2;
      strandGridModel->GetHarpingPointLocations( &hp1, &hp2 );

      VERIFY(poiMgr.AddPointOfInterest(pgsPointOfInterest(segmentKey, hp1, attrib | POI_HARPINGPOINT)) != INVALID_ID);
      VERIFY(poiMgr.AddPointOfInterest(pgsPointOfInterest(segmentKey, hp2, attrib | POI_HARPINGPOINT)) != INVALID_ID);
   }

   Uint32 mgrMode = (mode == POIFIND_AND ? POIMGR_AND : POIMGR_OR);
   PoiList vPoiList;
   poiMgr.GetPointsOfInterest(segmentKey, attrib, mgrMode, &vPoiList );

   MakePoiVector(vPoiList,pvPoi);
}

Float64 CBridgeAgentImp::GetMinimumOverhang(const CSegmentKey& segmentKey) const
{
   Float64 gdrLength = GetSegmentLength(segmentKey);

   GET_IFACE(ISegmentHaulingSpecCriteria,pCriteria);
   Float64 maxDistBetweenSupports = pCriteria->GetAllowableDistanceBetweenSupports(segmentKey);

   Float64 minOverhang = (gdrLength - maxDistBetweenSupports)/2;
   if ( minOverhang < 0 )
   {
      minOverhang = 0;
   }

   return minOverhang;
}

////////////////////////////////////////////////////////////////////////
// IUserDefinedLoads
bool CBridgeAgentImp::DoUserLoadsExist(const CSpanKey& spanKey) const
{
   IntervalIndexType nIntervals = m_IntervalManager.GetIntervalCount();
   for ( IntervalIndexType intervalIdx = 0; intervalIdx < nIntervals; intervalIdx++ )
   {
      if ( DoUserLoadsExist(spanKey,intervalIdx) )
      {
         return true;
      }
   }

   return false;
}

bool CBridgeAgentImp::DoUserLoadsExist(const CGirderKey& girderKey) const
{
   SpanIndexType startSpanIdx = GetGirderGroupStartSpan(girderKey.groupIndex);
   SpanIndexType endSpanIdx   = GetGirderGroupEndSpan(girderKey.groupIndex);
   for (SpanIndexType spanIdx = startSpanIdx; spanIdx <= endSpanIdx; spanIdx++ )
   {
      if ( DoUserLoadsExist(CSpanKey(spanIdx,girderKey.girderIndex)) )
      {
         return true;
      }
   }
   return false;
}

bool CBridgeAgentImp::DoUserLoadsExist(const CSpanKey& spanKey,IUserDefinedLoads::UserDefinedLoadCase loadCase) const
{
   GroupIndexType grpIdx = GetGirderGroupIndex(spanKey.spanIndex);
   CGirderKey girderKey(grpIdx,spanKey.girderIndex);
   IntervalIndexType nIntervals = m_IntervalManager.GetIntervalCount();
   for ( IntervalIndexType intervalIdx = 0; intervalIdx < nIntervals; intervalIdx++ )
   {
      if ( DoUserLoadsExist(spanKey,intervalIdx,loadCase) )
      {
         return true;
      }
   }

   return false;
}

bool CBridgeAgentImp::DoUserLoadsExist(const CGirderKey& girderKey,IUserDefinedLoads::UserDefinedLoadCase loadCase) const
{
   SpanIndexType startSpanIdx = GetGirderGroupStartSpan(girderKey.groupIndex);
   SpanIndexType endSpanIdx   = GetGirderGroupEndSpan(girderKey.groupIndex);
   for (SpanIndexType spanIdx = startSpanIdx; spanIdx <= endSpanIdx; spanIdx++ )
   {
      if ( DoUserLoadsExist(CSpanKey(spanIdx,girderKey.girderIndex),loadCase) )
      {
         return true;
      }
   }
   return false;
}

bool CBridgeAgentImp::DoUserLoadsExist(const CSpanKey& spanKey,IntervalIndexType intervalIdx) const
{
   if ( DoUserLoadsExist(spanKey,intervalIdx,IUserDefinedLoads::userDC) )
   {
      return true;
   }

   if ( DoUserLoadsExist(spanKey,intervalIdx,IUserDefinedLoads::userDW) )
   {
      return true;
   }

   if ( DoUserLoadsExist(spanKey,intervalIdx,IUserDefinedLoads::userLL_IM) )
   {
      return true;
   }

   return false;
}

bool CBridgeAgentImp::DoUserLoadsExist(const CGirderKey& girderKey,IntervalIndexType intervalIdx) const
{
   SpanIndexType startSpanIdx = GetGirderGroupStartSpan(girderKey.groupIndex);
   SpanIndexType endSpanIdx   = GetGirderGroupEndSpan(girderKey.groupIndex);
   for (SpanIndexType spanIdx = startSpanIdx; spanIdx <= endSpanIdx; spanIdx++ )
   {
      if ( DoUserLoadsExist(CSpanKey(spanIdx,girderKey.girderIndex),intervalIdx) )
      {
         return true;
      }
   }
   return false;
}

bool CBridgeAgentImp::DoUserLoadsExist(const CSpanKey& spanKey,IntervalIndexType intervalIdx,IUserDefinedLoads::UserDefinedLoadCase loadCase) const
{
   return DoUserLoadsExist(spanKey,intervalIdx,intervalIdx,loadCase);
}

bool CBridgeAgentImp::DoUserLoadsExist(const CGirderKey& girderKey,IntervalIndexType intervalIdx,IUserDefinedLoads::UserDefinedLoadCase loadCase) const
{
   SpanIndexType startSpanIdx = GetGirderGroupStartSpan(girderKey.groupIndex);
   SpanIndexType endSpanIdx   = GetGirderGroupEndSpan(girderKey.groupIndex);
   for (SpanIndexType spanIdx = startSpanIdx; spanIdx <= endSpanIdx; spanIdx++ )
   {
      if ( DoUserLoadsExist(CSpanKey(spanIdx,girderKey.girderIndex),intervalIdx,loadCase) )
      {
         return true;
      }
   }
   return false;
}

bool CBridgeAgentImp::DoUserLoadsExist(const CSpanKey& spanKey,IntervalIndexType firstIntervalIdx,IntervalIndexType lastIntervalIdx) const
{
   if ( DoUserLoadsExist(spanKey,firstIntervalIdx,lastIntervalIdx,IUserDefinedLoads::userDC) )
   {
      return true;
   }

   if ( DoUserLoadsExist(spanKey,firstIntervalIdx,lastIntervalIdx,IUserDefinedLoads::userDW) )
   {
      return true;
   }

   if ( DoUserLoadsExist(spanKey,firstIntervalIdx,lastIntervalIdx,IUserDefinedLoads::userLL_IM) )
   {
      return true;
   }

   return false;
}

bool CBridgeAgentImp::DoUserLoadsExist(const CGirderKey& girderKey,IntervalIndexType firstIntervalIdx,IntervalIndexType lastIntervalIdx) const
{
   SpanIndexType startSpanIdx = GetGirderGroupStartSpan(girderKey.groupIndex);
   SpanIndexType endSpanIdx   = GetGirderGroupEndSpan(girderKey.groupIndex);
   for (SpanIndexType spanIdx = startSpanIdx; spanIdx <= endSpanIdx; spanIdx++ )
   {
      if ( DoUserLoadsExist(CSpanKey(spanIdx,girderKey.girderIndex),firstIntervalIdx,lastIntervalIdx) )
      {
         return true;
      }
   }
   return false;
}

bool CBridgeAgentImp::DoUserLoadsExist(const CSpanKey& spanKey,IntervalIndexType firstIntervalIdx,IntervalIndexType lastIntervalIdx,IUserDefinedLoads::UserDefinedLoadCase loadCase) const
{
   for ( IntervalIndexType intervalIdx = firstIntervalIdx; intervalIdx <= lastIntervalIdx; intervalIdx++ )
   {
      const std::vector<IUserDefinedLoads::UserPointLoad>* uplv = GetPointLoads(intervalIdx,spanKey);
      if ( uplv )
      {
         std::vector<IUserDefinedLoads::UserPointLoad>::const_iterator iter(uplv->begin());
         std::vector<IUserDefinedLoads::UserPointLoad>::const_iterator iterEnd(uplv->end());
         for ( ; iter != iterEnd; iter++ )
         {
            const IUserDefinedLoads::UserPointLoad& load(*iter);
            if ( load.m_LoadCase == loadCase )
            {
               return true;
            }
         }
      }

      const std::vector<IUserDefinedLoads::UserDistributedLoad>* udlv = GetDistributedLoads(intervalIdx,spanKey);
      if ( udlv )
      {
         std::vector<IUserDefinedLoads::UserDistributedLoad>::const_iterator iter(udlv->begin());
         std::vector<IUserDefinedLoads::UserDistributedLoad>::const_iterator iterEnd(udlv->end());
         for ( ; iter != iterEnd; iter++ )
         {
            const IUserDefinedLoads::UserDistributedLoad& load(*iter);
            if ( load.m_LoadCase == loadCase )
            {
               return true;
            }
         }
      }

      const std::vector<IUserDefinedLoads::UserMomentLoad>* umlv = GetMomentLoads(intervalIdx,spanKey);
      if ( umlv )
      {
         std::vector<IUserDefinedLoads::UserMomentLoad>::const_iterator iter(umlv->begin());
         std::vector<IUserDefinedLoads::UserMomentLoad>::const_iterator iterEnd(umlv->end());
         for ( ; iter != iterEnd; iter++ )
         {
            const IUserDefinedLoads::UserMomentLoad& load(*iter);
            if ( load.m_LoadCase == loadCase )
            {
               return true;
            }
         }
      }
   }

   return false;
}

bool CBridgeAgentImp::DoUserLoadsExist(const CGirderKey& girderKey,IntervalIndexType firstIntervalIdx,IntervalIndexType lastIntervalIdx,IUserDefinedLoads::UserDefinedLoadCase loadCase) const
{
   SpanIndexType startSpanIdx = GetGirderGroupStartSpan(girderKey.groupIndex);
   SpanIndexType endSpanIdx   = GetGirderGroupEndSpan(girderKey.groupIndex);
   for (SpanIndexType spanIdx = startSpanIdx; spanIdx <= endSpanIdx; spanIdx++ )
   {
      if ( DoUserLoadsExist(CSpanKey(spanIdx,girderKey.girderIndex),firstIntervalIdx,lastIntervalIdx,loadCase) )
      {
         return true;
      }
   }
   return false;
}

const std::vector<IUserDefinedLoads::UserPointLoad>* CBridgeAgentImp::GetPointLoads(IntervalIndexType intervalIdx,const CSpanKey& spanKey) const
{
   VALIDATE(LOADS);

   CUserLoadKey key(spanKey,intervalIdx);
   auto found( m_PointLoads.find(key) );

   if (found == m_PointLoads.cend())
   {
      return nullptr;
   }

   return &(found->second);
}

const std::vector<IUserDefinedLoads::UserDistributedLoad>* CBridgeAgentImp::GetDistributedLoads(IntervalIndexType intervalIdx,const CSpanKey& spanKey) const
{
   VALIDATE(LOADS);

   CUserLoadKey key(spanKey,intervalIdx);
   auto found( m_DistributedLoads.find(key) );

   if (found == m_DistributedLoads.cend())
   {
      return nullptr;
   }

   return &(found->second);
}

const std::vector<IUserDefinedLoads::UserMomentLoad>* CBridgeAgentImp::GetMomentLoads(IntervalIndexType intervalIdx,const CSpanKey& spanKey) const
{
   VALIDATE(LOADS);

   CUserLoadKey key(spanKey,intervalIdx);
   auto found( m_MomentLoads.find(key) );

   if (found == m_MomentLoads.cend())
   {
      return nullptr;
   }
      
   return &(found->second);
}

const std::vector<IntervalIndexType> CBridgeAgentImp::GetUserDefinedLoadIntervals(const CGirderKey& girderKey) const
{
   std::vector<IntervalIndexType> vUserLoadIntervals;
   IntervalIndexType nIntervals = m_IntervalManager.GetIntervalCount();
   for (IntervalIndexType intervalIdx = 0; intervalIdx < nIntervals; intervalIdx++)
   {
      if (DoUserLoadsExist(girderKey, intervalIdx))
      {
         vUserLoadIntervals.push_back(intervalIdx);
      }
   }

   return vUserLoadIntervals;
}

/////////////////////////////////////////////////////
// ITempSupport
void CBridgeAgentImp::GetControlPoints(SupportIndexType tsIdx,pgsTypes::PlanCoordinateType pcType,IPoint2d** ppLeft,IPoint2d** ppAlignment,IPoint2d** ppBridge,IPoint2d** ppRight) const
{
   VALIDATE( BRIDGE );

   CComPtr<IBridgeGeometry> geometry;
   m_Bridge->get_BridgeGeometry(&geometry);

   CComPtr<IPierLine> pierline;
   SupportIDType tsID = ::GetTempSupportLineID(tsIdx);
   geometry->FindPierLine( tsID, &pierline);
   pierline->get_AlignmentPoint(ppAlignment);
   pierline->get_BridgePoint(ppBridge);

   // left and right edge points... intersect CL pier with deck edge
   CComPtr<ILine2d> line;
   pierline->get_Centerline(&line);

   // get the left and right segment girder line that touch this temporary support
   GET_IFACE(IBridgeDescription,pIBridgeDesc);
   const CBridgeDescription2* pBridgeDesc = pIBridgeDesc->GetBridgeDescription();

   const CTemporarySupportData* pTS = pBridgeDesc->GetTemporarySupport(tsIdx);
   Float64 tsStation = pTS->GetStation();

   // need to get the girder group this temporary support belongs with
   const CGirderGroupData* pGroup = pBridgeDesc->GetGirderGroup(pTS->GetSpan());
   GroupIndexType grpIdx = pGroup->GetIndex();

   // use left girder to get the number of segments as every girder in a group has the same number of segments
   GirderIndexType gdrIdx = 0;
   const CSplicedGirderData* pGirder = pBridgeDesc->GetGirderGroup(grpIdx)->GetGirder(gdrIdx);
   SegmentIndexType nSegments = pGirder->GetSegmentCount();
   SegmentIndexType segIdx = INVALID_INDEX;
   for ( segIdx = 0; segIdx < nSegments; segIdx++ )
   {
      const CPrecastSegmentData* pSegment = pGirder->GetSegment(segIdx);
      Float64 startStation,endStation;
      pSegment->GetStations(&startStation,&endStation);
      if ( ::InRange(startStation,tsStation,endStation) )
      {
         break;
      }
   }
   
   ATLASSERT( segIdx < nSegments ); // if this fails, the temp support wasn't found

   // since we don't have deck edges just yet, use the first and last girderline
   CComPtr<IGirderLine> left_girderline;
   LineIDType segID = ::GetGirderSegmentLineID(grpIdx,gdrIdx,segIdx);
   geometry->FindGirderLine( segID, &left_girderline);
   CComPtr<IPath> left_path;
   left_girderline->get_Path(&left_path);
   left_path->Intersect(line,*ppAlignment,ppLeft);

   GirderIndexType nGirderLines = pBridgeDesc->GetGirderGroup(grpIdx)->GetGirderCount();

   CComPtr<IGirderLine> right_girderline;
   segID = ::GetGirderSegmentLineID(grpIdx,nGirderLines-1,segIdx);
   geometry->FindGirderLine( segID, &right_girderline);
   CComPtr<IPath> right_path;
   right_girderline->get_Path( &right_path);
   right_path->Intersect(line,*ppAlignment,ppRight);

   if ( pcType == pgsTypes::pcGlobal )
   {
      (*ppLeft)->Offset(m_DeltaX,m_DeltaY);
      (*ppAlignment)->Offset(m_DeltaX,m_DeltaY);
      (*ppBridge)->Offset(m_DeltaX,m_DeltaY);
      (*ppRight)->Offset(m_DeltaX,m_DeltaY);
   }
}

void CBridgeAgentImp::GetDirection(SupportIndexType tsIdx,IDirection** ppDirection) const
{
   VALIDATE(BRIDGE);

   CComPtr<IBridgeGeometry> geometry;
   m_Bridge->get_BridgeGeometry(&geometry);

   CComPtr<IPierLine> pier;
   SupportIDType tsID = ::GetTempSupportLineID(tsIdx);
   geometry->FindPierLine( tsID, &pier );

   pier->get_Direction(ppDirection);
}

void CBridgeAgentImp::GetSkew(SupportIndexType tsIdx,IAngle** ppAngle) const
{
   VALIDATE(BRIDGE);

   CComPtr<IBridgeGeometry> geometry;
   m_Bridge->get_BridgeGeometry(&geometry);

   CComPtr<IPierLine> pier;
   SupportIDType tsID = ::GetTempSupportLineID(tsIdx);
   geometry->FindPierLine(tsID,&pier);

   pier->get_Skew(ppAngle);
}

std::vector<SupportIndexType> CBridgeAgentImp::GetTemporarySupports(GroupIndexType grpIdx) const
{
   GET_IFACE(IBridgeDescription, pIBridgeDesc);
   const CBridgeDescription2* pBridgeDesc = pIBridgeDesc->GetBridgeDescription();

   std::vector<SupportIndexType> vTS;
   SupportIndexType nTS = pBridgeDesc->GetTemporarySupportCount();
   for (SupportIndexType tsIdx = 0; tsIdx < nTS; tsIdx++)
   {
      const CTemporarySupportData* pTS = pBridgeDesc->GetTemporarySupport(tsIdx);
      if (grpIdx == ALL_GROUPS || pBridgeDesc->GetGirderGroup(pTS->GetSpan())->GetIndex() == grpIdx)
      {
         vTS.push_back(tsIdx);
      }
   }

   return vTS;
}

std::vector<TEMPORARYSUPPORTELEVATIONDETAILS> CBridgeAgentImp::GetElevationDetails(SupportIndexType tsIdx,GirderIndexType gdrIndex) const
{
   VALIDATE(BRIDGE);

   std::vector<TEMPORARYSUPPORTELEVATIONDETAILS> vDetails;

   GET_IFACE_NOCHECK(IDeformedGirderGeometry,pDeformedGirderGeometry);
   GET_IFACE(IBridgeDescription, pIBridgeDesc);
   const CBridgeDescription2* pBridgeDesc = pIBridgeDesc->GetBridgeDescription();

   // Elevation = Finished Grade Elevation - Overlay - Haunch - Hgirder
   // Haunch = Bottom Slab Elevation - Top Girder Elevation
   // 
   // We measure deck depth at the GCE - determine overlay depth at that time. (future overlays are after the GCE)
   IntervalIndexType gceInterval = GetGeometryControlInterval();

   Float64 overlay_depth = GetOverlayDepth(gceInterval);
   Float64 gross_slab_depth = GetGrossSlabDepth();

   // Get temp support elevation just prior to removal
   IntervalIndexType tsInterval = GetTemporarySupportRemovalInterval(tsIdx) - 1;

   // If haunchInputDepthType==hidACamber, we know that design and computed deck elevations are the same at bearings.
   pgsTypes::HaunchInputDepthType haunchInputDepthType = pBridgeDesc->GetHaunchInputDepthType();

   const CTemporarySupportData* pTS = pBridgeDesc->GetTemporarySupport(tsIdx);

   const CSpanData2* pSpan = pTS->GetSpan();
   const CGirderGroupData* pGroup = pBridgeDesc->GetGirderGroup(pSpan);
   GroupIndexType grpIdx = pGroup->GetIndex();

   GirderIndexType startGirder,endGirder;
   if (gdrIndex == ALL_GIRDERS)
   {
      startGirder = 0;
      endGirder = GetGirderCount(grpIdx) - 1;
   }
   else
   {
      startGirder = gdrIndex;
      endGirder = gdrIndex;
   }

   // use girder 0 because all girders in this group have the same number of segments
   // and temporary supports
   const CSplicedGirderData* pGirder = pGroup->GetGirder(0);
   SegmentIndexType nSegments = pGirder->GetSegmentCount();
   for (SegmentIndexType segIdx = 0; segIdx < nSegments; segIdx++)
   {
      const CPrecastSegmentData* pSegment = pGirder->GetSegment(segIdx);

      // get all the temporary supports supporting this segment
      std::vector<const CTemporarySupportData*> vTS = pSegment->GetTemporarySupports();

      for (const auto& ts : vTS)
      {
         if (ts->GetIndex() == tsIdx)
         {
            // this is the temporary support we are looking for....

            bool bContinuous;
            pgsTypes::MemberEndType endType;
            CComPtr<IPoint2d> pnt;
            for (GirderIndexType gdrIdx = startGirder; gdrIdx <= endGirder; gdrIdx++)
            {
               CSegmentKey segmentKey(grpIdx, gdrIdx, segIdx);
               if (ts->GetConnectionType() == pgsTypes::tsctContinuousSegment)
               {
                  pnt.Release();
                  bool bIntersection = GetSegmentTempSupportIntersection(segmentKey, tsIdx, pgsTypes::pcLocal, &pnt);
                  ATLASSERT(bIntersection == true);
                  bContinuous = true;
                  endType = pgsTypes::metStart; // not applicable, but set it to something so we don't have uninitialized values
               }
               else
               {
                  bContinuous = false;
                  const CPrecastSegmentData* pThisSegment = pGroup->GetGirder(gdrIdx)->GetSegment(segIdx);

                  CComPtr<IPoint2d> pntPier1, pntEnd1, pntBrg1, pntBrg2, pntEnd2, pntPier2;
                  GetSegmentEndPoints(segmentKey, pgsTypes::pcLocal, &pntPier1, &pntEnd1, &pntBrg1, &pntBrg2, &pntEnd2, &pntPier2);

                  if (pThisSegment->GetClosureJoint(pgsTypes::metStart) == ts->GetClosureJoint(gdrIdx))
                  {
                     endType = pgsTypes::metStart;
                     pnt = pntBrg1;
                  }
                  else
                  {
                     ATLASSERT(pThisSegment->GetClosureJoint(pgsTypes::metEnd) == ts->GetClosureJoint(gdrIdx));
                     endType = pgsTypes::metEnd;
                     pnt = pntBrg2;
                  }
               }

               Float64 girderOrientation = GetOrientation(segmentKey);
               girderOrientation = IsZero(girderOrientation) ? 0 : girderOrientation;

               // Adjust height for cross slope orientation. This is a reduction because the distance is measured 
               // along the cl of the tilted girder
               Float64 girder_orientation_adjustment = sqrt(1 + girderOrientation*girderOrientation);

               Float64 girderSlope = GetSegmentSlope(segmentKey);
               girderSlope = IsZero(girderSlope) ? 0 : girderSlope;

               // Adjust height for profile slope. This increases height because the bearing lies vertically 
               // below the bearing station.
               Float64 girder_slope_adjustment = sqrt(1 + girderSlope*girderSlope); // adjust for slope

               // total adjustment due to slope and tilt angle of girder
               Float64 girder_height_adjustment_factor = girder_slope_adjustment / girder_orientation_adjustment;

               // Want deflection and properties at ends of segments if at a closure joint
               pgsPointOfInterest poi;
               if (bContinuous)
               {
                  poi = GetTemporarySupportPointOfInterest(segmentKey,tsIdx);
               }
               else
               {
                  PoiAttributeType attrib = (endType == pgsTypes::metStart ? (POI_0L | POI_ERECTED_SEGMENT) : (POI_10L | POI_ERECTED_SEGMENT));
                  PoiList vPois;
                  GetPointsOfInterest(segmentKey,attrib,&vPois);
                  ATLASSERT(vPois.size() == 1);
                  poi = vPois.front();
               }

               Float64 slab_offset, haunch_depth;
               if (haunchInputDepthType == pgsTypes::hidACamber)
               {
                  slab_offset = GetTopSlabToTopGirderChordDistance(poi);
                  haunch_depth = slab_offset - gross_slab_depth;
               }
               else
               {
                  // Elevations for direct haunch input are not attached to the girder chord
                  haunch_depth = GetStructuralHaunchDepth(poi,pgsTypes::hspDetailedDescription);
                  slab_offset = haunch_depth + gross_slab_depth;
               }

               IntervalIndexType intervalIdx = GetPrestressReleaseInterval(segmentKey);
               Float64 Hg = GetHg(intervalIdx,poi); // this is the basic height of the segment
               Hg *= girder_height_adjustment_factor; // adjust the vertical dimension for orientation and grade slopes

               Float64 elevAdj = GetElevationAdjustment(gceInterval, poi);

               Float64 station,offset;
               GetStationAndOffset(pgsTypes::pcLocal,pnt,&station,&offset);
               Float64 design_elevation = GetElevation(station,offset);

               Float64 finished_elevation;
               if (haunchInputDepthType == pgsTypes::hidACamber)
               {
                  // For "A" dim input, the finished elevation is at the PGL by definition
                  finished_elevation = design_elevation + elevAdj;
               }
               else
               {
                  // Haunch depth input
                  // The elevation of the beam at bearing cl depends on the pre-deformed girder shape and bearing location, and the elevation adjustment
                  // Note that the call below starts a full bridge analysis up to the geometry control event interval. This is no longer just a geometry comp
                  Float64 lftHaunch,ctrHaunch,rgtHaunch;
                  finished_elevation = pDeformedGirderGeometry->GetFinishedElevation(poi,tsInterval,&lftHaunch,&ctrHaunch,&rgtHaunch);
               }

               Float64 crossSlope = GetSlope(station, offset);
               crossSlope = IsZero(crossSlope) ? 0 : crossSlope;
               Float64 crossSlopeAdjust = sqrt(1 + crossSlope*crossSlope);

               Float64 profileGrade = GetProfileGrade(station);
               profileGrade = IsZero(profileGrade) ? 0 : profileGrade;
               Float64 profileAngleAdjust = sqrt(1 + profileGrade*profileGrade);

               Float64 roadwayAngleAdjust = crossSlopeAdjust * profileAngleAdjust;

               TEMPORARYSUPPORTELEVATIONDETAILS elevDetails;

               elevDetails.girderIdx = gdrIdx;
               elevDetails.segmentIdx = segIdx;
               elevDetails.endType = endType;
               elevDetails.bContinuous = bContinuous;
               elevDetails.Station = station;
               elevDetails.Offset = offset;
               elevDetails.DesignGradeElevation = design_elevation;
               elevDetails.FinishedGradeElevation = finished_elevation;
               elevDetails.ProfileGrade = profileGrade;
               elevDetails.GirderGrade = girderSlope;
               elevDetails.GirderOrientation = girderOrientation;
               elevDetails.Hg = Hg;
               elevDetails.SlabOffset = slab_offset;
               elevDetails.HaunchDepth = haunch_depth;
               elevDetails.OverlayDepth = overlay_depth / roadwayAngleAdjust;
               elevDetails.ElevationAdjustment = elevAdj;
               elevDetails.Elevation = finished_elevation - elevDetails.OverlayDepth - elevDetails.SlabOffset - Hg;

               vDetails.push_back(elevDetails);

            } // next girder
         } // if our ts
      } // next ts
   } // next segment

   std::sort(std::begin(vDetails), std::end(vDetails));

   return vDetails;
}

/////////////////////////////////////////////////////
// IGirder

bool CBridgeAgentImp::IsPrismatic(IntervalIndexType intervalIdx,const CSegmentKey& segmentKey) const
{
   VALIDATE( BRIDGE );

   GET_IFACE(ISpecification, pSpec);
   // assume non-prismatic for all transformed sections
   GET_IFACE(ILibrary,pLib);
   const SpecLibraryEntry* pSpecEntry = pLib->GetSpecEntry(pSpec->GetSpecification().c_str());
   if ( pSpecEntry->GetSectionPropertyMode() == pgsTypes::spmTransformed )
   {
      return false;
   }

   const GirderLibraryEntry* pGirderEntry = GetGirderLibraryEntry(segmentKey);

   CComPtr<IBeamFactory> beamFactory;
   pGirderEntry->GetBeamFactory(&beamFactory);

   bool bPrismaticGirder = beamFactory->IsPrismatic(segmentKey);
   if ( !bPrismaticGirder )
   {
      return false; // if the bare girder is non-prismiatc... it will always be non-prismatic
   }

   if ( IsNonstructuralDeck(GetDeckType()) && intervalIdx < GetCastIntermediateDiaphragmsInterval())
   {
      // there is no structural deck and we are before the interval when diaphragms are cast
      // the girder is non-composite at the point... return the prismatic state
      return bPrismaticGirder;
   }

   if ( IsCompositeDeck() )
   {
      // there is a composite deck... compare the interval when the deck is made composite
      // against the interval we are evaluating prismatic-ness to

      // if the event we are evaluating is before the composite event then
      // we just have a bare girder... return its prismatic-ness
      if ( intervalIdx < m_IntervalManager.GetFirstCompositeDeckInterval() )
      {
         return bPrismaticGirder;
      }
      else
      {
         // we have a composite deck and interval is composite. See if haunch is non-prismatic
         if (GetHaunchAnalysisSectionPropertiesType() == pgsTypes::hspDetailedDescription)
         {
            return false;
         }
      }
   }

   // if the segment end is at the CL bearing, then the span points might end up in a different span than the other points
   // to avoid this problem, tweak the start point (0.0) and the end point (segment_length) when the segment end
   // distance is equal to the bearing offset
   Float64 start_end_distance, end_end_distance;
   GetSegmentEndDistance(segmentKey, &start_end_distance, &end_end_distance);
   Float64 start_bearing_offset, end_bearing_offset;
   GetSegmentBearingOffset(segmentKey, &start_bearing_offset, &end_bearing_offset);
   Float64 start_tweak = IsEqual(start_end_distance,start_bearing_offset) ? 0.001 : 0.00;
   Float64 end_tweak = IsEqual(end_end_distance,end_bearing_offset) ? 0.001 : 0.00;

   Float64 segmentLength = GetSegmentLength(segmentKey);
   CSpanKey startSpanKey, middleSpanKey, endSpanKey;
   Float64 XspanStart, XspanMiddle, XspanEnd;
   ConvertSegmentCoordinateToSpanPoint(segmentKey,            0.0+start_tweak,&startSpanKey, &XspanStart);
   ConvertSegmentCoordinateToSpanPoint(segmentKey,segmentLength/2,&middleSpanKey,&XspanMiddle);
   ConvertSegmentCoordinateToSpanPoint(segmentKey,segmentLength - end_tweak,  &endSpanKey,   &XspanEnd);

   // we have a prismatic section made composite and are evaluating in a composite event.
   // check to see if the composite section is non-prismatic

   // check the direction of each segment... if they aren't parallel, then the composite properties
   // are non-prismatic
   // for exterior segments, if the deck edge offset isn't the same at each end of the segment,
   // then the segment will be considered to be non-prismatic as well.
   //
   // this may not be the best way to figure it out, but it mostly works well and there isn't
   // any harm in being wrong except that section properties will be reported verbosely for
   // prismatic beams when a compact reporting would suffice.
   CComPtr<IDirection> dirLeftSegment, dirThisSegment, dirRightSegment;
   Float64 startOverhang = -1;
   Float64 endOverhang = -1;
   Float64 middleOverhang = -1;
   Float64 leftDir,thisDir,rightDir;
   bool bIsExterior = IsExteriorGirder(segmentKey);
   if ( bIsExterior )
   {
      GirderIndexType nGirders = GetGirderCount(segmentKey.groupIndex);
      if ( nGirders == 1 )
      {
         // if there is only one girder, then consider the section prismatic if the left and right 
         // overhangs match at both ends and mid-span of the span
         Float64 startOverhangLeft  = GetLeftSlabOverhang(startSpanKey.spanIndex,XspanStart);
         Float64 middleOverhangLeft = GetLeftSlabOverhang(middleSpanKey.spanIndex,XspanMiddle);
         Float64 endOverhangLeft    = GetLeftSlabOverhang(endSpanKey.spanIndex,XspanEnd);

         bool bLeftEqual = IsEqual(startOverhangLeft,middleOverhangLeft) && IsEqual(middleOverhangLeft,endOverhangLeft);

         Float64 startOverhangRight  = GetRightSlabOverhang(startSpanKey.spanIndex,XspanStart);
         Float64 middleOverhangRight = GetRightSlabOverhang(middleSpanKey.spanIndex,XspanMiddle);
         Float64 endOverhangRight    = GetRightSlabOverhang(endSpanKey.spanIndex,XspanEnd);

         bool bRightEqual = IsEqual(startOverhangRight,middleOverhangRight) && IsEqual(middleOverhangRight,endOverhangRight);

         return (bLeftEqual && bRightEqual);
      }
      else
      {
         if ( segmentKey.girderIndex == 0 )
         {
            // left exterior girder
            startOverhang  = GetLeftSlabOverhang(startSpanKey.spanIndex,XspanStart);
            middleOverhang = GetLeftSlabOverhang(middleSpanKey.spanIndex,XspanMiddle);
            endOverhang    = GetLeftSlabOverhang(endSpanKey.spanIndex,XspanEnd);

            GetSegmentBearing(segmentKey,  &dirThisSegment);
            CSegmentKey rightSegmentKey(segmentKey);
            rightSegmentKey.girderIndex++;
            GetSegmentBearing(rightSegmentKey,&dirRightSegment);
            dirThisSegment->get_Value(&thisDir);
            dirRightSegment->get_Value(&rightDir);
         }
         else
         {
            // right exterior girder
            CSegmentKey leftSegmentKey(segmentKey);
            leftSegmentKey.girderIndex--;
            GetSegmentBearing(leftSegmentKey,&dirLeftSegment);
            GetSegmentBearing(segmentKey,  &dirThisSegment);
            dirLeftSegment->get_Value(&leftDir);
            dirThisSegment->get_Value(&thisDir);

            startOverhang  = GetRightSlabOverhang(startSpanKey.spanIndex,XspanStart);
            middleOverhang = GetRightSlabOverhang(middleSpanKey.spanIndex,XspanMiddle);
            endOverhang    = GetRightSlabOverhang(endSpanKey.spanIndex,XspanEnd);
         }
      }
   }
   else
   {
      // if interior girders are not parallel, then they aren't going to be
      // prismatic if they have a composite deck
      CSegmentKey leftSegmentKey,rightSegmentKey;
      GetAdjacentSegmentKeys(segmentKey,&leftSegmentKey,&rightSegmentKey);
      GetSegmentBearing(leftSegmentKey,&dirLeftSegment);
      GetSegmentBearing(segmentKey,&dirThisSegment);
      GetSegmentBearing(rightSegmentKey,&dirRightSegment);

      dirLeftSegment->get_Value(&leftDir);
      dirThisSegment->get_Value(&thisDir);
      dirRightSegment->get_Value(&rightDir);
   }

   if ( dirLeftSegment == nullptr )
   {
      return (IsEqual(thisDir,rightDir) && IsEqual(startOverhang,middleOverhang) && IsEqual(middleOverhang,endOverhang) ? true : false);
   }
   else if ( dirRightSegment == nullptr )
   {
      return (IsEqual(leftDir,thisDir) && IsEqual(startOverhang,middleOverhang) && IsEqual(middleOverhang,endOverhang) ? true : false);
   }
   else
   {
      return (IsEqual(leftDir,thisDir) && IsEqual(thisDir,rightDir) ? true : false);
   }
}

bool CBridgeAgentImp::IsSymmetricSegment(const CSegmentKey& segmentKey) const
{
   VALIDATE( BRIDGE );

   const GirderLibraryEntry* pGirderEntry = GetGirderLibraryEntry(segmentKey);

   CComPtr<IBeamFactory> beamFactory;
   pGirderEntry->GetBeamFactory(&beamFactory);

   return beamFactory->IsSymmetric(segmentKey);
}

bool CBridgeAgentImp::IsSymmetric(IntervalIndexType intervalIdx,const CGirderKey& girderKey) const
{
   IntervalIndexType liveLoadIntervalIdx = m_IntervalManager.GetLiveLoadInterval();

   // need to look at girder spacing to see if it is constant
   if ( liveLoadIntervalIdx <= intervalIdx )
   {
      return false;
   }

   // other places in the program can gain huge speed efficiencies if the 
   // girder is symmetric (only half the work needs to be done)
   SegmentIndexType nSegments = GetSegmentCount(girderKey);
   Float64 start_length = GetSegmentStartEndDistance(CSegmentKey(girderKey,0));
   Float64 end_length   = GetSegmentEndEndDistance(CSegmentKey(girderKey,nSegments-1));
   
   if ( !IsEqual(start_length,end_length) )
   {
      return false; // different end lengths
   }

   SegmentIndexType leftSegIdx = 0;
   SegmentIndexType rightSegIdx = nSegments-1;
   for ( ; leftSegIdx < rightSegIdx && rightSegIdx != INVALID_INDEX; leftSegIdx++, rightSegIdx-- )
   {
      CSegmentKey leftSegmentKey(girderKey,leftSegIdx);
      CSegmentKey rightSegmentKey(girderKey,rightSegIdx);
      Float64 left_segment_length = GetSegmentLength(leftSegmentKey);
      Float64 right_segment_length = GetSegmentLength(rightSegmentKey);

      if ( !IsEqual(left_segment_length,right_segment_length) )
      {
         return false;
      }

      Float64 left_hp1, left_hp2;
      GetHarpingPointLocations(leftSegmentKey,&left_hp1,&left_hp2);

      Float64 right_hp1, right_hp2;
      GetHarpingPointLocations(rightSegmentKey,&right_hp1,&right_hp2); // measured from left end of segment
      right_hp1 = right_segment_length - right_hp1; // measured from right end of segment
      right_hp2 = right_segment_length - right_hp2; // measured from right end of segment
      std::swap(right_hp1,right_hp2);

      if ( !IsEqual(left_hp1,right_hp1) || !IsEqual(left_hp2,right_hp2) )
      {
         return false;
      }

      if ( !IsDebondingSymmetric(leftSegmentKey) || !IsDebondingSymmetric(rightSegmentKey) )
      {
         return false;
      }
   }

   return true;
}

MatingSurfaceIndexType CBridgeAgentImp::GetMatingSurfaceCount(const CGirderKey& girderKey) const
{
   VALIDATE( BRIDGE );

   pgsPointOfInterest poi = GetPointOfInterest(CSegmentKey(girderKey, 0), 0.0); // use a real poi so GetGirderSection draws from a cache instead of creating a new girder section
   ATLASSERT(poi.GetID() != INVALID_ID);

   CComPtr<IGirderSection> girder_section;
   HRESULT hr = GetGirderSection(poi, &girder_section);
   ATLASSERT(SUCCEEDED(hr));
   if (FAILED(hr))
   {
      return 0;
   }

   FlangeIndexType count;
   girder_section->get_MatingSurfaceCount(&count);

   return count;
}

Float64 CBridgeAgentImp::GetMatingSurfaceLocation(const pgsPointOfInterest& poi,MatingSurfaceIndexType msIdx, bool bGirderOnly) const
{
   VALIDATE( BRIDGE );

   CComPtr<IGirderSection> girder_section;
   HRESULT hr = GetGirderSection(poi, &girder_section);
   ATLASSERT(SUCCEEDED(hr));
   if (FAILED(hr))
   {
      return 0;
   }

   Float64 location;
   girder_section->get_MatingSurfaceLocation(msIdx,bGirderOnly ? VARIANT_TRUE : VARIANT_FALSE, &location);
   
   return location;
}

Float64 CBridgeAgentImp::GetMatingSurfaceWidth(const pgsPointOfInterest& poi,MatingSurfaceIndexType msIdx, bool bGirderOnly) const
{
   VALIDATE( BRIDGE );

   CComPtr<IGirderSection> girder_section;
   HRESULT hr = GetGirderSection(poi, &girder_section);
   ATLASSERT(SUCCEEDED(hr));
   if (FAILED(hr))
   {
      return 0;
   }

   Float64 width;
   girder_section->get_MatingSurfaceWidth(msIdx,bGirderOnly ? VARIANT_TRUE : VARIANT_FALSE, &width);

   return width;
}

bool CBridgeAgentImp::GetMatingSurfaceProfile(const pgsPointOfInterest& poi, MatingSurfaceIndexType msIdx, bool bGirderOnly, IPoint2dCollection** ppPoints) const
{
   VALIDATE(BRIDGE);

   CComPtr<IGirderSection> girder_section;
   HRESULT hr = GetGirderSection(poi, &girder_section);
   ATLASSERT(SUCCEEDED(hr));
   if (FAILED(hr))
   {
      return false;
   }

   bool bHasMSProfile = (FAILED(girder_section->get_MatingSurfaceProfile(msIdx, bGirderOnly ? VARIANT_TRUE : VARIANT_FALSE, ppPoints)) || *ppPoints == nullptr) ? false : true;
   return bHasMSProfile;
}

FlangeIndexType CBridgeAgentImp::GetTopFlangeCount(const CGirderKey& girderKey) const
{
   VALIDATE( BRIDGE );

   pgsPointOfInterest poi(CSegmentKey(girderKey,0),0.00);

   CComPtr<IGirderSection> girder_section;
   HRESULT hr = GetGirderSection(poi, &girder_section);
   ATLASSERT(SUCCEEDED(hr));
   if (FAILED(hr))
   {
      return 0;
   }

   FlangeIndexType nFlanges;
   girder_section->get_TopFlangeCount(&nFlanges);
   return nFlanges;
}

Float64 CBridgeAgentImp::GetTopFlangeLocation(const pgsPointOfInterest& poi,FlangeIndexType flangeIdx) const
{
   VALIDATE( BRIDGE );

   CComPtr<IGirderSection> girder_section;
   HRESULT hr = GetGirderSection(poi, &girder_section);
   ATLASSERT(SUCCEEDED(hr));
   if (FAILED(hr))
   {
      return 0;
   }

   Float64 location;
   girder_section->get_TopFlangeLocation(flangeIdx,&location);
   return location;
}

Float64 CBridgeAgentImp::GetTopFlangeWidth(const pgsPointOfInterest& poi,FlangeIndexType flangeIdx) const
{
   VALIDATE( BRIDGE );

   CComPtr<IGirderSection> girder_section;
   HRESULT hr = GetGirderSection(poi, &girder_section);
   ATLASSERT(SUCCEEDED(hr));
   if (FAILED(hr))
   {
      return 0;
   }

   Float64 width;
   girder_section->get_TopFlangeWidth(flangeIdx,&width);
   return width;
}

Float64 CBridgeAgentImp::GetTopFlangeThickness(const pgsPointOfInterest& poi,FlangeIndexType flangeIdx) const
{
   VALIDATE( BRIDGE );

   CComPtr<IGirderSection> girder_section;
   HRESULT hr = GetGirderSection(poi, &girder_section);
   ATLASSERT(SUCCEEDED(hr));
   if (FAILED(hr))
   {
      return 0;
   }

   Float64 thickness;
   girder_section->get_TopFlangeThickness(flangeIdx,&thickness);
   return thickness;
}

Float64 CBridgeAgentImp::GetTopFlangeSpacing(const pgsPointOfInterest& poi,FlangeIndexType flangeIdx) const
{
   VALIDATE( BRIDGE );

   CComPtr<IGirderSection> girder_section;
   HRESULT hr = GetGirderSection(poi, &girder_section);
   ATLASSERT(SUCCEEDED(hr));
   if (FAILED(hr))
   {
      return 0;
   }

   Float64 spacing;
   girder_section->get_TopFlangeSpacing(flangeIdx,&spacing);
   return spacing;
}

bool CBridgeAgentImp::CanTopFlangeBeLongitudinallyThickened(const CSegmentKey& segmentKey) const
{
   const GirderLibraryEntry* pGirderEntry = GetGirderLibraryEntry(segmentKey);

   CComPtr<IBeamFactory> beamFactory;
   pGirderEntry->GetBeamFactory(&beamFactory);

   return beamFactory->HasTopFlangeThickening();
}

pgsTypes::TopFlangeThickeningType CBridgeAgentImp::GetTopFlangeThickeningType(const CSegmentKey& segmentKey) const
{
   GET_IFACE(IBridgeDescription, pIBridgeDesc);
   const CPrecastSegmentData* pSegment = pIBridgeDesc->GetPrecastSegmentData(segmentKey);
   return pSegment->TopFlangeThickeningType;
}

Float64 CBridgeAgentImp::GetTopFlangeThickening(const CSegmentKey& segmentKey) const
{
   GET_IFACE(IBridgeDescription, pIBridgeDesc);
   const CPrecastSegmentData* pSegment = pIBridgeDesc->GetPrecastSegmentData(segmentKey);
   return pSegment->TopFlangeThickening;
}

Float64 CBridgeAgentImp::GetTopFlangeThickening(const pgsPointOfInterest& poi) const
{
   VALIDATE(BRIDGE);
   const CSegmentKey& segmentKey(poi.GetSegmentKey());
   return GetTopFlangeThickening(segmentKey, poi.GetDistFromStart());
}

Float64 CBridgeAgentImp::GetTopFlangeThickening(const CSegmentKey& segmentKey, Float64 Xpoi) const
{
   VALIDATE(BRIDGE);

   CComPtr<ISuperstructureMemberSegment> segment;
   GetSegment(segmentKey, &segment);

   CComQIPtr<IThickenedFlangeSegment> tfs(segment);
   if (tfs == nullptr)
   {
      return 0.0;
   }

   Float64 tft;
   tfs->get_TopFlangeThickening(Xpoi, &tft);
   return tft;
}

Float64 CBridgeAgentImp::GetTopFlangeThickening(const CPrecastSegmentData* pSegment, Float64 Xs) const
{
   if (pSegment->TopFlangeThickeningType == pgsTypes::tftNone)
   {
      return 0;
   }
   else
   {
      // parabolic interpolation of the depth of the top flange thickening
      const CSegmentKey& segmentKey(pSegment->GetSegmentKey());

      Float64 Ls = GetSegmentLength(segmentKey);

      Float64 flangeThickening = pSegment->TopFlangeThickening;

      Float64 thickening;
      if (pSegment->TopFlangeThickeningType == pgsTypes::tftEnds)
      {
         thickening = 4 * flangeThickening*Xs*Xs / (Ls*Ls) - 4 * flangeThickening*Xs / Ls + flangeThickening;
      }
      else
      {
         thickening = -4 * flangeThickening*Xs*Xs / (Ls*Ls) + 4 * flangeThickening*Xs / Ls;
      }
      return thickening;
   }

   ATLASSERT(false);
   return -99999;
}

Float64 CBridgeAgentImp::GetTopFlangeWidth(const pgsPointOfInterest& poi) const
{
   MatingSurfaceIndexType nMS = GetMatingSurfaceCount(poi.GetSegmentKey());
   Float64 wtf = 0;
   for ( MatingSurfaceIndexType msIdx = 0; msIdx < nMS; msIdx++ )
   {
      Float64 msw;
      msw = GetMatingSurfaceWidth(poi,msIdx);
      wtf += msw;
}

   return wtf;
}

Float64 CBridgeAgentImp::GetTopWidth(const pgsPointOfInterest& poi,Float64* pLeft,Float64* pRight) const
{
   VALIDATE( GIRDER );

   CComPtr<IGirderSection> girder_section;
   HRESULT hr = GetGirderSection(poi, &girder_section);
   ATLASSERT(SUCCEEDED(hr));
   if (FAILED(hr))
   {
      return 0;
   }

   Float64 wleft, wright;
   girder_section->get_TopWidth(&wleft, &wright);

   Float64 width = wleft + wright;

   if (pLeft && pRight)
   {
      *pLeft = wleft;
      *pRight = wright;
   }

   return width;
}

FlangeIndexType CBridgeAgentImp::GetBottomFlangeCount(const CGirderKey& girderKey) const
{
   VALIDATE( BRIDGE );

   pgsPointOfInterest poi = GetPointOfInterest(CSegmentKey(girderKey, 0), 0.0);  // use a real poi so GetGirderSection draws from a cache instead of creating a new girder section
   ATLASSERT(poi.GetID() != INVALID_ID);

   CComPtr<IGirderSection> girder_section;
   HRESULT hr = GetGirderSection(poi, &girder_section);
   ATLASSERT(SUCCEEDED(hr));
   if (FAILED(hr))
   {
      return 0;
   }

   FlangeIndexType nFlanges;
   girder_section->get_BottomFlangeCount(&nFlanges);
   return nFlanges;
}

Float64 CBridgeAgentImp::GetBottomFlangeLocation(const pgsPointOfInterest& poi,FlangeIndexType flangeIdx) const
{
   VALIDATE( BRIDGE );

   CComPtr<IGirderSection> girder_section;
   HRESULT hr = GetGirderSection(poi, &girder_section);
   ATLASSERT(SUCCEEDED(hr));
   if (FAILED(hr))
   {
      return 0;
   }

   Float64 location;
   girder_section->get_BottomFlangeLocation(flangeIdx,&location);
   return location;
}

Float64 CBridgeAgentImp::GetBottomFlangeWidth(const pgsPointOfInterest& poi,FlangeIndexType flangeIdx) const
{
   VALIDATE( BRIDGE );

   CComPtr<IGirderSection> girder_section;
   HRESULT hr = GetGirderSection(poi, &girder_section);
   ATLASSERT(SUCCEEDED(hr));
   if (FAILED(hr))
   {
      return 0;
   }

   Float64 width;
   girder_section->get_BottomFlangeWidth(flangeIdx,&width);
   return width;
}

Float64 CBridgeAgentImp::GetBottomFlangeThickness(const pgsPointOfInterest& poi,FlangeIndexType flangeIdx) const
{
   VALIDATE( BRIDGE );

   CComPtr<IGirderSection> girder_section;
   HRESULT hr = GetGirderSection(poi, &girder_section);
   ATLASSERT(SUCCEEDED(hr));
   if (FAILED(hr))
   {
      return 0;
   }

   Float64 thickness;
   girder_section->get_BottomFlangeThickness(flangeIdx,&thickness);
   return thickness;
}

Float64 CBridgeAgentImp::GetBottomFlangeSpacing(const pgsPointOfInterest& poi,FlangeIndexType flangeIdx) const
{
   VALIDATE( BRIDGE );

   CComPtr<IGirderSection> girder_section;
   HRESULT hr = GetGirderSection(poi, &girder_section);
   ATLASSERT(SUCCEEDED(hr));
   if (FAILED(hr))
   {
      return 0;
   }

   Float64 spacing;
   girder_section->get_BottomFlangeSpacing(flangeIdx,&spacing);
   return spacing;
}

Float64 CBridgeAgentImp::GetBottomFlangeWidth(const pgsPointOfInterest& poi) const
{
   VALIDATE( BRIDGE );

   CComPtr<IGirderSection> girder_section;
   HRESULT hr = GetGirderSection(poi, &girder_section);
   ATLASSERT(SUCCEEDED(hr));
   if (FAILED(hr))
   {
      return 0;
   }

   Float64 width = 0;
   FlangeIndexType nFlanges;
   girder_section->get_BottomFlangeCount(&nFlanges);
   for ( FlangeIndexType idx = 0; idx < nFlanges; idx++ )
   {
      Float64 w;
      girder_section->get_BottomFlangeWidth(idx,&w);
      width += w;
   }

   return width;
}

Float64 CBridgeAgentImp::GetBottomWidth(const pgsPointOfInterest& poi, Float64* pLeft, Float64* pRight) const
{
   VALIDATE( BRIDGE );

   CComPtr<IGirderSection> girder_section;
   HRESULT hr = GetGirderSection(poi, &girder_section);
   ATLASSERT(SUCCEEDED(hr));
   if (FAILED(hr))
   {
      return 0;
   }

   Float64 wleft, wright;
   girder_section->get_BottomWidth(&wleft, &wright);

   if (pLeft != nullptr && pRight != nullptr)
   {
      *pLeft = wleft;
      *pRight = wright;
   }

   return wleft + wright;
}

Float64 CBridgeAgentImp::GetMinWebWidth(const pgsPointOfInterest& poi) const
{
   VALIDATE( BRIDGE );

   CComPtr<IGirderSection> girder_section;
   HRESULT hr = GetGirderSection(poi, &girder_section);
   ATLASSERT(SUCCEEDED(hr));
   if (FAILED(hr))
   {
      return 0;
   }

   Float64 width;
   girder_section->get_MinWebThickness(&width);

   return width;
}

Float64 CBridgeAgentImp::GetWebThicknessAtDuct(const pgsPointOfInterest& poi,DuctIndexType ductIdx) const
{
   // Use a better implementation
   return GetMinWebWidth(poi); // this is good enough for now, but there is a better way to do this

   // If we have a 3D solid model in WBFLGenericBridge we could cut a section at this poi and then
   // shoot a line across the section at the duct level (line-shape intersection). The points on the
   // intersecting line define the width of the member at the level of the duct.
   // This would be a more general implementation and would cut down on the requirements of IBeamFactory
}

Float64 CBridgeAgentImp::GetMinTopFlangeThickness(const pgsPointOfInterest& poi) const
{
   VALIDATE( BRIDGE );

   CComPtr<IGirderSection> girder_section;
   HRESULT hr = GetGirderSection(poi, &girder_section);
   ATLASSERT(SUCCEEDED(hr));
   if (FAILED(hr))
   {
      return 0;
   }

   Float64 ttf;
   girder_section->get_MinTopFlangeThickness(&ttf);
   return ttf;
}

Float64 CBridgeAgentImp::GetMinBottomFlangeThickness(const pgsPointOfInterest& poi) const
{
   VALIDATE( BRIDGE );

   CComPtr<IGirderSection> girder_section;
   HRESULT hr = GetGirderSection(poi, &girder_section);
   ATLASSERT(SUCCEEDED(hr));
   if (FAILED(hr))
   {
      return 0;
   }

   Float64 tbf;
   girder_section->get_MinBottomFlangeThickness(&tbf);
   return tbf;
}

Float64 CBridgeAgentImp::GetHeight(const pgsPointOfInterest& poi) const
{
   VALIDATE( BRIDGE );

   CComPtr<IGirderSection> girder_section;
   HRESULT hr = GetGirderSection(poi, &girder_section);
   ATLASSERT(SUCCEEDED(hr));
   if (FAILED(hr))
   {
      return 0;
   }

   Float64 height;
   girder_section->get_NominalHeight(&height);

   return height;
}

Float64 CBridgeAgentImp::GetShearWidth(const pgsPointOfInterest& poi) const
{
   VALIDATE( BRIDGE );

   CComPtr<IGirderSection> girder_section;
   HRESULT hr = GetGirderSection(poi, &girder_section);
   ATLASSERT(SUCCEEDED(hr));
   if (FAILED(hr))
   {
      return 0;
   }

   Float64 shear_width;
   girder_section->get_ShearWidth(&shear_width);

   const CSegmentKey& segmentKey(poi.GetSegmentKey());
   CGirderKey girderKey(segmentKey);

   DuctIndexType nGirderDucts = GetDuctCount(girderKey);
   DuctIndexType nSegmentDucts = GetDuctCount(segmentKey);

   if ( (nGirderDucts + nSegmentDucts) == 0 )
   {
      // No ducts... don't have to make an adjustment.... leave now and
      // skip all work below
      return shear_width;
   }

   // Deduct for duct diameter. See LRFD C5.7.2.8 and 5.7.2.8 (pre2017: 5.8.2.9 and C5.8.2.9)
   // the method for determining if the shear width should be adjusted for the presense
   // of a duct, and the amount of duct to reduce the shear width, changed in LRFD 2nd Edition, 2000 interims
   //
   IntervalIndexType intervalIdx = GetIntervalCount() - 1;

   GET_IFACE(IShearCapacity,pShearCapacity);
   pgsTypes::FaceType tensionSide = pShearCapacity->GetFlexuralTensionSide(pgsTypes::StrengthI,intervalIdx,poi);

   GET_IFACE(ILibrary,pLib);
   GET_IFACE(ISpecification,pSpec);
   const SpecLibraryEntry* pSpecEntry = pLib->GetSpecEntry( pSpec->GetSpecification().c_str() );
   bool bAfter2000 = ( lrfdVersionMgr::SecondEditionWith2000Interims <= pSpecEntry->GetSpecificationType() ? true : false );

   // Limits of deduction for ducts is between the tensile and compression resultant
   // (limit is within dv for LRFD before 2000... see below)

   // get moment capacity details
   GET_IFACE(IMomentCapacity,pMomentCapacity);
   const MOMENTCAPACITYDETAILS* pCapDet = pMomentCapacity->GetMomentCapacityDetails(intervalIdx, poi, tensionSide == pgsTypes::BottomFace ? true : false);

   Float64 struct_slab_h = GetStructuralSlabDepth(poi);
   Float64 Ytop = struct_slab_h - pCapDet->dc; // compression resultant (from top of bare girder in Girder Section Coordinates)
   Float64 Ybot = struct_slab_h - pCapDet->de; // tension resultant (from top of bare girder in Girder Section Coordinates)

   if ( !bAfter2000 )
   {
      // before LRFD 2000, duct had to be within dv

      // determine top and bottom of "dv"
      // we have to compute dv here otherwise we get recursion with the shear capacity engineer
      Float64 de = pCapDet->de_shear; // see PCI BDM 8.4.1.2
      Float64 MomentArm = pCapDet->MomentArm;

      Float64 h = GetHeight(poi) + struct_slab_h;

      // lrfd 5.7.2.6 (pre2017: 5.8.2.7)
      Float64 dv1 = MomentArm;
      Float64 dv2 = 0.9*de;
      Float64 dv3 = 0.72*h;

      // assume dv1 controls. Ytop and Ybot are based on the moment arm (moment arm = de - dc)
      IndexType i = MaxIndex(dv1,dv2,dv3);
      if ( i == 1 || i == 2 )
      {
         // dv = moment arm does not control...

         Float64 Ymid = 0.5*(Ytop+Ybot); // assume middle of depth "dv" is at a fixed location
         if ( i == 1 )
         {
            // 0.9de controls
            Ytop = Ymid + dv2/2;
            Ybot = Ymid - dv2/2;
         }
         else
         {
            // 0.72h controls
            Ytop = Ymid + dv3/2;
            Ybot = Ymid - dv3/2;
         }
      }
   }

   Float64 duct_deduction = 0;
   if ( IsOnGirder(poi) && 0 < nGirderDucts)
   {
      GET_IFACE_NOCHECK(IDuctLimits, pDuctLimits);
      GET_IFACE(IGirderTendonGeometry, pGirderTendonGeom);
      for (DuctIndexType ductIdx = 0; ductIdx < nGirderDucts; ductIdx++)
      {
         if (pGirderTendonGeom->IsOnDuct(poi, ductIdx))
         {
            CComPtr<IPoint2d> point;
            GetGirderDuctPoint(poi, ductIdx, &point); // in Girder Section Coordinates
            Float64 y;
            point->get_Y(&y);

            if (::InRange(Ybot, y, Ytop))
            {
               Float64 deduct_factor = pDuctLimits->GetGirderDuctDeductionFactor(girderKey, ductIdx, intervalIdx);
               Float64 dia = GetOutsideDiameter(girderKey, ductIdx);
               duct_deduction = Max(duct_deduction, deduct_factor*dia);
            }
         }
      }

      if (IsOnSegment(poi))
      {
         GET_IFACE(ISegmentTendonGeometry, pSegmentTendonGeometry);
         if (pSegmentTendonGeometry->IsOnDuct(poi))
         {
            // assumes ducts are grouted and cured in the interval following their installation and stressing
            Float64 deduct_factor = pDuctLimits->GetSegmentDuctDeductionFactor(segmentKey, intervalIdx);

            for (DuctIndexType ductIdx = 0; ductIdx < nSegmentDucts; ductIdx++)
            {
               CComPtr<IPoint2d> point;
               GetSegmentDuctPoint(poi, ductIdx, &point); // in Girder Section Coordinates
               Float64 y;
               point->get_Y(&y);

               if (::InRange(Ybot, y, Ytop))
               {
                  Float64 dia = GetOutsideDiameter(segmentKey, ductIdx);
                  duct_deduction = Max(duct_deduction, deduct_factor*dia);
               }
            }
         }
      }
   }

   shear_width -= duct_deduction;

   return shear_width;
}

Float64 CBridgeAgentImp::GetShearInterfaceWidth(const pgsPointOfInterest& poi) const
{
   auto details = GetInterfaceShearWidthDetails(poi);
   return details.bvi;
}

InterfaceShearWidthDetails CBridgeAgentImp::GetInterfaceShearWidthDetails(const pgsPointOfInterest& poi) const
{
   VALIDATE( BRIDGE );

   InterfaceShearWidthDetails details;

   GET_IFACE(IBridgeDescription,pIBridgeDesc);
   const CBridgeDescription2* pBridgeDesc = pIBridgeDesc->GetBridgeDescription();
   const CDeckDescription2* pDeck = pBridgeDesc->GetDeckDescription();

   if (IsNonstructuralDeck(pDeck->GetDeckType()))
   {
      // the deck isn't structural so there isn't any interface shear resistance
      return details;
   }

   CComPtr<IGirderSection> girder_section;
   HRESULT hr = GetGirderSection(poi, &girder_section);
   ATLASSERT(SUCCEEDED(hr));
   if (FAILED(hr))
   {
      return details;
   }

   const CSegmentKey& segmentKey = poi.GetSegmentKey();

   // sum all the mating surface widths
   MatingSurfaceIndexType nMatingSurfaces = GetMatingSurfaceCount(segmentKey);
   for (MatingSurfaceIndexType i = 0; i < nMatingSurfaces; i++)
   {
      details.wMating += GetMatingSurfaceWidth(poi, i);
   }
   details.bvi = details.wMating;

   const GirderLibraryEntry* pGirderEntry = GetGirderLibraryEntry(segmentKey);
   Float64 bvir = pGirderEntry->GetInterfaceShearWidthReduction(); // this is the total reduction

   if (pDeck->GetDeckType() == pgsTypes::sdtCompositeSIP)
   {
      // SIP Deck Panel System... Area beneath the deck panels aren't part of the
      // shear transfer area
      Float64 panel_support = pDeck->PanelSupport;

      CComPtr<ISuperstructureMember> ssMbr;
      GetSuperstructureMember(segmentKey, &ssMbr);
      LocationType locationType;
      ssMbr->get_LocationType(&locationType);

      if (locationType == ltLeftExteriorGirder || locationType == ltRightExteriorGirder)
      {
         // For exterior girders, the panel is only on the interior side of the beam
         details.nMatingSurfaces = (2 * nMatingSurfaces - 1);
         details.wPanel = details.nMatingSurfaces * panel_support;
         details.wReduction = bvir / 2; // apply only half the reduction for the exterior side of the beam only
      }
      else
      {
         details.nMatingSurfaces = 2 * nMatingSurfaces;
         details.wPanel = details.nMatingSurfaces * panel_support;
         details.wReduction = 0; // bvi reduction isn't applied to interior girders when SIP deck panels are used
      }
      details.bvi -= details.wPanel + details.wReduction;
   }
   else
   {
      details.wReduction = bvir;
      details.bvi -= details.wReduction;
   }


   if ( details.bvi < 0 )
   {
      details.bvi = 0;

      CString strMsg;
      strMsg.Format(_T("%s, The interface shear width is a negative value after applying interface shear width reductions. An interface shear width of 0.0 will be used"),GIRDER_LABEL(segmentKey));

      std::unique_ptr<pgsBridgeDescriptionStatusItem> pStatusItem = std::make_unique<pgsBridgeDescriptionStatusItem>(m_StatusGroupID,m_scidBridgeDescriptionWarning,pgsBridgeDescriptionStatusItem::Deck,strMsg);

      GET_IFACE(IEAFStatusCenter,pStatusCenter);
      pStatusCenter->Add(pStatusItem.release());

   }

   return details;
}

WebIndexType CBridgeAgentImp::GetWebCount(const CGirderKey& girderKey) const
{
   VALIDATE( BRIDGE );

   pgsPointOfInterest poi = GetPointOfInterest(CSegmentKey(girderKey, 0), 0.0);
   ATLASSERT(poi.GetID() != INVALID_ID);

   CComPtr<IGirderSection> girder_section;
   HRESULT hr = GetGirderSection(poi, &girder_section);
   ATLASSERT(SUCCEEDED(hr));
   if (FAILED(hr))
   {
      return 0;
   }

   WebIndexType count;
   girder_section->get_WebCount(&count);

   return count;
}

Float64 CBridgeAgentImp::GetWebLocation(const pgsPointOfInterest& poi,WebIndexType webIdx) const
{
   VALIDATE( BRIDGE );

   CComPtr<IGirderSection> girder_section;
   HRESULT hr = GetGirderSection(poi, &girder_section);
   ATLASSERT(SUCCEEDED(hr));
   if (FAILED(hr))
   {
      return 0;
   }

   Float64 location;
   girder_section->get_WebLocation(webIdx,&location);
   
   return location;
}

Float64 CBridgeAgentImp::GetWebSpacing(const pgsPointOfInterest& poi,WebIndexType spaceIdx) const
{
   VALIDATE( BRIDGE );

   CComPtr<IGirderSection> girder_section;
   HRESULT hr = GetGirderSection(poi, &girder_section);
   ATLASSERT(SUCCEEDED(hr));
   if (FAILED(hr))
   {
      return 0;
   }

   Float64 spacing;
   girder_section->get_WebSpacing(spaceIdx,&spacing);

   return spacing;
}

Float64 CBridgeAgentImp::GetWebThickness(const pgsPointOfInterest& poi,WebIndexType webIdx) const
{
   VALIDATE( BRIDGE );

   CComPtr<IGirderSection> girder_section;
   HRESULT hr = GetGirderSection(poi, &girder_section);
   ATLASSERT(SUCCEEDED(hr));
   if (FAILED(hr))
   {
      return 0;
   }

   Float64 thickness;
   girder_section->get_WebThickness(webIdx,&thickness);
   
   return thickness;
}

Float64 CBridgeAgentImp::GetCL2ExteriorWebDistance(const pgsPointOfInterest& poi) const
{
   VALIDATE( BRIDGE );

   const CSegmentKey& segmentKey = poi.GetSegmentKey();

   CComPtr<IGirderSection> girder_section;
   HRESULT hr = GetGirderSection(poi, &girder_section);
   ATLASSERT(SUCCEEDED(hr));
   if (FAILED(hr))
   {
      return 0;
   }

   GET_IFACE(IBarriers,         pBarriers);
   pgsTypes::TrafficBarrierOrientation side = pBarriers->GetNearestBarrier(segmentKey);
   DirectionType dtside = (side==pgsTypes::tboLeft) ? qcbLeft : qcbRight;

   Float64 dist;
   girder_section->get_CL2ExteriorWebDistance(dtside, &dist);

   return dist;
}

Float64 CBridgeAgentImp::GetWebWidth(const pgsPointOfInterest& poi) const
{
   VALIDATE( BRIDGE );

   CComPtr<IGirderSection> girder_section;
   HRESULT hr = GetGirderSection(poi, &girder_section);
   ATLASSERT(SUCCEEDED(hr));
   if (FAILED(hr))
   {
      return 0;
   }

   Float64 shear_width;
   girder_section->get_ShearWidth(&shear_width);

   return shear_width;
}

Float64 CBridgeAgentImp::GetOrientation(const CSegmentKey& segmentKey) const
{
   ValidateSegmentOrientation(segmentKey);

   CComPtr<ISuperstructureMemberSegment> segment;
   GetSegment(segmentKey,&segment);

   Float64 orientation;
   segment->get_Orientation(&orientation);

   return orientation;
}

Float64 CBridgeAgentImp::GetWorkPointShiftOffset(const CSegmentKey& segmentKey) const
{
   VALIDATE_POINTS_OF_INTEREST(segmentKey); // calls VALIDATE(GIRDER);

   // Orientation was cached by geometry model builder
   Float64 shift = 0.0;
   auto found = m_GirderOrientationCollection.find(segmentKey);
   if (found != m_GirderOrientationCollection.end())
   {
      shift = found->second.m_LayoutLineShift;
   }
   else
   {
      ATLASSERT(0); // should never happen
   }

   return shift;
}

Float64 CBridgeAgentImp::GetTransverseTopFlangeSlope(const CSegmentKey& segmentKey) const
{
   CComPtr<ISuperstructureMemberSegment> segment;
   GetSegment(segmentKey, &segment);

   Float64 topFlangeSlope;
   CComQIPtr<IThickenedFlangeSegment> tfSegment(segment);
   if (tfSegment)
   {
      tfSegment->get_TopFlangeSlope(&topFlangeSlope);
      topFlangeSlope *= -1; // girder top flange slopes are different than roadway slopes... make an adjustment
   }
   else
   {
      topFlangeSlope = GetOrientation(segmentKey);
   }

   return topFlangeSlope;
}

Float64 CBridgeAgentImp::GetProfileChordElevation(const pgsPointOfInterest& poi) const
{
   // elevation profile chord is a reference chord that connects the
   // top of deck elevation at the CL Bearings at each end of the segment
   const CSegmentKey& segmentKey = poi.GetSegmentKey();

   CComPtr<IPoint2d> pntPier1, pntEnd1, pntBrg1, pntBrg2, pntEnd2, pntPier2;
   GetSegmentEndPoints(segmentKey, pgsTypes::pcLocal, &pntPier1, &pntEnd1, &pntBrg1, &pntBrg2, &pntEnd2, &pntPier2);

   // get the elevation at the CL Bearing points
   Float64 startStation, startOffset;
   GetStationAndOffset(pgsTypes::pcLocal, pntBrg1, &startStation, &startOffset);

   Float64 endStation, endOffset;
   GetStationAndOffset(pgsTypes::pcLocal, pntBrg2, &endStation, &endOffset);

   Float64 startElevation = GetElevation(startStation, startOffset);
   Float64 endElevation = GetElevation(endStation, endOffset);

   // distance between two points where elevation is computed
   Float64 distance;
   pntBrg1->DistanceEx(pntBrg2, &distance);

   // distance from the start elevation point to the poi
   CComPtr<IPoint2d> pntPoi;
   GetPoint(poi, pgsTypes::pcLocal, &pntPoi);
   Float64 X;
   pntBrg1->DistanceEx(pntPoi,&X);

   // chord is a straight line so use linear interpolation
   Float64 yc = ::LinInterp(X, startElevation, endElevation, distance);

   return yc;
}

Float64 CBridgeAgentImp::GetTopGirderChordElevation(const pgsPointOfInterest& poi) const
{
   VALIDATE(BRIDGE);

   const CSegmentKey& segmentKey = poi.GetSegmentKey();
   const auto& fn = GetGirderTopChordElevationFunction(segmentKey);
   Float64 Xpoi = poi.GetDistFromStart();
   return fn.Evaluate(Xpoi);
}

Float64 CBridgeAgentImp::GetTopGirderChordElevation(const pgsPointOfInterest& poi, Float64 Astart, Float64 Aend) const
{
   // THIS METHOD IS FOR DESIGN CASES... 
   // that means this is for PGSuper only (we don't have design for PGSplice)
#if defined _DEBUG
   // this is a weak but quick and dirty check... more general checks are made below
   GET_IFACE(IDocumentType, pDocType);
   ATLASSERT(pDocType->IsPGSuperDocument());
#endif

   // elevation of the top of girder reference chord
   // the reference chord is a straight line along to the top of the undeformed girder
   // the provided "A" dimensions are used at the start and end CL Bearing locations
   // instead of the values in the bridge model (this is a design case)
   const CSegmentKey& segmentKey = poi.GetSegmentKey();

   GET_IFACE(IBridgeDescription, pIBridgeDesc);
   const CPrecastSegmentData* pSegment = pIBridgeDesc->GetPrecastSegmentData(segmentKey);
   const CSplicedGirderData* pGirder = pSegment->GetGirder();

   ATLASSERT(pGirder->GetSegmentCount() == 1); // should be only one segment per girder for a PGSuper model
   // the group is one span long
   ATLASSERT(pGirder->GetGirderGroup()->GetPier(pgsTypes::metStart)->GetSpan(pgsTypes::Ahead) == pGirder->GetGirderGroup()->GetPier(pgsTypes::metEnd)->GetSpan(pgsTypes::Back));
#if defined
   auto vTS = pGirder->GetGirderGroup()->GetPier(pgsTypes::metStart)->GetSpan(pgsTypes::Ahead)->GetTemporarySupports();
   ATLASSERT(vTS.size() == 0); // no temporary supports in PGSuper models
#endif

   CSegmentKey startSegmentKey(segmentKey);
   startSegmentKey.segmentIndex = 0;

   CComPtr<IPoint2d> pntPier1, pntEnd1, pntBrg1, pntBrg2, pntEnd2, pntPier2;
   GetSegmentEndPoints(startSegmentKey,pgsTypes::pcLocal,&pntPier1,&pntEnd1,&pntBrg1,&pntBrg2,&pntEnd2,&pntPier2);

   CSegmentKey endSegmentKey(segmentKey);
   SegmentIndexType nSegments = pGirder->GetSegmentCount();
   endSegmentKey.segmentIndex = nSegments-1;

   CComPtr<IPoint2d> pntPier3, pntEnd3, pntBrg3, pntBrg4, pntEnd4, pntPier4;
   GetSegmentEndPoints(endSegmentKey, pgsTypes::pcLocal, &pntPier3, &pntEnd3, &pntBrg3, &pntBrg4, &pntEnd4, &pntPier4);

   Float64 startStation, startOffset;
   GetStationAndOffset(pgsTypes::pcLocal,pntBrg1,&startStation,&startOffset);

   Float64 endStation, endOffset;
   GetStationAndOffset(pgsTypes::pcLocal,pntBrg4,&endStation,&endOffset);

   Float64 startElevation = GetElevation(startStation,startOffset);
   Float64 endElevation   = GetElevation(endStation,  endOffset);

   // overlay is measured at the GCE. If it exists prior to the GCE, then it's included in the chord elev
   IntervalIndexType gceInterval = GetGeometryControlInterval();
   Float64 overlayDepth = GetOverlayDepth(gceInterval);

   Float64 length;
   pntBrg1->DistanceEx(pntBrg4,&length);

   Float64 Xg = ConvertPoiToGirderCoordinate(poi);
   Float64 end_dist = GetSegmentStartEndDistance(startSegmentKey);

   Float64 yc = ::LinInterp(Xg-end_dist,startElevation-Astart-overlayDepth, endElevation-Aend-overlayDepth,length);

   return yc;
}

bool CBridgeAgentImp::CanPrecamber(const CSegmentKey& segmentKey) const
{
   const GirderLibraryEntry* pGirderEntry = GetGirderLibraryEntry(segmentKey);

   CComPtr<IBeamFactory> beamFactory;
   pGirderEntry->GetBeamFactory(&beamFactory);

   return beamFactory->CanPrecamber();
}

Float64 CBridgeAgentImp::GetPrecamber(const CSegmentKey& segmentKey) const
{
   GET_IFACE(IBridgeDescription, pIBridgeDesc);
   const CPrecastSegmentData* pSegment = pIBridgeDesc->GetPrecastSegmentData(segmentKey);
   return pSegment->Precamber;
}

Float64 CBridgeAgentImp::GetPrecamber(const pgsPointOfInterest& poi) const
{
   const CSegmentKey& segmentKey(poi.GetSegmentKey());
   Float64 precamber = GetPrecamber(segmentKey);
   Float64 Xpoi = poi.GetDistFromStart();
   Float64 Ls = (const_cast<CBridgeAgentImp*>(this))->GetSegmentLength(segmentKey);
   Float64 Ypre = ::ComputePrecamber(Xpoi,Ls,precamber);
   return Ypre;
}

Float64 CBridgeAgentImp::GetPrecamber(IntervalIndexType intervalIdx, const pgsPointOfInterest& poi) const
{
   const CSegmentKey& segmentKey(poi.GetSegmentKey());
   IntervalIndexType liftingIntervalIdx = (const_cast<CBridgeAgentImp*>(this))->GetLiftSegmentInterval(segmentKey);
   IntervalIndexType storageIntervalIdx = (const_cast<CBridgeAgentImp*>(this))->GetStorageInterval(segmentKey);
   IntervalIndexType haulingIntervalIdx = (const_cast<CBridgeAgentImp*>(this))->GetHaulSegmentInterval(segmentKey);
   IntervalIndexType erectionIntervalIdx = (const_cast<CBridgeAgentImp*>(this))->GetErectSegmentInterval(segmentKey);

   Float64 supportAdjustment = 0;
   if (liftingIntervalIdx <= intervalIdx)
   {
      PoiAttributeType supportAttribute;

      if (liftingIntervalIdx <= intervalIdx && intervalIdx < storageIntervalIdx)
      {
         supportAttribute = POI_LIFT_SEGMENT;
      }
      else if (storageIntervalIdx <= intervalIdx && intervalIdx < haulingIntervalIdx)
      {
         supportAttribute = POI_STORAGE_SEGMENT;
      }
      else if (haulingIntervalIdx <= intervalIdx && intervalIdx < erectionIntervalIdx)
      {
         supportAttribute = POI_HAUL_SEGMENT;
      }
      else
      {
         ATLASSERT(erectionIntervalIdx <= intervalIdx);
         supportAttribute = POI_ERECTED_SEGMENT;
      }

      PoiList vPoi;
      GetPointsOfInterest(segmentKey, POI_0L | POI_10L | supportAttribute,&vPoi);
      ATLASSERT(vPoi.size() == 2);
      Float64 pc1 = GetPrecamber(vPoi.front());
      Float64 pc2 = GetPrecamber(vPoi.back());
      Float64 Ls = (const_cast<CBridgeAgentImp*>(this))->GetSegmentLength(segmentKey);

      supportAdjustment = LinInterp(poi.GetDistFromStart(), pc1, pc2, Ls);
   }

   return GetPrecamber(poi) + supportAdjustment;
}

Float64 CBridgeAgentImp::GetPrecamber(const CPrecastSegmentData* pSegment, Float64 Xs) const
{
   const CSegmentKey& segmentKey(pSegment->GetSegmentKey());
   Float64 precamber = pSegment->Precamber;
   Float64 Ls = (const_cast<CBridgeAgentImp*>(this))->GetSegmentLength(segmentKey);
   Float64 Ypre = ::ComputePrecamber(Xs,Ls,precamber);
   return Ypre;
}

Float64 CBridgeAgentImp::GetPrecamberSlope(const pgsPointOfInterest& poi) const
{
   const CSegmentKey& segmentKey(poi.GetSegmentKey());
   Float64 precamber = GetPrecamber(segmentKey);
   Float64 Xpoi = poi.GetDistFromStart();
   Float64 Ls = (const_cast<CBridgeAgentImp*>(this))->GetSegmentLength(segmentKey);
   Float64 Rpre = (4 * precamber / Ls)*(1 - 2*Xpoi / Ls);
   return Rpre;
}

bool CBridgeAgentImp::HasShearKey(const CGirderKey& girderKey,pgsTypes::SupportedBeamSpacing spacingType) const
{
   const GirderLibraryEntry* pGirderEntry = GetGirderLibraryEntry(girderKey);
   CComPtr<IBeamFactory> beamFactory;
   pGirderEntry->GetBeamFactory(&beamFactory);

   return beamFactory->IsShearKey(pGirderEntry->GetDimensions(), spacingType);
}

void CBridgeAgentImp::GetShearKeyAreas(const CGirderKey& girderKey,pgsTypes::SupportedBeamSpacing spacingType,Float64* uniformArea, Float64* areaPerJoint) const
{
   const GirderLibraryEntry* pGirderEntry = GetGirderLibraryEntry(girderKey);
   CComPtr<IBeamFactory> beamFactory;
   pGirderEntry->GetBeamFactory(&beamFactory);

   beamFactory->GetShearKeyAreas(pGirderEntry->GetDimensions(), spacingType, uniformArea, areaPerJoint);
}

bool CBridgeAgentImp::HasStructuralLongitudinalJoints() const
{
   GET_IFACE(IBridgeDescription, pIBridgeDesc);
   const CBridgeDescription2* pBridgeDesc = pIBridgeDesc->GetBridgeDescription();
   return pBridgeDesc->HasStructuralLongitudinalJoints();
}

Float64 CBridgeAgentImp::GetStructuralLongitudinalJointWidth(const pgsPointOfInterest& poi) const
{
   Float64 left, right;
   GetStructuralLongitudinalJointWidth(poi, &left, &right);
   return left + right;
}

void CBridgeAgentImp::GetStructuralLongitudinalJointWidth(const pgsPointOfInterest& poi, Float64* pLeft, Float64* pRight) const
{
   if (HasStructuralLongitudinalJoints())
   {
      GetSpacingAlongGirder(poi, pLeft, pRight);

      Float64 top_width = GetTopWidth(poi);

      const CSegmentKey& segmentKey = poi.GetSegmentKey();
      Float64 left_top_width, right_top_width;
      if (0 < segmentKey.girderIndex)
      {
         pgsPointOfInterest leftPoi(GetPointOfInterest(CSegmentKey(segmentKey.groupIndex, segmentKey.girderIndex - 1, segmentKey.segmentIndex), poi.GetDistFromStart()));
         left_top_width = GetTopWidth(leftPoi);
         *pLeft -= (left_top_width + top_width) / 2;
      }
#if defined _DEBUG
      else
      {
         ATLASSERT(IsZero(*pLeft));
      }
#endif

      GirderIndexType nGirders = GetGirderCount(segmentKey.groupIndex);
      if (segmentKey.girderIndex < nGirders - 1)
      {
         pgsPointOfInterest rightPoi(GetPointOfInterest(CSegmentKey(segmentKey.groupIndex, segmentKey.girderIndex + 1, segmentKey.segmentIndex), poi.GetDistFromStart()));
         right_top_width = GetTopWidth(rightPoi);
         *pRight -= (right_top_width + top_width) / 2;
      }
#if defined _DEBUG
      else
      {
         ATLASSERT(IsZero(*pRight));
      }
#endif
   }
   else
   {
      *pLeft = 0;
      *pRight = 0;
   }
}

void CBridgeAgentImp::GetSegmentEndPoints(const CSegmentKey& segmentKey,pgsTypes::PlanCoordinateType pcType,IPoint2d** ppSupport1,IPoint2d** ppEnd1,IPoint2d** ppBrg1,IPoint2d** ppBrg2,IPoint2d** ppEnd2,IPoint2d** ppSupport2) const
{
   CComPtr<IGirderLine> girderLine;
   GetGirderLine(segmentKey,&girderLine);
   girderLine->GetEndPoints(ppSupport1,ppEnd1,ppBrg1,ppBrg2,ppEnd2,ppSupport2);

   if ( pcType == pgsTypes::pcGlobal )
   {
      (*ppSupport1)->Offset(m_DeltaX,m_DeltaY);
      (*ppEnd1)->Offset(m_DeltaX,m_DeltaY);
      (*ppBrg1)->Offset(m_DeltaX,m_DeltaY);
      (*ppBrg2)->Offset(m_DeltaX,m_DeltaY);
      (*ppEnd2)->Offset(m_DeltaX,m_DeltaY);
      (*ppSupport2)->Offset(m_DeltaX,m_DeltaY);
   }
}

void CBridgeAgentImp::GetSegmentPlanPoints(const CSegmentKey& segmentKey, pgsTypes::PlanCoordinateType pcType, IPoint2d** ppEnd1Left, IPoint2d** ppEnd1, IPoint2d** ppEnd1Right, IPoint2d** ppEnd2Right, IPoint2d** ppEnd2, IPoint2d** ppEnd2Left) const
{
   CComPtr<IPoint2d> pntSupport1, pntEnd1, pntBrg1, pntBrg2, pntEnd2, pntSupport2;
   GetSegmentEndPoints(segmentKey, pcType, &pntSupport1, &pntEnd1, &pntBrg1, &pntBrg2, &pntEnd2, &pntSupport2);

   CComPtr<IPierLine> startLine, endLine;
   GetSupports(segmentKey, &startLine, &endLine);

   PoiList vPoi;
   GetPointsOfInterest(segmentKey, POI_START_FACE | POI_END_FACE,&vPoi);
   ATLASSERT(vPoi.size() == 2);
   const pgsPointOfInterest& startPoi(vPoi.front());
   const pgsPointOfInterest& endPoi(vPoi.back());

   // use left and right dimensions instead of total top width
   // can't assume girder are symmetric about their centerline (think flared deck girders)
   Float64 startLeft, startRight;
   GetTopWidth(startPoi,&startLeft,&startRight);

   Float64 endLeft, endRight;
   GetTopWidth(endPoi,&endLeft,&endRight);

   CComPtr<IDirection> segmentDirection;
   GetSegmentDirection(segmentKey, &segmentDirection);
   Float64 dirSegment;
   segmentDirection->get_Value(&dirSegment);

   CComPtr<IDirection> startDirection;
   startLine->get_Direction(&startDirection);
   Float64 dirStart;
   startDirection->get_Value(&dirStart);

   CComPtr<IDirection> endDirection;
   endLine->get_Direction(&endDirection);
   Float64 dirEnd;
   endDirection->get_Value(&dirEnd);

   Float64 startLeftOffset = startLeft/ sin(dirStart - dirSegment);
   Float64 startRightOffset = startRight / sin(dirStart - dirSegment);
   Float64 endLeftOffset = endLeft / sin(dirEnd - dirSegment);
   Float64 endRightOffset = endRight / sin(dirEnd - dirSegment);

   ByDistDir(pntEnd1, startLeftOffset, CComVariant(startDirection), 0.0, ppEnd1Left);
   pntEnd1.CopyTo(ppEnd1);
   ByDistDir(pntEnd1, -startRightOffset, CComVariant(startDirection), 0.0, ppEnd1Right);

   ByDistDir(pntEnd2, endLeftOffset, CComVariant(endDirection), 0.0, ppEnd2Left);
   pntEnd2.CopyTo(ppEnd2);
   ByDistDir(pntEnd2, -endRightOffset, CComVariant(endDirection), 0.0, ppEnd2Right);
}

Float64 CBridgeAgentImp::GetSegmentLength(const CSegmentKey& segmentKey) const
{
   // returns the end-to-end length of the segment.
   CComPtr<IGirderLine> girderLine;
   GetGirderLine(segmentKey,&girderLine);

   Float64 length;
   girderLine->get_GirderLength(&length);

   return length;
}

Float64 CBridgeAgentImp::GetSegmentSpanLength(const CSegmentKey& segmentKey) const
{
   // returns the CL-Brg to CL-Brg span length
   CComPtr<IGirderLine> girderLine;
   GetGirderLine(segmentKey,&girderLine);

   Float64 length;
   girderLine->get_SpanLength(&length);

   return length;
}

Float64 CBridgeAgentImp::GetSegmentLayoutLength(const CSegmentKey& segmentKey) const
{
   // Pier to pier length
   CComPtr<IGirderLine> girderLine;
   GetGirderLine(segmentKey,&girderLine);

   Float64 length;
   girderLine->get_LayoutLength(&length);

   return length;
}

Float64 CBridgeAgentImp::GetSegmentFramingLength(const CSegmentKey& segmentKey) const
{
   Float64 segment_framing_length = GetSegmentLayoutLength(segmentKey);

   if ( segmentKey.segmentIndex == 0 )
   {
      Float64 brgOffset = GetSegmentStartBearingOffset(segmentKey);
      Float64 endDist   = GetSegmentStartEndDistance(segmentKey);
      segment_framing_length -= (brgOffset - endDist);
   }
   
   if ( segmentKey.segmentIndex == GetSegmentCount(segmentKey)-1 )
   {
      Float64 brgOffset = GetSegmentEndBearingOffset(segmentKey);
      Float64 endDist   = GetSegmentEndEndDistance(segmentKey);
      segment_framing_length -= (brgOffset - endDist);
   }

   return segment_framing_length;
}

Float64 CBridgeAgentImp::GetSegmentPlanLength(const CSegmentKey& segmentKey) const
{
   // returns the length of the segment adjusted for slope
   Float64 length = GetSegmentLength(segmentKey);
   Float64 slope  = GetSegmentSlope(segmentKey);

   Float64 plan_length = length*sqrt(1.0 + slope*slope);

   return plan_length;
}

Float64 CBridgeAgentImp::GetSegmentSlope(const CSegmentKey& segmentKey) const
{
   const auto& fn = GetGirderTopChordElevationFunction(segmentKey);
   return fn.GetSlope();
}

void CBridgeAgentImp::GetSegmentPlan(const CSegmentKey& segmentKey, IShape** ppShape) const
{
   CComPtr<IPoint2d> pntEnd1Left, pntEnd1, pntEnd1Right, pntEnd2Right, pntEnd2, pntEnd2Left;
   GetSegmentPlanPoints(segmentKey, pgsTypes::pcGlobal, &pntEnd1Left, &pntEnd1, &pntEnd1Right, &pntEnd2Right, &pntEnd2, &pntEnd2Left);

   CComPtr<IPolyShape> polyShape;
   polyShape.CoCreateInstance(CLSID_PolyShape);
   polyShape->AddPointEx(pntEnd1Left);
   polyShape->AddPointEx(pntEnd1);
   polyShape->AddPointEx(pntEnd1Right);


   CComPtr<IPierLine> startLine, endLine;
   GetSupports(segmentKey, &startLine, &endLine);

   CComPtr<IDirection> startDirection;
   startLine->get_Direction(&startDirection);
   Float64 dirStart;
   startDirection->get_Value(&dirStart);

   CComPtr<IDirection> endDirection;
   endLine->get_Direction(&endDirection);
   Float64 dirEnd;
   endDirection->get_Value(&dirEnd);

   CComPtr<IDirection> segmentDirection;
   GetSegmentDirection(segmentKey, &segmentDirection);
   Float64 dirSegment;
   segmentDirection->get_Value(&dirSegment);

   Float64 start_angle = dirStart - dirSegment;
   Float64 end_angle = dirEnd - dirSegment;

   Float64 Ls = GetSegmentLength(segmentKey);

   // Get all the section change transition points
   PoiList vPoi;
   GetPointsOfInterest(segmentKey, POI_SECTCHANGE,&vPoi);
   RemovePointsOfInterest(vPoi, POI_START_FACE, 0);
   RemovePointsOfInterest(vPoi, POI_END_FACE, 0);
   std::vector<CComPtr<IPoint2d>> vLeft; // cache all the points on the left side of the girder
   for (const pgsPointOfInterest& poi : vPoi)
   {
      CComPtr<IPoint2d> pnt;
      GetPoint(poi, pgsTypes::pcGlobal, &pnt);

      Float64 left, right;
      GetTopWidth(poi, &left, &right);

      Float64 angle = ::LinInterp(poi.GetDistFromStart(), start_angle, end_angle, Ls);

      right /= sin(angle);
      left /= sin(angle);

      Float64 dir = dirSegment + angle;

      CComPtr<IPoint2d> pntLeft;
      ByDistDir(pnt, left, CComVariant(dir), 0.0, &pntLeft);
      vLeft.insert(vLeft.begin(), pntLeft);

      CComPtr<IPoint2d> pntRight;
      ByDistDir(pnt, -right, CComVariant(dir), 0.0, &pntRight);
      polyShape->AddPointEx(pntRight);
   }

   polyShape->AddPointEx(pntEnd2Right);
   polyShape->AddPointEx(pntEnd2);
   polyShape->AddPointEx(pntEnd2Left);

   for (const auto& pnt : vLeft)
   {
      polyShape->AddPointEx(pnt);
   }

   CComQIPtr<IShape> shape(polyShape);
   shape.CopyTo(ppShape);
}

void CBridgeAgentImp::GetSegmentProfile(const CSegmentKey& segmentKey,bool bIncludeClosure,IShape** ppShape) const
{
   CComPtr<ISuperstructureMemberSegment> segment;
   GetSegment(segmentKey,&segment);

   segment->get_Profile(bIncludeClosure ? VARIANT_TRUE : VARIANT_FALSE,ppShape);
}

void CBridgeAgentImp::GetSegmentProfile(const CSegmentKey& segmentKey,const CSplicedGirderData* pGirder,bool bIncludeClosure,IShape** ppShape) const
{
   // X-values for start and end of the segment under consideration
   // measured from the intersection of the CL Pier and CL Girder/Segment at
   // the start of the girder
   Float64 xStart,xEnd;
   GetSegmentRange(segmentKey,&xStart,&xEnd); // this is the start/end of the Girder Path Coordinates for this segment

   if ( segmentKey.segmentIndex == 0 )
   {
      // if this is the first segment, adjust the girder path coordinate so that it starts at the face of the segment
      Float64 brgOffset = GetSegmentStartBearingOffset(segmentKey);
      Float64 endDist   = GetSegmentStartEndDistance(segmentKey);
      Float64 offset_dist = brgOffset - endDist;
      offset_dist = IsZero(offset_dist) ? 0 : offset_dist;
      xStart += offset_dist;
   }

   SegmentIndexType nSegments = GetSegmentCount(segmentKey);
   if ( segmentKey.segmentIndex == nSegments-1 )
   {
      // if this is the last segment, adjust the girder path coordinate so that it end at the face of the segment
      Float64 brgOffset = GetSegmentEndBearingOffset(segmentKey);
      Float64 endDist   = GetSegmentEndEndDistance(segmentKey);
      Float64 offset_dist = brgOffset - endDist;
      offset_dist = IsZero(offset_dist) ? 0 : offset_dist;
      xEnd -= offset_dist;
   }

   // Create a function object that models the bottom of the girder
   auto f = CreateGirderProfile(pGirder);
   CComPtr<IPolyShape> polyShape;
   polyShape.CoCreateInstance(CLSID_PolyShape);

   // Determine x values for which we will compute y to create the shape
   std::vector<Float64> xValues;
   xValues.reserve(20);

   const CPrecastSegmentData* pSegment = pGirder->GetSegment(segmentKey.segmentIndex);

   Float64 segmentLength = GetSegmentLayoutLength(segmentKey);

   // if not including closure joint, adjust the start/end locations to be
   // at the actual start/end of the segment
   if ( !bIncludeClosure )
   {
      Float64 startBrgOffset, endBrgOffset;
      GetSegmentBearingOffset(segmentKey,&startBrgOffset,&endBrgOffset);

      Float64 startEndDist, endEndDist;
      GetSegmentEndDistance(segmentKey,&startEndDist,&endEndDist);

      if ( segmentKey.segmentIndex != 0 )
      {
         xStart += startBrgOffset - startEndDist;
      }

      if ( segmentKey.segmentIndex != nSegments-1 )
      {
         xEnd -= endBrgOffset   - endEndDist;
      }
   }

   pgsTypes::SegmentVariationType variationType = pSegment->GetVariationType();
   std::array<Float64, 4> variationLength;
   if (variationType != pgsTypes::svtNone)
   {
      for (int i = 0; i < 4; i++)
      {
         variationLength[i] = pSegment->GetVariationLength((pgsTypes::SegmentZoneType)i);
         if (variationLength[i] < 0)
         {
            ATLASSERT(-1.0 <= variationLength[i] && variationLength[i] <= 0.0);
            variationLength[i] *= -segmentLength;
         }
      }
   }

   // capture key values in segment
   if ( variationType == pgsTypes::svtLinear )
   {
      xValues.push_back(xStart + variationLength[pgsTypes::sztLeftPrismatic] );
      xValues.push_back(xEnd   - variationLength[pgsTypes::sztRightPrismatic] );
   }
   else if ( variationType == pgsTypes::svtParabolic )
   {
      Float64 xStartParabola = xStart + variationLength[pgsTypes::sztLeftPrismatic];
      Float64 xEndParabola   = xEnd   - variationLength[pgsTypes::sztRightPrismatic];
      xValues.push_back(xStartParabola);
      for ( int i = 0; i < 5; i++ )
      {
         Float64 x = i*(xEndParabola-xStartParabola)/5 + xStartParabola;
         xValues.push_back(x);
      }
      xValues.push_back(xEndParabola);
   }
   else if ( variationType == pgsTypes::svtDoubleLinear )
   {
      xValues.push_back(xStart + variationLength[pgsTypes::sztLeftPrismatic] );
      xValues.push_back(xStart + variationLength[pgsTypes::sztLeftPrismatic]  + variationLength[pgsTypes::sztLeftTapered] );
      xValues.push_back(xEnd   - variationLength[pgsTypes::sztRightPrismatic] - variationLength[pgsTypes::sztRightTapered] );
      xValues.push_back(xEnd   - variationLength[pgsTypes::sztRightPrismatic] );
   }
   else if ( variationType == pgsTypes::svtDoubleParabolic )
   {
      // left parabola
      Float64 xStartParabola = xStart + variationLength[pgsTypes::sztLeftPrismatic];
      Float64 xEndParabola   = xStart + variationLength[pgsTypes::sztLeftPrismatic]  + variationLength[pgsTypes::sztLeftTapered];

      xValues.push_back(xStartParabola);
      for ( int i = 0; i < 5; i++ )
      {
         Float64 x = i*(xEndParabola-xStartParabola)/5 + xStartParabola;
         xValues.push_back(x);
      }
      xValues.push_back(xEndParabola);

      // right parabola
      xStartParabola = xEnd   - variationLength[pgsTypes::sztRightPrismatic] - variationLength[pgsTypes::sztRightTapered];
      xEndParabola   = xEnd   - variationLength[pgsTypes::sztRightPrismatic];
      xValues.push_back(xStartParabola);
      for ( int i = 0; i < 5; i++ )
      {
         Float64 x = i*(xEndParabola-xStartParabola)/5 + xStartParabola;
         xValues.push_back(x);
      }
      xValues.push_back(xEndParabola);
   }

   // fill up with other points
   for ( int i = 0; i < 11; i++ )
   {
      Float64 x = i*(xEnd - xStart)/10 + xStart;
      xValues.push_back(x);
   }

   std::sort(xValues.begin(),xValues.end());
   xValues.erase(std::unique(std::begin(xValues), std::end(xValues)), std::end(xValues));

   // working left to right along the bottom of the segment
   for ( auto x : xValues)
   {
      Float64 y = f->Evaluate(x);
      polyShape->AddPoint(x,-y);
   }

   // working right to left across the top of the segment
   if (!IsZero(pSegment->Precamber) || (pSegment->TopFlangeThickeningType != pgsTypes::tftNone && !IsZero(pSegment->TopFlangeThickening)) )
   {
      Float64 thickening = 0.0;
      if (pSegment->TopFlangeThickeningType == pgsTypes::tftEnds)
      {
         thickening = pSegment->TopFlangeThickening;
      }

      polyShape->AddPoint(xEnd, 0);
      PoiList vPoi;
      GetPointsOfInterest(segmentKey, POI_RELEASED_SEGMENT, &vPoi);
      auto iter = std::rbegin(vPoi);
      auto end = std::rend(vPoi);
      for (; iter != end; iter++)
      {
         const pgsPointOfInterest& poi(*iter);
         Float64 Xpoi = poi.GetDistFromStart();
         Float64 precamber = GetPrecamber(pSegment,Xpoi);
         Float64 tft = GetTopFlangeThickening(pSegment,Xpoi);
         Float64 y = precamber + tft - thickening;

         Float64 Xsp = ConvertPoiToSegmentPathCoordinate(poi);
         Float64 Xgp = ConvertSegmentPathCoordinateToGirderPathCoordinate(segmentKey, Xsp);
         polyShape->AddPoint(Xgp, y);
      }
      polyShape->AddPoint(xStart, 0);
   }
   else
   {
      // top is a straight line
      polyShape->AddPoint(xEnd, 0);
      polyShape->AddPoint(xStart, 0);
   }

   polyShape->get_Shape(ppShape);
}

void CBridgeAgentImp::GetClosureJointProfile(const CClosureKey& closureKey, IShape** ppShape) const
{
   GroupIndexType      grpIdx = closureKey.groupIndex;
   GirderIndexType     gdrIdx = closureKey.girderIndex;
   CollectionIndexType closureIdx = closureKey.segmentIndex;

   GET_IFACE(IBridgeDescription, pIBridgeDesc);
   const CBridgeDescription2* pBridgeDesc = pIBridgeDesc->GetBridgeDescription();
   const CGirderGroupData* pGroup = pBridgeDesc->GetGirderGroup(grpIdx);
   const CSplicedGirderData* pGirder = pGroup->GetGirder(gdrIdx);
   const CClosureJointData* pClosureJoint = pGirder->GetClosureJoint(closureIdx);

   const CPrecastSegmentData* pLeftSegment = pClosureJoint->GetLeftSegment();
   SegmentIndexType leftSegIdx = pLeftSegment->GetIndex();

   const CPrecastSegmentData* pRightSegment = pClosureJoint->GetRightSegment();
   SegmentIndexType rightSegIdx = pRightSegment->GetIndex();

   CSegmentKey leftSegmentKey(grpIdx, gdrIdx, leftSegIdx);
   CSegmentKey rightSegmentKey(grpIdx, gdrIdx, rightSegIdx);

   Float64 leftSegStartOffset, leftSegEndOffset;
   GetSegmentEndDistance(leftSegmentKey, &leftSegStartOffset, &leftSegEndOffset);

   Float64 rightSegStartOffset, rightSegEndOffset;
   GetSegmentEndDistance(rightSegmentKey, pGirder, &rightSegStartOffset, &rightSegEndOffset);

   Float64 leftSegStartBrgOffset, leftSegEndBrgOffset;
   GetSegmentBearingOffset(leftSegmentKey, &leftSegStartBrgOffset, &leftSegEndBrgOffset);

   Float64 rightSegStartBrgOffset, rightSegEndBrgOffset;
   GetSegmentBearingOffset(rightSegmentKey, &rightSegStartBrgOffset, &rightSegEndBrgOffset);

   Float64 xLeftStart, xLeftEnd;
   GetSegmentRange(leftSegmentKey, &xLeftStart, &xLeftEnd);

   Float64 xRightStart, xRightEnd;
   GetSegmentRange(rightSegmentKey, &xRightStart, &xRightEnd);

   Float64 xStart = xLeftEnd;
   Float64 xEnd = xRightStart;

   xStart -= (leftSegEndBrgOffset - leftSegEndOffset);
   xEnd += (rightSegStartBrgOffset - rightSegStartOffset);

   auto f = CreateGirderProfile(pGirder);
   CComPtr<IPolyShape> polyShape;
   polyShape.CoCreateInstance(CLSID_PolyShape);

   std::vector<Float64> xValues;

   // fill up with other points
   for (int i = 0; i < 5; i++)
   {
      Float64 x = i*(xEnd - xStart) / 4 + xStart;
      xValues.push_back(x);
   }

   std::sort(xValues.begin(), xValues.end());

   std::vector<Float64>::iterator iter(xValues.begin());
   std::vector<Float64>::iterator end(xValues.end());
   for (; iter != end; iter++)
   {
      Float64 x = *iter;
      Float64 y = f->Evaluate(x);
      polyShape->AddPoint(x, -y);
   }

   // points across the top of the segment
   polyShape->AddPoint(xEnd, 0);
   polyShape->AddPoint(xStart, 0);

   polyShape->get_Shape(ppShape);
}

Float64 CBridgeAgentImp::GetSegmentHeight(const CSegmentKey& segmentKey,const CSplicedGirderData* pSplicedGirder,Float64 Xsp) const
{
   Float64 Xgp = ConvertSegmentPathCoordinateToGirderPathCoordinate(segmentKey,Xsp);
   auto f = CreateGirderProfile(pSplicedGirder); // profile includes precamber effect
   Float64 Y = f->Evaluate(Xgp);

   Float64 Xs = ConvertSegmentPathCoordinateToSegmentCoordinate(segmentKey, Xsp);
   const CPrecastSegmentData* pSegment = pSplicedGirder->GetSegment(segmentKey.segmentIndex);
   Float64 precamber = GetPrecamber(pSegment,Xs); // precamber doesn't change the height of the section, but the profile includes precamber so we have to take it out
   Float64 thickening = GetTopFlangeThickening(pSegment, Xs);

   Y += precamber + thickening;

   return Y;
}

void CBridgeAgentImp::GetSegmentEndDistance(const CSegmentKey& segmentKey,Float64* pStartEndDistance,Float64* pEndEndDistance) const
{
   CComPtr<IGirderLine> girderLine;
   GetGirderLine(segmentKey,&girderLine);

   girderLine->get_EndDistance(etStart,pStartEndDistance);
   girderLine->get_EndDistance(etEnd,  pEndEndDistance);
}

void CBridgeAgentImp::GetSegmentEndDistance(const CSegmentKey& segmentKey,const CSplicedGirderData* pGirder,Float64* pStartEndDistance,Float64* pEndEndDistance) const
{
   const CPrecastSegmentData* pSegment = pGirder->GetSegment(segmentKey.segmentIndex);
   const CClosureJointData* pStartClosure  = pSegment->GetClosureJoint(pgsTypes::metStart);
   const CClosureJointData* pEndClosure = pSegment->GetClosureJoint(pgsTypes::metEnd);

   // Assume pGirder is not associated with our bridge, but rather a detached copy that is
   // being used in an editing situation.

   GET_IFACE(IBridgeDescription,pIBridgeDesc);
   const CBridgeDescription2* pBridgeDesc = pIBridgeDesc->GetBridgeDescription();

   // Left End
   Float64 leftEndDistance;
   ConnectionLibraryEntry::EndDistanceMeasurementType leftMeasureType;
   CComPtr<IAngle> leftSkewAngle;
   if ( pStartClosure )
   {
      const CTemporarySupportData* pTS = pStartClosure->GetTemporarySupport();
      const CPierData2* pPier = pStartClosure->GetPier();
      ATLASSERT( pTS != nullptr || pPier != nullptr );

      if ( pTS )
      {
         pTS->GetGirderEndDistance(&leftEndDistance,&leftMeasureType);
         GetSkew(pTS->GetIndex(),&leftSkewAngle);
      }
      else
      {
         pPier->GetGirderEndDistance(pgsTypes::Ahead,&leftEndDistance,&leftMeasureType);
         GetPierSkew(pPier->GetIndex(),&leftSkewAngle);
      }
   }
   else
   {
      const CPierData2* pPier = pBridgeDesc->GetPier(pGirder->GetPierIndex(pgsTypes::metStart));
      pPier->GetGirderEndDistance(pgsTypes::Ahead,&leftEndDistance,&leftMeasureType);
      GetPierSkew(pPier->GetIndex(),&leftSkewAngle);
   }
   
   // Adjust for measurement datum
   if ( leftMeasureType == ConnectionLibraryEntry::FromPierNormalToPier )
   {
      Float64 skew;
      leftSkewAngle->get_Value(&skew);

      Float64 leftBrgOffset, rightBrgOffset;
      GetSegmentBearingOffset(segmentKey,&leftBrgOffset,&rightBrgOffset);

      leftEndDistance = leftBrgOffset - leftEndDistance/cos(fabs(skew));
   }
   else if ( leftMeasureType == ConnectionLibraryEntry::FromPierAlongGirder )
   {
      Float64 leftBrgOffset, rightBrgOffset;
      GetSegmentBearingOffset(segmentKey,&leftBrgOffset,&rightBrgOffset);

      leftEndDistance = leftBrgOffset - leftEndDistance;
   }
   else if ( leftMeasureType == ConnectionLibraryEntry::FromBearingNormalToPier )
   {
      Float64 skew;
      leftSkewAngle->get_Value(&skew);
      leftEndDistance /= cos(fabs(skew));
   }
#if defined _DEBUG
   else
   {
      // end distance is already in the format we want it
      ATLASSERT( leftMeasureType == ConnectionLibraryEntry::FromBearingAlongGirder );
   }
#endif

   Float64 rightEndDistance;
   ConnectionLibraryEntry::EndDistanceMeasurementType rightMeasureType;
   CComPtr<IAngle> rightSkewAngle;
   if ( pEndClosure )
   {
      const CTemporarySupportData* pTS = pEndClosure->GetTemporarySupport();
      const CPierData2* pPier = pEndClosure->GetPier();
      ATLASSERT( pTS != nullptr || pPier != nullptr );

      if ( pTS )
      {
         pTS->GetGirderEndDistance(&rightEndDistance,&rightMeasureType);
         GetSkew(pTS->GetIndex(),&rightSkewAngle);
      }
      else
      {
         pPier->GetGirderEndDistance(pgsTypes::Back,&rightEndDistance,&rightMeasureType);
         GetPierSkew(pPier->GetIndex(),&rightSkewAngle);
      }
   }
   else
   {
      const CPierData2* pPier = pBridgeDesc->GetPier(pGirder->GetPierIndex(pgsTypes::metEnd));
      pPier->GetGirderEndDistance(pgsTypes::Back,&rightEndDistance,&rightMeasureType);
      GetPierSkew(pPier->GetIndex(),&rightSkewAngle);
   }
   
   // Adjust for measurement datum
   if ( rightMeasureType == ConnectionLibraryEntry::FromPierNormalToPier )
   {
      Float64 skew;
      rightSkewAngle->get_Value(&skew);

      Float64 leftBrgOffset, rightBrgOffset;
      GetSegmentBearingOffset(segmentKey,&leftBrgOffset,&rightBrgOffset);

      rightEndDistance = rightBrgOffset - rightEndDistance/cos(fabs(skew));
   }
   else if ( rightMeasureType == ConnectionLibraryEntry::FromPierAlongGirder )
   {
      Float64 leftBrgOffset, rightBrgOffset;
      GetSegmentBearingOffset(segmentKey,&leftBrgOffset,&rightBrgOffset);

      rightEndDistance = rightBrgOffset - rightEndDistance;
   }
   else if ( rightMeasureType == ConnectionLibraryEntry::FromBearingNormalToPier )
   {
      Float64 skew;
      rightSkewAngle->get_Value(&skew);
      rightEndDistance /= cos(fabs(skew));
   }
#if defined _DEBUG
   else
   {
      // end distance is already in the format we want it
      ATLASSERT( rightMeasureType == ConnectionLibraryEntry::FromBearingAlongGirder );
   }
#endif

   *pStartEndDistance = leftEndDistance;
   *pEndEndDistance   = rightEndDistance;
}

void CBridgeAgentImp::GetSegmentBearingOffset(const CSegmentKey& segmentKey,Float64* pStartBearingOffset,Float64* pEndBearingOffset) const
{
   CComPtr<IGirderLine> girderLine;
   GetGirderLine(segmentKey,&girderLine);

   girderLine->get_BearingOffset(etStart,pStartBearingOffset);
   girderLine->get_BearingOffset(etEnd,  pEndBearingOffset);
}

void CBridgeAgentImp::GetSegmentStorageSupportLocations(const CSegmentKey& segmentKey,Float64* pDistFromLeftEnd,Float64* pDistFromRightEnd) const
{
   GET_IFACE(IBridgeDescription,pIBridgeDesc);
   const CPrecastSegmentData* pSegment = pIBridgeDesc->GetPrecastSegmentData(segmentKey);
   *pDistFromLeftEnd  = pSegment->HandlingData.LeftStoragePoint;
   *pDistFromRightEnd = pSegment->HandlingData.RightStoragePoint;

   // storage locations at -1 mean the segment is supported at its final bearing location during storage
   if ( pSegment->HandlingData.LeftStoragePoint < 0 )
   {
      *pDistFromLeftEnd = GetSegmentStartEndDistance(segmentKey);
   }

   if ( pSegment->HandlingData.RightStoragePoint < 0 )
   {
      *pDistFromRightEnd = GetSegmentEndEndDistance(segmentKey);
   }
}

void CBridgeAgentImp::GetSegmentReleaseSupportLocations(const CSegmentKey& segmentKey,Float64* pDistFromLeftEnd,Float64* pDistFromRightEnd) const
{
   GET_IFACE(IBridgeDescription,pIBridgeDesc);
   const CPrecastSegmentData* pSegment = pIBridgeDesc->GetPrecastSegmentData(segmentKey);
   *pDistFromLeftEnd  = pSegment->HandlingData.LeftReleasePoint;
   *pDistFromRightEnd = pSegment->HandlingData.RightReleasePoint;

   Float64 start_end_dist, end_end_dist;
   GetSegmentEndDistance(segmentKey, &start_end_dist, &end_end_dist);

   // locations at -1 mean the segment is supported at the ends of the segment
   if ( pSegment->HandlingData.LeftReleasePoint < 0 )
   {
      if (pSegment->HandlingData.LeftReleasePoint == -1)
      {
         // supported at end of girder
         *pDistFromLeftEnd = 0.0;
      }
      else if (pSegment->HandlingData.LeftReleasePoint == -2)
      {
         // supported at CL Bearing
         *pDistFromLeftEnd = start_end_dist;
      }
   }

   if ( pSegment->HandlingData.RightReleasePoint < 0 )
   {
      if (pSegment->HandlingData.RightReleasePoint == -1)
      {
         // supported at end of girder
         *pDistFromRightEnd = 0.0;
      }
      else if (pSegment->HandlingData.RightReleasePoint == -2)
      {
         // supported at CL Bearing
         *pDistFromRightEnd = end_end_dist;
      }
   }
}

const WBFL::Stability::Girder* CBridgeAgentImp::GetSegmentLiftingStabilityModel(const CSegmentKey& segmentKey) const
{
   auto found = m_LiftingStabilityModels.find(segmentKey);
   if ( found != m_LiftingStabilityModels.cend() )
   {
      return &(found->second);
   }

   IntervalIndexType liftingIntervalIdx = GetLiftSegmentInterval(segmentKey);
   WBFL::Stability::Girder girder;
   ConfigureSegmentStabilityModel(segmentKey,liftingIntervalIdx,&girder);

   auto result = m_LiftingStabilityModels.insert(std::make_pair(segmentKey,girder));
   ATLASSERT(result.second == true);
   found = result.first;
   return &(found->second);
}

const WBFL::Stability::Girder* CBridgeAgentImp::GetSegmentHaulingStabilityModel(const CSegmentKey& segmentKey) const
{
   auto found = m_HaulingStabilityModels.find(segmentKey);
   if (found != m_HaulingStabilityModels.cend())
   {
      return &(found->second);
   }

   IntervalIndexType haulingIntervalIdx = GetHaulSegmentInterval(segmentKey);
   WBFL::Stability::Girder girder;
   ConfigureSegmentStabilityModel(segmentKey, haulingIntervalIdx, &girder);

   auto result = m_HaulingStabilityModels.insert(std::make_pair(segmentKey, girder));
   ATLASSERT(result.second == true);
   found = result.first;
   return &(found->second);
}

void CBridgeAgentImp::ConfigureSegmentStabilityModel(const CSegmentKey& segmentKey,IntervalIndexType intervalIdx,WBFL::Stability::Girder* pGirder) const
{
   VALIDATE(BRIDGE);

   CComPtr<ISuperstructureMember> ssmbr;
   HRESULT hr = m_Bridge->get_SuperstructureMember(::GetSuperstructureMemberID(segmentKey.groupIndex,segmentKey.girderIndex),&ssmbr);
   ATLASSERT(SUCCEEDED(hr));

   CComPtr<ISuperstructureMemberSegment> segment;
   hr = ssmbr->get_Segment(segmentKey.segmentIndex,&segment);
   ATLASSERT(SUCCEEDED(hr));

   pGirder->SetSegment(segment);

   pGirder->ClearSections();

   GET_IFACE(IBridgeDescription,pIBridgeDesc);
   const CPrecastSegmentData* pSegment = pIBridgeDesc->GetPrecastSegmentData(segmentKey);
   pgsTypes::SegmentVariationType variationType = pSegment->GetVariationType();

   pGirder->SetPrecamber(pSegment->Precamber);

   // get all the cross section changes
   PoiList vPoi;
   GetPointsOfInterest(segmentKey, POI_SECTCHANGE,&vPoi,POIFIND_OR);

   // vPoi is a list of references to POIs. However if the segment has a parabolic variation
   // we generate intermediate points. Some of these points may not be at a standard poi location
   // that means, when we are adding things to the container below, we are adding locally scoped
   // POI. When we go out of the if/elseif blocks, those POI go out of scope. When we try to use
   // those POI later, they have bogus values and bad things happen
   // To prevent this problem, copy the POIs from vPOI into a vector that keeps all POI in the
   // scope of this method
   std::vector<pgsPointOfInterest> xsPOI(vPoi.begin(), vPoi.end());
   if ( variationType == pgsTypes::svtParabolic )
   {
      // single parabola
      Float64 Ls = GetSegmentLength(segmentKey);
      Float64 Lleft  = pSegment->GetVariationLength(pgsTypes::sztLeftPrismatic);
      Float64 Lright = pSegment->GetVariationLength(pgsTypes::sztRightPrismatic);
      Float64 L = Ls - Lleft - Lright; // length of the non-prismatic portion of the segment
      IndexType nSections = 10; // break into nSections along the parabolic taper
      for ( IndexType i = 0; i < nSections; i++ )
      {
         Float64 X = Lleft + i*L/nSections;
         xsPOI.emplace_back(GetPointOfInterest(segmentKey,X));
      }
   }
   else if ( variationType == pgsTypes::svtDoubleParabolic )
   {
      // double parabola
      IndexType nSections = 10; // break into nSections along the parabolic taper

      // left parabola
      Float64 Lleft  = pSegment->GetVariationLength(pgsTypes::sztLeftPrismatic);
      Float64 Lt     = pSegment->GetVariationLength(pgsTypes::sztLeftTapered);
      for ( IndexType i = 0; i < nSections; i++ )
      {
         Float64 X = Lleft + i*Lt/nSections;
         xsPOI.emplace_back(GetPointOfInterest(segmentKey,X));
      }

      // right parabola
      Float64 Ls = GetSegmentLength(segmentKey);
      Float64 Lright  = pSegment->GetVariationLength(pgsTypes::sztRightPrismatic);
      Float64 Lr     = pSegment->GetVariationLength(pgsTypes::sztRightTapered);
      Lleft = Ls - Lright - Lr; // location of the left end of the right parabola
      for ( IndexType i = 0; i < nSections; i++ )
      {
         Float64 X = Lleft + i*Lr/nSections;
         xsPOI.emplace_back(GetPointOfInterest(segmentKey,X));
      }
   }

   if (variationType == pgsTypes::svtParabolic || variationType == pgsTypes::svtDoubleParabolic)
   {
      // make sure the POIs are sorted
      std::sort(std::begin(xsPOI), std::end(xsPOI), [](const pgsPointOfInterest& a, const pgsPointOfInterest& b) {return a < b;});
      xsPOI.erase(std::unique(std::begin(xsPOI), std::end(xsPOI), [](const pgsPointOfInterest& a, const pgsPointOfInterest& b) {return a == b; }), std::end(xsPOI));
   }

   ATLASSERT(2 <= xsPOI.size());

   auto poiIter(xsPOI.begin());
   auto poiIterEnd(xsPOI.end());
   const pgsPointOfInterest& poi1(*poiIter++);
   Float64 X1 = poi1.GetDistFromStart();
   Float64 Ag1 = GetAg(intervalIdx,poi1);
   Float64 Ixx1 = GetIxx(intervalIdx,poi1);
   Float64 Iyy1 = GetIyy(intervalIdx, poi1);
   Float64 Ixy1 = GetIxy(intervalIdx, poi1);
   Float64 Xcg1 = GetXleft(intervalIdx,poi1);
   Float64 Ycg1 = -GetY(intervalIdx,poi1,pgsTypes::TopGirder);
   Float64 Hg1 = GetHg(intervalIdx,poi1);
   Float64 Wtop1 = GetTopWidth(poi1);
   Float64 Wbot1 = GetBottomWidth(poi1);

   pgsTypes::SectionPropertyType sectPropType = GetSectionPropertiesType();
   WBFL::Stability::Point pntTL1, pntTR1, pntBL1, pntBR1;
   SectProp props = GetSectionProperties(intervalIdx, poi1, sectPropType);
   CComQIPtr<ICompositeSectionEx> compSection(props.Section);
   CComPtr<ICompositeSectionItemEx> item;
   compSection->get_Item(0, &item);
   CComPtr<IShape> shape;
   item->get_Shape(&shape);

   CComPtr<IPoint2d> pntCG;
   props.ShapeProps->get_Centroid(&pntCG);

   Float64 xcg, ycg;
   pntCG->Location(&xcg, &ycg);

   if (HasAsymmetricGirders())
   {
      // use explicit stress points
      CComQIPtr<IAsymmetricSection> asymmetric(shape);
      CComPtr<IPoint2dCollection> topPoints, bottomPoints;
      asymmetric->GetStressPoints(spTop, &topPoints);
      asymmetric->GetStressPoints(spBottom, &bottomPoints);

      IndexType nPoints;
      topPoints->get_Count(&nPoints);
      ATLASSERT(2 <= nPoints);
      CComPtr<IPoint2d> cpntTL, cpntTR;
      topPoints->get_Item(0, &cpntTL);
      topPoints->get_Item(nPoints - 1, &cpntTR);

      bottomPoints->get_Count(&nPoints);
      ATLASSERT(2 <= nPoints);
      CComPtr<IPoint2d> cpntBL, cpntBR;
      bottomPoints->get_Item(0, &cpntBL);
      bottomPoints->get_Item(nPoints - 1, &cpntBR);

      cpntTL->Location(&pntTL1.X(), &pntTL1.Y());
      cpntTR->Location(&pntTR1.X(), &pntTR1.Y());
      cpntBL->Location(&pntBL1.X(), &pntBL1.Y());
      cpntBR->Location(&pntBR1.X(), &pntBR1.Y());

      pntTL1.Offset(-xcg, -ycg);
      pntTR1.Offset(-xcg, -ycg);
      pntBL1.Offset(-xcg, -ycg);
      pntBR1.Offset(-xcg, -ycg);
   }

   for ( ; poiIter != poiIterEnd; poiIter++ )
   {
      const pgsPointOfInterest& poi(*poiIter);
      Float64 X2 = poi.GetDistFromStart();
      Float64 Ag2 = GetAg(intervalIdx,poi);
      Float64 Ixx2 = GetIxx(intervalIdx,poi);
      Float64 Iyy2 = GetIyy(intervalIdx, poi);
      Float64 Ixy2 = GetIxy(intervalIdx, poi);
      Float64 Xcg2 = GetXleft(intervalIdx, poi);
      Float64 Ycg2 = -GetY(intervalIdx,poi,pgsTypes::TopGirder);
      Float64 Hg2 = GetHg(intervalIdx,poi);
      Float64 Wtop2 = GetTopWidth(poi);
      Float64 Wbot2 = GetBottomWidth(poi);

      Float64 L = X2 - X1;
      if (!IsZero(L))
      {
         IndexType sectionIdx = pGirder->AddSection(L, Ag1, Ixx1, Iyy1, Ixy1, Xcg1, Ycg1, Hg1, Wtop1, Wbot1, Ag2, Ixx2, Iyy2, Ixy2, Xcg2, Ycg2, Hg2, Wtop2, Wbot2);

         SectProp props = GetSectionProperties(intervalIdx, poi, sectPropType);
         CComQIPtr<ICompositeSectionEx> compSection(props.Section);
         CComPtr<ICompositeSectionItemEx> item;
         compSection->get_Item(0, &item);
         CComPtr<IShape> shape;
         item->get_Shape(&shape);

         CComPtr<IPoint2d> pntCG;
         props.ShapeProps->get_Centroid(&pntCG);

         Float64 xcg, ycg;
         pntCG->Location(&xcg, &ycg);

         if (HasAsymmetricGirders())
         {
            // use explicit stress points
            CComQIPtr<IAsymmetricSection> asymmetric(shape);
            CComPtr<IPoint2dCollection> topPoints, bottomPoints;
            asymmetric->GetStressPoints(spTop, &topPoints);
            asymmetric->GetStressPoints(spBottom, &bottomPoints);

            IndexType nPoints;
            topPoints->get_Count(&nPoints);
            ATLASSERT(2 <= nPoints);
            CComPtr<IPoint2d> cpntTL, cpntTR;
            topPoints->get_Item(0, &cpntTL);
            topPoints->get_Item(nPoints - 1, &cpntTR);

            bottomPoints->get_Count(&nPoints);
            ATLASSERT(2 <= nPoints);
            CComPtr<IPoint2d> cpntBL, cpntBR;
            bottomPoints->get_Item(0, &cpntBL);
            bottomPoints->get_Item(nPoints - 1, &cpntBR);

            WBFL::Stability::Point pntTL2, pntTR2, pntBL2, pntBR2;
            cpntTL->Location(&pntTL2.X(), &pntTL2.Y());
            cpntTR->Location(&pntTR2.X(), &pntTR2.Y());
            cpntBL->Location(&pntBL2.X(), &pntBL2.Y());
            cpntBR->Location(&pntBR2.X(), &pntBR2.Y());

            pntTL2.Offset(-xcg, -ycg);
            pntTR2.Offset(-xcg, -ycg);
            pntBL2.Offset(-xcg, -ycg);
            pntBR2.Offset(-xcg, -ycg);

            pGirder->SetStressPoints(sectionIdx, pntTL1, pntTR1, pntBL1, pntBR1, pntTL2, pntTR2, pntBL2, pntBR2);

            pntTL1 = pntTL2;
            pntTR1 = pntTR2;
            pntBL1 = pntBL2;
            pntBR1 = pntBR2;
         }
      }

      X1 = X2;
      Ag1 = Ag2;
      Ixx1 = Ixx2;
      Iyy1 = Iyy2;
      Ixy1 = Ixy2;
      Xcg1 = Xcg2;
      Ycg1 = Ycg2;
      Hg1 = Hg2;
      Wtop1 = Wtop2;
      Wbot1 = Wbot2;
   }

   // Add CIP diaphragm loads
   GET_IFACE(IProductLoads,pProductLoads);
   std::vector<DiaphragmLoad> vDiaphragmLoads;
   pProductLoads->GetPrecastDiaphragmLoads(segmentKey,&vDiaphragmLoads);
   std::vector<std::pair<Float64,Float64>> vLoads;
   for( const auto& load : vDiaphragmLoads)
   {
      vLoads.emplace_back(load.Loc,load.Load);
   }

   if ( 0 < vLoads.size() )
   {
      pGirder->SetAdditionalLoads(vLoads);
   }

   const GirderLibraryEntry* pGirderEntry = GetGirderLibraryEntry(segmentKey);
   pGirder->SetDragCoefficient(pGirderEntry->GetDragCoefficient());
}

const WBFL::Stability::LiftingStabilityProblem* CBridgeAgentImp::GetSegmentLiftingStabilityProblem(const CSegmentKey& segmentKey,const HANDLINGCONFIG& handlingConfig,ISegmentLiftingDesignPointsOfInterest* pPoiD) const
{
   ConfigureSegmentLiftingStabilityProblem(segmentKey,true, handlingConfig,pPoiD,&m_LiftingDesignStabilityProblem);
   return &m_LiftingDesignStabilityProblem;
}

const WBFL::Stability::LiftingStabilityProblem* CBridgeAgentImp::GetSegmentLiftingStabilityProblem(const CSegmentKey& segmentKey) const
{
   std::map<CSegmentKey,WBFL::Stability::LiftingStabilityProblem>::iterator found = m_LiftingStabilityProblems.find(segmentKey);
   if ( found != m_LiftingStabilityProblems.end() )
   {
      return &(found->second);
   }

   IntervalIndexType intervalIdx = m_IntervalManager.GetLiftingInterval(segmentKey);

   WBFL::Stability::LiftingStabilityProblem problem;
   HANDLINGCONFIG dummy;
   ConfigureSegmentLiftingStabilityProblem(segmentKey,false,dummy,nullptr,&problem);

   std::pair<std::map<CSegmentKey,WBFL::Stability::LiftingStabilityProblem>::iterator,bool> result = m_LiftingStabilityProblems.insert(std::make_pair(segmentKey,problem));
   ATLASSERT(result.second == true);
   found = result.first;
   return &(found->second);
}

void CBridgeAgentImp::ConfigureSegmentLiftingStabilityProblem(const CSegmentKey& segmentKey,bool bUseConfig,const HANDLINGCONFIG& handlingConfig,ISegmentLiftingDesignPointsOfInterest* pPoiD,WBFL::Stability::LiftingStabilityProblem* pProblem) const
{
   IntervalIndexType intervalIdx = m_IntervalManager.GetLiftingInterval(segmentKey);
   IntervalIndexType releaseIntervalIdx = m_IntervalManager.GetPrestressReleaseInterval(segmentKey);
   IntervalIndexType tsInstallationIntervalIdx = GetTemporaryStrandInstallationInterval(segmentKey);
   IntervalIndexType liftingIntervalIdx = m_IntervalManager.GetLiftingInterval(segmentKey);
   IntervalIndexType tendonStressingIntervalIdx = m_IntervalManager.GetStressSegmentTendonInterval(segmentKey);

   WBFL::Materials::SimpleConcrete concrete;
   if ( bUseConfig && !handlingConfig.bIgnoreGirderConfig )
   {
      concrete.SetType((WBFL::Materials::ConcreteType)handlingConfig.GdrConfig.ConcType);
      concrete.SetFc(handlingConfig.GdrConfig.fci);
      if (handlingConfig.GdrConfig.bUserEci )
      {
         concrete.SetE(handlingConfig.GdrConfig.Eci);
      }
      else
      {
         Float64 Eci = GetEconc(handlingConfig.GdrConfig.ConcType,handlingConfig.GdrConfig.fci, GetSegmentStrengthDensity(segmentKey),
                                                          GetSegmentEccK1(segmentKey),
                                                          GetSegmentEccK2(segmentKey));
         concrete.SetE(Eci);
      }
   }
   else
   {
      concrete.SetType((WBFL::Materials::ConcreteType)GetSegmentConcreteType(segmentKey));
      concrete.SetFc(GetSegmentFc(segmentKey,intervalIdx));
      concrete.SetE(GetSegmentEc(segmentKey,intervalIdx));
   }
   concrete.SetLambda(GetSegmentLambda(segmentKey));
   concrete.SetDensity(GetSegmentStrengthDensity(segmentKey));

   // self-weight is based on gross cross-sectional area. the stability engine computes moment using a linear force of density*area
   // when transformed section properties are used, we would get density*(transformed area) so we need to scale the desnsity
   // so it is equivalent to density*(gross area)
   PoiList vPoi;
   GetPointsOfInterest(segmentKey, POI_RELEASED_SEGMENT | POI_5L, &vPoi);
   ATLASSERT(vPoi.size() == 1);
   pgsPointOfInterest poi(vPoi.front());
   Float64 A = GetAg(intervalIdx, poi);
   Float64 Agross = GetAg(pgsTypes::sptGross, releaseIntervalIdx, poi);
   Float64 density = GetSegmentWeightDensity(segmentKey, intervalIdx);
   density *= (Agross / A);
   concrete.SetDensityForWeight(density);

   GET_IFACE(ISegmentLiftingSpecCriteria,pLiftingCriteria);
   if ( bUseConfig && !handlingConfig.bIgnoreGirderConfig )
   {
      concrete.SetFlexureFr(pLiftingCriteria->GetLiftingModulusOfRupture(segmentKey, handlingConfig.GdrConfig.fci, handlingConfig.GdrConfig.ConcType));
   }
   else
   {
      concrete.SetFlexureFr(pLiftingCriteria->GetLiftingModulusOfRupture(segmentKey));
   }
   
   pProblem->SetConcrete(concrete);

   Float64 E,Fy,Fu;
   GetSegmentLongitudinalRebarProperties(segmentKey,&E,&Fy,&Fu);
   pProblem->SetRebarYieldStrength(Fy);


   Float64 impactDown,impactUp;
   pLiftingCriteria->GetLiftingImpact(&impactDown,&impactUp);
   pProblem->SetImpact(impactUp,impactDown);
   
   pProblem->SetYRollAxis(pLiftingCriteria->GetHeightOfPickPointAboveGirderTop());
   pProblem->SetSupportPlacementTolerance(pLiftingCriteria->GetLiftingLoopPlacementTolerance());
   pProblem->SetLiftAngle(pLiftingCriteria->GetLiftingCableMinInclination());
   pProblem->SetSweepTolerance(pLiftingCriteria->GetLiftingSweepTolerance());
   pProblem->SetSweepGrowth(0.0); // no sweep growth at initial lifting
   pProblem->SetWindLoading((WBFL::Stability::WindType)pLiftingCriteria->GetLiftingWindType(),pLiftingCriteria->GetLiftingWindLoad());

   Float64 Loh, Roh;
   if ( bUseConfig )
   {
      Loh = handlingConfig.LeftOverhang;
      Roh = handlingConfig.RightOverhang;
   }
   else
   {
      GET_IFACE(ISegmentLifting,pSegmentLifting);
      Loh = pSegmentLifting->GetLeftLiftingLoopLocation(segmentKey);
      Roh = pSegmentLifting->GetRightLiftingLoopLocation(segmentKey);
   }
   pProblem->SetSupportLocations(Loh,Roh);


   // get camber... measured from end of segment as if it was supported at it's ends
   vPoi.clear();
   GetPointsOfInterest(segmentKey, POI_START_FACE, &vPoi);
   const pgsPointOfInterest& poiEnd(vPoi.front());
   ATLASSERT(vPoi.size() == 1);
   GetPointsOfInterest(segmentKey,  POI_5L | POI_RELEASED_SEGMENT, &vPoi);
   ATLASSERT(vPoi.size() == 2);
   const pgsPointOfInterest& poiMS(vPoi.back());

   // prestress related camber
   Float64 DpsMS = 0.0;
   Float64 DXpsMS = 0.0;
   Float64 DtpsMS = 0.0;
   Float64 DXtpsMS = 0.0;

   Float64 DpsEnd = 0.0;
   Float64 DXpsEnd = 0.0;
   Float64 DtpsEnd = 0.0;
   Float64 DXtpsEnd = 0.0;

   GET_IFACE_NOCHECK(ICamber, pCamber);
   if (bUseConfig && !handlingConfig.bIgnoreGirderConfig)
   {
      pCamber->GetPrestressDeflection(poiMS, pgsTypes::pddRelease, &handlingConfig.GdrConfig, &DXpsMS, &DpsMS);
      pCamber->GetInitialTempPrestressDeflection(poiMS, pgsTypes::pddRelease, &handlingConfig.GdrConfig, &DXtpsMS, &DtpsMS);
   }
   else
   {
      pCamber->GetPrestressDeflection(poiMS, pgsTypes::pddRelease, nullptr, &DXpsMS, &DpsMS);
      pCamber->GetInitialTempPrestressDeflection(poiMS, pgsTypes::pddRelease, nullptr, &DXtpsMS, &DtpsMS);
   }

   // girder self weight deflection
   Float64 DXgdrMS, DgdrMS;
   Float64 DXgdrEnd, DgdrEnd;
   if (bUseConfig)
   {
      // need deflection based on support at end of girder (this is because the Offset Factor from Mast's method uses deflecton datum at end of girder)
      // build a fem model and compute it
      pgsGirderModelFactory girderModelFactory;

      CComPtr<IFem2dModel> pModel;
      pgsPoiPairMap poiMap;

      Float64 Ls = GetSegmentLength(segmentKey);

      LoadCaseIDType lcid = 0;
      girderModelFactory.CreateGirderModel(m_pBroker, releaseIntervalIdx, segmentKey, Loh, Ls-Roh, Ls, concrete.GetE(), lcid, true, true, vPoi, &pModel, &poiMap);

      // Get results
      CComQIPtr<IFem2dModelResults> results(pModel);

      Float64 dx, dy, rz;
      PoiIDPairType femPoiID = poiMap.GetModelPoi(poiMS);
      CAnalysisResult ar(_T(__FILE__),__LINE__);
      ar = results->ComputePOIDeflections(lcid, femPoiID.first, lotMember, &dx, &dy, &rz);
      DgdrMS = dy;

      femPoiID = poiMap.GetModelPoi(poiEnd);
      CAnalysisResult ar2(_T(__FILE__),__LINE__);
      ar2 = results->ComputePOIDeflections(lcid, femPoiID.first, lotMember, &dx, &dy, &rz);
      DgdrEnd = dy;

      GET_IFACE(ISectionProperties, pSectProps);
      Float64 Iyy = pSectProps->GetIyy(releaseIntervalIdx, poiMS);
      Float64 Ixy = pSectProps->GetIxy(releaseIntervalIdx, poiMS);
      DXgdrMS = (-Ixy / Iyy)*DgdrMS;
      DXgdrEnd = (-Ixy / Iyy)*DgdrEnd;
   }
   else
   {
      GET_IFACE(IProductForces, pProduct);
      pgsTypes::BridgeAnalysisType bat = pProduct->GetBridgeAnalysisType(pgsTypes::Minimize);
      DgdrMS = pProduct->GetDeflection(liftingIntervalIdx, pgsTypes::pftGirder, poiMS, bat, rtCumulative, false);
      DXgdrMS = pProduct->GetXDeflection(liftingIntervalIdx, pgsTypes::pftGirder, poiMS, bat, rtCumulative);
      DgdrEnd = pProduct->GetDeflection(liftingIntervalIdx, pgsTypes::pftGirder, poiEnd, bat, rtCumulative, false);
      DXgdrEnd = pProduct->GetXDeflection(liftingIntervalIdx, pgsTypes::pftGirder, poiEnd, bat, rtCumulative);
   }

   Float64 ps_camber = (DgdrMS + DpsMS + DtpsMS) - (DgdrEnd + DpsEnd + DtpsEnd);

   GET_IFACE(IProductForces, pProduct);
   pgsTypes::BridgeAnalysisType bat = pProduct->GetBridgeAnalysisType(pgsTypes::Minimize);
   Float64 DptMS  = pProduct->GetDeflection(liftingIntervalIdx, pgsTypes::pftPostTensioning, poiMS,  bat, rtCumulative, false);
   Float64 DptEnd = pProduct->GetDeflection(liftingIntervalIdx, pgsTypes::pftPostTensioning, poiEnd, bat, rtCumulative, false);
   Float64 pt_camber = DptMS - DptEnd;

   Float64 camber = ps_camber + pt_camber;
   pProblem->SetCamber(camber);
   pProblem->SetCamberMultiplier(pLiftingCriteria->GetLiftingCamberMultiplier());

   Float64 xcamber = (DXgdrMS + DXpsMS + DXtpsMS) - (DXgdrEnd + DXpsEnd + DXtpsEnd);
   if (!IsZero(xcamber))
   {
      pProblem->IncludeLateralRollAxisOffset(true);
      pProblem->SetLateralCamber(xcamber);
   }


   // Prestress forces
   GET_IFACE(IPretensionForce, pPSForce);
   GET_IFACE_NOCHECK(IPosttensionForce, pPTForce); // not used if there aren't any segment PT
   std::vector<pgsPointOfInterest> vLocalPois; // this is outside of the if block below so that its scope matches that of vPoi
   if ( bUseConfig && !handlingConfig.bIgnoreGirderConfig )
   {
      pPoiD->GetLiftingDesignPointsOfInterest(segmentKey, handlingConfig.LeftOverhang,0,&vLocalPois);

      // this method uses a PoiList container which holds references to POIs... we will fill vPoi with references to the pois in vLocalPois
      MakePoiList(vLocalPois,&vPoi);
   }
   else
   {
      GetLiftingPointsOfInterest(segmentKey,0,&vPoi);
   }

   pProblem->ClearAnalysisPoints();
   pProblem->ClearFpe();

   std::vector<std::_tstring> vNames{ _T("Straight"), _T("Harped"), _T("Temporary") };
   GET_IFACE(ISegmentTendonGeometry, pSegmentTendonGeometry);
   DuctIndexType nSegmentDucts = pSegmentTendonGeometry->GetDuctCount(segmentKey);
   for (DuctIndexType ductIdx = 0; ductIdx < nSegmentDucts; ductIdx++)
   {
      std::_tostringstream os;
      os << _T("Duct ") << LABEL_DUCT(ductIdx);
      vNames.emplace_back(os.str());
   }

   std::vector<IntervalIndexType> vPrestressIntervals{ releaseIntervalIdx,releaseIntervalIdx,tsInstallationIntervalIdx }; // straight, harped, temporary
   for( const pgsPointOfInterest& poi : vPoi)
   {
      std::unique_ptr<WBFL::Stability::IAnalysisPoint> pAnalysisPoint(std::make_unique<pgsStabilityAnalysisPoint>(poi, POI_LIFT_SEGMENT));
      //pProblem->AddAnalysisPoint(std::move(pAnalysisPoint)); // don't add here because move will make the pointer null 

      Float64 Ytg = -GetY(releaseIntervalIdx,poi,pgsTypes::TopGirder);
      Float64 Xleft = GetXleft(releaseIntervalIdx, poi);

      if ( bUseConfig && !handlingConfig.bIgnoreGirderConfig )
      {
         ATLASSERT(nSegmentDucts == 0); // if we are using a config, this is design. Only PGSuper has design option. PGSuper doesn't have segment ducts
         for (int i = 0; i < 3; i++)
         {
            pgsTypes::StrandType strandType = (pgsTypes::StrandType)i;
            auto ecc = GetEccentricity(vPrestressIntervals[strandType], poi, strandType, &handlingConfig.GdrConfig);
            Float64 Xps = Xleft - ecc.X();
            Float64 Yps = Ytg - ecc.Y();
            Float64 Fpe = pPSForce->GetPrestressForce(poi, strandType, intervalIdx, pgsTypes::Start, pgsTypes::tltMinimum, &handlingConfig.GdrConfig);
            pProblem->AddFpe(vNames[strandType].c_str(), pAnalysisPoint->GetLocation(), Fpe, Xps, Yps);
         }
      }
      else
      {
         // strands are always stored in first 3 slots
         for (int i = 0; i < 3; i++)
         {
            pgsTypes::StrandType strandType = (pgsTypes::StrandType)i;
            auto ecc = GetEccentricity(vPrestressIntervals[strandType], poi, strandType);
            Float64 Xps = Xleft - ecc.X();
            Float64 Yps = Ytg - ecc.Y();
            Float64 Fpe = pPSForce->GetPrestressForce(poi, strandType, intervalIdx, pgsTypes::Start, pgsTypes::tltMinimum);
            pProblem->AddFpe(vNames[strandType].c_str(), pAnalysisPoint->GetLocation(), Fpe, Xps, Yps);
         }

         // segment tendons, if any,start at index 3
         for (int i = 3; i < vNames.size(); i++)
         {
            DuctIndexType ductIdx = DuctIndexType(i - 3);
            Float64 eccx, eccy;
            GetSegmentTendonEccentricity(tendonStressingIntervalIdx, poi, ductIdx,&eccx,&eccy);
            Float64 Xps = Xleft - eccx;
            Float64 Yps = Ytg - eccy;
            Float64 Fpe = pPTForce->GetSegmentTendonForce(poi, tendonStressingIntervalIdx, pgsTypes::Start, ductIdx);
            pProblem->AddFpe(vNames[i].c_str(), pAnalysisPoint->GetLocation(), Fpe, Xps, Yps);
         }
      }

      pProblem->AddAnalysisPoint(std::move(pAnalysisPoint));
   }
}

const WBFL::Stability::HaulingStabilityProblem* CBridgeAgentImp::GetSegmentHaulingStabilityProblem(const CSegmentKey& segmentKey) const
{
   std::map<CSegmentKey,WBFL::Stability::HaulingStabilityProblem>::iterator found = m_HaulingStabilityProblems.find(segmentKey);
   if ( found != m_HaulingStabilityProblems.end() )
   {
      return &(found->second);
   }

   WBFL::Stability::HaulingStabilityProblem problem;
   HANDLINGCONFIG dummy;
   ConfigureSegmentHaulingStabilityProblem(segmentKey,false,dummy,nullptr,&problem);

   std::pair<std::map<CSegmentKey,WBFL::Stability::HaulingStabilityProblem>::iterator,bool> result = m_HaulingStabilityProblems.insert(std::make_pair(segmentKey,problem));
   ATLASSERT(result.second == true);
   found = result.first;
   return &(found->second);
}

const WBFL::Stability::HaulingStabilityProblem* CBridgeAgentImp::GetSegmentHaulingStabilityProblem(const CSegmentKey& segmentKey,const HANDLINGCONFIG& handlingConfig,ISegmentHaulingDesignPointsOfInterest* pPOId) const
{
   ConfigureSegmentHaulingStabilityProblem(segmentKey,true, handlingConfig,pPOId,&m_HaulingDesignStabilityProblem);
   return &m_HaulingDesignStabilityProblem;
}

void CBridgeAgentImp::ConfigureSegmentHaulingStabilityProblem(const CSegmentKey& segmentKey,bool bUseConfig,const HANDLINGCONFIG& handlingConfig,ISegmentHaulingDesignPointsOfInterest* pPoiD,WBFL::Stability::HaulingStabilityProblem* pProblem) const
{
   IntervalIndexType intervalIdx = m_IntervalManager.GetHaulingInterval(segmentKey);
   IntervalIndexType releaseIntervalIdx = m_IntervalManager.GetPrestressReleaseInterval(segmentKey);
   IntervalIndexType tsInstallationIntervalIdx = GetTemporaryStrandInstallationInterval(segmentKey);
   IntervalIndexType storageIntervalIdx = m_IntervalManager.GetStorageInterval(segmentKey);
   IntervalIndexType haulingIntervalIdx = m_IntervalManager.GetHaulingInterval(segmentKey);
   IntervalIndexType tendonStressingIntervalIdx = m_IntervalManager.GetStressSegmentTendonInterval(segmentKey);

   WBFL::Materials::SimpleConcrete concrete;
   if ( bUseConfig && !handlingConfig.bIgnoreGirderConfig )
   {
      concrete.SetType((WBFL::Materials::ConcreteType)handlingConfig.GdrConfig.ConcType);
      concrete.SetFc(handlingConfig.GdrConfig.fc);
      if (handlingConfig.GdrConfig.bUserEci )
      {
         concrete.SetE(handlingConfig.GdrConfig.Ec);
      }
      else
      {
         Float64 Ec = GetEconc(handlingConfig.GdrConfig.ConcType,handlingConfig.GdrConfig.fc, GetSegmentStrengthDensity(segmentKey),
                                                        GetSegmentEccK1(segmentKey),
                                                        GetSegmentEccK2(segmentKey));
         concrete.SetE(Ec);
      }
   }
   else
   {
      concrete.SetType((WBFL::Materials::ConcreteType)GetSegmentConcreteType(segmentKey));
      concrete.SetFc(GetSegmentFc(segmentKey,intervalIdx));
      concrete.SetE(GetSegmentEc(segmentKey,intervalIdx));
   }
   concrete.SetLambda(GetSegmentLambda(segmentKey));
   concrete.SetDensity(GetSegmentStrengthDensity(segmentKey));

   // self-weight is based on gross cross-sectional area. the stability engine computes moment using a linear force of density*area
   // when transformed section properties are used, we would get density*(transformed area) so we need to scale the desnsity
   // so it is equivalent to density*(gross area)
   PoiList vPoi;
   GetPointsOfInterest(segmentKey, POI_RELEASED_SEGMENT | POI_5L, &vPoi);
   ATLASSERT(vPoi.size() == 1);
   pgsPointOfInterest poi(vPoi.front());
   Float64 A = GetAg(intervalIdx, poi);
   Float64 Agross = GetAg(pgsTypes::sptGross, releaseIntervalIdx, poi);
   Float64 density = GetSegmentWeightDensity(segmentKey, intervalIdx);
   density *= (Agross / A);
   concrete.SetDensityForWeight(density);

   GET_IFACE(ISegmentHaulingSpecCriteria,pHaulingCriteria);
   if ( bUseConfig && !handlingConfig.bIgnoreGirderConfig )
   {
      concrete.SetFlexureFr(pHaulingCriteria->GetHaulingModulusOfRupture(segmentKey, handlingConfig.GdrConfig.fc, handlingConfig.GdrConfig.ConcType));
   }
   else
   {
      concrete.SetFlexureFr(pHaulingCriteria->GetHaulingModulusOfRupture(segmentKey));
   }
   
   pProblem->SetConcrete(concrete);

   Float64 E,Fy,Fu;
   GetSegmentLongitudinalRebarProperties(segmentKey,&E,&Fy,&Fu);
   pProblem->SetRebarYieldStrength(Fy);

   Float64 impactDown,impactUp;
   pHaulingCriteria->GetHaulingImpact(&impactDown,&impactUp);
   pProblem->SetImpact(impactUp,impactDown);
   pProblem->SetImpactUsage((WBFL::Stability::HaulingImpact)pHaulingCriteria->GetHaulingImpactUsage());

   vPoi.clear();
   GetPointsOfInterest(segmentKey, POI_START_FACE, &vPoi);
   ATLASSERT(vPoi.size() == 1);
   const pgsPointOfInterest& poiStart(vPoi.front());
   GetPointsOfInterest(segmentKey, POI_5L | POI_RELEASED_SEGMENT, &vPoi);
   ATLASSERT(vPoi.size() == 2);
   const pgsPointOfInterest& poiMS(vPoi.back());
   GetPointsOfInterest(segmentKey, POI_END_FACE, &vPoi);
   ATLASSERT(vPoi.size() == 3);
   const pgsPointOfInterest& poiEnd(vPoi.back());


   Float64 Hg  = GetHg(intervalIdx,poiEnd);
   Float64 Hrc, Hbg, Wcc, Ktheta;

   if ( bUseConfig && handlingConfig.pHaulTruckEntry != nullptr )
   {
      Hrc = handlingConfig.pHaulTruckEntry->GetRollCenterHeight();
      Hbg = handlingConfig.pHaulTruckEntry->GetBottomOfGirderHeight();
      Wcc = handlingConfig.pHaulTruckEntry->GetAxleWidth();
      Ktheta = handlingConfig.pHaulTruckEntry->GetRollStiffness();
   }
   else
   {
      Hrc = pHaulingCriteria->GetHeightOfTruckRollCenterAboveRoadway(segmentKey);
      Hbg = pHaulingCriteria->GetHeightOfGirderBottomAboveRoadway(segmentKey);
      Wcc = pHaulingCriteria->GetAxleWidth(segmentKey);
      Ktheta = pHaulingCriteria->GetRollStiffness(segmentKey);
   }

   Float64 Yra = Hrc - (Hbg + Hg);
   pProblem->SetYRollAxis(Yra);
   pProblem->SetHeightOfRollAxis(Hrc);
   pProblem->SetSupportWidth(Wcc);
   pProblem->SetRotationalStiffness(Ktheta);

   pProblem->SetSupportPlacementTolerance(pHaulingCriteria->GetHaulingSupportPlacementTolerance());
   pProblem->SetSweepTolerance(pHaulingCriteria->GetHaulingSweepTolerance());
   pProblem->SetSweepGrowth(pHaulingCriteria->GetHaulingSweepGrowth());
   pProblem->SetWindLoading((WBFL::Stability::WindType)pHaulingCriteria->GetHaulingWindType(),pHaulingCriteria->GetHaulingWindLoad());

   pProblem->SetSupportSlope(pHaulingCriteria->GetNormalCrownSlope());
   pProblem->SetSuperelevation(pHaulingCriteria->GetMaxSuperelevation());

   pProblem->SetCentrifugalForceType((WBFL::Stability::CFType)pHaulingCriteria->GetCentrifugalForceType());
   pProblem->SetVelocity(pHaulingCriteria->GetHaulingSpeed());
   pProblem->SetTurningRadius(pHaulingCriteria->GetTurningRadius());


   Float64 Loh, Roh;
   if ( bUseConfig )
   {
      Loh = handlingConfig.LeftOverhang;
      Roh = handlingConfig.RightOverhang;
   }
   else
   {
      GET_IFACE(ISegmentHauling,pSegmentHauling);
      Loh = pSegmentHauling->GetTrailingOverhang(segmentKey);
      Roh = pSegmentHauling->GetLeadingOverhang(segmentKey);
   }
   pProblem->SetSupportLocations(Loh,Roh);


   // get camber... measured from end of segment as if it was supported at it's ends
   // deflections are measured relative to the support points. if there are unequal overhangs
   // we need to add the maximum overhang deflection to the mid-span deflection.
   GET_IFACE(IProductForces, pProduct);
   pgsTypes::BridgeAnalysisType bat = pProduct->GetBridgeAnalysisType(pgsTypes::Minimize);

   Float64 DXpsStart(0), DpsStart(0), DXpsMS(0), DpsMS(0), DXpsEnd(0), DpsEnd(0);

   GET_IFACE_NOCHECK(ICamber, pCamber);
   if (bUseConfig && !handlingConfig.bIgnoreGirderConfig)
   {
      Float64 xps, ps, xtps, tps;
      pCamber->GetPrestressDeflection(poiStart, pgsTypes::pddHauling, &handlingConfig.GdrConfig, &xps, &ps);
      pCamber->GetInitialTempPrestressDeflection(poiStart, pgsTypes::pddHauling, &handlingConfig.GdrConfig, &xtps, &tps);
      DXpsStart = xps + xtps;
      DpsStart = ps + tps;

      pCamber->GetPrestressDeflection(poiMS, pgsTypes::pddHauling, &handlingConfig.GdrConfig, &xps, &ps);
      pCamber->GetInitialTempPrestressDeflection(poiMS, pgsTypes::pddHauling, &handlingConfig.GdrConfig, &xtps, &tps);
      DXpsMS = xps + xtps;
      DpsMS = ps + tps;

      pCamber->GetPrestressDeflection(poiEnd, pgsTypes::pddHauling, &handlingConfig.GdrConfig, &xps, &ps);
      pCamber->GetInitialTempPrestressDeflection(poiEnd, pgsTypes::pddHauling, &handlingConfig.GdrConfig, &xtps, &tps);
      DXpsEnd = xps + xtps;
      DpsEnd = ps + tps;
   }
   else
   {
      DpsStart = pProduct->GetDeflection(haulingIntervalIdx, pgsTypes::pftPretension, poiStart, bat, rtCumulative, false);
      DXpsStart = pProduct->GetXDeflection(haulingIntervalIdx, pgsTypes::pftPretension, poiStart, bat, rtCumulative);
      DpsMS = pProduct->GetDeflection(haulingIntervalIdx, pgsTypes::pftPretension, poiMS, bat, rtCumulative, false);
      DXpsMS = pProduct->GetXDeflection(haulingIntervalIdx, pgsTypes::pftPretension, poiMS, bat, rtCumulative);
      DpsEnd = pProduct->GetDeflection(haulingIntervalIdx, pgsTypes::pftPretension, poiEnd, bat, rtCumulative, false);
      DXpsEnd = pProduct->GetXDeflection(haulingIntervalIdx, pgsTypes::pftPretension, poiEnd, bat, rtCumulative);
   }

   Float64 DXgdrStart, DgdrStart, DXgdrMS, DgdrMS, DXgdrEnd, DgdrEnd;
   if (bUseConfig)
   {
      // need deflection based on support at end of girder (this is because the Offset Factor from Mast's method uses deflecton datum at end of girder)
      // build a fem model and compute it
      pgsGirderModelFactory girderModelFactory;

      CComPtr<IFem2dModel> pModel;
      pgsPoiPairMap poiMap;

      Float64 Ls = GetSegmentLength(segmentKey);

      LoadCaseIDType lcid = 0;
      girderModelFactory.CreateGirderModel(m_pBroker, releaseIntervalIdx, segmentKey, Loh, Ls - Roh, Ls, concrete.GetE(), lcid, true, true, vPoi, &pModel, &poiMap);

      // Get results
      CComQIPtr<IFem2dModelResults> results(pModel);

      Float64 dx, dy, rz;

      PoiIDPairType femPoiID = poiMap.GetModelPoi(poiStart);
      CAnalysisResult arStart(_T(__FILE__), __LINE__);
      arStart = results->ComputePOIDeflections(lcid, femPoiID.first, lotMember, &dx, &dy, &rz);
      DgdrStart = dy;

      femPoiID = poiMap.GetModelPoi(poiMS);
      CAnalysisResult ar(_T(__FILE__),__LINE__);
      ar = results->ComputePOIDeflections(lcid, femPoiID.first, lotMember, &dx, &dy, &rz);
      DgdrMS = dy;

      femPoiID = poiMap.GetModelPoi(poiEnd);
      CAnalysisResult arEnd(_T(__FILE__),__LINE__);
      arEnd = results->ComputePOIDeflections(lcid, femPoiID.first, lotMember, &dx, &dy, &rz);
      DgdrEnd = dy;

      GET_IFACE(ISectionProperties, pSectProps);
      Float64 Iyy = pSectProps->GetIyy(releaseIntervalIdx, poiMS);
      Float64 Ixy = pSectProps->GetIxy(releaseIntervalIdx, poiMS);
      DXgdrStart = (-Ixy / Iyy) * DgdrStart;
      DXgdrMS = (-Ixy / Iyy)*DgdrMS;
      DXgdrEnd = (-Ixy / Iyy)*DgdrEnd;
   }
   else
   {
      DgdrStart = pProduct->GetDeflection(haulingIntervalIdx, pgsTypes::pftGirder, poiStart, bat, rtCumulative, false);
      DXgdrStart = pProduct->GetXDeflection(haulingIntervalIdx, pgsTypes::pftGirder, poiStart, bat, rtCumulative);
      DgdrMS = pProduct->GetDeflection(haulingIntervalIdx, pgsTypes::pftGirder, poiMS, bat, rtCumulative, false);
      DXgdrMS = pProduct->GetXDeflection(haulingIntervalIdx, pgsTypes::pftGirder, poiMS, bat, rtCumulative);
      DgdrEnd = pProduct->GetDeflection(haulingIntervalIdx, pgsTypes::pftGirder, poiEnd, bat, rtCumulative, false);
      DXgdrEnd = pProduct->GetXDeflection(haulingIntervalIdx, pgsTypes::pftGirder, poiEnd, bat, rtCumulative);
   }

   Float64 DcreepStart, DXcreepStart, DcreepMS, DXcreepMS, DcreepEnd, DXcreepEnd;
   GET_IFACE(ILossParameters, pLossParams);
   if (pLossParams->GetLossMethod() == pgsTypes::TIME_STEP)
   {
      DcreepStart = pProduct->GetDeflection(haulingIntervalIdx, pgsTypes::pftCreep, poiStart, bat, rtCumulative, false);
      DcreepMS = pProduct->GetDeflection(haulingIntervalIdx, pgsTypes::pftCreep, poiMS, bat, rtCumulative, false);
      DcreepEnd = pProduct->GetDeflection(haulingIntervalIdx, pgsTypes::pftCreep, poiEnd, bat, rtCumulative, false);

      DcreepStart += pProduct->GetDeflection(haulingIntervalIdx, pgsTypes::pftShrinkage, poiStart, bat, rtCumulative, false);
      DcreepMS += pProduct->GetDeflection(haulingIntervalIdx, pgsTypes::pftShrinkage, poiMS, bat, rtCumulative, false);
      DcreepEnd += pProduct->GetDeflection(haulingIntervalIdx, pgsTypes::pftShrinkage, poiEnd, bat, rtCumulative, false);

      DcreepStart += pProduct->GetDeflection(haulingIntervalIdx, pgsTypes::pftRelaxation, poiStart, bat, rtCumulative, false);
      DcreepMS += pProduct->GetDeflection(haulingIntervalIdx, pgsTypes::pftRelaxation, poiMS, bat, rtCumulative, false);
      DcreepEnd += pProduct->GetDeflection(haulingIntervalIdx, pgsTypes::pftRelaxation, poiEnd, bat, rtCumulative, false);


      DXcreepStart = pProduct->GetXDeflection(haulingIntervalIdx, pgsTypes::pftCreep, poiStart, bat, rtCumulative);
      DXcreepMS = pProduct->GetXDeflection(haulingIntervalIdx, pgsTypes::pftCreep, poiMS, bat, rtCumulative);
      DXcreepEnd = pProduct->GetXDeflection(haulingIntervalIdx, pgsTypes::pftCreep, poiEnd, bat, rtCumulative);

      DXcreepStart += pProduct->GetXDeflection(haulingIntervalIdx, pgsTypes::pftShrinkage, poiStart, bat, rtCumulative);
      DXcreepMS += pProduct->GetXDeflection(haulingIntervalIdx, pgsTypes::pftShrinkage, poiMS, bat, rtCumulative);
      DXcreepEnd += pProduct->GetXDeflection(haulingIntervalIdx, pgsTypes::pftShrinkage, poiEnd, bat, rtCumulative);

      DXcreepStart += pProduct->GetXDeflection(haulingIntervalIdx, pgsTypes::pftRelaxation, poiStart, bat, rtCumulative);
      DXcreepMS += pProduct->GetXDeflection(haulingIntervalIdx, pgsTypes::pftRelaxation, poiMS, bat, rtCumulative);
      DXcreepEnd += pProduct->GetXDeflection(haulingIntervalIdx, pgsTypes::pftRelaxation, poiEnd, bat, rtCumulative);
   }
   else
   {
      DcreepStart = pCamber->GetCreepDeflection(poiStart, ICamber::cpReleaseToDiaphragm, CREEP_MAXTIME, pgsTypes::pddStorage, bUseConfig && !handlingConfig.bIgnoreGirderConfig ? &handlingConfig.GdrConfig : nullptr);
      DXcreepStart = pCamber->GetXCreepDeflection(poiStart, ICamber::cpReleaseToDiaphragm, CREEP_MAXTIME, pgsTypes::pddStorage, bUseConfig && !handlingConfig.bIgnoreGirderConfig ? &handlingConfig.GdrConfig : nullptr);

      DcreepMS = pCamber->GetCreepDeflection(poiMS, ICamber::cpReleaseToDiaphragm, CREEP_MAXTIME, pgsTypes::pddStorage, bUseConfig && !handlingConfig.bIgnoreGirderConfig ? &handlingConfig.GdrConfig : nullptr);
      DXcreepMS = pCamber->GetXCreepDeflection(poiMS, ICamber::cpReleaseToDiaphragm, CREEP_MAXTIME, pgsTypes::pddStorage, bUseConfig && !handlingConfig.bIgnoreGirderConfig ? &handlingConfig.GdrConfig : nullptr);

      DcreepEnd = pCamber->GetCreepDeflection(poiEnd, ICamber::cpReleaseToDiaphragm, CREEP_MAXTIME, pgsTypes::pddStorage, bUseConfig && !handlingConfig.bIgnoreGirderConfig ? &handlingConfig.GdrConfig : nullptr);
      DXcreepEnd = pCamber->GetXCreepDeflection(poiEnd, ICamber::cpReleaseToDiaphragm, CREEP_MAXTIME, pgsTypes::pddStorage, bUseConfig && !handlingConfig.bIgnoreGirderConfig ? &handlingConfig.GdrConfig : nullptr);
   }

   Float64 ps_camber = (DgdrMS + DpsMS + DcreepMS) - 0.5*((DgdrStart + DpsStart + DcreepStart) + (DgdrEnd + DpsEnd + DcreepEnd));

   Float64 DptStart = pProduct->GetDeflection(haulingIntervalIdx, pgsTypes::pftPostTensioning, poiStart, bat, rtCumulative, false);
   Float64 DptMS = pProduct->GetDeflection(haulingIntervalIdx, pgsTypes::pftPostTensioning, poiMS, bat, rtCumulative, false);
   Float64 DptEnd = pProduct->GetDeflection(haulingIntervalIdx, pgsTypes::pftPostTensioning, poiEnd, bat, rtCumulative, false);
   Float64 pt_camber = DptMS - 0.5*(DptStart + DptEnd);

   Float64 camber = ps_camber + pt_camber;

   pProblem->SetCamber(camber);
   pProblem->SetCamberMultiplier(pHaulingCriteria->GetHaulingCamberMultiplier());

   Float64 xcamber = (DXgdrMS + DXpsMS + DXcreepMS) - 0.5*((DXgdrStart + DXpsStart + DXcreepStart) + (DXgdrEnd + DXpsEnd + DXcreepEnd));
   if (!IsZero(xcamber))
   {
      pProblem->IncludeLateralRollAxisOffset(true);
      pProblem->SetLateralCamber(xcamber);
   }

   // Prestress forces
   GET_IFACE(IPretensionForce, pPSForce);
   GET_IFACE_NOCHECK(IPosttensionForce, pPTForce); // not used if there aren't any segment PT
   std::vector<pgsPointOfInterest> vLocalPois; // this is outside of the if block below so that its scope matches that of vPoi
   if ( bUseConfig && !handlingConfig.bIgnoreGirderConfig )
   {
      pPoiD->GetHaulingDesignPointsOfInterest(segmentKey,10, handlingConfig.LeftOverhang, handlingConfig.RightOverhang,0,&vLocalPois);

      // this method uses a PoiList container which holds references to POIs... we will fill vPoi with references to the pois in vLocalPois
      MakePoiList(vLocalPois,&vPoi);
   }
   else
   {
      GetHaulingPointsOfInterest(segmentKey,0,&vPoi);
   }

   pProblem->ClearAnalysisPoints();
   pProblem->ClearFpe();

   std::vector<std::_tstring> vNames{ _T("Straight"), _T("Harped"), _T("Temporary") };
   GET_IFACE(ISegmentTendonGeometry, pSegmentTendonGeometry);
   DuctIndexType nSegmentDucts = pSegmentTendonGeometry->GetDuctCount(segmentKey);
   for (DuctIndexType ductIdx = 0; ductIdx < nSegmentDucts; ductIdx++)
   {
      std::_tostringstream os;
      os << _T("Duct ") << LABEL_DUCT(ductIdx);
      vNames.emplace_back(os.str());
   }

   std::vector<IntervalIndexType> vPrestressIntervals{ releaseIntervalIdx,releaseIntervalIdx,tsInstallationIntervalIdx }; // straight, harped, temporary
   for( const pgsPointOfInterest& poi : vPoi)
   {
      std::unique_ptr<WBFL::Stability::IAnalysisPoint> pAnalysisPoint(std::make_unique<pgsStabilityAnalysisPoint>(poi, POI_HAUL_SEGMENT));
      //pProblem->AddAnalysisPoint(std::move(pAnalysisPoint)); // don't add it here because move will make the pointer null

      Float64 Ytg = -GetY(releaseIntervalIdx, poi, pgsTypes::TopGirder);
      Float64 Xleft = GetXleft(releaseIntervalIdx, poi);

      if (bUseConfig && !handlingConfig.bIgnoreGirderConfig)
      {
         ATLASSERT(nSegmentDucts == 0); // if we are using a config, this is design. Only PGSuper has design option. PGSuper doesn't have segment ducts
         for (int i = 0; i < 3; i++)
         {
            pgsTypes::StrandType strandType = (pgsTypes::StrandType)i;
            auto ecc = GetEccentricity(vPrestressIntervals[strandType], poi, strandType, &handlingConfig.GdrConfig);
            Float64 Xps = Xleft - ecc.X();
            Float64 Yps = Ytg - ecc.Y();
            Float64 Fpe = pPSForce->GetPrestressForce(poi, strandType, intervalIdx, pgsTypes::Start, pgsTypes::tltMinimum, &handlingConfig.GdrConfig);
            pProblem->AddFpe(vNames[strandType].c_str(), pAnalysisPoint->GetLocation(), Fpe, Xps, Yps);
         }
      }
      else
      {
         // strands are always stored in first 3 slots
         for (int i = 0; i < 3; i++)
         {
            pgsTypes::StrandType strandType = (pgsTypes::StrandType)i;
            auto ecc = GetEccentricity(vPrestressIntervals[strandType], poi, strandType);
            Float64 Xps = Xleft - ecc.X();
            Float64 Yps = Ytg - ecc.Y();
            Float64 Fpe = pPSForce->GetPrestressForce(poi, strandType, intervalIdx, pgsTypes::Start, pgsTypes::tltMinimum);
            pProblem->AddFpe(vNames[strandType].c_str(), pAnalysisPoint->GetLocation(), Fpe, Xps, Yps);
         }

         // segment tendons, if any,start at index 3
         for (int i = 3; i < vNames.size(); i++)
         {
            DuctIndexType ductIdx = DuctIndexType(i - 3);
            Float64 eccx, eccy;
            GetSegmentTendonEccentricity(tendonStressingIntervalIdx, poi, ductIdx, &eccx, &eccy);
            Float64 Xps = Xleft - eccx;
            Float64 Yps = Ytg - eccy;
            Float64 Fpe = pPTForce->GetSegmentTendonForce(poi, tendonStressingIntervalIdx, pgsTypes::Start, ductIdx);
            pProblem->AddFpe(vNames[i].c_str(), pAnalysisPoint->GetLocation(), Fpe, Xps, Yps);
         }
      }

      pProblem->AddAnalysisPoint(std::move(pAnalysisPoint));
   }
}

std::vector<std::tuple<Float64, Float64, std::_tstring>> CBridgeAgentImp::GetWebSections(const pgsPointOfInterest& poi) const
{
   USES_CONVERSION;
   std::vector<std::tuple<Float64, Float64, std::_tstring>> web_flange_intersections;

   CComPtr<IGirderSection> girder_section;
   HRESULT hr = GetGirderSection(poi, &girder_section);
   ATLASSERT(SUCCEEDED(hr));
   if (FAILED(hr))
   {
      return web_flange_intersections;
   }

   CComPtr<IDblArray> Y;
   CComPtr<IDblArray> W;
   CComPtr<IBstrArray> Description;
   CComQIPtr<IPrestressedGirderSection> psgSection(girder_section);
   psgSection->GetWebSections(&Y, &W, &Description);

   IndexType nY, nW, nD;
   Y->get_Count(&nY);
   W->get_Count(&nW);
   Description->get_Count(&nD);
   ATLASSERT(nY == nW);
   ATLASSERT(nY == nD);

   for (IndexType i = 0; i < nY; i++)
   {
      Float64 y;
      Float64 w;
      CComBSTR bstrDesc;
      Y->get_Item(i, &y);
      W->get_Item(i, &w);
      Description->get_Item(i, &bstrDesc);

      web_flange_intersections.emplace_back(y, w, OLE2T(bstrDesc));
   }

   std::sort(web_flange_intersections.begin(), web_flange_intersections.end(), std::greater<>());
   return web_flange_intersections;
}

void CBridgeAgentImp::GetSegmentBottomFlangeProfile(const CSegmentKey& segmentKey,bool bIncludeClosure,IPoint2dCollection** points) const
{
   GroupIndexType grpIdx = segmentKey.groupIndex;
   GirderIndexType gdrIdx = segmentKey.girderIndex;

   GET_IFACE(IBridgeDescription,pIBridgeDesc);
   const CSplicedGirderData* pGirder = pIBridgeDesc->GetBridgeDescription()->GetGirderGroup(grpIdx)->GetGirder(gdrIdx);
   GetSegmentBottomFlangeProfile(segmentKey,pGirder,bIncludeClosure,points);
}

void CBridgeAgentImp::GetSegmentBottomFlangeProfile(const CSegmentKey& segmentKey,const CSplicedGirderData* pGirder,bool bIncludeClosure,IPoint2dCollection** ppPoints) const
{
   Float64 xStart,xEnd;
   GetSegmentRange(segmentKey,&xStart,&xEnd);

   if ( segmentKey.segmentIndex == 0 )
   {
      // if this is the first segment, adjust the girder path coordinate so that it starts at the face of the segment
      Float64 brgOffset = GetSegmentStartBearingOffset(segmentKey);
      Float64 endDist   = GetSegmentStartEndDistance(segmentKey);
      Float64 offset_dist = brgOffset - endDist;
      offset_dist = IsZero(offset_dist) ? 0 : offset_dist;
      xStart += offset_dist;
   }

   SegmentIndexType nSegments = GetSegmentCount(segmentKey);
   if ( segmentKey.segmentIndex == nSegments-1 )
   {
      // if this is the last segment, adjust the girder path coordinate so that it end at the face of the segment
      Float64 brgOffset = GetSegmentEndBearingOffset(segmentKey);
      Float64 endDist   = GetSegmentEndEndDistance(segmentKey);
      Float64 offset_dist = brgOffset - endDist;
      offset_dist = IsZero(offset_dist) ? 0 : offset_dist;
      xEnd -= offset_dist;
   }

   // if not including closure joint, adjust the start/end locations to be
   // at the actual start/end of the segment
   if ( !bIncludeClosure )
   {
      Float64 startBrgOffset, endBrgOffset;
      GetSegmentBearingOffset(segmentKey,&startBrgOffset,&endBrgOffset);

      Float64 startEndDist, endEndDist;
      GetSegmentEndDistance(segmentKey,&startEndDist,&endEndDist);

      if ( segmentKey.segmentIndex != 0 )
      {
         xStart += startBrgOffset - startEndDist;
      }

      if ( segmentKey.segmentIndex != nSegments-1 )
      {
         xEnd -= endBrgOffset   - endEndDist;
      }
   }

   Float64 segmentLength = GetSegmentLayoutLength(segmentKey);

   auto girder_depth         = CreateGirderProfile(pGirder);
   auto bottom_flange_height = CreateGirderBottomFlangeProfile(pGirder);

   CComPtr<IPoint2dCollection> points;
   points.CoCreateInstance(CLSID_Point2dCollection);

   std::vector<Float64> xValues;

   const CPrecastSegmentData* pSegment = pGirder->GetSegment(segmentKey.segmentIndex);

   // Get variation lengths and convert from fractional measure if necessary (neg lengths are fractional)
   Float64 variationLength[4];
   for ( int i = 0; i < 4; i++ )
   {
      variationLength[i] = pSegment->GetVariationLength((pgsTypes::SegmentZoneType)i);
      if ( variationLength[i] < 0 )
      {
         ATLASSERT(-1.0 <= variationLength[i] && variationLength[i] <= 0.0);
         variationLength[i] *= -segmentLength;
      }
   }

   pgsTypes::SegmentVariationType variationType = pSegment->GetVariationType();
   if ( variationType == pgsTypes::svtLinear )
   {
      xValues.push_back(xStart + variationLength[pgsTypes::sztLeftPrismatic] );
      xValues.push_back(xEnd   - variationLength[pgsTypes::sztRightPrismatic] );
   }
   else if ( variationType == pgsTypes::svtParabolic )
   {
      Float64 xStartParabola = xStart + variationLength[pgsTypes::sztLeftPrismatic];
      Float64 xEndParabola   = xEnd   - variationLength[pgsTypes::sztRightPrismatic];
      xValues.push_back(xStartParabola);
      for ( int i = 0; i < 5; i++ )
      {
         Float64 x = i*(xEndParabola-xStartParabola)/5 + xStartParabola;
         xValues.push_back(x);
      }
      xValues.push_back(xEndParabola);
   }
   else if ( variationType == pgsTypes::svtDoubleLinear )
   {
      xValues.push_back(xStart + variationLength[pgsTypes::sztLeftPrismatic] );
      xValues.push_back(xStart + variationLength[pgsTypes::sztLeftPrismatic]  + variationLength[pgsTypes::sztLeftTapered] );
      xValues.push_back(xEnd   - variationLength[pgsTypes::sztRightPrismatic] - variationLength[pgsTypes::sztRightTapered] );
      xValues.push_back(xEnd   - variationLength[pgsTypes::sztRightPrismatic] );
   }
   else if ( variationType == pgsTypes::svtDoubleParabolic )
   {
      // left parabola
      Float64 xStartParabola = xStart + variationLength[pgsTypes::sztLeftPrismatic];
      Float64 xEndParabola   = xStart + variationLength[pgsTypes::sztLeftPrismatic]  + variationLength[pgsTypes::sztLeftTapered];

      xValues.push_back(xStartParabola);
      for ( int i = 0; i < 5; i++ )
      {
         Float64 x = i*(xEndParabola-xStartParabola)/5 + xStartParabola;
         xValues.push_back(x);
      }
      xValues.push_back(xEndParabola);

      // right parabola
      xStartParabola = xEnd   - variationLength[pgsTypes::sztRightPrismatic] - variationLength[pgsTypes::sztRightTapered];
      xEndParabola   = xEnd   - variationLength[pgsTypes::sztRightPrismatic];
      xValues.push_back(xStartParabola);
      for ( int i = 0; i < 5; i++ )
      {
         Float64 x = i*(xEndParabola-xStartParabola)/5 + xStartParabola;
         xValues.push_back(x);
      }
      xValues.push_back(xEndParabola);
   }

   // fill up with other points
   for ( int i = 0; i < 11; i++ )
   {
      Float64 x = i*(xEnd - xStart)/10 + xStart;
      xValues.push_back(x);
   }

   std::sort(xValues.begin(),xValues.end());

   std::vector<Float64>::iterator iter(xValues.begin());
   std::vector<Float64>::iterator end(xValues.end());
   for ( ; iter != end; iter++ )
   {
      Float64 x = *iter;
      Float64 y = -girder_depth->Evaluate(x) + bottom_flange_height->Evaluate(x);
      
      CComPtr<IPoint2d> point;
      point.CoCreateInstance(CLSID_Point2d);
      point->Move(x,y);
      points->Add(point);
   }

   points.CopyTo(ppPoints);
}

std::shared_ptr<WBFL::Math::Function> CBridgeAgentImp::CreateGirderProfile(const CSplicedGirderData* pGirder) const
{
   return CreateGirderProfile(pGirder,true);
}

std::shared_ptr<WBFL::Math::Function> CBridgeAgentImp::CreateGirderBottomFlangeProfile(const CSplicedGirderData* pGirder) const
{
   return CreateGirderProfile(pGirder,false);
}

std::shared_ptr<WBFL::Math::Function> CBridgeAgentImp::CreateGirderProfile(const CSplicedGirderData* pGirder,bool bGirderProfile) const
{
   auto pCompositeFunction( std::make_shared<WBFL::Math::CompositeFunction>() );

   GET_IFACE(IBridgeDescription,pIBridgeDesc);
   const CBridgeDescription2* pBridgeDesc = pIBridgeDesc->GetBridgeDescription();

   GroupIndexType grpIdx = pGirder->GetGirderGroupIndex();
   GirderIndexType gdrIdx = pGirder->GetIndex();
   CSegmentKey segmentKey(grpIdx,gdrIdx,INVALID_INDEX);

   Float64 xSegmentStart = 0; // start of segment
   Float64 xStart        = 0; // start of curve section
   Float64 xEnd          = 0; // end of curve section

   bool bParabola = false;
   Float64 xParabolaStart,xParabolaEnd;
   Float64 yParabolaStart,yParabolaEnd;
   Float64 slopeParabola = 0;

   // go down each segment and create piece-wise functions for each part of the spliced girder profile
   SegmentIndexType nSegments = pGirder->GetSegmentCount();
   for ( SegmentIndexType segIdx = 0; segIdx < nSegments; segIdx++ )
   {
      segmentKey.segmentIndex = segIdx;

      const CPrecastSegmentData* pSegment = pGirder->GetSegment(segIdx);

      pgsTypes::SegmentVariationType  variation_type = pSegment->GetVariationType();

      Float64 segment_length = GetSegmentLayoutLength(segmentKey);
      if ( segIdx == 0 )
      {
         // start at face of first segment
         Float64 brgOffset = GetSegmentStartBearingOffset(segmentKey);
         Float64 endDist   = GetSegmentStartEndDistance(segmentKey);
         Float64 offset_dist = brgOffset - endDist;
         offset_dist = IsZero(offset_dist) ? 0 : offset_dist;
         xSegmentStart = offset_dist;
         segment_length -= offset_dist;
      }

      if ( segIdx == nSegments-1 )
      {
         Float64 brgOffset = GetSegmentEndBearingOffset(segmentKey);
         Float64 endDist   = GetSegmentEndEndDistance(segmentKey);
         Float64 offset_dist = brgOffset - endDist;
         offset_dist = IsZero(offset_dist) ? 0 : offset_dist;
         segment_length -= offset_dist;
      }

      xStart = xSegmentStart;

      if (variation_type == pgsTypes::svtNone)
      {
         Float64 h1, h2;
         if (bGirderProfile)
         {
            // we are creating a girder profile
            h1 = GetSegmentHeight(pSegment, 0.0);
            h2 = GetSegmentHeight(pSegment, segment_length);
         }
         else
         {
            // we are creating a bottom flange profile
            h1 = pSegment->GetVariationBottomFlangeDepth(pgsTypes::sztLeftPrismatic);
            h2 = h1;
         }
         
         xEnd = xStart + segment_length;
         if (!bGirderProfile || IsZero(pSegment->Precamber))
         {
            Float64 slope = (h2 - h1) / segment_length;
            WBFL::Math::LinearFunction func(slope, h1);
            pCompositeFunction->AddFunction(xStart, xEnd, func);
         }
         else
         {
            // NOTE: Tricky... using negative of precamber to make this parabola
            // the callers of this method use the negative of the value return
            // from the function to get the profile based on the top of the girder
            // being at zero. That negative cancels out the negative used here and we
            // get the profile we want
            auto func(GenerateParabola(xStart, xEnd, -pSegment->Precamber, h1));
            pCompositeFunction->AddFunction(xStart, xEnd, func);
         }
         slopeParabola = 0;
         xStart = xEnd;
      }
      else
      {
         std::array<Float64, 4> variation_length{
         pSegment->GetVariationLength(pgsTypes::sztLeftPrismatic),
         pSegment->GetVariationLength(pgsTypes::sztLeftTapered),
         pSegment->GetVariationLength(pgsTypes::sztRightTapered),
         pSegment->GetVariationLength(pgsTypes::sztRightPrismatic) };

         // deal with fractional measure
         ResolveFractionalDistance(variation_length, segment_length);

         Float64 h1, h2, h3, h4;
         if (bGirderProfile)
         {
            // we are creating a girder profile
            h1 = pSegment->GetVariationHeight(pgsTypes::sztLeftPrismatic);
            h2 = pSegment->GetVariationHeight(pgsTypes::sztRightPrismatic);
            h3 = pSegment->GetVariationHeight(pgsTypes::sztLeftTapered);
            h4 = pSegment->GetVariationHeight(pgsTypes::sztRightTapered);
         }
         else
         {
            // we are creating a bottom flange profile
            h1 = pSegment->GetVariationBottomFlangeDepth(pgsTypes::sztLeftPrismatic);
            h2 = pSegment->GetVariationBottomFlangeDepth(pgsTypes::sztRightPrismatic);
            h3 = pSegment->GetVariationBottomFlangeDepth(pgsTypes::sztLeftTapered);
            h4 = pSegment->GetVariationBottomFlangeDepth(pgsTypes::sztRightTapered);
         }

         if (0 < variation_length[pgsTypes::sztLeftPrismatic])
         {
            // create a prismatic segment
            WBFL::Math::LinearFunction func(0.0, h1);
            xEnd = xStart + (variation_type == pgsTypes::svtNone ? segment_length / 2 : variation_length[pgsTypes::sztLeftPrismatic]);
            pCompositeFunction->AddFunction(xStart, xEnd, func);
            slopeParabola = 0;
            xStart = xEnd;
         }

         if (variation_type == pgsTypes::svtLinear)
         {
            // create a linear taper segment
            Float64 taper_length = segment_length - variation_length[pgsTypes::sztLeftPrismatic] - variation_length[pgsTypes::sztRightPrismatic];
            Float64 slope = (h2 - h1) / taper_length;
            Float64 b = h1 - slope*xStart;

            WBFL::Math::LinearFunction func(slope, b);
            xEnd = xStart + taper_length;
            pCompositeFunction->AddFunction(xStart, xEnd, func);
            xStart = xEnd;
            slopeParabola = slope;
         }
         else if (variation_type == pgsTypes::svtDoubleLinear)
         {
            // create a linear taper for left side of segment
            Float64 slope = (h3 - h1) / variation_length[pgsTypes::sztLeftTapered];
            Float64 b = h1 - slope*xStart;

            WBFL::Math::LinearFunction left_func(slope, b);
            xEnd = xStart + variation_length[pgsTypes::sztLeftTapered];
            pCompositeFunction->AddFunction(xStart, xEnd, left_func);
            xStart = xEnd;

            // create a linear segment between left and right tapers
            Float64 taper_length = segment_length - std::accumulate(std::begin(variation_length), std::end(variation_length), 0.0);
            slope = (h4 - h3) / taper_length;
            b = h3 - slope*xStart;

            WBFL::Math::LinearFunction middle_func(slope, b);
            xEnd = xStart + taper_length;
            pCompositeFunction->AddFunction(xStart, xEnd, middle_func);
            xStart = xEnd;

            // create a linear taper for right side of segment
            slope = (h2 - h4) / variation_length[pgsTypes::sztRightTapered];
            b = h4 - slope*xStart;

            WBFL::Math::LinearFunction right_func(slope, b);
            xEnd = xStart + variation_length[pgsTypes::sztRightTapered];
            pCompositeFunction->AddFunction(xStart, xEnd, right_func);
            xStart = xEnd;
            slopeParabola = slope;
         }
         else if (variation_type == pgsTypes::svtParabolic)
         {
            if (!bParabola)
            {
               // this is the start of a parabolic segment
               bParabola = true;
               xParabolaStart = xStart;
               yParabolaStart = h1;
            }

            // Parabola ends in this segment if
            // 1) this segment has a prismatic segment on the right end -OR-
            // 2) this is the last segment -OR-
            // 3) the next segment starts with a prismatic segment -OR-
            // 4) the next segment has a linear transition

            const CPrecastSegmentData* pNextSegment = (segIdx == nSegments - 1 ? nullptr : pGirder->GetSegment(segIdx + 1));

            Float64 next_segment_left_prismatic_length = (pNextSegment ? pNextSegment->GetVariationLength(pgsTypes::sztLeftPrismatic) : 0);
            if (next_segment_left_prismatic_length < 0)
            {
               ATLASSERT(-1.0 <= next_segment_left_prismatic_length && next_segment_left_prismatic_length < 0.0);
               next_segment_left_prismatic_length *= -GetSegmentLayoutLength(pNextSegment->GetSegmentKey());
            }

            if (
               0 < variation_length[pgsTypes::sztRightPrismatic] || // parabola ends in this segment -OR-
               segIdx == nSegments - 1 || // this is the last segment (parabola ends here) -OR-
               0 < next_segment_left_prismatic_length || // next segment starts with prismatic section -OR-
               (pNextSegment->GetVariationType() == pgsTypes::svtNone || pNextSegment->GetVariationType() == pgsTypes::svtLinear || pNextSegment->GetVariationType() == pgsTypes::svtDoubleLinear) // next segment is linear 
               )
            {
               // parabola ends in this segment
               Float64 xParabolaEnd = xStart + segment_length - variation_length[pgsTypes::sztRightPrismatic];
               Float64 yParabolaEnd = h2;

               if (yParabolaEnd < yParabolaStart)
               {
                  // slope at end is zero
                  auto func = GenerateParabola2(xParabolaStart, yParabolaStart, xParabolaEnd, yParabolaEnd, 0.0);
                  pCompositeFunction->AddFunction(xParabolaStart, xParabolaEnd, func);
               }
               else
               {
                  // slope at start is zero
                  auto func = GenerateParabola1(xParabolaStart, yParabolaStart, xParabolaEnd, yParabolaEnd, slopeParabola);
                  pCompositeFunction->AddFunction(xParabolaStart, xParabolaEnd, func);
               }

               bParabola = false;
               xStart = xParabolaEnd;
            }
            else
            {
               // parabola ends further down the girderline
               // do nothing???
            }
         }
         else if (variation_type == pgsTypes::svtDoubleParabolic)
         {
            // left parabola ends in this segment
            if (!bParabola)
            {
               // not currently in a parabola, based the start point on this segment
               xParabolaStart = xSegmentStart + variation_length[pgsTypes::sztLeftPrismatic];
               yParabolaStart = h1;
            }

#pragma Reminder("BUG: Assuming slope at start is zero, but it may not be if tangent to a linear segment")
            xParabolaEnd = xSegmentStart + variation_length[pgsTypes::sztLeftPrismatic] + variation_length[pgsTypes::sztLeftTapered];
            yParabolaEnd = h3;
            WBFL::Math::PolynomialFunction func_left_parabola;
            if (yParabolaEnd < yParabolaStart)
            {
               func_left_parabola = GenerateParabola2(xParabolaStart, yParabolaStart, xParabolaEnd, yParabolaEnd, 0.0);
            }
            else
            {
               func_left_parabola = GenerateParabola1(xParabolaStart, yParabolaStart, xParabolaEnd, yParabolaEnd, slopeParabola);
            }

            pCompositeFunction->AddFunction(xParabolaStart, xParabolaEnd, func_left_parabola);

            // parabola on right side of this segment starts here
            xParabolaStart = xSegmentStart + segment_length - variation_length[pgsTypes::sztRightPrismatic] - variation_length[pgsTypes::sztRightTapered];
            yParabolaStart = h4;
            bParabola = true;

            if (!IsZero(xParabolaStart - xParabolaEnd))
            {
               // create a line segment between parabolas
               Float64 taper_length = segment_length - std::accumulate(std::begin(variation_length), std::end(variation_length), 0.0);
               Float64 slope = -(h4 - h3) / taper_length;
               Float64 b = h3 - slope*xParabolaEnd;

               WBFL::Math::LinearFunction middle_func(slope, b);
               pCompositeFunction->AddFunction(xParabolaEnd, xParabolaStart, middle_func);
               slopeParabola = slope;
            }

            // parabola ends in this segment if
            // 1) this is the last segment
            // 2) right prismatic section length > 0
            // 3) next segment is not parabolic
            const CPrecastSegmentData* pNextSegment = (segIdx == nSegments - 1 ? nullptr : pGirder->GetSegment(segIdx + 1));
            if (0 < variation_length[pgsTypes::sztRightPrismatic] ||
               segIdx == nSegments - 1 ||
               (pNextSegment->GetVariationType() == pgsTypes::svtNone || pNextSegment->GetVariationType() == pgsTypes::svtLinear || pNextSegment->GetVariationType() == pgsTypes::svtDoubleLinear) // next segment is linear 
               )
            {
               bParabola = false;
               xParabolaEnd = xSegmentStart + segment_length - variation_length[pgsTypes::sztRightPrismatic];
               yParabolaEnd = h2;


               WBFL::Math::PolynomialFunction func_right_parabola;
               if (yParabolaEnd < yParabolaStart)
               {
                  // compute slope at end of parabola
                  if (pNextSegment)
                  {
                     CSegmentKey nextSegmentKey(segmentKey);
                     nextSegmentKey.segmentIndex++;

                     Float64 next_segment_length = GetSegmentLayoutLength(nextSegmentKey);
                     Float64 next_segment_left_prismatic_length = pNextSegment->GetVariationLength(pgsTypes::sztLeftPrismatic);
                     if (next_segment_left_prismatic_length < 0)
                     {
                        ATLASSERT(-1.0 <= next_segment_left_prismatic_length && next_segment_left_prismatic_length < 0.0);
                        next_segment_left_prismatic_length *= -next_segment_length;
                     }

                     Float64 next_segment_right_prismatic_length = pNextSegment->GetVariationLength(pgsTypes::sztRightPrismatic);
                     if (next_segment_right_prismatic_length < 0)
                     {
                        ATLASSERT(-1.0 <= next_segment_right_prismatic_length && next_segment_right_prismatic_length < 0.0);
                        next_segment_right_prismatic_length *= -next_segment_length;
                     }

                     Float64 next_segment_left_tapered_length = pNextSegment->GetVariationLength(pgsTypes::sztLeftTapered);
                     if (next_segment_left_tapered_length < 0)
                     {
                        ATLASSERT(-1.0 <= next_segment_left_tapered_length && next_segment_left_tapered_length < 0.0);
                        next_segment_left_tapered_length *= -next_segment_length;
                     }

                     if (pNextSegment->GetVariationType() == pgsTypes::svtLinear)
                     {
                        // next segment is linear
                        if (IsZero(next_segment_left_prismatic_length))
                        {
                           Float64 dist = next_segment_length - next_segment_left_prismatic_length - next_segment_right_prismatic_length;
                           slopeParabola = (pNextSegment->GetVariationHeight(pgsTypes::sztRightPrismatic) - pNextSegment->GetVariationHeight(pgsTypes::sztLeftPrismatic)) / dist;
                        }
                     }
                     else if (pNextSegment->GetVariationType() == pgsTypes::svtDoubleLinear)
                     {
                        if (IsZero(next_segment_left_prismatic_length))
                        {
                           Float64 dist = next_segment_left_tapered_length;
                           slopeParabola = (pNextSegment->GetVariationHeight(pgsTypes::sztLeftTapered) - pNextSegment->GetVariationHeight(pgsTypes::sztLeftPrismatic)) / dist;
                        }
                     }
                  }
                  else
                  {
                     slopeParabola = 0;
                  }
                  func_right_parabola = GenerateParabola2(xParabolaStart, yParabolaStart, xParabolaEnd, yParabolaEnd, slopeParabola);
               }
               else
               {
                  func_right_parabola = GenerateParabola1(xParabolaStart, yParabolaStart, xParabolaEnd, yParabolaEnd, slopeParabola);
               }

               pCompositeFunction->AddFunction(xParabolaStart, xParabolaEnd, func_right_parabola);
            }
            else
            {
               // parabola ends further down the girderline
               bParabola = true;
            }

            xStart = xSegmentStart + segment_length - variation_length[pgsTypes::sztRightPrismatic];
         }

         if (0 < variation_length[pgsTypes::sztRightPrismatic])
         {
            // create a prismatic segment
            WBFL::Math::LinearFunction func(0.0, h2);
            xEnd = xStart + (variation_type == pgsTypes::svtNone ? segment_length / 2 : variation_length[pgsTypes::sztRightPrismatic]);
            pCompositeFunction->AddFunction(xStart, xEnd, func);
            slopeParabola = 0;
            xStart = xEnd;
         }
      }
      xSegmentStart += segment_length;
   }

   return pCompositeFunction;
}

void CBridgeAgentImp::GetSegmentRange(const CSegmentKey& segmentKey,Float64* pXgpStart,Float64* pXgpEnd) const
{
   // Returns the start and end of the segment in Girder Path Coordiantes
   CSegmentKey firstSegmentKey(segmentKey);
   firstSegmentKey.segmentIndex = 0;

   *pXgpStart = 0;

   // adding layout length of all preceeding segments will get us to the start of this segment
   for ( SegmentIndexType s = 0; s < segmentKey.segmentIndex; s++ )
   {
      CSegmentKey key(segmentKey.groupIndex,segmentKey.girderIndex,s);
      *pXgpStart += GetSegmentLayoutLength(key);
   }

   *pXgpEnd = *pXgpStart + GetSegmentLayoutLength(segmentKey);
}

void CBridgeAgentImp::GetSegmentDirection(const CSegmentKey& segmentKey,IDirection** ppDirection) const
{
   VALIDATE(BRIDGE);

   CComPtr<IGirderLine> girderLine;
   GetGirderLine(segmentKey,&girderLine);

   girderLine->get_Direction(ppDirection);
}

///////////////////////////////////////////////////////////////////////////////////////////
// IGirderTendonGeometry
void CBridgeAgentImp::GetDuctCenterline(const CGirderKey& girderKey,DuctIndexType ductIdx,IPoint2dCollection** ppPoints) const
{
   // Gets the duct centerline from the generic bridge model
   CComPtr<IPoint2dCollection> points;
   points.CoCreateInstance(CLSID_Point2dCollection);

   CComPtr<ISuperstructureMember> ssMbr;
   GetSuperstructureMember(girderKey,&ssMbr);

   CComQIPtr<IItemData> itemData(ssMbr);
   CComPtr<IUnknown> unk;
   itemData->GetItemData(CComBSTR(_T("Tendons")),&unk);

   CComQIPtr<ITendonCollection> tendons(unk);

   CComPtr<ITendon> tendon;
   tendons->get_Item(ductIdx,&tendon);

   CComPtr<IPoint3dCollection> centerline;
   tendon->get_Centerline(tmPath,&centerline);

   CComPtr<IEnumPoint3d> enumPoints;
   centerline->get__Enum(&enumPoints);
   CComPtr<IPoint3d> point;
   while ( enumPoints->Next(1,&point,nullptr) != S_FALSE )
   {
      Float64 x,y,z;
      point->Location(&x,&y,&z);

      CComPtr<IPoint2d> p;
      p.CoCreateInstance(CLSID_Point2d);
      p->Move(z,y);
      
      points->Add(p);

      point.Release();
   }

   points.CopyTo(ppPoints);
}

void CBridgeAgentImp::GetDuctCenterline(const CGirderKey& girderKey,DuctIndexType ductIdx,IPoint3dCollection** ppPoints) const
{
   // Gets the duct centerline from the generic bridge model
   CComPtr<ISuperstructureMember> ssMbr;
   GetSuperstructureMember(girderKey,&ssMbr);

   CComQIPtr<IItemData> itemData(ssMbr);
   CComPtr<IUnknown> unk;
   itemData->GetItemData(CComBSTR(_T("Tendons")),&unk);

   CComQIPtr<ITendonCollection> tendons(unk);

   CComPtr<ITendon> tendon;
   tendons->get_Item(ductIdx,&tendon);

   tendon->get_Centerline(tmPath,ppPoints);
}

DuctIndexType CBridgeAgentImp::GetDuctCount(const CGirderKey& girderKey) const
{
   CComPtr<ISuperstructureMember> ssMbr;
   GetSuperstructureMember(girderKey,&ssMbr);

   CComQIPtr<IItemData> itemData(ssMbr);

   CComPtr<IUnknown> unk;
   itemData->GetItemData(CComBSTR(_T("Tendons")),&unk);
   if (unk)
   {
      CComQIPtr<ITendonCollection> tendons(unk);

      DuctIndexType nDucts;
      tendons->get_Count(&nDucts);
      return nDucts;
   }
   else
   {
      return 0;
   }
}

void CBridgeAgentImp::GetDuctRange(const CGirderKey& girderKey, DuctIndexType ductIdx, Float64* pXgs, Float64* pXge) const
{
   CComPtr<ISuperstructureMember> ssMbr;
   GetSuperstructureMember(girderKey, &ssMbr);

   CComQIPtr<IItemData> itemData(ssMbr);

   CComPtr<IUnknown> unk;
   itemData->GetItemData(CComBSTR(_T("Tendons")), &unk);
   if (unk)
   {
      CComQIPtr<ITendonCollection> tendons(unk);

      CComPtr<ITendon> tendon;
      tendons->get_Item(ductIdx, &tendon);

      CComPtr<IPoint3d> pntStart, pntEnd;
      tendon->get_Start(&pntStart);
      tendon->get_End(&pntEnd);

      pntStart->get_Z(pXgs);
      pntEnd->get_Z(pXge);
   }
   else
   {
      *pXgs = 0;
      *pXge = GetGirderLength(girderKey);
   }
}

bool CBridgeAgentImp::IsOnDuct(const pgsPointOfInterest& poi, DuctIndexType ductIdx) const
{
   CComPtr<ISuperstructureMember> ssMbr;
   GetSuperstructureMember(poi.GetSegmentKey(), &ssMbr);

   CComQIPtr<IItemData> itemData(ssMbr);

   CComPtr<IUnknown> unk;
   itemData->GetItemData(CComBSTR(_T("Tendons")), &unk);
   if (unk)
   {
      CComQIPtr<ITendonCollection> tendons(unk);

      CComPtr<ITendon> tendon;
      tendons->get_Item(ductIdx, &tendon);

      CComPtr<IPoint3d> pntStart, pntEnd;
      tendon->get_Start(&pntStart);
      tendon->get_End(&pntEnd);

      Float64 Xgs, Xge;
      pntStart->get_Z(&Xgs);
      pntEnd->get_Z(&Xge);

      Float64 Xg = ConvertPoiToGirderCoordinate(poi);
      if (InRange(Xgs, Xg, Xge))
      {
         // maybe on the duct... check the end points
         if (IsEqual(Xgs, Xg))
         {
            return poi.HasAttribute(POI_DUCT_START);
         }
         else if (IsEqual(Xg, Xge))
         {
            return poi.HasAttribute(POI_DUCT_END);
         }
         else
         {
            // Xg is somewhere in the middle of the duct
            return true;
         }
      }
   }

   // if we got this far, the POI is out of range, or in range and at the end, but doesn't have the correct attribute
   return false;
}

void CBridgeAgentImp::GetDuctCenterline(const CGirderKey& girderKey, const CSplicedGirderData* pGirder, DuctIndexType ductIdx, const CPTData* pPTData, IPoint2dCollection** ppPoints) const
{
   const CDuctData* pDuctData = pPTData->GetDuct(ductIdx);
   GetDuctCenterline(girderKey, pGirder, pDuctData, ppPoints);
}

void CBridgeAgentImp::GetDuctCenterline(const CGirderKey& girderKey, const CSplicedGirderData* pGirder,const CDuctData* pDuctData, IPoint2dCollection** ppPoints) const
{
   ATLASSERT(pGirder ? girderKey == pGirder->GetGirderKey() : true); // if a girder is supplied, it must be the same girder as girder key
   switch (pDuctData->DuctGeometryType)
   {
   case CDuctGeometry::Linear:
      CreateDuctCenterline(girderKey, pGirder, pDuctData->LinearDuctGeometry, ppPoints);
      break;

   case CDuctGeometry::Parabolic:
      CreateDuctCenterline(girderKey, pGirder, pDuctData->ParabolicDuctGeometry, ppPoints);
      break;

   case CDuctGeometry::Offset:
      ATLASSERT(false); // this isn't supported
                        //GetDuctCenterline(girderKey,pDuctData->OffsetDuctGeometry.RefDuctIdx,pGirder,ppPoints); // instead of pGirder, we need pDuct for the source of the offset
                        //CreateDuctCenterline(girderKey,pDuctData->OffsetDuctGeometry,ppPoints);
      break;
   }
}

std::unique_ptr<WBFL::Math::CompositeFunction> CBridgeAgentImp::CreateDuctCenterline(const CGirderKey& girderKey,const CSplicedGirderData* pGirder,const CLinearDuctGeometry& geometry) const
{
   auto fnCenterline(std::make_unique<WBFL::Math::CompositeFunction>());

   Float64 x1 = 0;
   Float64 y1 = 0;
   CollectionIndexType nPoints = geometry.GetPointCount();
   for ( CollectionIndexType idx = 1; idx < nPoints; idx++ )
   {
      Float64 distFromPrev;
      Float64 offset;
      CDuctGeometry::OffsetType offsetType;
      geometry.GetPoint(idx-1,&distFromPrev,&offset,&offsetType);

      x1 += distFromPrev;
      y1 = ConvertDuctOffsetToDuctElevation(girderKey,pGirder,x1,offset,offsetType);

      geometry.GetPoint(idx,&distFromPrev,&offset,&offsetType);

      Float64 x2,y2;
      x2 = x1 + distFromPrev;
      y2 = ConvertDuctOffsetToDuctElevation(girderKey,pGirder,x2,offset,offsetType);

      Float64 m = (y2-y1)/(x2-x1);
      Float64 b = y2 - m*x2;

      WBFL::Math::LinearFunction fn(m, b);

      fnCenterline->AddFunction(x1,x2,fn);

      x1 = x2;
      y1 = y2;
   }

   return fnCenterline;
}

void CBridgeAgentImp::CreateDuctCenterline(const CGirderKey& girderKey,const CSplicedGirderData* pGirder,const CLinearDuctGeometry& geometry,IPoint2dCollection** ppPoints) const
{
   CComPtr<IPoint2dCollection> points;
   points.CoCreateInstance(CLSID_Point2dCollection);
   points.CopyTo(ppPoints);

   Float64 Lg = GetGirderLength(girderKey);

   Float64 Xg = 0;

   CollectionIndexType nPoints = geometry.GetPointCount();
   for ( CollectionIndexType idx = 0; idx < nPoints; idx++ )
   {
      Float64 location;
      Float64 offset;
      CDuctGeometry::OffsetType offsetType;
      geometry.GetPoint(idx,&location,&offset,&offsetType);

      if ( geometry.GetMeasurementType() == CLinearDuctGeometry::FromPrevious )
      {
         Xg += location;
      }
      else
      {
         if ( location < 0 )
         {
            // location is fractional
            location *= -Lg;
         }

         Xg = location;
      }

      Float64 y = ConvertDuctOffsetToDuctElevation(girderKey,pGirder,Xg,offset,offsetType);

      CComPtr<IPoint2d> point;
      point.CoCreateInstance(CLSID_Point2d);
      point->Move(Xg,y);
      points->Add(point);
   }
}

void CBridgeAgentImp::GetGirderDuctPoint(const pgsPointOfInterest& poi,DuctIndexType ductIdx,IPoint2d** ppPoint) const
{
   ATLASSERT(IsOnGirder(poi));
   Float64 Xg = ConvertPoiToGirderCoordinate(poi);
   const CGirderKey& girderKey(poi.GetSegmentKey());
   GetGirderDuctPoint(girderKey,Xg,ductIdx,ppPoint);
}

void CBridgeAgentImp::GetGirderDuctPoint(const CGirderKey& girderKey,Float64 Xg,DuctIndexType ductIdx,IPoint2d** ppPoint) const
{
   CComPtr<ISuperstructureMember> ssMbr;
   GetSuperstructureMember(girderKey,&ssMbr);

   CComQIPtr<IItemData> itemData(ssMbr);

   CComPtr<IUnknown> unk;
   itemData->GetItemData(CComBSTR(_T("Tendons")),&unk);

   CComQIPtr<ITendonCollection> tendons(unk);
   CComPtr<ITendon> tendon;
   tendons->get_Item(ductIdx,&tendon);

   Float64 Xgs, Xge;
   GetDuctRange(girderKey, ductIdx, &Xgs, &Xge);
   if (InRange(Xgs, Xg, Xge))
   {
      CComPtr<IPoint3d> cg;
      tendon->get_CG(Xg, tmPath, &cg);

      Float64 x, y, z;
      cg->Location(&x, &y, &z);
      ATLASSERT(IsEqual(z, Xg));

      CComPtr<IPoint2d> pnt;
      pnt.CoCreateInstance(CLSID_Point2d);
      pnt->Move(x, y);

      pnt.CopyTo(ppPoint);
   }
}

Float64 CBridgeAgentImp::GetOutsideDiameter(const CGirderKey& girderKey,DuctIndexType ductIdx) const
{
   CComPtr<ISuperstructureMember> ssMbr;
   GetSuperstructureMember(girderKey,&ssMbr);

   CComQIPtr<IItemData> itemData(ssMbr);

   CComPtr<IUnknown> unk;
   itemData->GetItemData(CComBSTR(_T("Tendons")),&unk);

   CComQIPtr<ITendonCollection> tendons(unk);
   CComPtr<ITendon> tendon;
   tendons->get_Item(ductIdx,&tendon);

   Float64 dia;
   tendon->get_OutsideDiameter(&dia);

   return dia;
}

Float64 CBridgeAgentImp::GetInsideDiameter(const CGirderKey& girderKey,DuctIndexType ductIdx) const
{
   CComPtr<ISuperstructureMember> ssMbr;
   GetSuperstructureMember(girderKey,&ssMbr);

   CComQIPtr<IItemData> itemData(ssMbr);

   CComPtr<IUnknown> unk;
   itemData->GetItemData(CComBSTR(_T("Tendons")),&unk);

   CComQIPtr<ITendonCollection> tendons(unk);
   CComPtr<ITendon> tendon;
   tendons->get_Item(ductIdx,&tendon);

   Float64 dia;
   tendon->get_InsideDiameter(&dia);

   return dia;
}

Float64 CBridgeAgentImp::GetNominalDiameter(const CGirderKey& girderKey, DuctIndexType ductIdx) const
{
   CComPtr<ISuperstructureMember> ssMbr;
   GetSuperstructureMember(girderKey, &ssMbr);

   CComQIPtr<IItemData> itemData(ssMbr);

   CComPtr<IUnknown> unk;
   itemData->GetItemData(CComBSTR(_T("Tendons")), &unk);

   CComQIPtr<ITendonCollection> tendons(unk);
   CComPtr<ITendon> tendon;
   tendons->get_Item(ductIdx, &tendon);

   Float64 dia;
   tendon->get_NominalDiameter(&dia);

   return dia;
}

Float64 CBridgeAgentImp::GetInsideDuctArea(const CGirderKey& girderKey,DuctIndexType ductIdx) const
{
   CComPtr<ISuperstructureMember> ssMbr;
   GetSuperstructureMember(girderKey,&ssMbr);

   CComQIPtr<IItemData> itemData(ssMbr);

   CComPtr<IUnknown> unk;
   itemData->GetItemData(CComBSTR(_T("Tendons")),&unk);

   CComQIPtr<ITendonCollection> tendons(unk);
   CComPtr<ITendon> tendon;
   tendons->get_Item(ductIdx,&tendon);

   Float64 Aduct;
   tendon->get_InsideDuctArea(&Aduct);

   return Aduct;
}

StrandIndexType CBridgeAgentImp::GetTendonStrandCount(const CGirderKey& girderKey,DuctIndexType ductIdx) const
{
   CComPtr<ISuperstructureMember> ssMbr;
   GetSuperstructureMember(girderKey,&ssMbr);

   CComQIPtr<IItemData> itemData(ssMbr);

   CComPtr<IUnknown> unk;
   itemData->GetItemData(CComBSTR(_T("Tendons")),&unk);

   CComQIPtr<ITendonCollection> tendons(unk);
   CComPtr<ITendon> tendon;
   tendons->get_Item(ductIdx,&tendon);

   StrandIndexType nStrands;
   tendon->get_StrandCount(&nStrands);

   return nStrands;
}

Float64 CBridgeAgentImp::GetGirderTendonArea(const CGirderKey& girderKey,IntervalIndexType intervalIdx,DuctIndexType ductIdx) const
{
   if ( intervalIdx < GetStressGirderTendonInterval(girderKey,ductIdx) )
   {
      return 0;
   }

   CComPtr<ISuperstructureMember> ssMbr;
   GetSuperstructureMember(girderKey,&ssMbr);

   CComQIPtr<IItemData> itemData(ssMbr);

   CComPtr<IUnknown> unk;
   itemData->GetItemData(CComBSTR(_T("Tendons")),&unk);

   CComQIPtr<ITendonCollection> tendons(unk);
   CComPtr<ITendon> tendon;
   tendons->get_Item(ductIdx,&tendon);

   Float64 Apt;
   tendon->get_TendonArea(&Apt);

   return Apt;
}

Float64 CBridgeAgentImp::GetPjack(const CGirderKey& girderKey,DuctIndexType ductIdx) const
{
   GET_IFACE(IBridgeDescription,pIBridgeDesc);
   const CPTData* pPTData = pIBridgeDesc->GetPostTensioning(girderKey);
   WebIndexType nWebs = GetWebCount(girderKey);
   return pPTData->GetPjack(ductIdx/nWebs);
}

Float64 CBridgeAgentImp::GetFpj(const CGirderKey& girderKey,DuctIndexType ductIdx) const
{
   Float64 Pj = GetPjack(girderKey,ductIdx);
   IntervalIndexType stressTendonIntervalIdx = GetStressGirderTendonInterval(girderKey,ductIdx);
   Float64 Apt = GetGirderTendonArea(girderKey,stressTendonIntervalIdx,ductIdx);
   return (IsZero(Apt) ? 0 : Pj/Apt);
}

Float64 CBridgeAgentImp::GetGirderDuctOffset(IntervalIndexType intervalIdx,const pgsPointOfInterest& poi,DuctIndexType ductIdx) const
{
   // Returns the distance from the top of the non-composite girder to the CG of the tendon

   // if interval is before tendon is installed, there isn't an eccentricity with respect to the girder cross section
   if ( intervalIdx < GetStressGirderTendonInterval(poi.GetSegmentKey(),ductIdx) )
   {
      return 0;
   }

   if ( !IsOnGirder(poi) )
   {
      return 0;
   }

   CComPtr<ISuperstructureMember> ssMbr;
   GetSuperstructureMember(poi.GetSegmentKey(),&ssMbr);

   CComQIPtr<IItemData> itemData(ssMbr);

   CComPtr<IUnknown> unk;
   itemData->GetItemData(CComBSTR(_T("Tendons")),&unk);

   CComQIPtr<ITendonCollection> tendons(unk);
   CComPtr<ITendon> tendon;
   tendons->get_Item(ductIdx,&tendon);

   StrandIndexType nStrands;
   tendon->get_StrandCount(&nStrands);
   if ( nStrands == 0 )
   {
      return 0;
   }

   Float64 Xg = ConvertPoiToGirderCoordinate(poi);
   CComPtr<IPoint3d> cg;
   tendon->get_CG(Xg,tmTendon /*account for tendon offset from center of duct*/,&cg);

   Float64 ecc;
   cg->get_Y(&ecc); // this is in Girder Section Coordinates so it should be < 0 if below top of girder
   ATLASSERT(ecc <= 0);

   return ecc;
}

Float64 CBridgeAgentImp::GetDuctLength(const CGirderKey& girderKey,DuctIndexType ductIdx) const
{
   CComPtr<ISuperstructureMember> ssMbr;
   GetSuperstructureMember(girderKey,&ssMbr);

   CComQIPtr<IItemData> itemData(ssMbr);

   CComPtr<IUnknown> unk;
   itemData->GetItemData(CComBSTR(_T("Tendons")),&unk);

   CComQIPtr<ITendonCollection> tendons(unk);
   CComPtr<ITendon> tendon;
   tendons->get_Item(ductIdx,&tendon);

   Float64 length;
   tendon->get_Length(&length);
   return length;
}

void CBridgeAgentImp::GetGirderTendonEccentricity(IntervalIndexType intervalIdx,const pgsPointOfInterest& poi,DuctIndexType ductIdx,Float64* pEccX,Float64* pEccY) const
{
   pgsTypes::SectionPropertyType sectPropType = GetSectionPropertiesType();
   GetGirderTendonEccentricity(sectPropType,intervalIdx,poi,ductIdx,pEccX,pEccY);
}

void CBridgeAgentImp::GetGirderTendonEccentricity(pgsTypes::SectionPropertyType spType,IntervalIndexType intervalIdx,const pgsPointOfInterest& poi,DuctIndexType ductIdx, Float64* pEccX, Float64* pEccY) const
{
   ATLASSERT(ductIdx != INVALID_INDEX);

   // if interval is before tendon is installed, there isn't an eccentricity with respect to the girder cross section
   IntervalIndexType stressTendonIntervalIdx = GetStressGirderTendonInterval(poi.GetSegmentKey(),ductIdx);
   if ( intervalIdx < stressTendonIntervalIdx || !IsOnGirder(poi))
   {
      *pEccX = 0;
      *pEccY = 0;
      return;
   }

   // get location of duct in girder section coordinates
   CComPtr<IPoint2d> pntDuct;
   GetGirderDuctPoint(poi, ductIdx, &pntDuct);

   Float64 Xd, Yd;
   pntDuct->Location(&Xd, &Yd);

   Float64 Ytop = GetY(spType, intervalIdx, poi, pgsTypes::TopGirder);

   *pEccX = Xd; // less than zero means tendon is to the left of the section cg
   *pEccY = -(Yd + Ytop); // greater than zero means tendon is below the section cg

   ATLASSERT(IsZero(GetPrecamber(poi)));
}

void CBridgeAgentImp::GetGirderTendonSlope(const pgsPointOfInterest& poi,DuctIndexType ductIdx,IVector3d** ppSlope) const
{
   ATLASSERT(IsOnGirder(poi));
   Float64 Xg = ConvertPoiToGirderCoordinate(poi);
   CGirderKey girderKey(poi.GetSegmentKey());
   GetGirderTendonSlope(girderKey,Xg,ductIdx,ppSlope);
}

void CBridgeAgentImp::GetGirderTendonSlope(const CGirderKey& girderKey,Float64 Xg,DuctIndexType ductIdx,IVector3d** ppSlope) const
{
   Float64 Xgs, Xge;
   GetDuctRange(girderKey, ductIdx, &Xgs, &Xge);
   if (InRange(Xgs, Xg, Xge))
   {
      CComPtr<ISuperstructureMember> ssMbr;
      GetSuperstructureMember(girderKey, &ssMbr);

      CComQIPtr<IItemData> itemData(ssMbr);

      CComPtr<IUnknown> unk;
      itemData->GetItemData(CComBSTR(_T("Tendons")), &unk);

      CComQIPtr<ITendonCollection> tendons(unk);
      CComPtr<ITendon> tendon;
      tendons->get_Item(ductIdx, &tendon);
      tendon->get_Slope(Xg, tmTendon, ppSlope);
   }
   else
   {
      *ppSlope = nullptr;
   }
}

Float64 CBridgeAgentImp::GetMinimumRadiusOfCurvature(const CGirderKey& girderKey,DuctIndexType ductIdx) const
{
   CComPtr<ISuperstructureMember> ssMbr;
   GetSuperstructureMember(girderKey,&ssMbr);

   CComQIPtr<IItemData> itemData(ssMbr);

   CComPtr<IUnknown> unk;
   itemData->GetItemData(CComBSTR(_T("Tendons")),&unk);

   CComQIPtr<ITendonCollection> tendons(unk);
   CComPtr<ITendon> tendon;
   tendons->get_Item(ductIdx,&tendon);

   Float64 radiusOfCurvature;
   tendon->get_MinimumRadiusOfCurvature(&radiusOfCurvature);
   return radiusOfCurvature;
}

Float64 CBridgeAgentImp::GetGirderTendonAngularChange(const pgsPointOfInterest& poi,DuctIndexType ductIdx,pgsTypes::MemberEndType endType) const
{
   if ( !IsOnDuct(poi,ductIdx) )
   {
      return 0;
   }

   PoiIDType startPoiID, endPoiID;
   m_pPoiMgr->GetDuctBoundary(poi.GetSegmentKey(), ductIdx, &startPoiID, &endPoiID);

   const pgsPointOfInterest& poiStart = GetPointOfInterest(endType == pgsTypes::metStart ? startPoiID : endPoiID);
   ATLASSERT(poiStart.HasAttribute(endType == pgsTypes::metStart ? POI_DUCT_START : POI_DUCT_END));
   
   return GetGirderTendonAngularChange(poiStart, poi, ductIdx);
}

Float64 CBridgeAgentImp::GetGirderTendonAngularChange(const pgsPointOfInterest& poi1,const pgsPointOfInterest& poi2,DuctIndexType ductIdx) const
{
   ATLASSERT(IsOnDuct(poi1,ductIdx));
   ATLASSERT(IsOnDuct(poi2,ductIdx));

   // POIs must be on the same girder
   ATLASSERT(CGirderKey(poi1.GetSegmentKey()) == CGirderKey(poi2.GetSegmentKey()));

   Float64 alpha = 0.0; // angular change

   // Get all the POI for this girder
   ATLASSERT(CGirderKey(poi1.GetSegmentKey()) == CGirderKey(poi2.GetSegmentKey()));
   GroupIndexType  grpIdx = poi1.GetSegmentKey().groupIndex;
   GirderIndexType gdrIdx = poi1.GetSegmentKey().girderIndex;

   PoiList vPoi;
   GetPointsOfInterest(CSegmentKey(grpIdx, gdrIdx, ALL_SEGMENTS), &vPoi);
   // vPoi is sorted left to right... if we are measuring angular change from right to left, order of the
   // elements in the vector have to be reversed
   bool bLeftToRight = true;
   if ( poi2 < poi1 )
   {
      bLeftToRight = false;
      std::reverse(vPoi.begin(),vPoi.end());
   }

   PoiList::iterator iter(vPoi.begin());
   pgsPointOfInterest prevPoi = *iter++;
   PoiList::iterator end(vPoi.end());
   for ( ; iter != end; iter++ )
   {
      const pgsPointOfInterest& poi = *iter;
      if ( bLeftToRight )
      {
         if ( prevPoi < poi1 )
         {
            prevPoi = poi;
            continue; // before the start poi... continue with next poi
         }
         
         if ( poi2 < poi ) // after end poi... just break out of the loop
         {
            break;
         }
      }
      else
      {
         if ( poi1 < prevPoi )
         {
            prevPoi = poi;
            continue; // prev poi is before the first poi (going right to left)
         }

         if ( poi < poi2 )
         {
            break; // current poi is after the second poi (going right to left)
         }
      }

      CComPtr<IVector3d> slope1, slope2;
      GetGirderTendonSlope(prevPoi,ductIdx,&slope1);
      GetGirderTendonSlope(poi,    ductIdx,&slope2);

      // if these assert, then prevPoi and/or poi is not on the duct... 
      ATLASSERT(slope1);
      ATLASSERT(slope2);

      Float64 delta_alpha;
      slope2->AngleBetween(slope1,&delta_alpha);

      alpha += delta_alpha;

      prevPoi = poi;
   }

   return alpha;
}

pgsTypes::JackingEndType CBridgeAgentImp::GetJackingEnd(const CGirderKey& girderKey,DuctIndexType ductIdx) const
{
   CComPtr<ISuperstructureMember> ssMbr;
   GetSuperstructureMember(girderKey,&ssMbr);

   CComQIPtr<IItemData> itemData(ssMbr);

   CComPtr<IUnknown> unk;
   itemData->GetItemData(CComBSTR(_T("Tendons")),&unk);

   CComQIPtr<ITendonCollection> tendons(unk);
   CComPtr<ITendon> tendon;
   tendons->get_Item(ductIdx,&tendon);

   JackingEndType tj;
   tendon->get_JackingEnd(&tj);

   return (pgsTypes::JackingEndType)tj;
}

Float64 CBridgeAgentImp::GetGirderAptTopHalf(const pgsPointOfInterest& poi) const
{
   return GetGirderAptTensionSide(poi,true);
}

Float64 CBridgeAgentImp::GetGirderAptBottomHalf(const pgsPointOfInterest& poi) const
{
   return GetGirderAptTensionSide(poi,false);
}

//////////////////////////////////////////////////////////////////////////
// ISegmentTendonGeometry
DuctIndexType CBridgeAgentImp::GetDuctCount(const CSegmentKey& segmentKey) const
{
   CComPtr<IPrecastGirder> girder;
   GetGirder(segmentKey, &girder);
   CComPtr<ITendonCollection> tendons;
   girder->get_Tendons(&tendons);

   if (tendons)
   {
      DuctIndexType nDucts;
      tendons->get_Count(&nDucts);
      return nDucts;
   }
   else
   {
      return 0;
   }
}

DuctIndexType CBridgeAgentImp::GetMaxDuctCount(const CGirderKey& girderKey) const
{
   SegmentIndexType nSegments = GetSegmentCount(girderKey);
   DuctIndexType nMaxSegmentDucts = 0;
   for (SegmentIndexType segIdx = 0; segIdx < nSegments; segIdx++)
   {
      CSegmentKey segmentKey(girderKey, segIdx);
      nMaxSegmentDucts = Max(nMaxSegmentDucts, GetDuctCount(segmentKey));
   }
   return nMaxSegmentDucts;
}

bool CBridgeAgentImp::IsOnDuct(const pgsPointOfInterest& poi) const
{
   // segment ducts run end to end of the segment so poi must be between 0 and Ls
   const CSegmentKey& segmentKey(poi.GetSegmentKey());
   return IsOnSegment(poi) && 0 < GetDuctCount(segmentKey);
}

void CBridgeAgentImp::GetDuctCenterline(const CSegmentKey& segmentKey, const CPrecastSegmentData* pSegment, DuctIndexType ductIdx, const CSegmentPTData* pPTData, IPoint2dCollection** ppPoints) const
{
   const CSegmentDuctData* pDuctData = pPTData->GetDuct(ductIdx);
   GetDuctCenterline(segmentKey, pSegment, pDuctData, ppPoints);
}

void CBridgeAgentImp::GetDuctCenterline(const CSegmentKey& segmentKey, const CPrecastSegmentData* pSegment, const CSegmentDuctData* pDuctData, IPoint2dCollection** ppPoints) const
{
   ATLASSERT(pSegment ? segmentKey == pSegment->GetSegmentKey() : true); // if a segment is supplied, it must be the same segment as segmentKey

   CComPtr<IPoint2dCollection> points;
   points.CoCreateInstance(CLSID_Point2dCollection);
   points.CopyTo(ppPoints);

   PoiList vPoi;
   GetPointsOfInterest(segmentKey, POI_5L | POI_RELEASED_SEGMENT, &vPoi);
   GetPointsOfInterest(segmentKey, POI_START_FACE | POI_END_FACE, &vPoi, POIFIND_OR);
   ATLASSERT(vPoi.size() == 3);
   SortPoiList(&vPoi);

   std::array<std::pair<Float64, Float64>, 3> control_points;
   for (int i = 0; i < 3; i++)
   {
      Float64 x = vPoi[i].get().GetDistFromStart();
      Float64 y = -pDuctData->DuctPoint[i].first;
      if (pDuctData->DuctPoint[i].second == pgsTypes::BottomFace)
      {
         Float64 Hg;
         if (pSegment)
         {
            Hg = GetSegmentHeight(pSegment, vPoi[i].get().GetDistFromStart());
         }
         else
         {
            Hg = GetHeight(vPoi[i].get());
         }
         y = -y - Hg;
      }
      control_points[i] = std::make_pair(x, y);
   }

   if (pDuctData->DuctGeometryType == CSegmentDuctData::Parabolic)
   {
      // simple parabola using vertix form

      // Left side parabola
      Float64 x0 = control_points[0].first;
      Float64 y0 = control_points[0].second;
      Float64 h = control_points[1].first;
      Float64 k = control_points[1].second;
      Float64 a = (y0 - k) / pow(x0 - h, 2);
      Float64 Ls = GetSegmentLength(segmentKey);
      for (int i = 0; i <= 10; i++)
      {
         Float64 x = i*Ls / 20 + x0;
         Float64 y = a*(x - h)*(x - h) + k;
         CComPtr<IPoint2d> point;
         point.CoCreateInstance(CLSID_Point2d);
         x = ConvertSegmentCoordinateToSegmentPathCoordinate(segmentKey, x);
         x = ConvertSegmentPathCoordinateToGirderPathCoordinate(segmentKey, x);
         point->Move(x, y);
         points->Add(point);
      }


      // Right side parabola
      x0 = control_points[2].first;
      y0 = control_points[2].second;
      h = control_points[1].first;
      k = control_points[1].second;
      a = (y0 - k) / pow(x0 - h, 2);
      for (int i = 0; i <= 10; i++)
      {
         Float64 x = x0 - Ls/2 + i*Ls / 20;
         Float64 y = a*(x - h)*(x - h) + k;
         CComPtr<IPoint2d> point;
         point.CoCreateInstance(CLSID_Point2d);
         x = ConvertSegmentCoordinateToSegmentPathCoordinate(segmentKey, x);
         x = ConvertSegmentPathCoordinateToGirderPathCoordinate(segmentKey, x);
         point->Move(x, y);
         points->Add(point);
      }
   }
   else
   {
      for (int i = 0; i < 3; i++)
      {
         if (i == 1) continue; // this is the center point, it isn't applicable to a linear straight tendon

         CComPtr<IPoint2d> point;
         point.CoCreateInstance(CLSID_Point2d);
         Float64 x = control_points[i].first;
         x = ConvertSegmentCoordinateToSegmentPathCoordinate(segmentKey, x);
         x = ConvertSegmentPathCoordinateToGirderPathCoordinate(segmentKey, x);
         point->Move(x, control_points[i].second);
         points->Add(point);
      }
   }
}

void CBridgeAgentImp::GetDuctCenterline(const CSegmentKey& segmentKey, DuctIndexType ductIdx, IPoint2dCollection** ppPoints) const
{
   // Gets the duct centerline from the generic bridge model
   CComPtr<IPoint2dCollection> points;
   points.CoCreateInstance(CLSID_Point2dCollection);

   CComPtr<IPrecastGirder> girder;
   GetGirder(segmentKey, &girder);
   CComPtr<ITendonCollection> tendons;
   girder->get_Tendons(&tendons);
   ATLASSERT(tendons);

   CComPtr<ITendon> tendon;
   tendons->get_Item(ductIdx, &tendon);
   ATLASSERT(tendon);

   CComPtr<IPoint3dCollection> centerline;
   tendon->get_Centerline(tmPath, &centerline);

   CComPtr<IEnumPoint3d> enumPoints;
   centerline->get__Enum(&enumPoints);
   CComPtr<IPoint3d> point;
   while (enumPoints->Next(1, &point, nullptr) != S_FALSE)
   {
      Float64 x, y, z;
      point->Location(&x, &y, &z);

      CComPtr<IPoint2d> p;
      p.CoCreateInstance(CLSID_Point2d);
      p->Move(z, y);

      points->Add(p);

      point.Release();
   }

   points.CopyTo(ppPoints);
}

void CBridgeAgentImp::GetDuctCenterline(const CSegmentKey& segmentKey, DuctIndexType ductIdx, IPoint3dCollection** ppPoints) const
{
   // Gets the duct centerline from the generic bridge model
   CComPtr<IPrecastGirder> girder;
   GetGirder(segmentKey, &girder);
   CComPtr<ITendonCollection> tendons;
   girder->get_Tendons(&tendons);
   ATLASSERT(tendons);

   CComPtr<ITendon> tendon;
   tendons->get_Item(ductIdx, &tendon);
   ATLASSERT(tendon);

   tendon->get_Centerline(tmPath, ppPoints);
}

void CBridgeAgentImp::GetSegmentDuctPoint(const CSegmentKey& segmentKey, Float64 Xs, DuctIndexType ductIdx, IPoint2d** ppPoint) const
{
   CComPtr<IPrecastGirder> girder;
   GetGirder(segmentKey, &girder);
   CComPtr<ITendonCollection> tendons;
   girder->get_Tendons(&tendons);
   ATLASSERT(tendons);

   CComPtr<ITendon> tendon;
   tendons->get_Item(ductIdx, &tendon);
   ATLASSERT(tendon);

   CComPtr<IPoint3d> cg;
   tendon->get_CG(Xs, tmPath, &cg);

   if (cg)
   {
      Float64 x, y, z;
      cg->Location(&x, &y, &z);
      ATLASSERT(IsEqual(z, Xs));

      CComPtr<IPoint2d> pnt;
      pnt.CoCreateInstance(CLSID_Point2d);
      pnt->Move(x, y);

      pnt.CopyTo(ppPoint);
   }
   else
   {
      *ppPoint = nullptr;
   }
}

void CBridgeAgentImp::GetSegmentDuctPoint(const pgsPointOfInterest& poi, DuctIndexType ductIdx, IPoint2d** ppPoint) const
{
   GetSegmentDuctPoint(poi.GetSegmentKey(), poi.GetDistFromStart(), ductIdx, ppPoint);
}

void CBridgeAgentImp::GetSegmentDuctPoint(const pgsPointOfInterest& poi, const CPrecastSegmentData* pSegment, DuctIndexType ductIdx, IPoint3d** ppPoint) const
{
   const CPrecastSegmentData* pSeg;
   const CSegmentDuctData* pDuctData;
   if (pSegment == nullptr)
   {
      GET_IFACE(IBridgeDescription, pIBridgeDesc);
      pSeg = pIBridgeDesc->GetPrecastSegmentData(poi.GetSegmentKey());
   }
   else
   {
      pSeg = pSegment;
   }
   pDuctData = pSeg->Tendons.GetDuct(ductIdx);

   GetSegmentDuctPoint(poi, pSeg, pDuctData, ppPoint);
}

void CBridgeAgentImp::GetSegmentDuctPoint(const pgsPointOfInterest& poi, const CPrecastSegmentData* pSegment, const CSegmentDuctData* pDuctData, IPoint3d** ppPoint) const
{
   // gets the location of a segment duct at the specified poi
   if (!IsOnSegment(poi))
   {
      ATLASSERT(false);
      *ppPoint = nullptr;
      return;
   }

   const CSegmentKey& segmentKey(poi.GetSegmentKey());

   Float64 z = poi.GetDistFromStart(); // in 3d coordinate, z is measured along the main axis of the segment

   // Determine the overall height of the segment so it can be used to adjust the duct data if measured from bottom of girder section
   CComPtr<IShape> shape;
   if (pSegment)
   {
      GET_IFACE(ILibrary, pLib);
      const GirderLibraryEntry* pGdrEntry = pLib->GetGirderEntry(pSegment->GetGirder()->GetGirderName());

      CComPtr<IBeamFactory> factory;
      pGdrEntry->GetBeamFactory(&factory);

      Float64 height = factory->GetSegmentHeight(m_pBroker, pSegment, z); // this takes into account things like section trasitions

      CComPtr<IGirderSection> gdrSection;
      factory->CreateGirderSection(m_pBroker, INVALID_ID, pGdrEntry->GetDimensions(), height, -1, &gdrSection); // get the section with the actual same (-1 for bottom flange thickness since we don't care about it in this context)

      gdrSection.QueryInterface(&shape);
   }
   else
   {
      CComPtr<ISuperstructureMemberSegment> pSSMbrSegment;
      GetSegment(segmentKey, &pSSMbrSegment);
      pSSMbrSegment->get_GirderShape(z, sbRight, cstGirder, &shape);
   }

   CComQIPtr<IGirderSection> section(shape);
   ATLASSERT(section != nullptr);

   Float64 Hg;
   section->get_OverallHeight(&Hg);

   // get the elevation of the duct point
   Float64 y;
   Uint16 tenth_point = poi.IsTenthPoint(POI_RELEASED_SEGMENT);
   if (tenth_point == 1 || tenth_point == 11)
   {
      // poi is at start or end of segment so we can just use the control data from the DuctPoint structure
      CSegmentDuctData::DuctPointType ductPoint = (tenth_point == 1 ? CSegmentDuctData::Left : CSegmentDuctData::Right);
      if (pDuctData->DuctPoint[ductPoint].second == pgsTypes::TopFace)
      {
         y = -pDuctData->DuctPoint[ductPoint].first;
      }
      else
      {
         y = pDuctData->DuctPoint[ductPoint].first - Hg;
      }
   }
   else
   {
      // poi is in the middle of the segment... need to build a model of the duct geometry along the lenght of the segment
      Float64 Ls = GetSegmentLength(segmentKey);

      if (pDuctData->DuctGeometryType == CSegmentDuctData::Linear)
      {
         // duct is linear so just use interpolation from start to end of segment
         Float64 z1 = 0;
         Float64 z2 = Ls;

         Float64 y1 = ConvertSegmentDuctOffsetToDuctElevation(segmentKey, pSegment, z1, pDuctData->DuctPoint[CSegmentDuctData::Left].first, pDuctData->DuctPoint[CSegmentDuctData::Left].second);
         Float64 y2 = ConvertSegmentDuctOffsetToDuctElevation(segmentKey, pSegment, z2, pDuctData->DuctPoint[CSegmentDuctData::Right].first, pDuctData->DuctPoint[CSegmentDuctData::Right].second);

         y = ::LinInterp(z, y1, y2, Ls);
      }
      else
      {
         // duct is parabolic so build a polynomial function to represent the duct and get the elevation from that
         ATLASSERT(pDuctData->DuctGeometryType == CSegmentDuctData::Parabolic);

         // start, middle, end
         Float64 z1 = 0;
         Float64 z2 = Ls / 2;
         Float64 z3 = Ls;

         // start, middle, end elevation
         Float64 y1 = ConvertSegmentDuctOffsetToDuctElevation(segmentKey, pSegment, z1, pDuctData->DuctPoint[CSegmentDuctData::Left].first, pDuctData->DuctPoint[CSegmentDuctData::Left].second);
         Float64 y2 = ConvertSegmentDuctOffsetToDuctElevation(segmentKey, pSegment, z2, pDuctData->DuctPoint[CSegmentDuctData::Middle].first, pDuctData->DuctPoint[CSegmentDuctData::Middle].second);
         Float64 y3 = ConvertSegmentDuctOffsetToDuctElevation(segmentKey, pSegment, z3, pDuctData->DuctPoint[CSegmentDuctData::Right].first, pDuctData->DuctPoint[CSegmentDuctData::Right].second);

         Float64 A, B, C; // y = Az^2 + Bz + C polynomial coefficients
         Float64 slope = 0; // slope at mid-segment is zero by definition
         if (z <= z2)
         {
            // parabola on left half of segment (zero slope at right end of parabola)
            Float64 dy = y2 - y1;
            Float64 dz = z2 - z1;
            A = -(dy - dz*slope) / (dz*dz);
            B = slope - 2 * A*z2;
            C = y1 - A*z1*z1 - B*z1;
         }
         else
         {
            // parabola on right half of segment (zero slope at left end of parabola)
            Float64 dy = y3 - y2;
            Float64 dz = z3 - z2;
            A = (dy - dz*slope) / (dz*dz);
            B = slope - 2 * A*z2;
            C = y2 - A*z2*z2 - B*z2;
         }

         std::vector<Float64> coefficients{ A,B,C };
         WBFL::Math::PolynomialFunction parabola(coefficients);
         y = parabola.Evaluate(z);
      }
   }

   // use the plane of the girder web to get the x position of the duct point
   CComPtr<IPlane3d> webPlane;
   section->get_WebPlane(0,&webPlane);

   Float64 x;
   webPlane->GetX(y, z, &x);

   CComPtr<IPoint3d> pnt;
   pnt.CoCreateInstance(CLSID_Point3d);
   pnt->Move(x, y, z);

   pnt.CopyTo(ppPoint);
}

Float64 CBridgeAgentImp::GetOutsideDiameter(const CSegmentKey& segmentKey, DuctIndexType ductIdx) const
{
   CComPtr<IPrecastGirder> girder;
   GetGirder(segmentKey, &girder);
   CComPtr<ITendonCollection> tendons;
   girder->get_Tendons(&tendons);
   ATLASSERT(tendons);

   CComPtr<ITendon> tendon;
   tendons->get_Item(ductIdx, &tendon);
   ATLASSERT(tendon);

   Float64 dia;
   tendon->get_OutsideDiameter(&dia);

   return dia;
}

Float64 CBridgeAgentImp::GetInsideDiameter(const CSegmentKey& segmentKey, DuctIndexType ductIdx) const
{
   CComPtr<IPrecastGirder> girder;
   GetGirder(segmentKey, &girder);
   CComPtr<ITendonCollection> tendons;
   girder->get_Tendons(&tendons);
   ATLASSERT(tendons);

   CComPtr<ITendon> tendon;
   tendons->get_Item(ductIdx, &tendon);
   ATLASSERT(tendon);

   Float64 dia;
   tendon->get_InsideDiameter(&dia);

   return dia;
}

Float64 CBridgeAgentImp::GetNominalDiameter(const CSegmentKey& segmentKey, DuctIndexType ductIdx) const
{
   CComPtr<IPrecastGirder> girder;
   GetGirder(segmentKey, &girder);
   CComPtr<ITendonCollection> tendons;
   girder->get_Tendons(&tendons);
   ATLASSERT(tendons);

   CComPtr<ITendon> tendon;
   tendons->get_Item(ductIdx, &tendon);
   ATLASSERT(tendon);

   Float64 dia;
   tendon->get_NominalDiameter(&dia);

   return dia;
}

Float64 CBridgeAgentImp::GetInsideDuctArea(const CSegmentKey& segmentKey, DuctIndexType ductIdx) const
{
   CComPtr<IPrecastGirder> girder;
   GetGirder(segmentKey, &girder);
   CComPtr<ITendonCollection> tendons;
   girder->get_Tendons(&tendons);
   ATLASSERT(tendons);

   CComPtr<ITendon> tendon;
   tendons->get_Item(ductIdx, &tendon);
   ATLASSERT(tendon);

   Float64 Aduct;
   tendon->get_InsideDuctArea(&Aduct);

   return Aduct;
}

StrandIndexType CBridgeAgentImp::GetTendonStrandCount(const CSegmentKey& segmentKey, DuctIndexType ductIdx) const
{
   CComPtr<IPrecastGirder> girder;
   GetGirder(segmentKey, &girder);
   CComPtr<ITendonCollection> tendons;
   girder->get_Tendons(&tendons);
   ATLASSERT(tendons);

   CComPtr<ITendon> tendon;
   tendons->get_Item(ductIdx, &tendon);
   ATLASSERT(tendon);

   StrandIndexType nStrands;
   tendon->get_StrandCount(&nStrands);

   return nStrands;
}

Float64 CBridgeAgentImp::GetSegmentTendonArea(const CSegmentKey& segmentKey, IntervalIndexType intervalIdx, DuctIndexType ductIdx) const
{
   if (intervalIdx < GetStressSegmentTendonInterval(segmentKey))
   {
      return 0;
   }

   CComPtr<IPrecastGirder> girder;
   GetGirder(segmentKey, &girder);
   CComPtr<ITendonCollection> tendons;
   girder->get_Tendons(&tendons);
   ATLASSERT(tendons);

   CComPtr<ITendon> tendon;
   tendons->get_Item(ductIdx, &tendon);
   ATLASSERT(tendon);

   Float64 Apt;
   tendon->get_TendonArea(&Apt);

   return Apt;
}

void CBridgeAgentImp::GetSegmentTendonSlope(const pgsPointOfInterest& poi, DuctIndexType ductIdx, IVector3d** ppSlope) const
{
   GetSegmentTendonSlope(poi.GetSegmentKey(), poi.GetDistFromStart(), ductIdx, ppSlope);
}

void CBridgeAgentImp::GetSegmentTendonSlope(const CSegmentKey& segmentKey, Float64 Xs, DuctIndexType ductIdx, IVector3d** ppSlope) const
{
   CComPtr<IPrecastGirder> girder;
   GetGirder(segmentKey, &girder);
   CComPtr<ITendonCollection> tendons;
   girder->get_Tendons(&tendons);
   ATLASSERT(tendons);

   CComPtr<ITendon> tendon;
   tendons->get_Item(ductIdx, &tendon);
   ATLASSERT(tendon);
   tendon->get_Slope(Xs, tmTendon, ppSlope);
}

Float64 CBridgeAgentImp::GetMinimumRadiusOfCurvature(const CSegmentKey& segmentKey, DuctIndexType ductIdx) const
{
   CComPtr<IPrecastGirder> girder;
   GetGirder(segmentKey, &girder);
   CComPtr<ITendonCollection> tendons;
   girder->get_Tendons(&tendons);
   ATLASSERT(tendons);

   CComPtr<ITendon> tendon;
   tendons->get_Item(ductIdx, &tendon);
   ATLASSERT(tendon);

   Float64 radiusOfCurvature;
   tendon->get_MinimumRadiusOfCurvature(&radiusOfCurvature);
   return radiusOfCurvature;
}

Float64 CBridgeAgentImp::GetPjack(const CSegmentKey& segmentKey, DuctIndexType ductIdx) const
{
   GET_IFACE(IBridgeDescription, pIBridgeDesc);
   const auto* pSegment = pIBridgeDesc->GetPrecastSegmentData(segmentKey);
   WebIndexType nWebs = GetWebCount(segmentKey);
   return pSegment->Tendons.GetPjack(ductIdx / nWebs);
}

Float64 CBridgeAgentImp::GetFpj(const CSegmentKey& segmentKey, DuctIndexType ductIdx) const
{
   Float64 Pj = GetPjack(segmentKey, ductIdx);
   IntervalIndexType stressTendonIntervalIdx = GetStressSegmentTendonInterval(segmentKey);
   Float64 Apt = GetSegmentTendonArea(segmentKey, stressTendonIntervalIdx, ductIdx);
   return (IsZero(Apt) ? 0 : Pj / Apt);
}

Float64 CBridgeAgentImp::GetSegmentDuctOffset(IntervalIndexType intervalIdx, const pgsPointOfInterest& poi, DuctIndexType ductIdx) const
{
   // Returns the distance from the top of the non-composite girder to the CG of the tendon

   const CSegmentKey& segmentKey(poi.GetSegmentKey());

   // if interval is before tendon is installed, there isn't an eccentricity with respect to the girder cross section
   if (intervalIdx < GetStressSegmentTendonInterval(segmentKey))
   {
      return 0;
   }

   CComPtr<IPrecastGirder> girder;
   GetGirder(segmentKey, &girder);
   CComPtr<ITendonCollection> tendons;
   girder->get_Tendons(&tendons);
   ATLASSERT(tendons);

   CComPtr<ITendon> tendon;
   tendons->get_Item(ductIdx, &tendon);
   ATLASSERT(tendon);

   StrandIndexType nStrands;
   tendon->get_StrandCount(&nStrands);
   if (nStrands == 0)
   {
      return 0;
   }

   Float64 Xs = poi.GetDistFromStart();
   CComPtr<IPoint3d> cg;
   tendon->get_CG(Xs, tmTendon /*account for tendon offset from center of duct*/, &cg);

   Float64 ecc;
   cg->get_Y(&ecc); // this is in Girder Section Coordinates so it should be < 0 if below top of girder
   ATLASSERT(ecc <= 0);

   return ecc;
}

Float64 CBridgeAgentImp::GetDuctLength(const CSegmentKey& segmentKey, DuctIndexType ductIdx) const
{
   CComPtr<IPrecastGirder> girder;
   GetGirder(segmentKey, &girder);
   CComPtr<ITendonCollection> tendons;
   girder->get_Tendons(&tendons);
   ATLASSERT(tendons);

   CComPtr<ITendon> tendon;
   tendons->get_Item(ductIdx, &tendon);
   ATLASSERT(tendon);

   Float64 length;
   tendon->get_Length(&length);
   return length;
}

void CBridgeAgentImp::GetSegmentTendonEccentricity(IntervalIndexType intervalIdx, const pgsPointOfInterest& poi, DuctIndexType ductIdx,Float64* pEccX,Float64* pEccY) const
{
   pgsTypes::SectionPropertyType sectPropType = GetSectionPropertiesType();
   GetSegmentTendonEccentricity(sectPropType, intervalIdx, poi, ductIdx, pEccX, pEccY);
}

void CBridgeAgentImp::GetSegmentTendonEccentricity(pgsTypes::SectionPropertyType spType, IntervalIndexType intervalIdx, const pgsPointOfInterest& poi, DuctIndexType ductIdx, Float64* pEccX, Float64* pEccY) const
{
   ATLASSERT(ductIdx != INVALID_INDEX);

   // if interval is before tendon is installed, there isn't an eccentricity with respect to the girder cross section
   IntervalIndexType stressTendonIntervalIdx = GetStressSegmentTendonInterval(poi.GetSegmentKey());
   if (intervalIdx < stressTendonIntervalIdx || !IsOnSegment(poi))
   {
      *pEccX = 0;
      *pEccY = 0;
      return;
   }

   // get location of duct in girder section coordinates
   CComPtr<IPoint2d> pntDuct;
   GetSegmentDuctPoint(poi, ductIdx, &pntDuct);

   Float64 Xd, Yd;
   pntDuct->Location(&Xd, &Yd);

   Float64 Ytop = GetY(spType, intervalIdx, poi, pgsTypes::TopGirder);

   *pEccX = Xd; // less than zero means tendon is to the left of the section cg
   *pEccY = -(Yd + Ytop); // greater than zero means tendon is below the section cg

   ATLASSERT(IsZero(GetPrecamber(poi)));
}

Float64 CBridgeAgentImp::GetSegmentTendonAngularChange(const pgsPointOfInterest& poi, DuctIndexType ductIdx, pgsTypes::MemberEndType endType) const
{
   if (!IsOnDuct(poi))
   {
      return 0;
   }

   PoiList vPoi;
   GetPointsOfInterest(poi.GetSegmentKey(), (endType == pgsTypes::metStart ? POI_0L : POI_10L) | POI_RELEASED_SEGMENT, &vPoi);
   ATLASSERT(vPoi.size() == 1);
   const pgsPointOfInterest& poiStart(vPoi.front());
   return GetSegmentTendonAngularChange(poiStart, poi, ductIdx);
}

Float64 CBridgeAgentImp::GetSegmentTendonAngularChange(const pgsPointOfInterest& poi1, const pgsPointOfInterest& poi2, DuctIndexType ductIdx) const
{
   ATLASSERT(IsOnDuct(poi1));
   ATLASSERT(IsOnDuct(poi2));
   ATLASSERT(poi1.GetSegmentKey() == poi2.GetSegmentKey()); // must be on same segment

   Float64 alpha = 0.0; // angular change

   // Get all the POI for this segment
   PoiList vPoi;
   GetPointsOfInterest(poi1.GetSegmentKey(), &vPoi);

   // vPoi is sorted left to right... if we are measuring angular change from right to left, order of the
   // elements in the vector have to be reversed
   bool bLeftToRight = true;
   if (poi2 < poi1)
   {
      bLeftToRight = false;
      std::reverse(vPoi.begin(), vPoi.end());
   }

   PoiList::iterator iter(vPoi.begin());
   pgsPointOfInterest prevPoi = *iter++;
   PoiList::iterator end(vPoi.end());
   for (; iter != end; iter++)
   {
      const pgsPointOfInterest& poi = *iter;
      if (bLeftToRight)
      {
         if (prevPoi < poi1)
         {
            prevPoi = poi;
            continue; // before the start poi... continue with next poi
         }

         if (poi2 < poi) // after end poi... just break out of the loop
         {
            break;
         }
      }
      else
      {
         if (poi1 < prevPoi)
         {
            prevPoi = poi;
            continue; // prev poi is before the first poi (going right to left)
         }

         if (poi < poi2)
         {
            break; // current poi is after the second poi (going right to left)
         }
      }

      CComPtr<IVector3d> slope1, slope2;
      GetSegmentTendonSlope(prevPoi, ductIdx, &slope1);
      GetSegmentTendonSlope(poi, ductIdx, &slope2);

      // if these assert, then prevPoi and/or poi is not on the duct... 
      ATLASSERT(slope1);
      ATLASSERT(slope2);

      Float64 delta_alpha;
      slope2->AngleBetween(slope1, &delta_alpha);

      alpha += delta_alpha;

      prevPoi = poi;
   }

   return alpha;
}

pgsTypes::JackingEndType CBridgeAgentImp::GetJackingEnd(const CSegmentKey& segmentKey, DuctIndexType ductIdx) const
{
   CComPtr<IPrecastGirder> girder;
   GetGirder(segmentKey, &girder);
   CComPtr<ITendonCollection> tendons;
   girder->get_Tendons(&tendons);
   ATLASSERT(tendons);
   
   CComPtr<ITendon> tendon;
   tendons->get_Item(ductIdx, &tendon);
   ATLASSERT(tendon);

   JackingEndType tj;
   tendon->get_JackingEnd(&tj);

   return (pgsTypes::JackingEndType)tj;
}

Float64 CBridgeAgentImp::GetSegmentAptTopHalf(const pgsPointOfInterest& poi) const
{
   return GetSegmentAptTensionSide(poi, true);
}

Float64 CBridgeAgentImp::GetSegmentAptBottomHalf(const pgsPointOfInterest& poi) const
{
   return GetSegmentAptTensionSide(poi, false);
}


//////////////////////////////////////////////////////////////////////////
// IIntervals
IntervalIndexType CBridgeAgentImp::GetIntervalCount() const
{
   VALIDATE(BRIDGE);
   return m_IntervalManager.GetIntervalCount();
}

EventIndexType CBridgeAgentImp::GetStartEvent(IntervalIndexType idx) const
{
   VALIDATE(BRIDGE);
   return m_IntervalManager.GetStartEvent(idx);
}

EventIndexType CBridgeAgentImp::GetEndEvent(IntervalIndexType idx) const
{
   VALIDATE(BRIDGE);
   return m_IntervalManager.GetEndEvent(idx);
}

Float64 CBridgeAgentImp::GetTime(IntervalIndexType idx,pgsTypes::IntervalTimeType timeType) const
{
   VALIDATE(BRIDGE);
   return m_IntervalManager.GetTime(idx,timeType);
}

Float64 CBridgeAgentImp::GetDuration(IntervalIndexType idx) const
{
   VALIDATE(BRIDGE);
   return m_IntervalManager.GetDuration(idx);
}

std::_tstring CBridgeAgentImp::GetDescription(IntervalIndexType idx) const
{
   VALIDATE(BRIDGE);
   return m_IntervalManager.GetDescription(idx);
}

IntervalIndexType CBridgeAgentImp::GetInterval(EventIndexType eventIdx) const
{
   VALIDATE(BRIDGE);
   return m_IntervalManager.GetInterval(eventIdx);
}

IntervalIndexType CBridgeAgentImp::GetErectPierInterval(PierIndexType pierIdx) const
{
   VALIDATE(BRIDGE);
   return m_IntervalManager.GetErectPierInterval(pierIdx);
}

IntervalIndexType CBridgeAgentImp::GetCastClosureJointInterval(const CClosureKey& closureKey) const
{
   VALIDATE(BRIDGE);
   return m_IntervalManager.GetCastClosureInterval(closureKey);
}

IntervalIndexType CBridgeAgentImp::GetCompositeClosureJointInterval(const CClosureKey& closureKey) const
{
   SegmentIndexType nSegments = GetSegmentCount(closureKey);
   if ( closureKey.segmentIndex == nSegments-1 )
   {
      return INVALID_INDEX; // asking for closure joint after the last segment.. it doesn't exist... return INVALID_INDEX
   }

   // closure joints are composite with the girder two intervals after they are cast
   // cast interval (+0), curing interval (+1), composite interval (+2)
   return GetCastClosureJointInterval(closureKey)+2;
}

IntervalIndexType CBridgeAgentImp::GetFirstCompositeClosureJointInterval(const CGirderKey& girderKey) const
{
   VALIDATE(BRIDGE);
   IntervalIndexType intervalIdx = m_IntervalManager.GetFirstCastClosureJointInterval(girderKey);
   intervalIdx += 2;
   return intervalIdx;
}

IntervalIndexType CBridgeAgentImp::GetLastCompositeClosureJointInterval(const CGirderKey& girderKey) const
{
   VALIDATE(BRIDGE);
   IntervalIndexType intervalIdx = m_IntervalManager.GetLastCastClosureJointInterval(girderKey);
   intervalIdx += 2;
   return intervalIdx;
}

void CBridgeAgentImp::GetContinuityInterval(PierIndexType pierIdx,IntervalIndexType* pBack,IntervalIndexType* pAhead) const
{
   VALIDATE( BRIDGE );

   GET_IFACE(IBridgeDescription,pIBridgeDesc);
   const CBridgeDescription2* pBridgeDesc = pIBridgeDesc->GetBridgeDescription();
   IntervalIndexType noncompositeIntervalIdx = GetLastNoncompositeInterval();
   IntervalIndexType compositeIntervalIdx = GetLastCompositeInterval();

   const CPierData2* pPier = pBridgeDesc->GetPier(pierIdx);
   if ( pPier->IsBoundaryPier() )
   {
      pgsTypes::BoundaryConditionType cType = pPier->GetBoundaryConditionType();

      if ( cType == pgsTypes::bctContinuousBeforeDeck || cType == pgsTypes::bctIntegralBeforeDeck )
      {
         *pBack  = noncompositeIntervalIdx;
         *pAhead = noncompositeIntervalIdx;
      }
      else if ( cType == pgsTypes::bctIntegralBeforeDeckHingeBack )
      {
         *pBack  = compositeIntervalIdx;
         *pAhead = noncompositeIntervalIdx;
      }
      else if ( cType == pgsTypes::bctIntegralBeforeDeckHingeAhead )
      {
         *pBack  = noncompositeIntervalIdx;
         *pAhead = compositeIntervalIdx;
      }
      else if (cType == pgsTypes::bctHinge || cType == pgsTypes::bctRoller)
      {
         // there is never continuity
         *pBack = INVALID_INDEX;
         *pAhead = INVALID_INDEX;
      }
      else if (cType == pgsTypes::bctHinge || cType == pgsTypes::bctRoller)
      {
         // there is never continuity
         *pBack = INVALID_INDEX;
         *pAhead = INVALID_INDEX;
      }
      else // ContinuousAfterDeck, IntegralAfterDeck, 
           // IntegralAfterDeckHingeAhead, IntegralAfterDeckHingeBack
      {
         *pBack  = compositeIntervalIdx;
         *pAhead = compositeIntervalIdx;
      }
   }
   else
   {
      pgsTypes::PierSegmentConnectionType cType = pPier->GetSegmentConnectionType();
      if ( cType == pgsTypes::psctContinousClosureJoint || cType == pgsTypes::psctIntegralClosureJoint )
      {
         const CClosureJointData* pClosure = pPier->GetClosureJoint(0);
         IntervalIndexType compositeClosureIntervalIdx = GetCompositeClosureJointInterval(pClosure->GetClosureKey());
         *pBack  = compositeClosureIntervalIdx;
         *pAhead = compositeClosureIntervalIdx;
      }
      else if ( cType == pgsTypes::psctContinuousSegment || cType == pgsTypes::psctIntegralSegment )
      {
         // which segment is continuous over this pier?
         GroupIndexType nGroups = pBridgeDesc->GetGirderGroupCount();
         for ( GroupIndexType grpIdx = 0; grpIdx < nGroups; grpIdx++ )
         {
            const CGirderGroupData* pGroup = pBridgeDesc->GetGirderGroup(grpIdx);
            const CSplicedGirderData* pGirder = pGroup->GetGirder(0);
            SegmentIndexType nSegments = pGirder->GetSegmentCount();
            for ( SegmentIndexType segIdx = 0; segIdx < nSegments; segIdx++ )
            {
               const CPrecastSegmentData* pSegment = pGirder->GetSegment(segIdx);
               const CSpanData2* pStartSpan = pSegment->GetSpan(pgsTypes::metStart);
               const CSpanData2* pEndSpan   = pSegment->GetSpan(pgsTypes::metEnd);
               PierIndexType leftPierIdx = pStartSpan->GetNextPier()->GetIndex();
               PierIndexType rightPierIdx = pEndSpan->GetPrevPier()->GetIndex();
               if ( leftPierIdx <= pierIdx && pierIdx <= rightPierIdx )
               {
                  // we found the segment
                  IntervalIndexType erectSegmentIntervalIdx = GetErectSegmentInterval(pSegment->GetSegmentKey());
                  *pBack  = erectSegmentIntervalIdx;
                  *pAhead = erectSegmentIntervalIdx;
                  return; // we found the answer
               }
            }
         }
         ATLASSERT(false); // if we got this far, the segment was not found and it should have been
      }
      else
      {
         ATLASSERT(false); // is there a new connection type?
      }
   }
}

IntervalIndexType CBridgeAgentImp::GetCastIntermediateDiaphragmsInterval() const
{
   VALIDATE(BRIDGE);
   return m_IntervalManager.GetCastIntermediateDiaphragmsInterval();
}

IntervalIndexType CBridgeAgentImp::GetCompositeIntermediateDiaphragmsInterval() const
{
   VALIDATE(BRIDGE);
   return m_IntervalManager.GetCompositeIntermediateDiaphragmsInterval();
}

IntervalIndexType CBridgeAgentImp::GetCastLongitudinalJointInterval() const
{
   VALIDATE(BRIDGE);
   return m_IntervalManager.GetCastLongitudinalJointInterval();
}

IntervalIndexType CBridgeAgentImp::GetCompositeLongitudinalJointInterval() const
{
   VALIDATE(BRIDGE);
   return m_IntervalManager.GetCompositeLongitudinalJointInterval();
}

IntervalIndexType CBridgeAgentImp::GetCastDeckInterval(IndexType castingRegionIdx) const
{
   VALIDATE(BRIDGE);
   return m_IntervalManager.GetCastDeckInterval(castingRegionIdx);
}

IntervalIndexType CBridgeAgentImp::GetFirstCastDeckInterval() const
{
   VALIDATE(BRIDGE);
   return m_IntervalManager.GetFirstCastDeckInterval();
}

IntervalIndexType CBridgeAgentImp::GetLastCastDeckInterval() const
{
   VALIDATE(BRIDGE);
   return m_IntervalManager.GetLastCastDeckInterval();
}

IntervalIndexType CBridgeAgentImp::GetCompositeDeckInterval(IndexType castingRegionIdx) const
{
   VALIDATE(BRIDGE);
   return m_IntervalManager.GetCompositeDeckInterval(castingRegionIdx);
}

IntervalIndexType CBridgeAgentImp::GetFirstCompositeDeckInterval() const
{
   VALIDATE(BRIDGE);
   return m_IntervalManager.GetFirstCompositeDeckInterval();
}

IntervalIndexType CBridgeAgentImp::GetLastCompositeDeckInterval() const
{
   VALIDATE(BRIDGE);
   return m_IntervalManager.GetLastCompositeDeckInterval();
}

IntervalIndexType CBridgeAgentImp::GetCastShearKeyInterval() const
{
   GET_IFACE(IBridgeDescription, pIBridgeDesc);

   const CBridgeDescription2* pBridgeDesc = pIBridgeDesc->GetBridgeDescription();
   pgsTypes::SupportedBeamSpacing spacingType = pBridgeDesc->GetGirderSpacingType();

   GroupIndexType nGroups = pBridgeDesc->GetGirderGroupCount();
   for (GroupIndexType grpIdx = 0; grpIdx < nGroups; grpIdx++)
   {
      const CGirderGroupData* pGroup = pBridgeDesc->GetGirderGroup(grpIdx);
      GirderIndexType nGirders = pGroup->GetGirderCount();
      for (GirderIndexType gdrIdx = 0; gdrIdx < nGirders; gdrIdx++)
      {
         if (HasShearKey(CGirderKey(grpIdx, gdrIdx), spacingType))
         {
            return GetLastNoncompositeInterval();
         }
      }
   }

   return INVALID_INDEX;
}

IntervalIndexType CBridgeAgentImp::GetConstructionLoadInterval() const
{
   return GetLastNoncompositeInterval();
}

IntervalIndexType CBridgeAgentImp::GetFirstStressStrandInterval(const CGirderKey& girderKey) const
{
   VALIDATE(BRIDGE);
   return m_IntervalManager.GetFirstStressStrandInterval(girderKey);
}

IntervalIndexType CBridgeAgentImp::GetLastStressStrandInterval(const CGirderKey& girderKey) const
{
   VALIDATE(BRIDGE);
   return m_IntervalManager.GetLastStressStrandInterval(girderKey);
}

IntervalIndexType CBridgeAgentImp::GetStressStrandInterval(const CSegmentKey& segmentKey) const
{
   VALIDATE(BRIDGE);
   return m_IntervalManager.GetStressStrandInterval(segmentKey);
}

IntervalIndexType CBridgeAgentImp::GetFirstPrestressReleaseInterval(const CGirderKey& girderKey) const
{
   VALIDATE(BRIDGE);
   return m_IntervalManager.GetFirstPrestressReleaseInterval(girderKey);
}

IntervalIndexType CBridgeAgentImp::GetLastPrestressReleaseInterval(const CGirderKey& girderKey) const
{
   VALIDATE(BRIDGE);
   return m_IntervalManager.GetLastPrestressReleaseInterval(girderKey);
}

IntervalIndexType CBridgeAgentImp::GetPrestressReleaseInterval(const CSegmentKey& segmentKey) const
{
   VALIDATE(BRIDGE);
   return m_IntervalManager.GetPrestressReleaseInterval(segmentKey);
}

IntervalIndexType CBridgeAgentImp::GetLiftSegmentInterval(const CSegmentKey& segmentKey) const
{
   VALIDATE(BRIDGE);
   return m_IntervalManager.GetLiftingInterval(segmentKey);
}

IntervalIndexType CBridgeAgentImp::GetFirstLiftSegmentInterval(const CGirderKey& girderKey) const
{
   VALIDATE(BRIDGE);
   return m_IntervalManager.GetFirstLiftingInterval(girderKey);
}

IntervalIndexType CBridgeAgentImp::GetLastLiftSegmentInterval(const CGirderKey& girderKey) const
{
   VALIDATE(BRIDGE);
   return m_IntervalManager.GetLastLiftingInterval(girderKey);
}

IntervalIndexType CBridgeAgentImp::GetStorageInterval(const CSegmentKey& segmentKey) const
{
   VALIDATE(BRIDGE);
   return m_IntervalManager.GetStorageInterval(segmentKey);
}

IntervalIndexType CBridgeAgentImp::GetFirstStorageInterval(const CGirderKey& girderKey) const
{
   VALIDATE(BRIDGE);
   return m_IntervalManager.GetFirstStorageInterval(girderKey);
}

IntervalIndexType CBridgeAgentImp::GetLastStorageInterval(const CGirderKey& girderKey) const
{
   VALIDATE(BRIDGE);
   return m_IntervalManager.GetLastStorageInterval(girderKey);
}

IntervalIndexType CBridgeAgentImp::GetHaulSegmentInterval(const CSegmentKey& segmentKey) const
{
   VALIDATE(BRIDGE);
   return m_IntervalManager.GetHaulingInterval(segmentKey);
}

bool CBridgeAgentImp::IsHaulSegmentInterval(IntervalIndexType intervalIdx) const
{
   VALIDATE(BRIDGE);
   return m_IntervalManager.IsHaulingInterval(intervalIdx);
}

IntervalIndexType CBridgeAgentImp::GetFirstSegmentErectionInterval(const CGirderKey& girderKey) const
{
   VALIDATE(BRIDGE);
   return m_IntervalManager.GetFirstSegmentErectionInterval(girderKey);
}

IntervalIndexType CBridgeAgentImp::GetLastSegmentErectionInterval(const CGirderKey& girderKey) const
{
   VALIDATE(BRIDGE);
   return m_IntervalManager.GetLastSegmentErectionInterval(girderKey);
}

IntervalIndexType CBridgeAgentImp::GetErectSegmentInterval(const CSegmentKey& segmentKey) const
{
   VALIDATE(BRIDGE);
   return m_IntervalManager.GetErectSegmentInterval(segmentKey);
}

bool CBridgeAgentImp::IsSegmentErectionInterval(IntervalIndexType intervalIdx) const
{
   VALIDATE(BRIDGE);
   return m_IntervalManager.IsSegmentErectionInterval(intervalIdx);
}

bool CBridgeAgentImp::IsSegmentErectionInterval(const CGirderKey& girderKey,IntervalIndexType intervalIdx) const
{
   VALIDATE(BRIDGE);
   return m_IntervalManager.IsSegmentErectionInterval(girderKey,intervalIdx);
}

IntervalIndexType CBridgeAgentImp::GetTemporaryStrandStressingInterval(const CSegmentKey& segmentKey) const
{
   // this is the interval when the temporary strands are actually stressed... if the TTS are pretensioned,
   // they are stressed before release
   GET_IFACE(IBridgeDescription,pIBridgeDesc);
   const CPrecastSegmentData* pSegment = pIBridgeDesc->GetPrecastSegmentData(segmentKey);
   if ( pSegment->Strands.GetTemporaryStrandUsage() == pgsTypes::ttsPretensioned )
   {
      return GetStressStrandInterval(segmentKey);
   }
   else
   {
      // temp strands are post-tensioned.. they are stressed in the same interval they are installed
      return GetTemporaryStrandInstallationInterval(segmentKey);
   }
}

IntervalIndexType CBridgeAgentImp::GetTemporaryStrandInstallationInterval(const CSegmentKey& segmentKey) const
{
   // this is the interval when the temporary strand force is imparted into the girder segment
   GET_IFACE(IBridgeDescription,pIBridgeDesc);
   const CPrecastSegmentData* pSegment = pIBridgeDesc->GetPrecastSegmentData(segmentKey);

   IntervalIndexType intervalIdx;
   switch( pSegment->Strands.GetTemporaryStrandUsage() )
   {
   case pgsTypes::ttsPretensioned:
      intervalIdx = GetPrestressReleaseInterval(segmentKey);
      break;

   case pgsTypes::ttsPTBeforeLifting:
      intervalIdx = GetLiftSegmentInterval(segmentKey);
      break;

   case pgsTypes::ttsPTAfterLifting:
      intervalIdx = GetLiftSegmentInterval(segmentKey) + 1;
      break;
      
   case pgsTypes::ttsPTBeforeShipping:
      intervalIdx = GetHaulSegmentInterval(segmentKey);
      break;
   }

   return intervalIdx;
}

IntervalIndexType CBridgeAgentImp::GetTemporaryStrandRemovalInterval(const CSegmentKey& segmentKey) const
{
   VALIDATE(BRIDGE);
   return m_IntervalManager.GetTemporaryStrandRemovalInterval(segmentKey);
}

IntervalIndexType CBridgeAgentImp::GetLiveLoadInterval() const
{
   VALIDATE(BRIDGE);
   return m_IntervalManager.GetLiveLoadInterval();
}

IntervalIndexType CBridgeAgentImp::GetLoadRatingInterval() const
{
   VALIDATE(BRIDGE);
   GET_IFACE(IBridgeDescription,pIBridgeDesc);
   const CTimelineManager* pTimelineMgr = pIBridgeDesc->GetTimelineManager();
   EventIndexType eventIdx = pTimelineMgr->GetLoadRatingEventIndex();
   if ( eventIdx == INVALID_INDEX )
   {
      // load rating event wasn't specifically defined... assum last interval
      return m_IntervalManager.GetIntervalCount()-1;
   }
   else
   {
      return m_IntervalManager.GetInterval(eventIdx);
   }
}

IntervalIndexType CBridgeAgentImp::GetOverlayInterval() const
{
   VALIDATE(BRIDGE);
   return m_IntervalManager.GetOverlayInterval();
}

IntervalIndexType CBridgeAgentImp::GetInstallRailingSystemInterval() const
{
   VALIDATE(BRIDGE);
   return m_IntervalManager.GetInstallRailingSystemInterval();
}

IntervalIndexType CBridgeAgentImp::GetStressSegmentTendonInterval(const CSegmentKey& segmentKey) const
{
   VALIDATE(BRIDGE);
   return m_IntervalManager.GetStressSegmentTendonInterval(segmentKey);
}

IntervalIndexType CBridgeAgentImp::GetFirstSegmentTendonStressingInterval(const CGirderKey& girderKey) const
{
   VALIDATE(BRIDGE);
   return m_IntervalManager.GetFirstSegmentTendonStressingInterval(girderKey);
}

IntervalIndexType CBridgeAgentImp::GetLastSegmentTendonStressingInterval(const CGirderKey& girderKey) const
{
   VALIDATE(BRIDGE);
   return m_IntervalManager.GetLastSegmentTendonStressingInterval(girderKey);
}

IntervalIndexType CBridgeAgentImp::GetFirstGirderTendonStressingInterval(const CGirderKey& girderKey) const
{
   VALIDATE(BRIDGE);
   return m_IntervalManager.GetFirstGirderTendonStressingInterval(girderKey);
}

IntervalIndexType CBridgeAgentImp::GetLastGirderTendonStressingInterval(const CGirderKey& girderKey) const
{
   VALIDATE(BRIDGE);

   return m_IntervalManager.GetLastGirderTendonStressingInterval(girderKey);
}

IntervalIndexType CBridgeAgentImp::GetStressGirderTendonInterval(const CGirderKey& girderKey,DuctIndexType ductIdx) const
{
   VALIDATE(BRIDGE);
   ATLASSERT(ductIdx != INVALID_INDEX);
   return m_IntervalManager.GetStressGirderTendonInterval(girderKey,ductIdx);
}

bool CBridgeAgentImp::IsGirderTendonStressingInterval(const CGirderKey& girderKey,IntervalIndexType intervalIdx) const
{
   VALIDATE(BRIDGE);
   ATLASSERT(intervalIdx != INVALID_INDEX);

   DuctIndexType nDucts = GetDuctCount(girderKey);
   for ( DuctIndexType ductIdx = 0; ductIdx < nDucts; ductIdx++ )
   {
      IntervalIndexType stressingIntervalIdx = GetStressGirderTendonInterval(girderKey,ductIdx);
      if ( stressingIntervalIdx == intervalIdx )
      {
         return true;
      }
   }

   return false;
}

bool CBridgeAgentImp::IsUserDefinedLoadingInterval(IntervalIndexType intervalIdx) const
{
   VALIDATE(BRIDGE);
   return m_IntervalManager.IsUserDefinedLoadingInterval(intervalIdx);
}

bool CBridgeAgentImp::IsSegmentTendonStressingInterval(const CSegmentKey& segmentKey, IntervalIndexType intervalIdx) const
{
   VALIDATE(BRIDGE);
   ATLASSERT(intervalIdx != INVALID_INDEX);

   DuctIndexType nDucts = GetDuctCount(segmentKey);
   for (DuctIndexType ductIdx = 0; ductIdx < nDucts; ductIdx++)
   {
      IntervalIndexType stressingIntervalIdx = GetStressSegmentTendonInterval(segmentKey);
      if (stressingIntervalIdx == intervalIdx)
      {
         return true;
      }
   }

   return false;
}

bool CBridgeAgentImp::IsStressingInterval(const CGirderKey& girderKey,IntervalIndexType intervalIdx) const
{
   SegmentIndexType nSegments = GetSegmentCount(girderKey);
   for ( SegmentIndexType segIdx = 0; segIdx < nSegments; segIdx++ )
   {
      CSegmentKey segmentKey(girderKey,segIdx);
      IntervalIndexType releaseIntervalIdx = GetPrestressReleaseInterval(segmentKey);
      if ( intervalIdx == releaseIntervalIdx )
      {
         return true;
      }

      StrandIndexType Nt = GetStrandCount(segmentKey,pgsTypes::Temporary);
      if ( 0 < Nt )
      {
         IntervalIndexType tempStrandInstallationIntervalIdx = GetTemporaryStrandInstallationInterval(segmentKey);
         if ( tempStrandInstallationIntervalIdx == intervalIdx )
         {
            return true;
         }

         IntervalIndexType tempStrandRemovalIntervalIdx = GetTemporaryStrandRemovalInterval(segmentKey);
         if ( tempStrandRemovalIntervalIdx == intervalIdx )
         {
            return true;
         }
      }

      if (IsSegmentTendonStressingInterval(segmentKey, intervalIdx))
      {
         return true;
      }
   }

   return IsGirderTendonStressingInterval(girderKey, intervalIdx);
}

IntervalIndexType CBridgeAgentImp::GetTemporarySupportErectionInterval(SupportIndexType tsIdx) const
{
   VALIDATE(BRIDGE);
   return m_IntervalManager.GetTemporarySupportErectionInterval(tsIdx);
}

IntervalIndexType CBridgeAgentImp::GetTemporarySupportRemovalInterval(SupportIndexType tsIdx) const
{
   VALIDATE(BRIDGE);
   return m_IntervalManager.GetTemporarySupportRemovalInterval(tsIdx);
}

std::vector<IntervalIndexType> CBridgeAgentImp::GetTemporarySupportRemovalIntervals(GroupIndexType groupIdx) const
{
   std::vector<IntervalIndexType> tsrIntervals;

   GET_IFACE(IBridgeDescription,pIBridgeDesc);

   GroupIndexType firstGroupIdx = (groupIdx == ALL_GROUPS ? 0 : groupIdx);
   GroupIndexType lastGroupIdx  = (groupIdx == ALL_GROUPS ? GetGirderGroupCount()-1 : firstGroupIdx);
   for ( GroupIndexType grpIdx = firstGroupIdx; grpIdx <= lastGroupIdx; grpIdx++ )
   {
      // Get the intervals when temporary supports are removed for this group
      const CGirderGroupData* pGroup = pIBridgeDesc->GetGirderGroup(grpIdx);
      const CSpanData2* pSpan        = pGroup->GetPier(pgsTypes::metStart)->GetNextSpan();
      const CSpanData2* pEndSpan     = pGroup->GetPier(pgsTypes::metEnd)->GetNextSpan();

      while ( pSpan != pEndSpan )
      {
         std::vector<const CTemporarySupportData*> vTS( pSpan->GetTemporarySupports() );
         std::vector<const CTemporarySupportData*>::iterator tsIter(vTS.begin());
         std::vector<const CTemporarySupportData*>::iterator tsIterEnd(vTS.end());
         for ( ; tsIter != tsIterEnd; tsIter++ )
         {
            const CTemporarySupportData* pTS = *tsIter;
            SupportIndexType tsIdx = pTS->GetIndex();
            ATLASSERT(tsIdx != INVALID_INDEX);
            
            IntervalIndexType intervalIdx = GetTemporarySupportRemovalInterval(tsIdx);
            ATLASSERT(intervalIdx != INVALID_INDEX);

            tsrIntervals.push_back( intervalIdx );
         }

         pSpan = pSpan->GetNextPier()->GetNextSpan();
      }
   }

   // sort and remove any duplicates
   std::sort(tsrIntervals.begin(),tsrIntervals.end());
   tsrIntervals.erase( std::unique(tsrIntervals.begin(),tsrIntervals.end()), tsrIntervals.end() );

   return tsrIntervals;
}

std::vector<IntervalIndexType> CBridgeAgentImp::GetUserDefinedLoadIntervals(const CSpanKey& spanKey) const
{
   std::vector<IntervalIndexType> vIntervals;

   SpanIndexType nSpans = GetSpanCount();
   SpanIndexType startSpanIdx = (spanKey.spanIndex == ALL_SPANS ? 0 : spanKey.spanIndex);
   SpanIndexType endSpanIdx   = (spanKey.spanIndex == ALL_SPANS ? nSpans-1 : startSpanIdx);

   IntervalIndexType nIntervals = GetIntervalCount();

   // loads are defined by span, so loop over all the spans in the range
   for ( SpanIndexType spanIdx = startSpanIdx; spanIdx <= endSpanIdx; spanIdx++ )
   {
      CSpanKey thisSpanKey(spanIdx,spanKey.girderIndex);

      GirderIndexType nGirders = GetGirderCountBySpan(spanIdx);
      thisSpanKey.girderIndex = Min(spanKey.girderIndex,nGirders-1);

      for ( IntervalIndexType intervalIdx = 0; intervalIdx < nIntervals; intervalIdx++ )
      {
         if ( DoUserLoadsExist(thisSpanKey,intervalIdx) )
         {
            // user defined loads are defined in this interval
            vIntervals.push_back(intervalIdx);
         }
      } // interval loop
   } // span loop

   return vIntervals;
}

std::vector<IntervalIndexType> CBridgeAgentImp::GetUserDefinedLoadIntervals(const CSpanKey& spanKey,pgsTypes::ProductForceType pfType) const
{
   std::vector<IntervalIndexType> vIntervals;

   SpanIndexType nSpans = GetSpanCount();
   SpanIndexType startSpanIdx = (spanKey.spanIndex == ALL_SPANS ? 0 : spanKey.spanIndex);
   SpanIndexType endSpanIdx   = (spanKey.spanIndex == ALL_SPANS ? nSpans-1 : startSpanIdx);

   IntervalIndexType nIntervals = GetIntervalCount();

   ATLASSERT(pfType == pgsTypes::pftUserDC || pfType == pgsTypes::pftUserDW);
   IUserDefinedLoads::UserDefinedLoadCase loadCase = (pfType == pgsTypes::pftUserDC ? IUserDefinedLoads::userDC : IUserDefinedLoads::userDW);

   // loads are defined by span, so loop over all the spans in the range
   for ( SpanIndexType spanIdx = startSpanIdx; spanIdx <= endSpanIdx; spanIdx++ )
   {
      CSpanKey thisSpanKey(spanIdx,spanKey.girderIndex);

      GirderIndexType nGirders = GetGirderCountBySpan(spanIdx);
      thisSpanKey.girderIndex = Min(spanKey.girderIndex,nGirders-1);

      for ( IntervalIndexType intervalIdx = 0; intervalIdx < nIntervals; intervalIdx++ )
      {
         if ( DoUserLoadsExist(thisSpanKey,intervalIdx,loadCase) )
         {
            // user defined loads are defined in this interval
            vIntervals.push_back(intervalIdx);
         }
      } // interval loop
   } // span loop

   return vIntervals;
}

IntervalIndexType CBridgeAgentImp::GetNoncompositeUserLoadInterval() const
{
   return GetLastNoncompositeInterval();
}

IntervalIndexType CBridgeAgentImp::GetCompositeUserLoadInterval() const
{
   return GetInstallRailingSystemInterval();
}

IntervalIndexType CBridgeAgentImp::GetLastNoncompositeInterval() const
{
   IntervalIndexType castDiaphragmsIntervalIdx = GetCastIntermediateDiaphragmsInterval();
   IntervalIndexType castLongitudinalJointsIntervalIdx = GetCastLongitudinalJointInterval();
   IntervalIndexType compositeLongitudinalJointsIntervalIdx = GetCompositeLongitudinalJointInterval();
   IntervalIndexType castDeckIntervalIdx = IsNonstructuralDeck(GetDeckType()) ? INVALID_INDEX : GetFirstCastDeckInterval();

   if (castLongitudinalJointsIntervalIdx == INVALID_INDEX)
   {
      // no longitudinal joints.... set the interval to something that wont be the max
      castLongitudinalJointsIntervalIdx = 0;
   }

   if (castDeckIntervalIdx == INVALID_INDEX)
   {
      // no cast deck.... set the interval to something that wont be the max
      castDeckIntervalIdx = 0;
   }
   else if (compositeLongitudinalJointsIntervalIdx <= castDeckIntervalIdx)
   {
      // there is a cast deck, but it is cast at or after the longituinal joints are composite
      // set the interval to something that wont be the max
      castDeckIntervalIdx = 0;
   }

   // we want the greatest of the three "casting" intervals
   IntervalIndexType intervalIdx = Max(castDiaphragmsIntervalIdx, castLongitudinalJointsIntervalIdx, castDeckIntervalIdx);
   return intervalIdx;
}

IntervalIndexType CBridgeAgentImp::GetLastCompositeInterval() const
{
   IntervalIndexType compositeLongitudinalJointsIntervalIdx = GetCompositeLongitudinalJointInterval();
   IntervalIndexType compositeDeckIntervalIdx = IsNonstructuralDeck(GetDeckType()) ? INVALID_INDEX : GetLastCompositeDeckInterval();
   IntervalIndexType trafficBarrierIntervalIdx = GetInstallRailingSystemInterval();

   if (compositeDeckIntervalIdx != INVALID_INDEX)
   {
      return compositeDeckIntervalIdx;
   }
   else if (compositeLongitudinalJointsIntervalIdx != INVALID_INDEX)
   {
      return compositeLongitudinalJointsIntervalIdx;
   }
   else
   {
      return trafficBarrierIntervalIdx;
   }
}

IntervalIndexType CBridgeAgentImp::GetGeometryControlInterval() const
{
   VALIDATE(BRIDGE);
   return m_IntervalManager.GetGeometryControlEventInterval();
}

std::vector<IntervalIndexType> CBridgeAgentImp::GetReportingGeometryControlIntervals() const
{
   VALIDATE(BRIDGE);
   return m_IntervalManager.GetGeometryControlIntervals(pgsTypes::gcaGeometryReportingEvent);
}

std::vector<IntervalIndexType> CBridgeAgentImp::GetSpecCheckGeometryControlIntervals() const
{
   VALIDATE(BRIDGE);
   return m_IntervalManager.GetGeometryControlIntervals(pgsTypes::gcaSpecCheckEvent);
}

////////////////////////////////////
Float64 CBridgeAgentImp::ConvertSegmentDuctOffsetToDuctElevation(const CSegmentKey& segmentKey, const CPrecastSegmentData* pSegment, Float64 Xs, Float64 offset, pgsTypes::FaceType offsetType) const
{
   if (offsetType == pgsTypes::TopFace)
   {
      return -offset;
   }
   else
   {
      ATLASSERT(offsetType == pgsTypes::BottomFace);
      pgsPointOfInterest poi = GetPointOfInterest(segmentKey, Xs);
      Float64 Hg;
      if (pSegment)
      {
         Hg = GetSegmentHeight(pSegment, Xs);
      }
      else
      {
         Hg = GetHeight(poi);
      }
      return offset - Hg;
   }
}

Float64 CBridgeAgentImp::ConvertDuctOffsetToDuctElevation(const CGirderKey& girderKey, const CSplicedGirderData* pGirder, Float64 Xg,Float64 offset,CDuctGeometry::OffsetType offsetType) const
{
   // Returns the elevation of the duct relative to the top of the girder
   if ( offsetType == CDuctGeometry::TopGirder )
   {
      return -offset;
   }
   else
   {
      ATLASSERT(offsetType == pgsTypes::BottomGirder);
      pgsPointOfInterest poi = ConvertGirderCoordinateToPoi(girderKey, Xg);
      Float64 Hg;
      if (pGirder)
      {
         const CPrecastSegmentData* pSegment = pGirder->GetSegment(poi.GetSegmentKey().segmentIndex);
         Hg = GetSegmentHeight(pSegment, poi.GetDistFromStart());
      }
      else
      {
         Hg = GetHeight(poi);
      }
      return offset - Hg;
   }
}

std::unique_ptr<WBFL::Math::CompositeFunction> CBridgeAgentImp::CreateDuctCenterline(const CGirderKey& girderKey, const CSplicedGirderData* pGirder, const CParabolicDuctGeometry& ductGeometry) const
{
   auto fnCenterline(std::make_unique<WBFL::Math::CompositeFunction>());

   PierIndexType startPierIdx, endPierIdx;
   ductGeometry.GetRange(&startPierIdx, &endPierIdx);
   SpanIndexType startSpanIdx = (SpanIndexType)startPierIdx;
   SpanIndexType endSpanIdx = (SpanIndexType)(endPierIdx - 1);

   SpanIndexType startGroupSpanIdx, endGroupSpanIdx;
   GetGirderGroupSpans(girderKey.groupIndex, &startGroupSpanIdx, &endGroupSpanIdx);

   Float64 Ls_offset = 0;
   for (SpanIndexType spanIdx = startGroupSpanIdx; spanIdx < startSpanIdx; spanIdx++)
   {
      Float64 L = GetSpanLength(spanIdx, girderKey.girderIndex);
      Ls_offset += L;
   }
   Float64 x1 = Ls_offset; // x is measured from the start face of the girder. x1 is where the tendon starts

   //
   // Start to first low point
   //
   SpanIndexType nSpans = ductGeometry.GetSpanCount();

   // start point
   PierIndexType pierIdx;
   Float64 dist,offset;
   CDuctGeometry::OffsetType offsetType;
   ductGeometry.GetStartPoint(&pierIdx,&dist,&offset,&offsetType);
   if (dist < 0) // fraction of the span length
   {
      dist *= -GetSpanLength(startSpanIdx, girderKey.girderIndex);
   }

   x1 += dist;
   Float64 y1 = ConvertDuctOffsetToDuctElevation(girderKey,pGirder,x1,offset,offsetType);

   // low point
   ductGeometry.GetLowPoint(startSpanIdx,&dist,&offset,&offsetType);
   if ( dist < 0 ) // fraction of the span length
   {
      dist *= -GetSpanLength(startSpanIdx,girderKey.girderIndex);
   }

   Float64 x2 = x1 + dist;
   Float64 y2 = ConvertDuctOffsetToDuctElevation(girderKey,pGirder,x2,offset,offsetType);

   WBFL::Math::PolynomialFunction leftParabola = GenerateParabola2(x1,y1,x2,y2,0.0);
   fnCenterline->AddFunction(x1,x2,leftParabola);

   x1 = x2; // start next group of parabolas at the low point
   y1 = y2;

   //
   // Low Point to High Point to Low Point
   //
   Float64 x3,y3;
   WBFL::Math::PolynomialFunction rightParabola;
   Float64 startStation = GetPierStation(startPierIdx);
   Float64 Ls = Ls_offset;
   for ( PierIndexType pierIdx = startPierIdx+1; pierIdx < endPierIdx; pierIdx++ )
   {
      SpanIndexType prevSpanIdx = SpanIndexType(pierIdx-1);
      SpanIndexType nextSpanIdx = prevSpanIdx+1;

      Float64 distLeftIP, highOffset, distRightIP;
      CDuctGeometry::OffsetType highOffsetType;
      ductGeometry.GetHighPoint(pierIdx,&distLeftIP,&highOffset,&highOffsetType,&distRightIP);

      // low to high point
      Ls += GetSpanLength(prevSpanIdx,girderKey.girderIndex);
      x3 = Ls;
      y3 = ConvertDuctOffsetToDuctElevation(girderKey,pGirder,x3,highOffset,highOffsetType);

      if ( distLeftIP < 0 ) // fraction of distance between low and high point
      {
         distLeftIP *= -(x3-x1);
      }

      x2 = x3 - distLeftIP; // inflection point measured from high point

      GenerateReverseParabolas(x1,y1,x2,x3,y3,&leftParabola,&rightParabola);
      fnCenterline->AddFunction(x1,x2,leftParabola);
      fnCenterline->AddFunction(x2,x3,rightParabola);

      // high to low point
      ductGeometry.GetLowPoint(pierIdx,&dist,&offset,&offsetType);
      x1 = x3; 
      y1 = y3;

      if ( dist < 0 ) // fraction of span length
      {
         dist *= -GetSpanLength(nextSpanIdx,girderKey.girderIndex);
      }

      if ( nextSpanIdx == nSpans-1 )
      {
         // low point in last span is measured from the right end
         // change it around to be measured from the left end
         dist = GetSpanLength(nextSpanIdx,girderKey.girderIndex) - dist;
      }

      x3 = x1 + dist; // low point, measured from previous high point
      y3 = ConvertDuctOffsetToDuctElevation(girderKey,pGirder,x3,offset,offsetType);

      if ( distRightIP < 0 ) // fraction of distance between high and low point
      {
         distRightIP *= -(x3 - x1);
      }

      x2 = x1 + distRightIP; // inflection point measured from high point

      GenerateReverseParabolas(x1,y1,x2,x3,y3,&leftParabola,&rightParabola);
      fnCenterline->AddFunction(x1,x2,leftParabola);
      fnCenterline->AddFunction(x2,x3,rightParabola);

      x1 = x3;
      y1 = y3;
   }

   //
   // last low point to end
   //
   ductGeometry.GetEndPoint(&pierIdx,&dist,&offset,&offsetType);
   if ( dist < 0 ) // fraction of last span length
   {
      dist *= -GetSpanLength(startSpanIdx + nSpans-1,girderKey.girderIndex);
   }

   Float64 Lg = GetGirderLength(girderKey);
   for (SpanIndexType spanIdx = endSpanIdx + 1; spanIdx <= endGroupSpanIdx; spanIdx++)
   {
      Float64 L = GetSpanLength(spanIdx, girderKey.girderIndex);
      Lg -= L;
   }

   x2 = Lg - dist;
   y2 = ConvertDuctOffsetToDuctElevation(girderKey,pGirder,x2,offset,offsetType);
   rightParabola = GenerateParabola1(x1,y1,x2,y2,0.0);
   fnCenterline->AddFunction(x1,x2,rightParabola);

   return fnCenterline;
}

void CBridgeAgentImp::CreateDuctCenterline(const CGirderKey& girderKey, const CSplicedGirderData* pGirder, const CParabolicDuctGeometry& geometry,IPoint2dCollection** ppPoints) const
{
   auto fnCenterline = CreateDuctCenterline(girderKey,pGirder,geometry);
   IndexType nFunctions = fnCenterline->GetFunctionCount();

   CComPtr<IPoint2dCollection> points;
   points.CoCreateInstance(CLSID_Point2dCollection);
   points.CopyTo(ppPoints);

   for ( IndexType fnIdx = 0; fnIdx < nFunctions; fnIdx++ )
   {
      Float64 xMin,xMax;
      auto& pFN = fnCenterline->GetFunction(fnIdx,&xMin,&xMax);
      for ( int i = 0; i < 11; i++ )
      {
         Float64 x = xMin + i*(xMax-xMin)/10;
         Float64 y = fnCenterline->Evaluate(x);

         CComPtr<IPoint2d> p;
         p.CoCreateInstance(CLSID_Point2d);
         p->Move(x,y);
         points->Add(p);
      }
   }
}

void CBridgeAgentImp::CreateDuctCenterline(const CGirderKey& girderKey, const CSplicedGirderData* pGirder, const COffsetDuctGeometry& geometry,IPoint2dCollection** ppPoints) const
{
   ATLASSERT(*ppPoints != nullptr); // should contain the points from the duct that this duct offsets from

   CollectionIndexType nPoints;
   (*ppPoints)->get_Count(&nPoints);
   for ( CollectionIndexType idx = 0; idx < nPoints; idx++ )
   {
      CComPtr<IPoint2d> point;
      (*ppPoints)->get_Item(idx,&point);

      Float64 x,y;
      point->Location(&x,&y);
      Float64 offset = geometry.GetOffset(x);
      y += offset;

      point->put_Y(y);
   }
}

////////////////////////////////////////////////////////////////////////
// IBridgeDescriptionEventSink
//
HRESULT CBridgeAgentImp::OnBridgeChanged(CBridgeChangedHint* pHint)
{
//   LOG(_T("OnBridgeChanged Event Received"));
   INVALIDATE( CLEAR_ALL );
   return S_OK;
}

HRESULT CBridgeAgentImp::OnGirderFamilyChanged()
{
//   LOG(_T("OnGirderFamilyChanged Event Received"));
   INVALIDATE( CLEAR_ALL );
   return S_OK;
}

HRESULT CBridgeAgentImp::OnGirderChanged(const CGirderKey& girderKey,Uint32 lHint)
{
   INVALIDATE( CLEAR_ALL );
   return S_OK;
}

HRESULT CBridgeAgentImp::OnLiveLoadChanged()
{
   // No changes necessary to bridge model
   LOG(_T("OnLiveLoadChanged Event Received"));
   return S_OK;
}

HRESULT CBridgeAgentImp::OnLiveLoadNameChanged(LPCTSTR strOldName,LPCTSTR strNewName)
{
   // No changes necessary to bridge model
   LOG(_T("OnLiveLoadNameChanged Event Received"));
   return S_OK;
}

HRESULT CBridgeAgentImp::OnConstructionLoadChanged()
{
   LOG(_T("OnConstructionLoadChanged Event Received"));
   return S_OK;
}

////////////////////////////////////////////////////////////////////////
// ISpecificationEventSink
HRESULT CBridgeAgentImp::OnSpecificationChanged()
{
//   LOG(_T("OnSpecificationChanged Event Received"));
   INVALIDATE( CLEAR_ALL );
   return S_OK;
}

////////////////////////////////////////////////////////////////////////
// ILossParametersEventSink
HRESULT CBridgeAgentImp::OnLossParametersChanged()
{
   // When the loss parameters are changed, we have to invalidate
   // the transformed section properties. For time-step analysis,
   // the transformed section properties are computed with age
   // adjusted modulus which depend on creep. If creep effects
   // are toggled between enabled and disabled, the section properties
   // have to be updated. Since the event model doesn't say which
   // loss parameter changed, we just have to blast the transformed
   // section properties.
   InvalidateSectionProperties(pgsTypes::sptTransformed);
   InvalidateSectionProperties(pgsTypes::sptTransformedNoncomposite);
   return S_OK;
}

////////////////////////////////////////////////////////////////////////
HRESULT CBridgeAgentImp::OnAnalysisTypeChanged()
{
   // Remove critical section POIs.
   // They will move when the analysis type changes
   CollectionIndexType size = sizeof(m_CriticalSectionState) / sizeof(std::set<CGirderKey>);
   for (CollectionIndexType idx = 0; idx < size; idx++)
   {
      m_CriticalSectionState[idx].clear();
   }

   m_pPoiMgr->RemovePointsOfInterest(POI_CRITSECTSHEAR1);
   m_pPoiMgr->RemovePointsOfInterest(POI_CRITSECTSHEAR2);
   return S_OK;
}

void CBridgeAgentImp::GetAlignment(IAlignment** ppAlignment) const
{
   VALIDATE(BRIDGE);
   HRESULT hr = m_Bridge->get_Alignment(ppAlignment);
   ATLASSERT(SUCCEEDED(hr));
}

void CBridgeAgentImp::GetProfile(IProfile** ppProfile) const
{
   CComPtr<IAlignment> alignment;
   GetAlignment(&alignment);
   HRESULT hr = alignment->GetProfile(CBridgeGeometryModelBuilder::ProfileID,ppProfile);
   ATLASSERT(SUCCEEDED(hr));
   ATLASSERT(*ppProfile != nullptr);
}

void CBridgeAgentImp::GetBarrierProperties(pgsTypes::TrafficBarrierOrientation orientation,IShapeProperties** props) const
{
   CComPtr<ISidewalkBarrier> barrier;
   if ( orientation == pgsTypes::tboLeft )
   {
      m_Bridge->get_LeftBarrier(&barrier);
   }
   else
   {
      m_Bridge->get_RightBarrier(&barrier);
   }

   if ( barrier == nullptr )
   {
      *props = 0;
      return;
   }

   CComPtr<IShape> shape;
   barrier->get_Shape(&shape);

   shape->get_ShapeProperties(props);
}

PoiIntervalKey CBridgeAgentImp::GetSectionPropertiesKey(IntervalIndexType intervalIdx,const pgsPointOfInterest& poi,pgsTypes::SectionPropertyType sectPropType) const
{
   // The section properties storage is set up for the most general case... time-step analysis. We compute and store
   // section properties at every poi and at every interval. This is very inefficient for non-time-step analysis.
   // To get around this problem, this method defines a PoiIntervalKey used for computing and storing section properties.
   // Section properties are only computed for certain POIs and intervals, reducing the work done.

   GET_IFACE(ILossParameters,pLossParams);
   if ( pLossParams->GetLossMethod() == pgsTypes::TIME_STEP )
   {
      // no mapping for this case
      return PoiIntervalKey(poi,intervalIdx);
   }
   else
   {
      // not doing time-step analysis... 
      const auto& segmentKey(poi.GetSegmentKey());

      // storage interval is the last interval for release strength
      IntervalIndexType storageIntervalIdx = GetStorageInterval(segmentKey);
      IntervalIndexType compositeIntervalIdx = GetLastCompositeInterval();
      if ( intervalIdx <= storageIntervalIdx)
      {
         IntervalIndexType releaseIntervalIdx = GetPrestressReleaseInterval(segmentKey);
         return PoiIntervalKey(poi,releaseIntervalIdx);
      }
      else if (storageIntervalIdx < intervalIdx &&  intervalIdx < compositeIntervalIdx)
      {
         // this is an in between interval... the girder concrete is at the final strength, but the deck is not composite yet
         return PoiIntervalKey(poi, intervalIdx);
      }
      else
      {
         // girder is at final concrete strength and deck is composite
         GET_IFACE(ILibrary, pLib);
         GET_IFACE(ISpecification, pSpec);
         const SpecLibraryEntry* pSpecEntry = pLib->GetSpecEntry(pSpec->GetSpecification().c_str());
         bool bUse90DayStrength;
         Float64 factor;
         pSpecEntry->Use90DayStrengthForSlowCuringConcrete(&bUse90DayStrength, &factor);
         Float64 age = GetSegmentConcreteAge(segmentKey, intervalIdx, pgsTypes::Middle);
         auto type = GetSegmentConcreteType(segmentKey);
         if (type == pgsTypes::Normal && bUse90DayStrength && factor != 1.0 && 90 < age)
         {
            IntervalIndexType nIntervals = GetIntervalCount();
            return PoiIntervalKey(poi, nIntervals-1); // use last interval for properties since they will be the same from day 90 to the end
         }
         else
         {
            return PoiIntervalKey(poi, compositeIntervalIdx);
         }
      }
   }

#pragma Reminder("UPDATE: this can be more efficient")
   // we can make this concept more efficient by considering the section property type (gross, net, transformed) and if the segment is prismatic or not.
}

const CBridgeAgentImp::SectProp& CBridgeAgentImp::GetSectionProperties(IntervalIndexType ivalIdx,const pgsPointOfInterest& thePoi,pgsTypes::SectionPropertyType sectPropType) const
{
   VALIDATE(BRIDGE);

   USES_CONVERSION;

   PoiIntervalKey poiKey = GetSectionPropertiesKey(ivalIdx,thePoi,sectPropType);

   // check for on the fly properties
   if ( m_LOTFSectionPropertiesKey == poiKey && m_LOTFSectionPropertiesType == sectPropType )
   {
      return m_LOTFSectionProperties;
   }

   // Find properties and return... if not found, compute them now
   SectPropContainer::iterator found( m_pSectProps[sectPropType]->find(poiKey) );
   if ( found != m_pSectProps[sectPropType]->end() )
   {
      return (*found).second;
   }

   //
   //   ... not found ... compute, store, return stored value
   //
   SectProp props; 

   const pgsPointOfInterest& poi = poiKey.GetPoi();
   IntervalIndexType intervalIdx = poiKey.GetSubKey();

   const CSegmentKey& segmentKey = poi.GetSegmentKey();

   IndexType deckCastingRegionIdx = GetDeckCastingRegion(poi);

   IntervalIndexType releaseIntervalIdx       = GetPrestressReleaseInterval(segmentKey);
   IntervalIndexType compositeDeckIntervalIdx = GetCompositeDeckInterval(deckCastingRegionIdx);
   IntervalIndexType compositeIntervalIdx     = GetLastCompositeInterval();

   GET_IFACE(ILossParameters,pLossParams);
   bool bIsTimeStepAnalysis = (pLossParams->GetLossMethod() == pgsTypes::TIME_STEP ? true : false);


   // figure out where the poi is located and if the concrete is cured enough to make the section act as a structural member
   CClosureKey closureKey;
   bool bIsInClosureJoint          = IsInClosureJoint(poi,&closureKey);
   bool bIsOnSegment               = IsOnSegment(poi);
   bool bIsInBoundaryPierDiaphragm = IsInBoundaryPierDiaphragm(poi);
   bool bIsSection                 = IsStructuralSection(poi,intervalIdx);

   // if net deck properties are requested and the interval is before the deck is made composite
   // then the deck is not yet structural and its section properties are taken to be zero
   if (compositeDeckIntervalIdx != INVALID_INDEX)
   {
      if (sectPropType == pgsTypes::sptNetDeck && intervalIdx < compositeDeckIntervalIdx)
      {
         bIsSection = false;
      }
   }

   // if we can compute properties do it... otherwise the properties are taken to be zero
   if ( bIsSection )
   {
      Float64 Xs = poi.GetDistFromStart();

      GET_IFACE(ILibrary,       pLib);
      GET_IFACE(ISpecification, pSpec);
      const SpecLibraryEntry* pSpecEntry = pLib->GetSpecEntry( pSpec->GetSpecification().c_str() );

      if ( pSpecEntry->GetEffectiveFlangeWidthMethod() == pgsTypes::efwmTribWidth )
      {
         CComQIPtr<IPGSuperEffectiveFlangeWidthTool> eff_tool(m_EffFlangeWidthTool);
         ATLASSERT(eff_tool);
         eff_tool->put_UseTributaryWidth(VARIANT_TRUE);
      }

      GirderIDType leftGdrID,gdrID,rightGdrID;
      GetAdjacentSuperstructureMemberIDs(segmentKey,&leftGdrID,&gdrID,&rightGdrID);
      if (sectPropType == pgsTypes::sptGrossNoncomposite ||
         sectPropType == pgsTypes::sptGross ||
         sectPropType == pgsTypes::sptTransformedNoncomposite ||
         sectPropType == pgsTypes::sptTransformed ||
         sectPropType == pgsTypes::sptNetGirder)
      {
         CComPtr<ISection> section;
         IndexType gdr_idx, slab_idx;
         HRESULT hr = CreateSection(intervalIdx, poi, sectPropType, pgsTypes::scBridge, &gdr_idx, &slab_idx, &section);
         ATLASSERT(SUCCEEDED(hr));

         // Assuming section is a Composite section
         CComQIPtr<ICompositeSectionEx> compositeSection(section);
         ATLASSERT(compositeSection != nullptr);
         CComPtr<ICompositeSectionItemEx> sectionItem;
         compositeSection->get_Item(gdr_idx, &sectionItem);
         CComPtr<IShape> girderShape;
         sectionItem->get_Shape(&girderShape);
         girderShape->get_Perimeter(&props.Perimeter);

         // we got the shape in bridge coordinates, but what we really want is the shape in girder coordinates (0,0 at top cl of basic girder)
         // instead of creating the shape twice, once in bridge and once in girder coordinates, we get the shape
         // in bridge coordinates, figure out where it's top center point is, and then move the shape to girder coordinates
         // whenever we want the shape in bridge coordinates, we just offset it back to its original position
         CComQIPtr<IXYPosition> girderPosition(girderShape);
         CComPtr<IPoint2d> pntTC;
         girderPosition->get_LocatorPoint(lpTopCenter, &pntTC);
         pntTC->Location(&props.dx, &props.dy);
         CComQIPtr<IXYPosition> pos(section); // offset the entire cross section, not just the girder shape
         pos->Offset(-props.dx, -props.dy);

         CComQIPtr<IJointedSection> jointedSection(girderShape);
         if ( jointedSection )
         {
            CComPtr<IShape> leftJointShape, rightJointShape;
            jointedSection->GetJointShapes(&leftJointShape, &rightJointShape); // this clones the shapes so clients can't mess with the original

            if (leftJointShape)
            {
               CComQIPtr<IXYPosition> pos(leftJointShape);
               pos->Offset(-props.dx, -props.dy);
            }

            if (rightJointShape)
            {
               CComQIPtr<IXYPosition> pos(rightJointShape);
               pos->Offset(-props.dx, -props.dy);
            }

            // we've moved the joint shapes. now update the original section with the new joint shapes
            jointedSection->SetJointShapes(leftJointShape, rightJointShape);
         }

         // get elastic properties of section
         CComPtr<IElasticProperties> eprop;
         section->get_ElasticProperties(&eprop);

         // transform section properties
         // this transforms all materials into equivalent girder concrete
         // we always do this because the deck must be transformed, even for net properties
         Float64 Egdr;
         if (bIsOnSegment)
         {
            Egdr = (bIsTimeStepAnalysis ? GetSegmentAgeAdjustedEc(segmentKey, intervalIdx) : GetSegmentEc(segmentKey, intervalIdx));
         }
         else if (bIsInClosureJoint)
         {
            Egdr = (bIsTimeStepAnalysis ? GetClosureJointAgeAdjustedEc(closureKey, intervalIdx) : GetClosureJointEc(closureKey, intervalIdx));
         }
         else if (bIsInBoundaryPierDiaphragm)
         {
            Egdr = (bIsTimeStepAnalysis ? GetDeckAgeAdjustedEc(deckCastingRegionIdx,intervalIdx) : GetDeckEc(deckCastingRegionIdx,intervalIdx));
         }

         CComPtr<IShapeProperties> shapeprops;
         eprop->TransformProperties(Egdr, &shapeprops);

         props.Section = section;
         props.GirderShapeIndex = gdr_idx;
         props.SlabShapeIndex = slab_idx;
         props.ElasticProps = eprop;
         props.ShapeProps = shapeprops;

#if defined _DEBUG
         Float64 Ag;
         shapeprops->get_Area(&Ag);
         LOG(_T("Interval = ") << intervalIdx << _T(" Group = ") << LABEL_GROUP(segmentKey.groupIndex) << _T(" Girder = ") << LABEL_GIRDER(segmentKey.girderIndex) << _T(" Segment = ") << LABEL_SEGMENT(segmentKey.segmentIndex) << _T(" x = ") << WBFL::Units::ConvertFromSysUnits(poi.GetDistFromStart(), WBFL::Units::Measure::Feet) << _T(" ft") << _T(" Ag = ") << WBFL::Units::ConvertFromSysUnits(Ag, WBFL::Units::Measure::Inch2) << _T(" in2") << _T(" Eg = ") << WBFL::Units::ConvertFromSysUnits(Egdr, WBFL::Units::Measure::KSI) << _T(" KSI"));
#endif

         // Q slab
         if (INVALID_INDEX != slab_idx)
         {
            // Get our slab shape from the composite and compute its properties
            CComPtr<ICompositeSectionItemEx> slabSectionItem;
            compositeSection->get_Item(slab_idx, &slabSectionItem);
            CComPtr<IShape> slabShape;
            slabSectionItem->get_Shape(&slabShape);

            Float64 Eslab;
            slabSectionItem->get_Efg(&Eslab);

            CComPtr<IShapeProperties> slabProps;
            slabShape->get_ShapeProperties(&slabProps);

            Float64 Aslab;
            slabProps->get_Area(&Aslab);

            Float64 EAslab = Eslab * Aslab;
            Float64 Aslabt = EAslab / Egdr; // Transformed to equivalent girder material

            CComPtr<IPoint2d> cg_section;
            shapeprops->get_Centroid(&cg_section);

            CComPtr<IPoint2d> cg_slab;
            slabProps->get_Centroid(&cg_slab);

            Float64 Yg, Ys;
            cg_slab->get_Y(&Ys);
            cg_section->get_Y(&Yg);

            Float64 Qslab = Aslabt*(Ys - Yg);
            
            ATLASSERT(0 < Qslab);

            props.Qslab = Qslab;
         }
         else
         {
            props.Qslab = 0.0;
         }

         // Area on bottom half of composite section for LRFD Fig 5.7.3.4.2-3 (pre2017: 5.8.3.4.2-3)

         // Ytop Girder
         // if these are composite properties, shapeprops->get_Ytop() gives Ytop to the top of the composite (eg, top of slab)
         // we want Y to the top of the basic girder for the current section... Yt = H - Yb
         props.YtopGirder = ComputeYtopGirder(shapeprops, girderShape);

         // measured down from top of non-composite girder Y=0.0 at top of girder
         //Float64 half_depth_elevation = GetHalfElevation(poi); causes recursion with this method
         Float64 height;
         CComQIPtr<IGirderSection> girder_section(girderShape);
         if (girder_section)
         {
            girder_section->get_NominalHeight(&height);
         }
         else
         {
            Float64 Yt, Yb;
            shapeprops->get_Ytop(&Yt);
            shapeprops->get_Ybottom(&Yb);
            height = Yt + Yb;
         }
         Float64 deck_thickness = GetStructuralSlabDepth(poi);
         Float64 half_depth_elevation = GetHalfElevation(height, deck_thickness);

         // Create clipping line through beam/slab interface
         CComPtr<ILine2d> line;
         line.CoCreateInstance(CLSID_Line2d);

         CComPtr<IPoint2d> p1, p2;
         p1.CoCreateInstance(CLSID_Point2d);
         p2.CoCreateInstance(CLSID_Point2d);

         p1->Move(-99999,half_depth_elevation);
         p2->Move( 99999,half_depth_elevation);

         line->ThroughPoints(p1,p2);

         CComPtr<ISection> clipped_section;
         section->ClipWithLine(line,&clipped_section);

         CComPtr<IElasticProperties> bottomHalfElasticProperties;
         clipped_section->get_ElasticProperties(&bottomHalfElasticProperties);

         CComPtr<IShapeProperties> bottomHalfShapeProperties;
         bottomHalfElasticProperties->TransformProperties(Egdr,&bottomHalfShapeProperties);

         Float64 area;
         bottomHalfShapeProperties->get_Area(&area);
         props.AcBottomHalf = area;

         // Area on top half of composite section for LRFD Fig. 5.7.3.4.2-3 (pre2017: 5.8.3.4.2-3)
         if (bIsOnSegment && GetSegmentConcreteType(segmentKey) == pgsTypes::UHPC)
         {
            // "Half" section area is only used for shear calculations. For UHPC, shear strength
            // is limited to the UHPC part of the section only (ie. only the girder).
            // Get the area of the girder and deduct the bottom half area.
            CComPtr<IShapeProperties> gdrProps;
            girderShape->get_ShapeProperties(&gdrProps);
            gdrProps->get_Area(&area);
            props.AcTopHalf = area - props.AcBottomHalf; // top + bottom = full  ==> top = full - bottom
         }
         else
         {
            CComPtr<IShapeProperties> fullShapeProperties;
            props.ElasticProps->TransformProperties(Egdr, &fullShapeProperties);
            fullShapeProperties->get_Area(&area);
            props.AcTopHalf = area - props.AcBottomHalf; // top + bottom = full  ==> top = full - bottom
         }
      }
      else if ( sectPropType == pgsTypes::sptNetDeck )
      {
         CComPtr<ISection> deckSection;
         IndexType gdr_idx, slabIdx;
         HRESULT hr = CreateSection(intervalIdx,poi,sectPropType, pgsTypes::scGirder, &gdr_idx,&slabIdx,&deckSection);
         ATLASSERT(SUCCEEDED(hr));

         // get elastic properties of section
         CComPtr<IElasticProperties> eprop;
         deckSection->get_ElasticProperties(&eprop);

         // transform section properties
         // this transforms all materials into equivalent girder concrete
         // we always do this because the deck must be transformed, even for net properties
         Float64 Edeck;
         if ( bIsTimeStepAnalysis )
         {
            Edeck = GetDeckAgeAdjustedEc(deckCastingRegionIdx,intervalIdx);
         }
         else
         {
            Edeck = GetDeckEc(deckCastingRegionIdx,intervalIdx);
         }
         CComPtr<IShapeProperties> shapeprops;
         eprop->TransformProperties(Edeck,&shapeprops);

         props.Section = deckSection;
         props.GirderShapeIndex = gdr_idx;
         props.SlabShapeIndex = slabIdx;
         props.dx = -99999; // not used
         props.dy = -99999; // not used
         props.ElasticProps = eprop;
         props.ShapeProps   = shapeprops;
      }
      else
      {
         ATLASSERT(false); // should never get here
      }
   }
   else
   {
      // prestressing has not been released into segment yet so essentially we don't have a segment 
      // -OR-
      // we are at a closure joint and it hasn't reached strength enough to be effective
      // create default properties (all zero values)
      props.ElasticProps.CoCreateInstance(CLSID_ElasticProperties);
      props.ElasticProps->TransformProperties(1.0,&props.ShapeProps);
   }


   // don't store if not a real POI
   if ( poi.GetID() == INVALID_ID )
   {
      m_LOTFSectionPropertiesKey = poiKey;
      m_LOTFSectionPropertiesType = sectPropType;
      m_LOTFSectionProperties = props;

      return m_LOTFSectionProperties;
   }

   // Store the properties
   std::pair<SectPropContainer::iterator,bool> result( m_pSectProps[sectPropType]->insert(std::make_pair(poiKey,props)) );
   ATLASSERT(result.second == true);
   found = result.first; 
   ATLASSERT(found == m_pSectProps[sectPropType]->find(poiKey));
   ATLASSERT(found != m_pSectProps[sectPropType]->end());
   return (*found).second;
}

HRESULT CBridgeAgentImp::CreateSection(IntervalIndexType intervalIdx,const pgsPointOfInterest& poi,pgsTypes::SectionPropertyType sectPropType,pgsTypes::SectionCoordinateType coordinateType,IndexType* pGdrIdx,IndexType* pSlabIdx,ISection** ppSection) const
{
   VALIDATE(BRIDGE);

   pgsTypes::HaunchAnalysisSectionPropertiesType haunchAnalysisType = GetHaunchAnalysisSectionPropertiesType();

   const CSegmentKey& segmentKey = poi.GetSegmentKey();

   IntervalIndexType lastNoncompositeIntervalIdx = GetLastNoncompositeInterval();
   bool bFollowMatingSurface = (intervalIdx <= lastNoncompositeIntervalIdx ? false : IsAsymmetricGirder(segmentKey));

   Float64 Xs = poi.GetDistFromStart();
   GirderIDType gdrID = GetSuperstructureMemberID(segmentKey);

   SectionBias sectionBias = GetSectionBias(poi);
   if ( sectPropType == pgsTypes::sptGrossNoncomposite       ||
        sectPropType == pgsTypes::sptGross                   || 
        sectPropType == pgsTypes::sptTransformedNoncomposite || 
        sectPropType == pgsTypes::sptTransformed             || 
        sectPropType == pgsTypes::sptNetGirder )
   {
      // use tool to create section
      CComPtr<ISection> section;
      HRESULT hr = m_SectCutTool->CreateGirderSectionBySegment(m_Bridge,gdrID,segmentKey.segmentIndex,Xs,sectionBias,(SectionCoordinateSystemType)coordinateType,intervalIdx,(SectionPropertyMethod)sectPropType,(HaunchDepthMethod)haunchAnalysisType, bFollowMatingSurface && IsZero(GetOrientation(segmentKey)),pGdrIdx,pSlabIdx,&section);
      ATLASSERT(SUCCEEDED(hr));

      return section.CopyTo(ppSection);
   }
   else if ( sectPropType == pgsTypes::sptNetDeck )
   {
      CComPtr<ISection> deckSection;
      HRESULT hr = m_SectCutTool->CreateNetDeckSection(m_Bridge,gdrID,segmentKey.segmentIndex,Xs, sectionBias, (SectionCoordinateSystemType)coordinateType,intervalIdx,(HaunchDepthMethod)haunchAnalysisType, bFollowMatingSurface, &deckSection);
      ATLASSERT(SUCCEEDED(hr));

      *pGdrIdx = INVALID_INDEX;
      *pSlabIdx = 0;

      return deckSection.CopyTo(ppSection);
   }

   ATLASSERT(false); // should never get here
   return E_FAIL;
}

Float64 CBridgeAgentImp::ComputeY(IntervalIndexType intervalIdx,const pgsPointOfInterest& poi,pgsTypes::StressLocation location,IShapeProperties* sprops) const
{
   const CSegmentKey& segmentKey(poi.GetSegmentKey());
   Float64 Xpoi = poi.GetDistFromStart();
   CComPtr<ISuperstructureMemberSegment> segment;
   GetSegment(segmentKey,&segment);

   SectionBias sectionBias = GetSectionBias(poi);

   CComPtr<IShape> shape;
   segment->get_GirderShape(Xpoi,sectionBias, cstGirder, &shape);

   Float64 Y;
   switch (location)
   {
   case pgsTypes::TopGirder:
   case pgsTypes::TopDeck:
   case pgsTypes::BottomDeck:
      {
         IndexType deckCastingRegionIdx = GetDeckCastingRegion(poi);
         IntervalIndexType compositeDeckIntervalIdx = GetCompositeDeckInterval(deckCastingRegionIdx);
         if ( location == pgsTypes::TopDeck && compositeDeckIntervalIdx <= intervalIdx && IsCompositeDeck() )
         {
            // top of composite deck that has been installed
            sprops->get_Ytop(&Y);
         }
         else
         {
            // top girder, bottom deck, (and top deck if deck not composite or installed yet)
            // are all at the same location
            Y = ComputeYtopGirder(sprops,shape);
         }
      }
      break;

   case pgsTypes::BottomGirder:
      sprops->get_Ybottom(&Y);
      break;

   default:
      ATLASSERT(false);
   }

   return Y;
}

Float64 CBridgeAgentImp::ComputeYtopGirder(IShapeProperties* compositeProps,IShape* pShape) const
{
   Float64 Ybc;
   compositeProps->get_Ybottom(&Ybc);

   Float64 Hg;
   CComQIPtr<IGirderSection> gdrSection(pShape);
   if (gdrSection)
   {
      gdrSection->get_NominalHeight(&Hg);
   }
   else
   { 
      CComPtr<IShapeProperties> shapeProps;
      pShape->get_ShapeProperties(&shapeProps);
      Float64 Yb, Yt;
      shapeProps->get_Ytop(&Yt);
      shapeProps->get_Ybottom(&Yb);
      Hg = Yt + Yb;
   }
   Float64 YtopGirder = Hg - Ybc;
   return YtopGirder;
}

Float64 CBridgeAgentImp::GetHalfElevation(const pgsPointOfInterest& poi) const
{
   Float64 deck_thickness = GetStructuralSlabDepth(poi);
   Float64 girder_depth = GetHeight(poi);
   return GetHalfElevation(girder_depth, deck_thickness);
}

Float64 CBridgeAgentImp::GetHalfElevation(Float64 gdrHeight, Float64 deckThickness) const
{
   // cut line is at 1/2 of the compsite section depth
   Float64 half_depth = (deckThickness + gdrHeight)/2.;
   // half depth elevation is measured down from the top of the non-composite girder
   // this puts it in Girder Section Coordinates
   return -(half_depth - deckThickness);
}

HRESULT CBridgeAgentImp::GetSlabOverhangs(Float64 Xb,Float64* pLeft,Float64* pRight) const
{
   Float64 station = ConvertBridgeLineToRouteCoordinate(Xb);

   SpanIndexType spanIdx = GetSpanIndex(Xb);
   if ( spanIdx == INVALID_INDEX )
   {
      if ( Xb < 0 )
      {
         spanIdx = 0;
      }
      else
      {
         spanIdx = GetSpanCount()-1;
      }
   }

   GET_IFACE(IBridgeDescription,pIBridgeDesc);
   const CBridgeDescription2* pBridgeDesc = pIBridgeDesc->GetBridgeDescription();
   const CSpanData2* pSpan = pBridgeDesc->GetSpan(spanIdx);
   const CGirderGroupData* pGroup = pBridgeDesc->GetGirderGroup(pSpan);
   GroupIndexType grpIdx = pGroup->GetIndex();
   GirderIndexType nGirders = pGroup->GetGirderCount();

   GirderIDType leftGdrID  = ::GetSuperstructureMemberID(grpIdx,0);
   GirderIDType rightGdrID = ::GetSuperstructureMemberID(grpIdx,nGirders-1);

   m_BridgeGeometryTool->DeckOverhang(m_Bridge,station,leftGdrID, nullptr,qcbLeft, pLeft);
   m_BridgeGeometryTool->DeckOverhang(m_Bridge,station,rightGdrID,nullptr,qcbRight,pRight);

   return S_OK;
}

HRESULT CBridgeAgentImp::GetGirderSection(const pgsPointOfInterest& poi,IGirderSection** gdrSection) const
{

   // Get the girder section from the generic bridge model
   const CSegmentKey& segmentKey = poi.GetSegmentKey();

 
   if (poi.GetID() == INVALID_ID)
   {
      CComPtr<ISuperstructureMemberSegment> segment;
      GetSegment(segmentKey, &segment);

      SectionBias sectionBias = GetSectionBias(poi);

      Float64 Xs = poi.GetDistFromStart();
      Float64 Ls = GetSegmentLength(segmentKey);
      Xs = ::ForceIntoRange(0.0, Xs, Ls);

      CComPtr<IShape> girder_shape;
      segment->get_GirderShape(Xs, sectionBias, cstGirder, &girder_shape);

      CComQIPtr<IGirderSection> section(girder_shape);
      section.CopyTo(gdrSection);
      return S_OK;
   }
   else
   {
      pgsPointOfInterest thePoi(poi);
      if (!IsOnSegment(poi))
      {
         Float64 Xs = poi.GetDistFromStart();
         Float64 Ls = GetSegmentLength(segmentKey);
         Xs = ::ForceIntoRange(0.0, Xs, Ls);
         thePoi = GetPointOfInterest(segmentKey, Xs);
         ATLASSERT(IsOnSegment(thePoi) && thePoi.GetSegmentKey() == segmentKey);
      }

      IntervalIndexType releaseIntervalIdx = GetPrestressReleaseInterval(segmentKey);
      const SectProp& sectProps = GetSectionProperties(releaseIntervalIdx, thePoi, pgsTypes::sptGross);
      if (sectProps.Section == nullptr)
      {
         return E_FAIL;
      }

      CComQIPtr<ICompositeSectionEx> composite(sectProps.Section);
      CComPtr<ICompositeSectionItemEx> item;
      composite->get_Item(sectProps.GirderShapeIndex, &item);
      CComPtr<IShape> shape;
      item->get_Shape(&shape);
      CComQIPtr<IGirderSection> section(shape);
      section.CopyTo(gdrSection);
   }

   return S_OK;
}

HRESULT CBridgeAgentImp::GetSuperstructureMember(const CGirderKey& girderKey,ISuperstructureMember* *ssmbr) const
{
   VALIDATE(BRIDGE);
   return ::GetSuperstructureMember(m_Bridge,girderKey,ssmbr);
}

HRESULT CBridgeAgentImp::GetSegment(const CSegmentKey& segmentKeyOrig,ISuperstructureMemberSegment** segment) const
{
   VALIDATE(BRIDGE);

   // keep girder in bounds
   GirderIndexType gdrIdx = min(segmentKeyOrig.girderIndex, this->GetGirderCount(segmentKeyOrig.groupIndex)-1);
   CSegmentKey segmentKey(segmentKeyOrig.groupIndex, gdrIdx, segmentKeyOrig.segmentIndex);

   return ::GetSegment(m_Bridge,segmentKey,segment);
}

HRESULT CBridgeAgentImp::GetGirder(const CSegmentKey& segmentKeyOrig,IPrecastGirder** girder) const
{
   VALIDATE(BRIDGE);

   // keep girder in bounds
   GirderIndexType gdrIdx = min(segmentKeyOrig.girderIndex, this->GetGirderCount(segmentKeyOrig.groupIndex)-1);
   CSegmentKey segmentKey(segmentKeyOrig.groupIndex, gdrIdx, segmentKeyOrig.segmentIndex);

   return ::GetGirder(m_Bridge,segmentKey,girder);
}

HRESULT CBridgeAgentImp::GetGirder(const pgsPointOfInterest& poi,IPrecastGirder** girder) const
{
   return GetGirder(poi.GetSegmentKey(),girder);
}

Float64 CBridgeAgentImp::GetGrossSlabDepth() const
{
   // Private method for getting gross slab depth
   // Gross slab depth is needed during validation of bridge model,
   // but public method causes validation. This causes a recusion problem
   
   CComPtr<IBridgeDeck> deck;
   m_Bridge->get_Deck(&deck);

   CComQIPtr<ICastSlab>    cip(deck);
   CComQIPtr<IPrecastSlab> sip(deck);
   CComQIPtr<IOverlaySlab> overlay(deck);

   Float64 deck_thickness;
   if ( cip != nullptr )
   {
      cip->get_GrossDepth(&deck_thickness);
   }
   else if ( sip != nullptr )
   {
      Float64 cast_depth;
      sip->get_CastDepth(&cast_depth);

      Float64 panel_depth;
      sip->get_PanelDepth(&panel_depth);

      deck_thickness = cast_depth + panel_depth;
   }
   else if ( overlay != nullptr )
   {
      overlay->get_GrossDepth(&deck_thickness);
   }
   else
   {
      ATLASSERT(deck == nullptr); // no deck
      deck_thickness = 0;
   }

   return deck_thickness;
}

Float64 CBridgeAgentImp::GetCastDepth() const
{
   CComPtr<IBridgeDeck> deck;
   m_Bridge->get_Deck(&deck);

   CComQIPtr<ICastSlab>    cip(deck);
   CComQIPtr<IPrecastSlab> sip(deck);
   CComQIPtr<IOverlaySlab> overlay(deck);

   Float64 cast_depth;
   if ( cip != nullptr )
   {
      cip->get_GrossDepth(&cast_depth);
   }
   else if ( sip != nullptr )
   {
      sip->get_CastDepth(&cast_depth);
   }
   else if ( overlay != nullptr )
   {
      overlay->get_GrossDepth(&cast_depth);
   }
   else
   {
      ATLASSERT(false); // bad deck type
      cast_depth = 0;
   }

   return cast_depth;
}

Float64 CBridgeAgentImp::GetPanelDepth() const
{
   // Private method for getting gross slab depth
   // Gross slab depth is needed during validation of bridge model,
   // but public method causes validation. This causes a recusion problem
   CComPtr<IBridgeDeck> deck;
   m_Bridge->get_Deck(&deck);

   CComQIPtr<ICastSlab>    cip(deck);
   CComQIPtr<IPrecastSlab> sip(deck);
   CComQIPtr<IOverlaySlab> overlay(deck);

   Float64 panel_depth;
   if ( cip != nullptr )
   {
      panel_depth = 0;
   }
   else if ( sip != nullptr )
   {
      sip->get_PanelDepth(&panel_depth);
   }
   else if ( overlay != nullptr )
   {
      panel_depth = 0;
   }
   else
   {
      ATLASSERT(false); // bad deck type
      panel_depth = 0;
   }

   return panel_depth;
}


Float64 CBridgeAgentImp::GetSlabOverhangDepth(pgsTypes::SideType side) const
{
   CComPtr<IBridgeDeck> deck;
   m_Bridge->get_Deck(&deck);

   CComQIPtr<ICastSlab>    cip(deck);
   CComQIPtr<IPrecastSlab> sip(deck);
   CComQIPtr<IOverlaySlab> overlay(deck);

   Float64 overhang_depth;
   if ( cip != nullptr )
   {
      cip->get_OverhangDepth((DirectionType)side, &overhang_depth);
   }
   else if ( sip != nullptr )
   {
      sip->get_OverhangDepth((DirectionType)side, &overhang_depth);
   }
   else if ( overlay != nullptr )
   {
      overlay->get_GrossDepth(&overhang_depth);
   }
   else
   {
      ATLASSERT(false); // bad deck type
      // Not implemented yet... need to return the top flange thickness of exterior girder if there is not slab
      overhang_depth = 0;
   }

   return overhang_depth;
}

void CBridgeAgentImp::LayoutDeckRebar(const CDeckDescription2* pDeck,IBridgeDeck* deck)
{
   const CDeckRebarData& rebar_data = pDeck->DeckRebarData;

   CComPtr<IBridgeDeckRebarLayout> rebar_layout;
   rebar_layout.CoCreateInstance(CLSID_BridgeDeckRebarLayout);
   deck->putref_RebarLayout(rebar_layout);
   rebar_layout->putref_Bridge(m_Bridge);
   rebar_layout->putref_EffectiveFlangeWidthTool(m_EffFlangeWidthTool);

   Float64 deck_height;
   deck->get_GrossDepth(&deck_height);

   // Get the stage where the rebar is first introducted into the system.
   // Technically, the rebar is first introduced to the system after girder erection and before the deck
   // concrete is cast, however the rebar isn't performing any structural function
   // until the concrete is cured
   IntervalIndexType compositeDeckIntervalIdx = m_IntervalManager.GetFirstCompositeDeckInterval();

   // Create a rebar factory. This does the work of creating rebar objects
   CComPtr<IRebarFactory> rebar_factory;
   rebar_factory.CoCreateInstance(CLSID_RebarFactory);

   // Rebar factory needs a unit server object for units conversion
   CComPtr<IUnitServer> unitServer;
   unitServer.CoCreateInstance(CLSID_UnitServer);
   HRESULT hr = ConfigureUnitServer(unitServer);
   ATLASSERT(SUCCEEDED(hr));

   CComPtr<IUnitConvert> unit_convert;
   unitServer->get_UnitConvert(&unit_convert);

   // First layout rebar that runs the full length of the deck
   CComPtr<IBridgeDeckRebarLayoutItem> deck_rebar_layout_item;
   deck_rebar_layout_item.CoCreateInstance(CLSID_BridgeDeckRebarLayoutItem);
   deck_rebar_layout_item->putref_Bridge(m_Bridge);
   rebar_layout->Add(deck_rebar_layout_item);

   // Top Mat - Bars
   if ( rebar_data.TopRebarSize != WBFL::Materials::Rebar::Size::bsNone )
   {
      // create the rebar object
      BarSize       matSize  = GetBarSize(rebar_data.TopRebarSize);
      MaterialSpec  matSpec  = GetRebarSpecification(rebar_data.TopRebarType);
      RebarGrade    matGrade = GetRebarGrade(rebar_data.TopRebarGrade);

      CComPtr<IRebar> rebar;
      rebar_factory->CreateRebar(matSpec,matGrade,matSize,unit_convert,compositeDeckIntervalIdx,&rebar);

      Float64 db;
      rebar->get_NominalDiameter(&db);

      // create the rebar pattern (definition of rebar in the cross section)
      CComPtr<IBridgeDeckRebarPattern> rebar_pattern;
      rebar_pattern.CoCreateInstance(CLSID_BridgeDeckRebarPattern);

      // Locate rebar from the bottom of the deck
      Float64 Y = deck_height - rebar_data.TopCover - db/2;

      // create the rebar pattern
      rebar_pattern->putref_Rebar(rebar);
      rebar_pattern->putref_RebarLayoutItem(deck_rebar_layout_item);
      rebar_pattern->put_Spacing( rebar_data.TopSpacing );
      rebar_pattern->put_Location( Y );
      rebar_pattern->put_IsLumped(VARIANT_FALSE);

      // add this pattern to the layout
      deck_rebar_layout_item->AddRebarPattern(rebar_pattern);
   }

   // Top Mat - Lump Sum
   if ( !IsZero(rebar_data.TopLumpSum) )
   {
      MaterialSpec  matSpec  = GetRebarSpecification(rebar_data.TopRebarType);
      RebarGrade    matGrade = GetRebarGrade(rebar_data.TopRebarGrade);

      // create a dummy #3 bar, then change the diameter and bar area to match
      // the lump sum bar
      CComPtr<IRebar> rebar;
      rebar_factory->CreateRebar(matSpec,matGrade,bs3,unit_convert,compositeDeckIntervalIdx,&rebar);
      rebar->put_NominalDiameter(0.0);
      rebar->put_NominalArea(rebar_data.TopLumpSum);

      Float64 Y = deck_height - rebar_data.TopCover;

      // create the rebar pattern (definition of rebar in the cross section)
      CComPtr<IBridgeDeckRebarPattern> rebar_pattern;
      rebar_pattern.CoCreateInstance(CLSID_BridgeDeckRebarPattern);

      // create the rebar pattern
      rebar_pattern->putref_Rebar(rebar);
      rebar_pattern->putref_RebarLayoutItem(deck_rebar_layout_item);
      rebar_pattern->put_Spacing( 0.0 );
      rebar_pattern->put_Location( Y );
      rebar_pattern->put_IsLumped(VARIANT_TRUE);

      // add this pattern to the layout
      deck_rebar_layout_item->AddRebarPattern(rebar_pattern);
   }

   // Bottom Mat - Rebar
   if ( pDeck->GetDeckType() != pgsTypes::sdtCompositeSIP )
   {
      if ( rebar_data.BottomRebarSize != WBFL::Materials::Rebar::Size::bsNone )
      {
         // create the rebar object
         BarSize       matSize  = GetBarSize(rebar_data.BottomRebarSize);
         MaterialSpec  matSpec  = GetRebarSpecification(rebar_data.BottomRebarType);
         RebarGrade    matGrade = GetRebarGrade(rebar_data.BottomRebarGrade);

         CComPtr<IRebar> rebar;
         rebar_factory->CreateRebar(matSpec,matGrade,matSize,unit_convert,compositeDeckIntervalIdx,&rebar);

         Float64 db;
         rebar->get_NominalDiameter(&db);

         // create the rebar pattern (definition of rebar in the cross section)
         CComPtr<IBridgeDeckRebarPattern> rebar_pattern;
         rebar_pattern.CoCreateInstance(CLSID_BridgeDeckRebarPattern);

         // Locate rebar from the bottom of the deck
         Float64 Y = rebar_data.BottomCover + db/2;

         // create the rebar pattern
         rebar_pattern->putref_Rebar(rebar);
         rebar_pattern->putref_RebarLayoutItem(deck_rebar_layout_item);
         rebar_pattern->put_Spacing( rebar_data.BottomSpacing );
         rebar_pattern->put_Location( Y );
         rebar_pattern->put_IsLumped(VARIANT_FALSE);

         // add this pattern to the layout
         deck_rebar_layout_item->AddRebarPattern(rebar_pattern);
      }

      // Bottom Mat - Lump Sum
      if ( !IsZero(rebar_data.BottomLumpSum) )
      {
         MaterialSpec  matSpec  = GetRebarSpecification(rebar_data.BottomRebarType);
         RebarGrade    matGrade = GetRebarGrade(rebar_data.BottomRebarGrade);

         CComPtr<IRebar> rebar;
         rebar_factory->CreateRebar(matSpec,matGrade,bs3,unit_convert,compositeDeckIntervalIdx,&rebar);
         rebar->put_NominalDiameter(0.0);
         rebar->put_NominalArea(rebar_data.BottomLumpSum);

         Float64 Y = rebar_data.BottomCover;

         // create the rebar pattern (definition of rebar in the cross section)
         CComPtr<IBridgeDeckRebarPattern> rebar_pattern;
         rebar_pattern.CoCreateInstance(CLSID_BridgeDeckRebarPattern);

         // create the rebar pattern
         rebar_pattern->putref_Rebar(rebar);
         rebar_pattern->putref_RebarLayoutItem(deck_rebar_layout_item);
         rebar_pattern->put_Spacing( 0.0 );
         rebar_pattern->put_Location( Y );
         rebar_pattern->put_IsLumped(VARIANT_TRUE);

         // add this pattern to the layout
         deck_rebar_layout_item->AddRebarPattern(rebar_pattern);
      }
   }

   // Negative moment rebar over piers
   std::vector<CDeckRebarData::NegMomentRebarData>::const_iterator iter(rebar_data.NegMomentRebar.begin());
   std::vector<CDeckRebarData::NegMomentRebarData>::const_iterator end(rebar_data.NegMomentRebar.end());
   for ( ; iter != end; iter++ )
   {
      const CDeckRebarData::NegMomentRebarData& nm_rebar_data = *iter;

      CComPtr<INegativeMomentBridgeDeckRebarLayoutItem> nm_deck_rebar_layout_item;
      nm_deck_rebar_layout_item.CoCreateInstance(CLSID_NegativeMomentBridgeDeckRebarLayoutItem);
      nm_deck_rebar_layout_item->putref_Bridge(m_Bridge);
      rebar_layout->Add(nm_deck_rebar_layout_item);

      // negative moment rebar needs to be associed with a pier in the generic bridge model
      // association is done by pier ID. The generic bridge model Pier ID is the same as
      // its PierLine ID.
      nm_deck_rebar_layout_item->put_PierID( ::GetPierLineID(nm_rebar_data.PierIdx) );
      nm_deck_rebar_layout_item->put_LeftCutoff(  nm_rebar_data.LeftCutoff );
      nm_deck_rebar_layout_item->put_RightCutoff( nm_rebar_data.RightCutoff );

      if ( nm_rebar_data.RebarSize != WBFL::Materials::Rebar::Size::bsNone )
      {
         // Rebar
         BarSize       matSize  = GetBarSize(nm_rebar_data.RebarSize);
         MaterialSpec  matSpec  = GetRebarSpecification(nm_rebar_data.RebarType);
         RebarGrade    matGrade = GetRebarGrade(nm_rebar_data.RebarGrade);

         CComPtr<IRebar> rebar;
         rebar_factory->CreateRebar(matSpec,matGrade,matSize,unit_convert,compositeDeckIntervalIdx,&rebar);

         Float64 db;
         rebar->get_NominalDiameter(&db);

         // create the rebar pattern (definition of rebar in the cross section)
         CComPtr<IBridgeDeckRebarPattern> rebar_pattern;
         rebar_pattern.CoCreateInstance(CLSID_BridgeDeckRebarPattern);

         // Locate rebar from the bottom of the deck
         Float64 Y;
         if ( nm_rebar_data.Mat == CDeckRebarData::TopMat )
         {
            Y = deck_height - rebar_data.TopCover - db/2;
         }
         else
         {
            Y = rebar_data.BottomCover + db/2;
         }

         // create the rebar pattern
         rebar_pattern->putref_Rebar(rebar);
         rebar_pattern->putref_RebarLayoutItem(nm_deck_rebar_layout_item);
         rebar_pattern->put_Spacing( nm_rebar_data.Spacing );
         rebar_pattern->put_Location( Y );
         rebar_pattern->put_IsLumped(VARIANT_FALSE);

         // add this pattern to the layout
         nm_deck_rebar_layout_item->AddRebarPattern(rebar_pattern);
      }

      // Lump Sum
      if ( !IsZero(nm_rebar_data.LumpSum) )
      {
         MaterialSpec  matSpec  = GetRebarSpecification(nm_rebar_data.RebarType);
         RebarGrade    matGrade = GetRebarGrade(nm_rebar_data.RebarGrade);

         // create a dummy #3 bar, then change the diameter and bar area to match
         // the lump sum bar
         CComPtr<IRebar> rebar;
         rebar_factory->CreateRebar(matSpec,matGrade,bs3,unit_convert,compositeDeckIntervalIdx,&rebar);
         rebar->put_NominalDiameter(0.0);
         rebar->put_NominalArea(nm_rebar_data.LumpSum);

         Float64 Y;
         if ( nm_rebar_data.Mat == CDeckRebarData::TopMat )
         {
            Y = deck_height - rebar_data.TopCover;
         }
         else
         {
            Y = rebar_data.BottomCover;
         }

         // create the rebar pattern (definition of rebar in the cross section)
         CComPtr<IBridgeDeckRebarPattern> rebar_pattern;
         rebar_pattern.CoCreateInstance(CLSID_BridgeDeckRebarPattern);

         // create the rebar pattern
         rebar_pattern->putref_Rebar(rebar);
         rebar_pattern->putref_RebarLayoutItem(nm_deck_rebar_layout_item);
         rebar_pattern->put_Spacing( 0.0 );
         rebar_pattern->put_Location( Y );
         rebar_pattern->put_IsLumped(VARIANT_TRUE);

         // add this pattern to the layout
         nm_deck_rebar_layout_item->AddRebarPattern(rebar_pattern);
      }
   }
}

void CBridgeAgentImp::LayoutSegmentRebar(const CSegmentKey& segmentKey)
{
   // Get the rebar input data
   GET_IFACE(IBridgeDescription,pIBridgeDesc);
   const CPrecastSegmentData* pSegment = pIBridgeDesc->GetPrecastSegmentData(segmentKey);
   const CLongitudinalRebarData& rebar_data = pSegment->LongitudinalRebarData;

   GET_IFACE_NOCHECK(IEAFStatusCenter,pStatusCenter);

   const std::vector<CLongitudinalRebarData::RebarRow>& rebar_rows = rebar_data.RebarRows;
   if ( 0 < rebar_rows.size() )
   {
      // Get the stage where the rebar is first introducted into the system.
      // Technically, the rebar is first introduced to the system when the segment
      // concrete is cast, however the rebar isn't doing anything structural
      // until the concrete is cured and the prestressing is released
      IntervalIndexType releaseIntervalIdx = m_IntervalManager.GetPrestressReleaseInterval(segmentKey);

      // Get the PrecastGirder object that will create the rebar model in
      // Given the basic input, this guy will compute the actual coordinates of
      // rebar at any cross section along the segment
      CComPtr<IPrecastGirder> girder;
      GetGirder(segmentKey,&girder);

      CComPtr<ISuperstructureMemberSegment> segment;
      girder->get_SuperstructureMemberSegment(&segment);

      Float64 segment_length = GetSegmentLength(segmentKey);
      Float64 startEndDist = GetSegmentStartEndDistance(segmentKey);
      Float64 endEndDist   = GetSegmentEndEndDistance(segmentKey);

      CComPtr<IRebarLayout> rebar_layout;
      girder->get_RebarLayout(&rebar_layout);

      GET_IFACE(ILongitudinalRebar,pLongRebar);
      std::_tstring strRebarName = pLongRebar->GetSegmentLongitudinalRebarMaterial(segmentKey);
      
      WBFL::Materials::Rebar::Grade grade;
      WBFL::Materials::Rebar::Type type;
      pLongRebar->GetSegmentLongitudinalRebarMaterial(segmentKey,type,grade);

      MaterialSpec matSpec = GetRebarSpecification(type);
      RebarGrade matGrade  = GetRebarGrade(grade);

      CComPtr<IRebarFactory> rebar_factory;
      rebar_factory.CoCreateInstance(CLSID_RebarFactory);

      CComPtr<IUnitServer> unitServer;
      unitServer.CoCreateInstance(CLSID_UnitServer);
      HRESULT hr = ConfigureUnitServer(unitServer);
      ATLASSERT(SUCCEEDED(hr));

      CComPtr<IUnitConvert> unit_convert;
      unitServer->get_UnitConvert(&unit_convert);

      pgsTypes::ConcreteType concreteType = GetSegmentConcreteType(segmentKey);

      // need this for clear spacing validation below
      Float64 max_aggregate_size = GetSegmentMaxAggrSize(segmentKey);
      Float64 fiber_length = GetSegmentConcreteFiberLength(segmentKey);

      pgsTypes::SegmentVariationType segmentVariation = pSegment->GetVariationType();

      IndexType idx = 0;
      for (const auto& info : rebar_rows)
      {
         Float64 start(0), end(0);

         if ( !info.GetRebarStartEnd(segment_length, &start, &end) )
         {
            continue; // this bar doesn't go on this segment
         }

         BarSize bar_size = GetBarSize(info.BarSize);
         CComPtr<IRebar> rebar;
         rebar_factory->CreateRebar(matSpec,matGrade,bar_size,unit_convert,releaseIntervalIdx,&rebar);

         Float64 db;
         rebar->get_NominalDiameter(&db);

#pragma Reminder("UPDATE - this be a spec check")
         // validate bar spacing within the row
         // LRFD 5.10.3.1.2 - clear distance between parallel bars in a layer shall not be less than:
         // * nominal diameter of bar
         // * 1.33 times the maximum size of the coarse aggregate
         // * 1.0 inch
         // * 1.0 times fiber length for PCI UHPC
         // clear spacing is bar spacing minus nominal diameter of bar
         if ( 1 < info.NumberOfBars ) // only have to validate spacing between bars if there is more than one bar
         {
            Float64 clear = info.BarSpacing - db;
            if ( clear < db )
            {
               std::_tostringstream os;
               os << SEGMENT_LABEL(segmentKey)
                  << _T(": Clearance between longitudinal bars in row ") << LABEL_INDEX(idx) << _T(" is less than the nominal diameter of the bar (See LRFD 5.10.3.1.2)") << std::endl;

               std::unique_ptr<pgsGirderDescriptionStatusItem> pStatusItem = std::make_unique<pgsGirderDescriptionStatusItem>(segmentKey,EGD_LONG_REINF,m_StatusGroupID,m_scidGirderDescriptionWarning,os.str().c_str());
               pStatusCenter->Add(pStatusItem.release());
            }
            else if ( clear < 1.33*max_aggregate_size )
            {
               std::_tostringstream os;
               os << SEGMENT_LABEL(segmentKey)
                  << _T(": Clearance between longitudinal bars in row ") << LABEL_INDEX(idx) << _T(" is less than 1.33 times the maximum size of the coarse aggregate (See LRFD 5.10.3.1.2)") << std::endl;

               std::unique_ptr<pgsGirderDescriptionStatusItem> pStatusItem = std::make_unique<pgsGirderDescriptionStatusItem>(segmentKey,EGD_LONG_REINF,m_StatusGroupID,m_scidGirderDescriptionWarning,os.str().c_str());
               pStatusCenter->Add(pStatusItem.release());
            }
            else if ( clear < WBFL::Units::ConvertToSysUnits(1.0,WBFL::Units::Measure::Inch) )
            {
               std::_tostringstream os;
               os << SEGMENT_LABEL(segmentKey)
                  << _T(": Clearance between longitudinal bars in row ") << LABEL_INDEX(idx) << _T(" is less than 1.0 inch (See LRFD 5.10.3.1.2)") << std::endl;

               std::unique_ptr<pgsGirderDescriptionStatusItem> pStatusItem = std::make_unique<pgsGirderDescriptionStatusItem>(segmentKey,EGD_LONG_REINF,m_StatusGroupID,m_scidGirderDescriptionWarning,os.str().c_str());
               pStatusCenter->Add(pStatusItem.release());
            }
            else if (concreteType == pgsTypes::PCI_UHPC && clear < 1.0*fiber_length)
            {
               std::_tostringstream os;
               os << SEGMENT_LABEL(segmentKey)
                  << _T(": Clearance between longitudinal bars in row ") << LABEL_INDEX(idx) << _T(" is less than the fiber length (See PCI UHPC SDG E.10.2)") << std::endl;

               std::unique_ptr<pgsGirderDescriptionStatusItem> pStatusItem = std::make_unique<pgsGirderDescriptionStatusItem>(segmentKey, EGD_LONG_REINF, m_StatusGroupID, m_scidGirderDescriptionWarning, os.str().c_str());
               pStatusCenter->Add(pStatusItem.release());
            }
         }

         // break the bar into segments. Bar is modeled as straight except for bars that are
         // referenced from the bottom of the segment and the segment has a linear or parabolic profile
         std::vector<std::pair<Float64,Float64>> vBarSegments;
         if ( segmentVariation == pgsTypes::svtLinear && info.Face == pgsTypes::BottomFace )
         {
            // if the segment has a linear variation and the bar is referenced from the bottom
            // of the girder, make it follow the bottom of the girder.
            Float64 L1 = pSegment->GetVariationLength(pgsTypes::sztLeftPrismatic) - startEndDist;
            L1 = (L1 < 0 ? 0 : L1);
            Float64 L3 = pSegment->GetVariationLength(pgsTypes::sztRightPrismatic) - endEndDist;
            L3 = (L3 < 0 ? 0 : L3);
            Float64 L2 = segment_length - L1 - L3;

            Float64 s1 = (start < L1 ? start : -1);
            Float64 e1 = (end   < L1 ? end   : L1);

            Float64 s2 = (start < L1 ? L1 : (start < (L1+L2) ? start : -1));
            Float64 e2 = (end   < L1 ? -1 : (end   < (L1+L2) ? end   : L1+L2));

            Float64 s3 = (start < (L1+L2) ? L1+L2 : start);
            Float64 e3 = (end   < (L1+L2) ? -1    : end);

            if ( 0 <= s1 && 0 <= e1 && !IsEqual(s1,e1)  )
            {
               vBarSegments.emplace_back(s1,e1);
            }

            if ( 0 <= s2 && 0 <= e2 && !IsEqual(s2,e2) )
            {
               vBarSegments.emplace_back(s2,e2);
            }

            if ( 0 <= s3 && 0 <= e3 && !IsEqual(s3,e3)  )
            {
               vBarSegments.emplace_back(s3,e3);
            }
         }
         else if ( segmentVariation == pgsTypes::svtDoubleLinear && info.Face == pgsTypes::BottomFace )
         {
            // if the segment has a double linear variation and the bar is referenced from the bottom
            // of the girder, make it follow the bottom of the girder.
            Float64 L1 = pSegment->GetVariationLength(pgsTypes::sztLeftPrismatic) - startEndDist;
            Float64 L2 = pSegment->GetVariationLength(pgsTypes::sztLeftTapered);
            Float64 L4 = pSegment->GetVariationLength(pgsTypes::sztRightTapered);
            Float64 L5 = pSegment->GetVariationLength(pgsTypes::sztRightPrismatic) - endEndDist;
            L1 = (L1 < 0 ? 0 : L1);
            L5 = (L5 < 0 ? 0 : L5);
            if ( IsZero(L1) )
            {
               L2 = Max(0.0,L2-startEndDist);
            }

            if ( IsZero(L5) )
            {
               L4 = Max(0.0,L4-endEndDist);
            }

            Float64 L3 = segment_length - L1 - L2 - L4 - L5;

            Float64 s1 = (start < L1 ? start : -1);
            Float64 e1 = (end   < L1 ? end   : L1);

            Float64 s2 = (start < L1 ? L1 : (start < (L1+L2) ? start : -1));
            Float64 e2 = (end   < L1 ? -1 : (end   < (L1+L2) ? end   : L1+L2));

            Float64 s3 = (start < (L1+L2) ? L1+L2 : (start < (L1+L2+L3) ? start : -1));
            Float64 e3 = (end   < (L1+L2) ? -1    : (end   < (L1+L2+L3) ? end   : (L1+L2+L3)));

            Float64 s4 = (start < (L1+L2+L3) ? (L1+L2+L3) : (start < (L1+L2+L3+L4) ? start : -1));
            Float64 e4 = (end   < (L1+L2+L3) ? -1         : (end   < (L1+L2+L3+L4) ? end   : (L1+L2+L3+L4)));

            Float64 s5 = (start < (L1+L2+L3+L4) ? (L1+L2+L3+L4) : start);
            Float64 e5 = (end   < (L1+L2+L3+L4) ? -1            : end);

            if ( 0 <= s1 && 0 <= e1 && !IsEqual(s1,e1)  )
            {
               vBarSegments.emplace_back(s1,e1);
            }

            if ( 0 <= s2 && 0 <= e2 && !IsEqual(s2,e2)  )
            {
               vBarSegments.emplace_back(s2,e2);
            }

            if ( 0 <= s3 && 0 <= e3 && !IsEqual(s3,e3)  )
            {
               vBarSegments.emplace_back(s3,e3);
            }

            if ( 0 <= s4 && 0 <= e4 && !IsEqual(s4,e4)  )
            {
               vBarSegments.emplace_back(s4,e4);
            }

            if ( 0 <= s5 && 0 <= e5 && !IsEqual(s5,e5)  )
            {
               vBarSegments.emplace_back(s5,e5);
            }
         }
         else
         {
            vBarSegments.emplace_back(start,end);
         }

         std::vector<std::pair<Float64, Float64>>::iterator barSegmentIterBegin(vBarSegments.begin());
         std::vector<std::pair<Float64, Float64>>::iterator barSegmentIter(vBarSegments.begin());
         std::vector<std::pair<Float64,Float64>>::iterator barSegmentIterEnd(vBarSegments.end());
         for ( ; barSegmentIter != barSegmentIterEnd; barSegmentIter++ )
         {
            Float64 startLayout = barSegmentIter->first;
            Float64 endLayout = barSegmentIter->second;

            CComPtr<IFixedLengthRebarLayoutItem> fixedlength_layout_item;
            hr = fixedlength_layout_item.CoCreateInstance(CLSID_FixedLengthRebarLayoutItem);

            fixedlength_layout_item->put_Start(startLayout);
            fixedlength_layout_item->put_End(endLayout);

            CComPtr<IRebarRowFacePattern> row_pattern;
            row_pattern.CoCreateInstance(CLSID_RebarRowFacePattern);
            row_pattern->putref_Segment(segment);
            row_pattern->putref_Rebar(rebar);
            row_pattern->put_Face((FaceType)info.Face);
            row_pattern->put_Offset(info.Cover + db / 2);
            row_pattern->put_Count(info.NumberOfBars);
            row_pattern->put_Spacing(info.BarSpacing);
            row_pattern->put_Orientation(rroHCenter);

            // we will put a dummy 90 degree hook on extended bars
            // extended bars are assumed to be fully developed at all locations in the segment
            // extended bars are typically used in the girders of continuous "no deck" bridges for negative moment caapcity
            if (barSegmentIter == barSegmentIterBegin && info.IsLeftEndExtended())
            {
               row_pattern->put_Hook(qcbLeft, ht90);
            }

            if ((barSegmentIter + 1) == barSegmentIterEnd && info.IsRightEndExtended())
            {
               row_pattern->put_Hook(qcbRight, ht90);
            }

            fixedlength_layout_item->AddRebarPattern(row_pattern);

            rebar_layout->Add(fixedlength_layout_item);

            idx++;
         }
      }
   }
}

void CBridgeAgentImp::LayoutClosureJointRebar(const CClosureKey& closureKey)
{
   // Get the rebar input data
   GET_IFACE(IBridgeDescription,pIBridgeDesc);
   const CClosureJointData* pClosure = pIBridgeDesc->GetClosureJointData(closureKey);
   const CLongitudinalRebarData& rebar_data = pClosure->GetRebar();

   // If there aren't any rows of rebar data defined for this segment,
   // leave now
   const std::vector<CLongitudinalRebarData::RebarRow>& rebar_rows = rebar_data.RebarRows;
   if ( rebar_rows.size() == 0 )
   {
      return;
   }

   GET_IFACE_NOCHECK(IEAFStatusCenter, pStatusCenter);

   // Get the stage where the rebar is first introducted into the system.
   // Technically, the rebar is first introduced to the system when the closure joint
   // concrete is cast, however the rebar isn't doing anything structural
   // until the concrete is cured
   IntervalIndexType compositeClosureIntervalIdx = GetCompositeClosureJointInterval(closureKey);

   // Get the keys for the segments on either side of the closure
   CSegmentKey prevSegmentKey(pClosure->GetLeftSegment()->GetSegmentKey());
   CSegmentKey nextSegmentKey(pClosure->GetRightSegment()->GetSegmentKey());

   // Get the PrecastGirder object that will create the rebar model in
   // Given the basic input, this guy will compute the actual coordinates of
   // rebar at any cross section along the segment
   CComPtr<IPrecastGirder> girder;
   GetGirder(prevSegmentKey,&girder);

   CComPtr<IRebarLayout> rebar_layout;
   girder->get_ClosureJointRebarLayout(&rebar_layout);

   // Gather some information for layout of the rebar along the length of the
   // girder and within the girder cross section
   Float64 closure_length = GetClosureJointLength(closureKey);
   Float64 segment_length = GetSegmentLength(prevSegmentKey);
   pgsPointOfInterest startPoi(prevSegmentKey,segment_length);
   pgsPointOfInterest endPoi(nextSegmentKey,0,0);

   // Get the start and end closure height
   // Since we are in the process of validating the bridge model
   // we can't use the normal section properties interface (recursion would result).
   // The technique that will be used here will be to get the bounding box of
   // the segment shape and compute the height based on its top and bottom elevation

   // (1) get shape
   CComPtr<IShape> startShape, endShape;
   GetSegmentShapeDirect(startPoi,&startShape);
   GetSegmentShapeDirect(endPoi,  &endShape);

   // (2) get bounding box
   CComPtr<IRect2d> bbStart, bbEnd;
   startShape->get_BoundingBox(&bbStart);
   endShape->get_BoundingBox(&bbEnd);

   // (3) compute height of segment
   Float64 HgStart, HgEnd;
   bbStart->get_Height(&HgStart);
   bbEnd->get_Height(&HgEnd);

   // Get some basic information about the rebar so we can build a rebar material object
   // We need to map PGSuper data into WBFLGenericBridge data
   MaterialSpec matSpec  = GetRebarSpecification(rebar_data.BarType);
   RebarGrade   matGrade = GetRebarGrade(rebar_data.BarGrade);

   // Create a rebar factory. This does the work of creating rebar objects
   CComPtr<IRebarFactory> rebar_factory;
   rebar_factory.CoCreateInstance(CLSID_RebarFactory);

   // Need a unit server object for units conversion
   CComPtr<IUnitServer> unitServer;
   unitServer.CoCreateInstance(CLSID_UnitServer);
   HRESULT hr = ConfigureUnitServer(unitServer);
   ATLASSERT(SUCCEEDED(hr));

   CComPtr<IUnitConvert> unit_convert;
   unitServer->get_UnitConvert(&unit_convert);

   IndexType nRows = rebar_rows.size();
   for ( IndexType idx = 0; idx < nRows; idx++ )
   {
      // get the data for this row
      const CLongitudinalRebarData::RebarRow& info = rebar_rows[idx];

      // if there are bars in this row, and the bars have size, define
      // the rebar pattern for this row. Rebar pattern is the definition of the
      // rebar within the cross section
      if ( info.BarSize != WBFL::Materials::Rebar::Size::bsNone && 0 < info.NumberOfBars )
      {
         CComPtr<IFixedLengthRebarLayoutItem> fixed_layout_item;
         fixed_layout_item.CoCreateInstance(CLSID_FixedLengthRebarLayoutItem);
         ATLASSERT(fixed_layout_item);

         fixed_layout_item->put_Start(segment_length);
         fixed_layout_item->put_End(segment_length + closure_length);

         CComQIPtr<IRebarLayoutItem> rebar_layout_item(fixed_layout_item);

         // Create the rebar object
         BarSize bar_size = GetBarSize(info.BarSize);
         CComPtr<IRebar> rebar;
         rebar_factory->CreateRebar(matSpec,matGrade,bar_size,unit_convert,compositeClosureIntervalIdx,&rebar);

         Float64 db;
         rebar->get_NominalDiameter(&db);

         // create the rebar pattern (definition of rebar in the cross section)
         CComPtr<IRebarRowPattern> row_pattern;
         row_pattern.CoCreateInstance(CLSID_RebarRowPattern);

         // Locate the rebar in Girder Section Coordinates
         // (0,0) is at the top of the girder so Y is measured
         // down from the top
         Float64 yStart, yEnd;
         if ( info.Face == pgsTypes::TopFace )
         {
            yStart = -(info.Cover + db/2);
            yEnd   = yStart;
         }
         else
         {
            yStart = -(HgStart - info.Cover - db/2);
            yEnd   = -(HgEnd   - info.Cover - db/2);
         }

         if (yStart < -HgStart || yEnd < -HgEnd)
         {
            std::_tostringstream os;
            os << CLOSURE_LABEL(closureKey)
               << _T(": bars in row ") << LABEL_INDEX(idx) << _T(" are outside of the girder section. These bars will be ignored.") << std::endl;

            std::unique_ptr<pgsGirderDescriptionStatusItem> pStatusItem = std::make_unique<pgsGirderDescriptionStatusItem>(closureKey, EGD_LONG_REINF, m_StatusGroupID, m_scidGirderDescriptionWarning, os.str().c_str());
            pStatusCenter->Add(pStatusItem.release());

            continue;
         }

         CComPtr<IPoint2d> startAnchor;
         startAnchor.CoCreateInstance(CLSID_Point2d);
         startAnchor->Move(0,yStart);

         CComPtr<IPoint2d> endAnchor;
         endAnchor.CoCreateInstance(CLSID_Point2d);
         endAnchor->Move(0,yEnd);

         // create the rebar pattern
         row_pattern->putref_Rebar(rebar);
         row_pattern->put_AnchorPoint(etStart, startAnchor);
         row_pattern->put_AnchorPoint(etEnd,   endAnchor);
         row_pattern->put_Count( info.NumberOfBars );
         row_pattern->put_Spacing( info.BarSpacing );
         row_pattern->put_Orientation( rroHCenter );

         // add this pattern to the layout
         rebar_layout_item->AddRebarPattern(row_pattern);
      
         rebar_layout->Add(rebar_layout_item);
      }
   }
}

void CBridgeAgentImp::CheckBridge()
{
   GET_IFACE_NOCHECK(IEAFStatusCenter,pStatusCenter); // only used if there is an issue

   GET_IFACE(IBridgeDescription,pIBridgeDesc);
   const CBridgeDescription2* pBridgeDesc = pIBridgeDesc->GetBridgeDescription();

   if ( HasOverlay() && IsZero(GetOverlayWeight()) )
   {
      CString strMsg(_T("An overlay is specified, but the overlay load is zero."));
      std::unique_ptr<pgsInformationalStatusItem> pStatusItem = std::make_unique<pgsInformationalStatusItem>(m_StatusGroupID,m_scidZeroOverlayWarning,strMsg);
      GET_IFACE(IEAFStatusCenter,pStatusCenter);
      pStatusCenter->Add(pStatusItem.release());
   }

   // make sure all girders have positive lengths
   GroupIndexType nGroups = pBridgeDesc->GetGirderGroupCount();
   for ( GroupIndexType grpIdx = 0; grpIdx < nGroups; grpIdx++ )
   {
      GirderIndexType nGirders = pBridgeDesc->GetGirderGroup(grpIdx)->GetGirderCount();
      for( GirderIndexType gdrIdx = 0; gdrIdx < nGirders; gdrIdx++ )
      {
         const CSplicedGirderData* pGirder = pBridgeDesc->GetGirderGroup(grpIdx)->GetGirder(gdrIdx);
         SegmentIndexType nSegments = pGirder->GetSegmentCount();
         for ( SegmentIndexType segIdx = 0; segIdx < nSegments; segIdx++ )
         {
            CSegmentKey segmentKey(grpIdx,gdrIdx,segIdx);
            CComPtr<IPrecastGirder> girder;
            GetGirder(segmentKey, &girder);

            Float64 sLength;
            girder->get_SpanLength(&sLength);

            if ( sLength <= 0 )
            {
               std::_tostringstream os;
               os << SEGMENT_LABEL(segmentKey) << _T(" does not have a positive length.") << std::endl;

               std::unique_ptr<pgsBridgeDescriptionStatusItem> pStatusItem = std::make_unique<pgsBridgeDescriptionStatusItem>(m_StatusGroupID,m_scidBridgeDescriptionError,pgsBridgeDescriptionStatusItem::General,os.str().c_str());
               pStatusCenter->Add(pStatusItem.release());
            }


            if ( segIdx < nSegments-1 )
            {
               // Closure Joints
               CClosureKey closureKey = segmentKey;
               Float64 closure_length = GetClosureJointLength(closureKey);
               if ( ::IsLE(closure_length,0.0) )
               {
                  std::_tostringstream os;
                  os << _T("Closure joint length for Group ") << LABEL_GROUP(grpIdx) << _T(" Girder ") << LABEL_GIRDER(gdrIdx) << _T(" at the end of Segment ") << LABEL_SEGMENT(segIdx)
                     << _T(" must be greater than zero.") << std::endl;

                  std::unique_ptr<pgsBridgeDescriptionStatusItem> pStatusItem = std::make_unique<pgsBridgeDescriptionStatusItem>(m_StatusGroupID,m_scidBridgeDescriptionError,pgsBridgeDescriptionStatusItem::Framing,os.str().c_str());
                  pStatusCenter->Add(pStatusItem.release());
               }
            }
         } // next segment
      } // next girder
   } // next group

   // Make sure support lines don't intersect
   // this can happen with really short, wide bridges with high skew angles
   CComPtr<IBridgeGeometry> bridgeGeometry;
   m_Bridge->get_BridgeGeometry(&bridgeGeometry);
   PierIndexType nPierLines; // these are "generic piers"... piers and temporary supports
   bridgeGeometry->get_PierLineCount(&nPierLines);
   CComPtr<IPierLine> prevPierLine;
   bridgeGeometry->GetPierLine(0, &prevPierLine);
   CComPtr<ILineSegment2d> line1, line2;
   line1.CoCreateInstance(CLSID_LineSegment2d);
   line2.CoCreateInstance(CLSID_LineSegment2d);

   CComPtr<IPoint2d> pntLeft1, pntRight1;
   prevPierLine->get_LeftPoint(&pntLeft1);
   prevPierLine->get_RightPoint(&pntRight1);
   line1->ThroughPoints(pntLeft1, pntRight1);

   CComPtr<IGeomUtil2d> geomUtil;
   geomUtil.CoCreateInstance(CLSID_GeomUtil);
   for (PierIndexType pierLineIdx = 1; pierLineIdx < nPierLines; pierLineIdx++)
   {
      CComPtr<IPierLine> pierLine;
      bridgeGeometry->GetPierLine(pierLineIdx, &pierLine);

      CComPtr<IPoint2d> pntLeft2, pntRight2;
      pierLine->get_LeftPoint(&pntLeft2);
      pierLine->get_RightPoint(&pntRight2);
      line2->ThroughPoints(pntLeft2, pntRight2);

      CComPtr<IPoint2d> pnt;
      HRESULT result = geomUtil->SegSegIntersect(line1, line2, &pnt);
      if (result == S_OK)
      {
         // the line segments intersect... there the pier lines cross... this is bad
         std::_tostringstream os;
         os << _T("Abutment/Pier/Temporary Support line ") << LABEL_PIER(pierLineIdx-1) << _T(" intersects with abutment/pier/temporary support line ") << LABEL_PIER(pierLineIdx) << _T(". This is invalid framing geometry.") << std::endl;

         std::unique_ptr<pgsBridgeDescriptionStatusItem> pStatusItem = std::make_unique<pgsBridgeDescriptionStatusItem>(m_StatusGroupID, m_scidBridgeDescriptionError, pgsBridgeDescriptionStatusItem::Framing, os.str().c_str());
         pStatusCenter->Add(pStatusItem.release());
      }

      pntLeft1 = pntLeft2;
      pntRight1 = pntRight2;
      line1->ThroughPoints(pntLeft1, pntRight1);
      prevPierLine = pierLine;
   }

   // Make sure casting regions don't overlap
   Float64 first_station = GetPierStation(0);
   IndexType nRegions = GetDeckCastingRegionCount();
   Float64 XbLast = 0;
   for (IndexType regionIdx = 0; regionIdx < nRegions; regionIdx++)
   {
      PierIndexType startPierIdx, endPierIdx;
      Float64 Xstart, Xend;
      CCastingRegion::RegionType regionType;
      IndexType sequenceIdx;
      GetDeckCastingRegionLimits(regionIdx, &startPierIdx, &Xstart, &endPierIdx, &Xend, &regionType, &sequenceIdx);
      Float64 start_pier_station = GetPierStation(startPierIdx);
      Float64 XbStart = start_pier_station - first_station + Xstart;
      Float64 end_pier_station = GetPierStation(endPierIdx);
      Float64 XbEnd = end_pier_station - first_station + Xend;

      if (IsLE(XbEnd - XbStart, 0.0))
      {
         // this region has no or negative length
         std::_tostringstream os;
         os << _T("Deck Casting region ") << LABEL_INDEX(regionIdx) << _T(" has a length of zero. Revise deck casting regions.") << std::endl;

         std::unique_ptr<pgsBridgeDescriptionStatusItem> pStatusItem = std::make_unique<pgsBridgeDescriptionStatusItem>(m_StatusGroupID, m_scidBridgeDescriptionError, pgsBridgeDescriptionStatusItem::DeckCasting, os.str().c_str());
         pStatusCenter->Add(pStatusItem.release());
      }

      if (regionIdx == 0)
      {
         XbLast = XbEnd;
      }
      else
      {
         if (!IsEqual(XbLast, XbStart))
         {
            // there is a gap between region i and i-1
            std::_tostringstream os;
            os << _T("Deck Casting regions ") << LABEL_INDEX(regionIdx-1) << _T(" and ") << LABEL_INDEX(regionIdx) << _T(" do not share a common boundary. Revise deck casting regions.") << std::endl;

            std::unique_ptr<pgsBridgeDescriptionStatusItem> pStatusItem = std::make_unique<pgsBridgeDescriptionStatusItem>(m_StatusGroupID, m_scidBridgeDescriptionError, pgsBridgeDescriptionStatusItem::DeckCasting, os.str().c_str());
            pStatusCenter->Add(pStatusItem.release());
         }

         XbLast = XbEnd;
      }
   }

   

   // COGO model doesn't save correctly... fix this later
//#if defined _DEBUG
//   // Dumps the cogo model to a file so it can be viewed/debugged
//   CComPtr<IStructuredSave2> save;
//   save.CoCreateInstance(CLSID_StructuredSave2);
//   save->Open(CComBSTR(_T("CogoModel.cogo")));
//
//   save->BeginUnit(CComBSTR(_T("Cogo")),1.0);
//
//   CComQIPtr<IStructuredStorage2> ss(m_CogoModel);
//   ss->Save(save);
//
//   save->EndUnit();
//   save->Close();
//#endif // _DEBUG
}

SpanIndexType CBridgeAgentImp::GetSpanCount_Private() const
{
   GET_IFACE(IBridgeDescription,pIBridgeDesc);
   const CBridgeDescription2* pBridgeDesc = pIBridgeDesc->GetBridgeDescription();
   return pBridgeDesc->GetSpanCount();
}

PierIndexType CBridgeAgentImp::GetPierCount_Private() const
{
   GET_IFACE(IBridgeDescription,pIBridgeDesc);
   const CBridgeDescription2* pBridgeDesc = pIBridgeDesc->GetBridgeDescription();
   return pBridgeDesc->GetPierCount();
}

Float64 CBridgeAgentImp::GetIxy_Private(pgsTypes::SectionPropertyType spType, IntervalIndexType intervalIdx, const pgsPointOfInterest& poi) const
{
   const SectProp& props = GetSectionProperties(intervalIdx, poi, spType);
   Float64 ixy;
   props.ShapeProps->get_Ixy(&ixy);
   return ixy;
}

bool CBridgeAgentImp::ComputeNumPermanentStrands(StrandIndexType totalPermanent,const CSegmentKey& segmentKey,StrandIndexType* numStraight,StrandIndexType* numHarped) const
{
   VALIDATE( GIRDER );

   CComPtr<IPrecastGirder> girder;
   GetGirder(segmentKey,&girder);

   CComPtr<IStrandModel> strandModel;
   girder->get_StrandModel(&strandModel);
   CComQIPtr<IStrandGridModel> strandGridModel(strandModel);

   HRESULT hr = m_StrandFillers[segmentKey].ComputeNumPermanentStrands(strandGridModel, totalPermanent, numStraight, numHarped);
   ATLASSERT(SUCCEEDED(hr));

   return hr==S_OK;
}

bool CBridgeAgentImp::ComputeNumPermanentStrands(StrandIndexType totalPermanent,LPCTSTR strGirderName, StrandIndexType* numStraight, StrandIndexType* numHarped) const
{
   GET_IFACE(ILibrary,pLib);
   const GirderLibraryEntry* pGirderEntry = pLib->GetGirderEntry( strGirderName );
   return pGirderEntry->GetPermStrandDistribution(totalPermanent, numStraight, numHarped);
}

StrandIndexType CBridgeAgentImp::GetMaxNumPermanentStrands(const CSegmentKey& segmentKey) const
{
   VALIDATE( GIRDER );

   CComPtr<IPrecastGirder> girder;
   GetGirder(segmentKey,&girder);

   CComPtr<IStrandModel> strandModel;
   girder->get_StrandModel(&strandModel);
   CComQIPtr<IStrandGridModel> strandGridModel(strandModel);

   StrandIndexType maxNum;
   HRESULT hr = m_StrandFillers[segmentKey].GetMaxNumPermanentStrands(strandGridModel, &maxNum);
   ATLASSERT(SUCCEEDED(hr));

   return maxNum;
}

StrandIndexType CBridgeAgentImp::GetMaxNumPermanentStrands(LPCTSTR strGirderName) const
{
   GET_IFACE(ILibrary,pLib);
   const GirderLibraryEntry* pGirderEntry = pLib->GetGirderEntry( strGirderName );
   std::vector<GirderLibraryEntry::StrandDefinitionType> permStrands = pGirderEntry->GetPermanentStrands();
   return permStrands.size()-1;
}

StrandIndexType CBridgeAgentImp::GetPreviousNumPermanentStrands(const CSegmentKey& segmentKey,StrandIndexType curNum) const
{
   VALIDATE( GIRDER );

   CComPtr<IPrecastGirder> girder;
   GetGirder(segmentKey,&girder);

   CComPtr<IStrandModel> strandModel;
   girder->get_StrandModel(&strandModel);
   CComQIPtr<IStrandGridModel> strandGridModel(strandModel);

   StrandIndexType nextNum;
   HRESULT hr = m_StrandFillers[segmentKey].GetPreviousNumberOfPermanentStrands(strandGridModel, curNum, &nextNum);
   ATLASSERT(SUCCEEDED(hr));

   return nextNum;
}

StrandIndexType CBridgeAgentImp::GetPreviousNumPermanentStrands(LPCTSTR strGirderName,StrandIndexType curNum) const
{
   GET_IFACE(ILibrary,pLib);
   const GirderLibraryEntry* pGdrEntry = pLib->GetGirderEntry(strGirderName);

   CStrandFiller strandFiller;
   strandFiller.Init(pGdrEntry);

   StrandIndexType prevNum;
   strandFiller.GetPreviousNumberOfPermanentStrands(nullptr,curNum,&prevNum);

   return prevNum;
}

StrandIndexType CBridgeAgentImp::GetNextNumPermanentStrands(const CSegmentKey& segmentKey,StrandIndexType curNum) const
{
   VALIDATE( GIRDER );

   CComPtr<IPrecastGirder> girder;
   GetGirder(segmentKey,&girder);

   CComPtr<IStrandModel> strandModel;
   girder->get_StrandModel(&strandModel);
   CComQIPtr<IStrandGridModel> strandGridModel(strandModel);

   StrandIndexType nextNum;
   HRESULT hr = m_StrandFillers[segmentKey].GetNextNumberOfPermanentStrands(strandGridModel, curNum, &nextNum);
   ATLASSERT(SUCCEEDED(hr));

   return nextNum;
}

StrandIndexType CBridgeAgentImp::GetNextNumPermanentStrands(LPCTSTR strGirderName,StrandIndexType curNum) const
{
   GET_IFACE(ILibrary,pLib);
   const GirderLibraryEntry* pGdrEntry = pLib->GetGirderEntry(strGirderName);

   CStrandFiller strandFiller;
   strandFiller.Init(pGdrEntry);

   StrandIndexType nextNum;
   strandFiller.GetNextNumberOfPermanentStrands(nullptr,curNum,&nextNum);

   return nextNum;
}

void CBridgeAgentImp::ComputePermanentStrandIndices(const CSegmentKey& segmentKey, pgsTypes::StrandType strType, IIndexArray** permIndices) const
{
   const GirderLibraryEntry* pGdrEntry = GetGirderLibraryEntry(segmentKey);
   auto config = GetSegmentConfiguration(segmentKey);
   ComputePermanentStrandIndices(pGdrEntry->GetName().c_str(), config.PrestressConfig, strType, permIndices);
}

void CBridgeAgentImp::ComputePermanentStrandIndices(LPCTSTR strGirderName,const PRESTRESSCONFIG& rconfig, pgsTypes::StrandType strType, IIndexArray** permIndices) const
{
   CComPtr<IIndexArray> permStrands;  // array index = permanent strand for each strand of type
   permStrands.CoCreateInstance(CLSID_IndexArray);
   ATLASSERT(permStrands);

   GET_IFACE(ILibrary,pLib);
   const GirderLibraryEntry* pGdrEntry = pLib->GetGirderEntry(strGirderName);

   const ConfigStrandFillVector& rStraightFillVec( rconfig.GetStrandFill(pgsTypes::Straight) );
   const ConfigStrandFillVector& rHarpedFillVec(   rconfig.GetStrandFill(pgsTypes::Harped) );

   GridIndexType maxStraightGrid = pGdrEntry->GetNumStraightStrandCoordinates();
   GridIndexType maxHarpedGrid = pGdrEntry->GetNumHarpedStrandCoordinates();
   ATLASSERT(maxStraightGrid == rStraightFillVec.size()); // this function won't play well without this
   ATLASSERT(maxHarpedGrid == rHarpedFillVec.size());

   GridIndexType maxPermGrid = pGdrEntry->GetPermanentStrandGridSize();
   // Loop over all available permanent strands and add index for strType if it's filled
   StrandIndexType permIdc = 0;
   for (GridIndexType idxPermGrid = 0; idxPermGrid < maxPermGrid; idxPermGrid++)
   {
      GridIndexType localGridIdx;
      GirderLibraryEntry::psStrandType type;
      pGdrEntry->GetGridPositionFromPermStrandGrid(idxPermGrid, &type, &localGridIdx);

      if (type==pgsTypes::Straight)
      {
         // If filled, use count from fill vec, otherwise use x coordinate
         StrandIndexType strCnt;
         bool isFilled = rStraightFillVec[localGridIdx] > 0;
         if (isFilled)
         {
            strCnt = rStraightFillVec[localGridIdx];
         }
         else
         {
            Float64 start_x, start_y, end_x, end_y;
            bool can_debond;
            pGdrEntry->GetStraightStrandCoordinates(localGridIdx, &start_x, &start_y, &end_x, &end_y, &can_debond);
            strCnt = (start_x > 0.0 || end_x > 0.0) ? 2 : 1;
         }

         permIdc += strCnt;

         // if strand is filled, add its permanent index to the collection
         if (isFilled && strType==pgsTypes::Straight)
         {
            if (strCnt==1)
            {
               permStrands->Add(permIdc-1);
            }
            else
            {
               permStrands->Add(permIdc-2);
               permStrands->Add(permIdc-1);
            }
         }
      }
      else
      {
         ATLASSERT(type==pgsTypes::Harped);
         // If filled, use count from fill vec, otherwise use x coordinate
         StrandIndexType strCnt;
         bool isFilled = rHarpedFillVec[localGridIdx] > 0;
         if (isFilled)
         {
            strCnt = rHarpedFillVec[localGridIdx];
         }
         else
         {
            Float64 startx, starty, hpx, hpy, endx, endy;
            pGdrEntry->GetHarpedStrandCoordinates(localGridIdx, &startx, &starty, &hpx, &hpy, &endx, &endy);
            strCnt = (startx > 0.0 || hpx > 0.0 || endx > 0.0) ? 2 : 1;
         }

         permIdc += strCnt;

         // if strand is filled, add its permanent index to the collection
         if (isFilled && strType==pgsTypes::Harped)
         {
            permStrands->Add(permIdc-1);

            if (strCnt==2)
            {
               permStrands->Add(permIdc-2);
            }
         }
      }
   }

   permStrands.CopyTo(permIndices);
}

bool CBridgeAgentImp::IsValidNumStrands(const CSegmentKey& segmentKey,pgsTypes::StrandType type,StrandIndexType curNum) const
{
   VALIDATE( GIRDER );

   CComPtr<IPrecastGirder> girder;
   GetGirder(segmentKey,&girder);

   CComPtr<IStrandModel> strandModel;
   girder->get_StrandModel(&strandModel);
   CComQIPtr<IStrandGridModel> strandGridModel(strandModel);

   VARIANT_BOOL bIsValid;
   HRESULT hr = E_FAIL;
   switch( type )
   {
   case pgsTypes::Straight:
      hr = m_StrandFillers[segmentKey].IsValidNumStraightStrands(strandGridModel, curNum, &bIsValid);
      break;

   case pgsTypes::Harped:
      hr = m_StrandFillers[segmentKey].IsValidNumHarpedStrands(strandGridModel, curNum, &bIsValid);
      break;

   case pgsTypes::Temporary:
      hr = m_StrandFillers[segmentKey].IsValidNumTemporaryStrands(strandGridModel, curNum, &bIsValid);
      break;
   }
   ATLASSERT(SUCCEEDED(hr));

   return bIsValid == VARIANT_TRUE ? true : false;
}

bool CBridgeAgentImp::IsValidNumStrands(LPCTSTR strGirderName,pgsTypes::StrandType type,StrandIndexType curNum) const
{
   GET_IFACE(ILibrary,pLib);
   const GirderLibraryEntry* pGdrEntry = pLib->GetGirderEntry(strGirderName);

   CStrandFiller strandFiller;
   strandFiller.Init(pGdrEntry);

   // The position of the strands in the strand grid doesn't matter
   // for this method. Just use dummy values.
   Float64 Hg = 0;

   VARIANT_BOOL isvalid(VARIANT_FALSE);
   HRESULT hr(E_FAIL);
   switch( type )
   {
   case pgsTypes::Straight:
      {
         CComPtr<IStrandGrid> startGrid, endGrid;
         startGrid.CoCreateInstance(CLSID_StrandGrid);
         endGrid.CoCreateInstance(CLSID_StrandGrid);
         pGdrEntry->ConfigureStraightStrandGrid(Hg,Hg,startGrid,endGrid);

         CComQIPtr<IStrandGridFiller> gridFiller(startGrid);

         hr = strandFiller.IsValidNumStraightStrands(gridFiller,curNum,&isvalid);
      }
      break;

   case pgsTypes::Harped:
      {
         CComPtr<IStrandGrid> startGrid, startHPGrid, endHPGrid, endGrid;
         startGrid.CoCreateInstance(CLSID_StrandGrid);
         startHPGrid.CoCreateInstance(CLSID_StrandGrid);
         endHPGrid.CoCreateInstance(CLSID_StrandGrid);
         endGrid.CoCreateInstance(CLSID_StrandGrid);
         pGdrEntry->ConfigureHarpedStrandGrids(Hg,Hg,Hg,Hg,startGrid,startHPGrid,endHPGrid,endGrid);

         CComQIPtr<IStrandGridFiller> startFiller(startGrid);
         CComQIPtr<IStrandGridFiller> endFiller(endGrid);

         hr = strandFiller.IsValidNumHarpedStrands(pGdrEntry->OddNumberOfHarpedStrands(),startFiller,endFiller,curNum,&isvalid);
      }
      break;

   case pgsTypes::Temporary:
      {
         CComPtr<IStrandGrid> startGrid, endGrid;
         startGrid.CoCreateInstance(CLSID_StrandGrid);
         endGrid.CoCreateInstance(CLSID_StrandGrid);
         pGdrEntry->ConfigureTemporaryStrandGrid(Hg,Hg,startGrid,endGrid);

         CComQIPtr<IStrandGridFiller> gridFiller(startGrid);

         hr = strandFiller.IsValidNumTemporaryStrands(gridFiller,curNum,&isvalid);
      }
      break;
   }
   ATLASSERT(SUCCEEDED(hr));

   return isvalid==VARIANT_TRUE;
}

StrandIndexType CBridgeAgentImp::GetNextNumStraightStrands(const CSegmentKey& segmentKey,StrandIndexType curNum) const
{
   VALIDATE( GIRDER );

   CComPtr<IPrecastGirder> girder;
   GetGirder(segmentKey,&girder);

   CComPtr<IStrandModel> strandModel;
   girder->get_StrandModel(&strandModel);
   CComQIPtr<IStrandGridModel> strandGridModel(strandModel);

   StrandIndexType nextNum;
   HRESULT hr = m_StrandFillers[segmentKey].GetNextNumberOfStraightStrands(strandGridModel, curNum, &nextNum);
   ATLASSERT(SUCCEEDED(hr));

   return nextNum;
}

StrandIndexType CBridgeAgentImp::GetNextNumStraightStrands(LPCTSTR strGirderName,StrandIndexType curNum) const
{
   GET_IFACE(ILibrary,pLib);
   const GirderLibraryEntry* pGdrEntry = pLib->GetGirderEntry(strGirderName);

   CStrandFiller strandFiller;
   strandFiller.Init(pGdrEntry);

   // The position of the strands in the strand grid doesn't matter
   // for this method. Just use dummy values.
   Float64 Hg = 0;

   CComPtr<IStrandGrid> startGrid, endGrid;
   startGrid.CoCreateInstance(CLSID_StrandGrid);
   endGrid.CoCreateInstance(CLSID_StrandGrid);
   pGdrEntry->ConfigureStraightStrandGrid(Hg,Hg,startGrid,endGrid);

   CComQIPtr<IStrandGridFiller> gridFiller(startGrid);

   StrandIndexType nextNum;
   strandFiller.GetNextNumberOfStraightStrands(gridFiller,curNum,&nextNum);

   return nextNum;
}

StrandIndexType CBridgeAgentImp::GetNextNumHarpedStrands(const CSegmentKey& segmentKey,StrandIndexType curNum) const
{
   VALIDATE( GIRDER );

   CComPtr<IPrecastGirder> girder;
   GetGirder(segmentKey,&girder);

   CComPtr<IStrandModel> strandModel;
   girder->get_StrandModel(&strandModel);
   CComQIPtr<IStrandGridModel> strandGridModel(strandModel);

   StrandIndexType nextNum;
   HRESULT hr = m_StrandFillers[segmentKey].GetNextNumberOfHarpedStrands(strandGridModel, curNum, &nextNum);
   ATLASSERT(SUCCEEDED(hr));

   return nextNum;
}

StrandIndexType CBridgeAgentImp::GetNextNumHarpedStrands(LPCTSTR strGirderName,StrandIndexType curNum) const
{
   GET_IFACE(ILibrary,pLib);
   const GirderLibraryEntry* pGdrEntry = pLib->GetGirderEntry(strGirderName);

   CStrandFiller strandFiller;
   strandFiller.Init(pGdrEntry);

   // The position of the strands in the strand grid doesn't matter
   // for this method. Just use dummy values.
   Float64 Hg = 0;

   CComPtr<IStrandGrid> startGrid, startHPGrid, endHPGrid, endGrid;
   startGrid.CoCreateInstance(CLSID_StrandGrid);
   startHPGrid.CoCreateInstance(CLSID_StrandGrid);
   endHPGrid.CoCreateInstance(CLSID_StrandGrid);
   endGrid.CoCreateInstance(CLSID_StrandGrid);
   pGdrEntry->ConfigureHarpedStrandGrids(Hg,Hg,Hg,Hg,startGrid,startHPGrid,endHPGrid,endGrid);

   CComQIPtr<IStrandGridFiller> gridFiller(startGrid);

   StrandIndexType nextNum;
   strandFiller.GetNextNumberOfHarpedStrands(pGdrEntry->OddNumberOfHarpedStrands(),gridFiller,curNum,&nextNum);

   return nextNum;
}

StrandIndexType CBridgeAgentImp::GetNextNumTempStrands(const CSegmentKey& segmentKey,StrandIndexType curNum) const
{
   VALIDATE( GIRDER );

   CComPtr<IPrecastGirder> girder;
   GetGirder(segmentKey,&girder);

   CComPtr<IStrandModel> strandModel;
   girder->get_StrandModel(&strandModel);
   CComQIPtr<IStrandGridModel> strandGridModel(strandModel);

   StrandIndexType nextNum;
   HRESULT hr = m_StrandFillers[segmentKey].GetNextNumberOfTemporaryStrands(strandGridModel, curNum, &nextNum);
   ATLASSERT(SUCCEEDED(hr));

   return nextNum;
}

StrandIndexType CBridgeAgentImp::GetNextNumTempStrands(LPCTSTR strGirderName,StrandIndexType curNum) const
{
   GET_IFACE(ILibrary,pLib);
   const GirderLibraryEntry* pGdrEntry = pLib->GetGirderEntry(strGirderName);

   CStrandFiller strandFiller;
   strandFiller.Init(pGdrEntry);

   // The position of the strands in the strand grid doesn't matter
   // for this method. Just use dummy values.
   Float64 Hg = 0;

   CComPtr<IStrandGrid> startGrid, endGrid;
   startGrid.CoCreateInstance(CLSID_StrandGrid);
   endGrid.CoCreateInstance(CLSID_StrandGrid);
   pGdrEntry->ConfigureTemporaryStrandGrid(Hg,Hg,startGrid,endGrid);

   CComQIPtr<IStrandGridFiller> gridFiller(startGrid);

   StrandIndexType nextNum;
   strandFiller.GetNextNumberOfTemporaryStrands(gridFiller,curNum,&nextNum);

   return nextNum;
}

StrandIndexType CBridgeAgentImp::GetPrevNumStraightStrands(const CSegmentKey& segmentKey,StrandIndexType curNum) const
{
   VALIDATE( GIRDER );

   CComPtr<IPrecastGirder> girder;
   GetGirder(segmentKey,&girder);

   CComPtr<IStrandModel> strandModel;
   girder->get_StrandModel(&strandModel);
   CComQIPtr<IStrandGridModel> strandGridModel(strandModel);

   StrandIndexType nextNum;
   HRESULT hr = m_StrandFillers[segmentKey].GetPreviousNumberOfStraightStrands(strandGridModel, curNum, &nextNum);
   ATLASSERT(SUCCEEDED(hr));

   return nextNum;
}

StrandIndexType CBridgeAgentImp::GetPrevNumStraightStrands(LPCTSTR strGirderName,StrandIndexType curNum) const
{
   GET_IFACE(ILibrary,pLib);
   const GirderLibraryEntry* pGdrEntry = pLib->GetGirderEntry(strGirderName);

   CStrandFiller strandFiller;
   strandFiller.Init(pGdrEntry);

   // The position of the strands in the strand grid doesn't matter
   // for this method. Just use dummy values.
   Float64 Hg = 0;

   CComPtr<IStrandGrid> startGrid, endGrid;
   startGrid.CoCreateInstance(CLSID_StrandGrid);
   endGrid.CoCreateInstance(CLSID_StrandGrid);
   pGdrEntry->ConfigureStraightStrandGrid(Hg,Hg,startGrid,endGrid);

   CComQIPtr<IStrandGridFiller> gridFiller(startGrid);

   StrandIndexType prevNum;
   strandFiller.GetPrevNumberOfStraightStrands(gridFiller,curNum,&prevNum);

   return prevNum;
}

StrandIndexType CBridgeAgentImp::GetPrevNumHarpedStrands(const CSegmentKey& segmentKey,StrandIndexType curNum) const
{
   VALIDATE( GIRDER );

   CComPtr<IPrecastGirder> girder;
   GetGirder(segmentKey,&girder);

   CComPtr<IStrandModel> strandModel;
   girder->get_StrandModel(&strandModel);
   CComQIPtr<IStrandGridModel> strandGridModel(strandModel);

   StrandIndexType nextNum;
   HRESULT hr = m_StrandFillers[segmentKey].GetPreviousNumberOfHarpedStrands(strandGridModel, curNum, &nextNum);
   ATLASSERT(SUCCEEDED(hr));

   return nextNum;
}

StrandIndexType CBridgeAgentImp::GetPrevNumHarpedStrands(LPCTSTR strGirderName,StrandIndexType curNum) const
{
   GET_IFACE(ILibrary,pLib);
   const GirderLibraryEntry* pGdrEntry = pLib->GetGirderEntry(strGirderName);

   CStrandFiller strandFiller;
   strandFiller.Init(pGdrEntry);

   // The position of the strands in the strand grid doesn't matter
   // for this method. Just use dummy values.
   Float64 Hg = 0;

   CComPtr<IStrandGrid> startGrid, startHPGrid, endHPGrid, endGrid;
   startGrid.CoCreateInstance(CLSID_StrandGrid);
   startHPGrid.CoCreateInstance(CLSID_StrandGrid);
   endHPGrid.CoCreateInstance(CLSID_StrandGrid);
   endGrid.CoCreateInstance(CLSID_StrandGrid);
   pGdrEntry->ConfigureHarpedStrandGrids(Hg,Hg,Hg,Hg,startGrid,startHPGrid,endHPGrid,endGrid);

   CComQIPtr<IStrandGridFiller> gridFiller(startGrid);

   StrandIndexType prevNum;
   strandFiller.GetPrevNumberOfHarpedStrands(pGdrEntry->OddNumberOfHarpedStrands(),gridFiller,curNum,&prevNum);

   return prevNum;
}

StrandIndexType CBridgeAgentImp::GetPrevNumTempStrands(const CSegmentKey& segmentKey,StrandIndexType curNum) const
{
   VALIDATE( GIRDER );

   CComPtr<IPrecastGirder> girder;
   GetGirder(segmentKey,&girder);

   CComPtr<IStrandModel> strandModel;
   girder->get_StrandModel(&strandModel);
   CComQIPtr<IStrandGridModel> strandGridModel(strandModel);

   StrandIndexType nextNum;
   HRESULT hr = m_StrandFillers[segmentKey].GetPreviousNumberOfTemporaryStrands(strandGridModel, curNum, &nextNum);
   ATLASSERT(SUCCEEDED(hr));

   return nextNum;
}

StrandIndexType CBridgeAgentImp::GetPrevNumTempStrands(LPCTSTR strGirderName,StrandIndexType curNum) const
{
   GET_IFACE(ILibrary,pLib);
   const GirderLibraryEntry* pGdrEntry = pLib->GetGirderEntry(strGirderName);

   CStrandFiller strandFiller;
   strandFiller.Init(pGdrEntry);

   // The position of the strands in the strand grid doesn't matter
   // for this method. Just use dummy values.
   Float64 Hg = 0;

   CComPtr<IStrandGrid> startGrid, endGrid;
   startGrid.CoCreateInstance(CLSID_StrandGrid);
   endGrid.CoCreateInstance(CLSID_StrandGrid);
   pGdrEntry->ConfigureTemporaryStrandGrid(Hg,Hg,startGrid,endGrid);

   CComQIPtr<IStrandGridFiller> gridFiller(startGrid);

   StrandIndexType prevNum;
   strandFiller.GetPrevNumberOfTemporaryStrands(gridFiller,curNum,&prevNum);

   return prevNum;
}

Float64 CBridgeAgentImp::GetCutLocation(const pgsPointOfInterest& poi) const
{
   GET_IFACE(IBridge, pBridge);

   const CSegmentKey& segmentKey = poi.GetSegmentKey();

   Float64 dist_from_start_of_girder = poi.GetDistFromStart();

   Float64 start_brg_offset = pBridge->GetSegmentStartBearingOffset(segmentKey);
   Float64 start_end_size   = pBridge->GetSegmentStartEndDistance(segmentKey);
   Float64 dist_from_start_pier = dist_from_start_of_girder - start_end_size + start_brg_offset;

   return dist_from_start_pier;
}

void CBridgeAgentImp::GetSegmentShapeDirect(const pgsPointOfInterest& poi,IShape** ppShape) const
{
   // This gets the segment shape while bypassing bridge model validation
   // This method is used to get a segment shape during validation where calling into
   // the public facing methods causes recursion

   // The primary shape is in Bridge Section Coordinates
   CComPtr<ISection> section;

   const CSegmentKey& segmentKey = poi.GetSegmentKey();
   CComPtr<ISuperstructureMemberSegment> segment;
   GetSegment(segmentKey,&segment);

   SectionBias sectionBias = GetSectionBias(poi);
   Float64 Xs = poi.GetDistFromStart();
   segment->get_GirderShape(Xs,sectionBias,cstGirder,ppShape);
}

BarSize CBridgeAgentImp::GetBarSize(WBFL::Materials::Rebar::Size size) const
{
   switch(size)
   {
   case WBFL::Materials::Rebar::Size::bs3:  return bs3;
   case WBFL::Materials::Rebar::Size::bs4:  return bs4;
   case WBFL::Materials::Rebar::Size::bs5:  return bs5;
   case WBFL::Materials::Rebar::Size::bs6:  return bs6;
   case WBFL::Materials::Rebar::Size::bs7:  return bs7;
   case WBFL::Materials::Rebar::Size::bs8:  return bs8;
   case WBFL::Materials::Rebar::Size::bs9:  return bs9;
   case WBFL::Materials::Rebar::Size::bs10: return bs10;
   case WBFL::Materials::Rebar::Size::bs11: return bs11;
   case WBFL::Materials::Rebar::Size::bs14: return bs14;
   case WBFL::Materials::Rebar::Size::bs18: return bs18;
   default:
      ATLASSERT(false); // should not get here
   }
   
   ATLASSERT(false); // should not get here
   return bs3;
}

RebarGrade CBridgeAgentImp::GetRebarGrade(WBFL::Materials::Rebar::Grade grade) const
{
   RebarGrade matGrade;
   switch(grade)
   {
   case WBFL::Materials::Rebar::Grade40: matGrade = Grade40; break;
   case WBFL::Materials::Rebar::Grade::Grade60: matGrade = Grade60; break;
   case WBFL::Materials::Rebar::Grade75: matGrade = Grade75; break;
   case WBFL::Materials::Rebar::Grade80: matGrade = Grade80; break;
   case WBFL::Materials::Rebar::Grade100: matGrade = Grade100; break;
   default:
      ATLASSERT(false);
   }

#if defined _DEBUG
      if ( matGrade == Grade100 )
      {
         ATLASSERT(lrfdVersionMgr::SixthEditionWith2013Interims <= lrfdVersionMgr::GetVersion());
      }
#endif

   return matGrade;
}

MaterialSpec CBridgeAgentImp::GetRebarSpecification(WBFL::Materials::Rebar::Type type) const
{
   return (type == WBFL::Materials::Rebar::Type::A615 ? msA615 : (type == WBFL::Materials::Rebar::Type::A706 ? msA706 : msA1035));
}

Float64 CBridgeAgentImp::GetAsTensionSideOfGirder(const pgsPointOfInterest& poi,bool bDevAdjust,bool bTensionTop) const
{
   CComPtr<IRebarSection> rebar_section;
   GetRebars(poi,&rebar_section);

   CComPtr<IEnumRebarSectionItem> enum_items;
   rebar_section->get__EnumRebarSectionItem(&enum_items);

   Float64 half_depth_elevation = GetHalfElevation(poi); // y = 0 at top of girder... measured in Girder Section Coordinates

   Float64 As = 0;

   CComPtr<IRebarSectionItem> item;
   while ( enum_items->Next(1,&item,nullptr) != S_FALSE )
   {
      CComPtr<IRebar> rebar;
      item->get_Rebar(&rebar);

      Float64 as;
      rebar->get_NominalArea(&as);

      CComPtr<IPoint2d> location;
      item->get_Location(&location);

      Float64 y;
      location->get_Y(&y); // measured in Girder Section Coordinates

      // include bar if tension on top and y is greater than centerline or if
      // tension is not top (tension is bottom) and y is less than centerline
      bool bIncludeBar = ( (bTensionTop && half_depth_elevation < y) || (!bTensionTop && y <= half_depth_elevation) ) ? true : false;

      if ( bIncludeBar )
      {
         Float64 fra = 1.0;
         if ( bDevAdjust )
         {
            fra = GetDevLengthFactor(poi,item);
         }

         As += fra*as;
      }

      item.Release();
   }

   return As;
}

Float64 CBridgeAgentImp::GetApsInHalfDepth(const pgsPointOfInterest& poi,DevelopmentAdjustmentType devAdjust,bool bBottomHalf,const GDRCONFIG* pConfig) const
{
   VALIDATE( GIRDER );

   Float64 Aps = 0.0;
   if ( !IsOnSegment(poi) )
   {
      return Aps;
   }


   IntervalIndexType releaseIntervalIdx = GetPrestressReleaseInterval(poi.GetSegmentKey());
   Float64 Hg = GetHg(releaseIntervalIdx,poi);

   Float64 half_depth_elevation = GetHalfElevation(poi); // y=0 at top of girder... measured in Girder Section Coordinates
   half_depth_elevation += Hg; // now measured up from bottom of girder

   const CSegmentKey& segmentKey = poi.GetSegmentKey();

   CComPtr<IPrecastGirder> girder;
   GetGirder(segmentKey,&girder);

   CComPtr<IStrandModel> strandModel;
   girder->get_StrandModel(&strandModel);
   CComQIPtr<IStrandGridModel> strandGridModel(strandModel);

   Float64 dist_from_start = poi.GetDistFromStart();
   Float64 segment_length = GetSegmentLength(segmentKey);

   // Only use approximate bond method if poi is in mid-section of beam (within CSS's).
   Float64 min_dist_from_ends = Min(dist_from_start, segment_length - dist_from_start);
   bool use_approximate = (devAdjust == dlaApproximate && fabs(half_depth_elevation)*3.0 < min_dist_from_ends) ? true : false; // Factor here is balance between performance and accuracy.

   ////////////////////////////////
   // Straight strands
   ////////////////////////////////
   const auto* pStrand = GetStrandMaterial(segmentKey,pgsTypes::Straight);
   Float64 aps = pStrand->GetNominalArea();

   // Get straight strand locations
   CComPtr<IPoint2dCollection> strand_points;
   if( pConfig )
   {
      CIndexArrayWrapper strand_fill(pConfig->PrestressConfig.GetStrandFill(pgsTypes::Straight));
      strandGridModel->GetStrandPositionsEx(Straight,dist_from_start,&strand_fill,&strand_points);
   }
   else
   {
      strandModel->GetStrandPositions(Straight,dist_from_start,&strand_points);
   }

   StrandIndexType Ns;
   strand_points->get_Count(&Ns);

   StrandIndexType strandIdx;
   for(strandIdx = 0; strandIdx < Ns; strandIdx++)
   {
      CComPtr<IPoint2d> strand_point;
      strand_points->get_Item(strandIdx, &strand_point);

      Float64 y;
      strand_point->get_Y(&y); // measured in Girder Section Coordinates
      y += Hg; // now measured up from bottom

      // include bar if top half and y is greater than centerline or if
      // bottom half and y is less than centerline
      bool bIncludeStrand = ( (!bBottomHalf && half_depth_elevation < y) || (bBottomHalf && y <= half_depth_elevation) ) ? true : false;

      if ( bIncludeStrand )
      {
         Float64 debond_factor;
         if(devAdjust == dlaNone || use_approximate)
         {
            // Use mid-span development length details to approximate debond factor
            // determine minimum bonded length from poi
            Float64 bond_start, bond_end;
            bool bDebonded = IsStrandDebonded(segmentKey,strandIdx,pgsTypes::Straight,pConfig,&bond_start,&bond_end);

            if (devAdjust == dlaNone)
            {
               debond_factor = (bDebonded && !InRange(bond_start, dist_from_start, bond_end)) ? 0.0 : 1.0;
            }
            else
            {
               // For approximate development length adjustment, take development length information at mid span and use for entire girder
               // adjusted for distance to ends of strands
               PoiList vPoi;
               GetPointsOfInterest(segmentKey, POI_5L | POI_ERECTED_SEGMENT, &vPoi);
               ATLASSERT(vPoi.size() == 1);
               const pgsPointOfInterest& mid_span_poi = vPoi.front();
               ATLASSERT(mid_span_poi.IsMidSpan(POI_ERECTED_SEGMENT));

               GET_IFACE(IPretensionForce, pPSForce);
               const std::shared_ptr<pgsDevelopmentLength> pDevLength = pPSForce->GetDevelopmentLengthDetails(mid_span_poi, pgsTypes::Straight, false, pConfig);
               Float64 fps = pDevLength->GetFps();
               Float64 fpe = pDevLength->GetFpe();

               debond_factor = pPSForce->GetDevelopmentLengthAdjustment(poi, strandIdx, pgsTypes::Straight, fps, fpe, pConfig);
            }
         }
         else
         {
            // Full adjustment for development
            GET_IFACE(IPretensionForce,pPSForce);
            debond_factor = pPSForce->GetDevelopmentLengthAdjustment(poi,strandIdx,pgsTypes::Straight,false, pConfig);
         }

         Aps += debond_factor*aps;
      }
   }

   ////////////////////////////////
   // Harped strands
   ////////////////////////////////
   pStrand = GetStrandMaterial(segmentKey,pgsTypes::Harped);
   aps = pStrand->GetNominalArea();

   GET_IFACE(IStrandGeometry, pStrandGeom);
   StrandIndexType Nh = pStrandGeom->GetStrandCount(segmentKey,pgsTypes::Harped,pConfig);

   strand_points.Release();
   if(pConfig)
   {
      CIndexArrayWrapper strand_fill(pConfig->PrestressConfig.GetStrandFill(pgsTypes::Harped));
      // Use CStrandMoverSwapper to temporarily swap out girder's strand mover and harping offset limits
      //  for design
      IntervalIndexType releaseIntervalIdx = GetPrestressReleaseInterval(segmentKey);
      Float64 Hg = GetHg(releaseIntervalIdx,poi);

      GET_IFACE(IBridgeDescription,pIBridgeDesc);
      CStrandMoverSwapper swapper(segmentKey, Hg, pConfig->PrestressConfig, this, strandGridModel, pIBridgeDesc);
      strandGridModel->GetStrandPositionsEx(Harped, dist_from_start, &strand_fill, &strand_points);
   }
   else
   {
      strandModel->GetStrandPositions(Harped,dist_from_start,&strand_points);
   }

   StrandIndexType nstst; // reality test
   strand_points->get_Count(&nstst);
   ATLASSERT(nstst==Nh);

   for(strandIdx = 0; strandIdx < Nh; strandIdx++)
   {
      CComPtr<IPoint2d> strand_point;
      strand_points->get_Item(strandIdx, &strand_point);

      Float64 y;
      strand_point->get_Y(&y); // measured in Girder Section Coordinates
      y += Hg; // now measured up from bottom

      // include bar if top half and y is greater than centerline or if
      // bottom half and y is less than centerline
      bool bIncludeStrand = ( (!bBottomHalf && IsLT(half_depth_elevation,y)) || (bBottomHalf && IsLE(y,half_depth_elevation)) ) ? true : false;

      if ( bIncludeStrand )
      {
         Float64 debond_factor = 1.;
         bool use_one = use_approximate || devAdjust==dlaNone;
         if ( use_one )
         {
            debond_factor = 1.0;
         }
         else
         {
            GET_IFACE(IPretensionForce,pPSForce);
            debond_factor = pPSForce->GetDevelopmentLengthAdjustment(poi,strandIdx,pgsTypes::Harped,false,pConfig);
         }

         Aps += debond_factor*aps;
      }
   }

   return Aps;
}

Float64 CBridgeAgentImp::GetGirderAptTensionSide(const pgsPointOfInterest& poi,bool bTensionTop) const
{
   VALIDATE( GIRDER );

   Float64 Apt = 0.0;
   if ( !IsOnGirder(poi) )
   {
      return Apt;
   }

   Float64 half_depth_elevation = GetHalfElevation(poi); // y=0 at top of girder... measured in Girder Section Coordinates

   CGirderKey girderKey(poi.GetSegmentKey());

   const auto* pTendon = GetGirderTendonMaterial(girderKey);
   Float64 apt = pTendon->GetNominalArea();

   DuctIndexType nDucts = GetDuctCount(girderKey);
   for ( DuctIndexType ductIdx = 0; ductIdx < nDucts; ductIdx++ )
   {
      if (IsOnDuct(poi, ductIdx))
      {
         CComPtr<IPoint2d> point;
         GetGirderDuctPoint(poi, ductIdx, &point);

         IndexType nStrands = GetTendonStrandCount(girderKey, ductIdx);

         Float64 y;
         point->get_Y(&y);

         if ((bTensionTop && half_depth_elevation < y) || (!bTensionTop && y <= half_depth_elevation))
         {
            Apt += nStrands*apt;
         }
      }
   }

   return Apt;
}

Float64 CBridgeAgentImp::GetSegmentAptTensionSide(const pgsPointOfInterest& poi, bool bTensionTop) const
{
   VALIDATE(GIRDER);

   Float64 Apt = 0.0;
   if (!IsOnSegment(poi))
   {
      return Apt;
   }

   Float64 half_depth_elevation = GetHalfElevation(poi); // y=0 at top of girder... measured in Girder Section Coordinates

   const CSegmentKey segmentKey(poi.GetSegmentKey());

   const auto* pTendon = GetSegmentTendonMaterial(segmentKey);
   Float64 apt = pTendon->GetNominalArea();

   DuctIndexType nDucts = GetDuctCount(segmentKey);
   for (DuctIndexType ductIdx = 0; ductIdx < nDucts; ductIdx++)
   {
      if (IsOnDuct(poi))
      {
         CComPtr<IPoint2d> point;
         GetSegmentDuctPoint(poi, ductIdx, &point);

         IndexType nStrands = GetTendonStrandCount(segmentKey, ductIdx);

         Float64 y;
         point->get_Y(&y);

         if ((bTensionTop && half_depth_elevation < y) || (!bTensionTop && y <= half_depth_elevation))
         {
            Apt += nStrands*apt;
         }
      }
   }

   return Apt;
}

Float64 CBridgeAgentImp::GetAsDeckMats(const pgsPointOfInterest& poi,pgsTypes::DeckRebarBarType barType,pgsTypes::DeckRebarCategoryType barCategory,bool bTopMat,bool bBottomMat) const
{
   Float64 As, Yb;
   GetDeckMatData(poi,barType,barCategory,bTopMat,bBottomMat,true,&As,&Yb);
   return As;
}

Float64 CBridgeAgentImp::GetLocationDeckMats(const pgsPointOfInterest& poi,pgsTypes::DeckRebarBarType barType,pgsTypes::DeckRebarCategoryType barCategory,bool bTopMat,bool bBottomMat) const
{
   Float64 As, Yb;
   GetDeckMatData(poi,barType,barCategory,bTopMat,bBottomMat,true,&As,&Yb);
   return Yb;
}

void CBridgeAgentImp::GetDeckMatData(const pgsPointOfInterest& poi,pgsTypes::DeckRebarBarType barType,pgsTypes::DeckRebarCategoryType barCategory,bool bTopMat,bool bBottomMat,bool bAdjForDevLength,Float64* pAs,Float64* pYb) const
{
#pragma Reminder("UPDATE: this information should come from the generic bridge model")
   // The location of deck bars are available in the generic bridge model. They should be retreived
   // from that model instead of re-computed here.


   // Computes the area of the deck rebar mats and their location (cg) measured from the top of girder
   GET_IFACE(IBridgeDescription,pIBridgeDesc);
   const CBridgeDescription2* pBridgeDesc = pIBridgeDesc->GetBridgeDescription();
   const CDeckDescription2* pDeck = pBridgeDesc->GetDeckDescription();
   const CDeckRebarData& rebarData = pDeck->DeckRebarData;

   if ( IsNonstructuralDeck(pDeck->GetDeckType()) || // no deck, no deck rebar
        (pDeck->GetDeckType() == pgsTypes::sdtCompositeSIP && !bTopMat && bBottomMat) // SIP Panels and only want bottom rebar... no bottom rebar
       )
   {
      *pAs = 0;
      *pYb = 0;
      return;
   }

   Float64 tSlab = GetGrossSlabDepth(poi);

   // The reinforcing in this section is the amount of reinforcing within
   // the rebar section width. The rebar section width is the lessor of
   // the effective flange width and the tributary width.
   // Effective flange width can be greater than the tributary flange width
   // when the traffic barrier is structurally continuous and additional
   // width, based on barrier stiffness, is added to the effective flange width
   Float64 Weff = GetEffectiveFlangeWidth(poi);
   Float64 rebarSectionWidth = Weff;

   if ( lrfdVersionMgr::FourthEditionWith2008Interims <= lrfdVersionMgr::GetVersion() )
   {
      Float64 Wtrib = GetTributaryFlangeWidth(poi);
      rebarSectionWidth = Min(Weff,Wtrib);
   }

   Float64 topCover    = rebarData.TopCover;
   Float64 bottomCover = rebarData.BottomCover;

   //
   // full length reinforcement
   //
   const WBFL::Materials::Rebar* pBar = nullptr;
   Float64 As_Top    = 0;
   Float64 As_Bottom = 0;
   Float64 YbAs_Top    = 0;
   Float64 YbAs_Bottom = 0;

   // NOTE: The method used here to get the reinforcing steel area is different then what was used in V2.9.
   // It is an equally good method however it produces slightly different areas. The method used here
   // must exactly match the method used in WBFL::GenericBridge::CBridgeDeckRebarLayout::CreateRebarSection() or
   // the section properties used in time-step analysis will be messed up.
   //
   // It might be a good idea to use the generic bridge model to get the rebar instead of doing it here

   if ( barCategory == pgsTypes::drcPrimary || barCategory == pgsTypes::drcAll )
   {
      // top mat
      if ( bTopMat )
      {
         if ( (barType == pgsTypes::drbIndividual || barType == pgsTypes::drbAll) && rebarData.TopRebarSize != WBFL::Materials::Rebar::Size::bsNone )
         {
            pBar = lrfdRebarPool::GetInstance()->GetRebar( rebarData.TopRebarType, rebarData.TopRebarGrade, rebarData.TopRebarSize );
            Float64 db = pBar->GetNominalDimension();
            Float64 Yb = tSlab - topCover - db/2;

            IndexType nBars = 0;
            if (0 < rebarData.TopSpacing)
            {
               Float64 fnBars = rebarSectionWidth / rebarData.TopSpacing;
               nBars = (IndexType)::Round(fnBars); // round to nearest integer
            }

            Float64 As = nBars*pBar->GetNominalArea()/rebarSectionWidth;
            YbAs_Top += Yb*As;
            As_Top   += As;
         }

         if ( barType == pgsTypes::drbLumpSum || barType == pgsTypes::drbAll )
         {
            YbAs_Top += rebarData.TopLumpSum*(tSlab - topCover);
            As_Top   += rebarData.TopLumpSum;
         }
      }

      // bottom mat
      if ( bBottomMat && pDeck->GetDeckType() != pgsTypes::sdtCompositeSIP)
      {
         if ( (barType == pgsTypes::drbIndividual || barType == pgsTypes::drbAll) && rebarData.BottomRebarSize != WBFL::Materials::Rebar::Size::bsNone )
         {
            pBar = lrfdRebarPool::GetInstance()->GetRebar( rebarData.BottomRebarType, rebarData.BottomRebarGrade, rebarData.BottomRebarSize );
            Float64 db = pBar->GetNominalDimension();
            Float64 Yb = bottomCover + db/2;

            IndexType nBars = 0;
            if (0 < rebarData.BottomSpacing)
            {
               Float64 fnBars = rebarSectionWidth / rebarData.BottomSpacing;
               nBars = (IndexType)::Round(fnBars); // round to nearest integer
            }

            Float64 As = nBars*pBar->GetNominalArea()/rebarSectionWidth;
            YbAs_Bottom += Yb*As;
            As_Bottom   += As;
         }

         if ( barType == pgsTypes::drbLumpSum || barType == pgsTypes::drbAll )
         {
            YbAs_Bottom += bottomCover*rebarData.BottomLumpSum;
            As_Bottom   += rebarData.BottomLumpSum;
         }
      }
   }

   if ( barCategory == pgsTypes::drcSupplemental || barCategory == pgsTypes::drcAll )
   {
      //
      // negative moment reinforcement
      //

      Float64 station, offset;
      GetStationAndOffset(poi,&station,&offset);
      Float64 firstPierStation = GetPierStation(0);
      std::vector<CDeckRebarData::NegMomentRebarData>::const_iterator iter(rebarData.NegMomentRebar.begin());
      std::vector<CDeckRebarData::NegMomentRebarData>::const_iterator end(rebarData.NegMomentRebar.end());
      for ( ; iter != end; iter++ )
      {
         const CDeckRebarData::NegMomentRebarData& nmRebarData = *iter;

         Float64 pierStation = GetPierStation(nmRebarData.PierIdx);
         
         CComPtr<IAngle> objSkewAngle;
         GetPierSkew(nmRebarData.PierIdx,&objSkewAngle);
         Float64 skewAngle;
         objSkewAngle->get_Value(&skewAngle);

         Float64 stationAdjustment = offset*tan(skewAngle);

         Float64 start = pierStation - nmRebarData.LeftCutoff + stationAdjustment;
         Float64 end = start + (nmRebarData.LeftCutoff + nmRebarData.RightCutoff);
         if ( ::InRange(start,station,end) )
         {
            if ( (bTopMat    && (nmRebarData.Mat == CDeckRebarData::TopMat)) ||
                 (bBottomMat && (nmRebarData.Mat == CDeckRebarData::BottomMat) && pDeck->GetDeckType() != pgsTypes::sdtCompositeSIP) )
            {
               if ( (barType == pgsTypes::drbIndividual || barType == pgsTypes::drbAll) && nmRebarData.RebarSize != WBFL::Materials::Rebar::Size::bsNone )
               {
                  // Explicit rebar. Reduce area for development if needed.
                  pBar = lrfdRebarPool::GetInstance()->GetRebar( nmRebarData.RebarType, nmRebarData.RebarGrade, nmRebarData.RebarSize);

                  IndexType nBars = 0;
                  if (0 < nmRebarData.Spacing)
                  {
                     Float64 fnBars = rebarSectionWidth / nmRebarData.Spacing;
                     nBars = (IndexType)::Round(fnBars); // round to nearest integer
                  }

                  Float64 As = nBars*pBar->GetNominalArea()/rebarSectionWidth;
                  Float64 db = pBar->GetNominalDimension();

                  if ( bAdjForDevLength )
                  {
                     // Get development length of bar

                     // remove metric from bar name
                     std::_tstring barst(pBar->GetName());
                     std::size_t sit = barst.find(_T(" "));
                     if (sit != std::_tstring::npos)
                     {
                        barst.erase(sit, barst.size()-1);
                     }

                     WBFL::Materials::Rebar::Size size = lrfdRebarPool::GetBarSize(barst.c_str());
                     REBARDEVLENGTHDETAILS devdet = lrfdRebar::GetRebarDevelopmentLengthDetails(size, pBar->GetNominalArea(), 
                                                                                       pBar->GetNominalDimension(), pBar->GetYieldStrength(), 
                                                                                       (WBFL::Materials::ConcreteType)pDeck->Concrete.Type, pDeck->Concrete.Fc, 
                                                                                       pDeck->Concrete.bHasFct, pDeck->Concrete.Fct,pDeck->Concrete.StrengthDensity, false, false, true);
                     Float64 ld = devdet.ld;

                     Float64 left_bar_length = station - start; // distance from left end of bar to poi
                     Float64 right_bar_length = end - station; // distance from right end of bar to poi
                     Float64 bar_cutoff = Min(left_bar_length,right_bar_length); // cutoff length from POI

                     bar_cutoff = IsZero(bar_cutoff) ? 0 : bar_cutoff;

                     // Reduce As for development if needed
                     if (bar_cutoff < ld)
                     {
                        ATLASSERT(0 < ld);
                        As *= bar_cutoff / ld;
                     }
                  }

                  if (nmRebarData.Mat == CDeckRebarData::TopMat)
                  {
                     Float64 Yb = tSlab - topCover - db/2;
                     YbAs_Top += Yb*As;
                     As_Top += As;
                  }
                  else if ( nmRebarData.Mat == CDeckRebarData::BottomMat && pDeck->GetDeckType() != pgsTypes::sdtCompositeSIP)
                  {
                     Float64 Yb = bottomCover + db/2;
                     YbAs_Bottom += Yb*As;
                     As_Bottom += As;
                  }
               }

               // Lump sum bars are not adjusted for development
               if ( (barType == pgsTypes::drbLumpSum || barType == pgsTypes::drbAll) )
               {
                  if (nmRebarData.Mat == CDeckRebarData::TopMat)
                  {
                     Float64 Yb = tSlab - topCover;
                     YbAs_Top += Yb*nmRebarData.LumpSum;
                     As_Top   += nmRebarData.LumpSum;
                  }
                  else if ( nmRebarData.Mat == CDeckRebarData::BottomMat && pDeck->GetDeckType() != pgsTypes::sdtCompositeSIP)
                  {
                     YbAs_Bottom += bottomCover*nmRebarData.LumpSum;
                     As_Bottom   += nmRebarData.LumpSum;
                  }
               }
            }
         }
      }
   }

   Float64 As = As_Bottom + As_Top;
   *pAs = As*rebarSectionWidth;
   if (IsZero(As))
   {
      *pYb = 0;
   }
   else
   {
      // So far, we have measured the mat location (cg) from the bottom of the slab. Add in 
      // the haunch depth to get to the top of the girder
      GET_IFACE(ISectionProperties,pSectProps);
      pgsTypes::HaunchAnalysisSectionPropertiesType hatype = pSectProps->GetHaunchAnalysisSectionPropertiesType();
      Float64 haunch_depth = pSectProps->GetStructuralHaunchDepth(poi, hatype);

      *pYb = haunch_depth + (YbAs_Bottom + YbAs_Top) / As;
   }
}

void CBridgeAgentImp::GetShapeProperties(IntervalIndexType intervalIdx,const pgsPointOfInterest& poi,Float64 Ecgdr,IShapeProperties** ppShapeProps) const
{
   pgsTypes::SectionPropertyType sectPropType = GetSectionPropertiesType();
   GetShapeProperties(sectPropType,intervalIdx,poi,Ecgdr,ppShapeProps);
}

void CBridgeAgentImp::GetShapeProperties(pgsTypes::SectionPropertyType sectPropType,IntervalIndexType intervalIdx,const pgsPointOfInterest& poi,Float64 Ecgdr,IShapeProperties** ppShapeProps) const
{
   const auto& sprops = GetSectionProperties(intervalIdx, poi, sectPropType);
   CComPtr<ISection> section;

   // we are going to be changing the section, so make a clone so we don't mess up the original   
   sprops.Section->Clone(&section);
   IndexType gdr_idx = sprops.GirderShapeIndex;
   IndexType slab_idx = sprops.SlabShapeIndex;

   // Assuming section is a Composite section
   CComQIPtr<ICompositeSectionEx> cmpsection(section);
   CollectionIndexType nItems;
   cmpsection->get_Count(&nItems);

   if ( 0 < nItems )
   {
      CComPtr<ICompositeSectionItemEx> csi;
      cmpsection->get_Item(gdr_idx,&csi); // this should be the beam

      Float64 Ec;
      csi->get_Efg(&Ec);

      //ATLASSERT(!IsEqual(Ec, Ecgdr)); // why are we doing this is the young's modulus isn't different?

      //Update E for the girder
      csi->put_Efg(Ecgdr);

      // change background materials
      for ( CollectionIndexType i = 1; i < nItems; i++ )
      {
         csi.Release();
         cmpsection->get_Item(i,&csi);

         Float64 E;
         csi->get_Ebg(&E);
         if ( IsEqual(Ec,E) )
         {
            csi->put_Ebg(Ecgdr);
         }
      }
   }

   CComPtr<IElasticProperties> eprops;
   section->get_ElasticProperties(&eprops);

   eprops->TransformProperties(Ecgdr,ppShapeProps);
}

void CBridgeAgentImp::GetSlabEdgePoint(Float64 station, IDirection* direction,DirectionType side,pgsTypes::PlanCoordinateType pcType,IPoint2d** point) const
{
   VALIDATE(BRIDGE);

   HRESULT hr = m_BridgeGeometryTool->DeckEdgePoint(m_Bridge,station,direction,side,point);
   ATLASSERT(SUCCEEDED(hr));

   if ( pcType == pgsTypes::pcGlobal )
   {
      (*point)->Offset(m_DeltaX,m_DeltaY);
   }
}

void CBridgeAgentImp::GetSlabEdgePoint(Float64 station, IDirection* direction,DirectionType side,pgsTypes::PlanCoordinateType pcType,IPoint3d** point) const
{
   VALIDATE(BRIDGE);

   CComPtr<IPoint2d> pnt2d;
   GetSlabEdgePoint(station,direction,side,pcType,&pnt2d);

   Float64 x,y;
   pnt2d->Location(&x,&y);

   Float64 normal_station,offset;
   GetStationAndOffset(pcType,pnt2d,&normal_station,&offset);

   Float64 elev = GetElevation(normal_station,offset);

   CComPtr<IPoint3d> pnt3d;
   pnt3d.CoCreateInstance(CLSID_Point3d);
   pnt3d->Move(x,y,elev);

   (*point) = pnt3d;
   (*point)->AddRef();
}

void CBridgeAgentImp::GetCurbLinePoint(Float64 station, IDirection* direction,DirectionType side,pgsTypes::PlanCoordinateType pcType,IPoint2d** point) const
{
   VALIDATE(BRIDGE);

   HRESULT hr = m_BridgeGeometryTool->CurbLinePoint(m_Bridge,station,direction,side,point);
   ATLASSERT(SUCCEEDED(hr));

   if ( pcType == pgsTypes::pcGlobal )
   {
      (*point)->Offset(m_DeltaX,m_DeltaY);
   }
}

void CBridgeAgentImp::GetCurbLinePoint(Float64 station, IDirection* direction,DirectionType side,pgsTypes::PlanCoordinateType pcType,IPoint3d** point) const
{
   VALIDATE(BRIDGE);

   CComPtr<IPoint2d> pnt2d;
   GetCurbLinePoint(station,direction,side,pcType,&pnt2d);

   Float64 x,y;
   pnt2d->Location(&x,&y);

   Float64 normal_station,offset;
   GetStationAndOffset(pcType,pnt2d,&normal_station,&offset);

   Float64 elev = GetElevation(normal_station,offset);

   CComPtr<IPoint3d> pnt3d;
   pnt3d.CoCreateInstance(CLSID_Point3d);
   pnt3d->Move(x,y,elev);

   (*point) = pnt3d;
   (*point)->AddRef();
}

SegmentIndexType CBridgeAgentImp::GetSegmentIndex(const CSplicedGirderData* pGirder,Float64 Xb) const
{
   // convert distance from start of bridge to a station so it can be
   // compared with pier and temp support stations
   const CPierData2* pStartPier = pGirder->GetPier(pgsTypes::metStart);
   Float64 station = Xb + pStartPier->GetStation();

   SegmentIndexType nSegments = pGirder->GetSegmentCount();
   for ( SegmentIndexType segIdx = 0; segIdx < nSegments; segIdx++ )
   {
      const CPrecastSegmentData* pSegment = pGirder->GetSegment(segIdx);
      Float64 startStation,endStation;
      pSegment->GetStations(&startStation,&endStation);

      if ( ::InRange(startStation,station,endStation) )
      {
         return segIdx;
      }
   }

   return INVALID_INDEX;
}

SegmentIndexType CBridgeAgentImp::GetSegmentIndex(const CGirderKey& girderKey,ILine2d* pLine,IPoint2d** ppIntersection) const
{
   // Finds where a line intersections a girder line. Returns the index of the segment that is intersected
   // as well as the intersection point
   
   SegmentIndexType nSegments = GetSegmentCount(girderKey);
   for ( SegmentIndexType segIdx = 0; segIdx < nSegments; segIdx++ )
   {
      CComPtr<IGirderLine> girderLine;
      GetGirderLine(CSegmentKey(girderKey,segIdx),&girderLine);

      CComPtr<IPath> path;
      girderLine->get_Path(&path);

      CComPtr<IPoint2d> pntNearest;
      girderLine->get_EndPoint(etStart,&pntNearest);

      VARIANT_BOOL bProjectBack  = (segIdx == 0           ? VARIANT_TRUE : VARIANT_FALSE);
      VARIANT_BOOL bProjectAhead = (segIdx == nSegments-1 ? VARIANT_TRUE : VARIANT_FALSE);

      HRESULT hr = path->IntersectEx(pLine,pntNearest,bProjectBack,bProjectAhead,ppIntersection);
      if ( SUCCEEDED(hr) )
      {
         return segIdx;
      }
   }

   (*ppIntersection) = nullptr;
   return INVALID_INDEX;
}

SpanIndexType CBridgeAgentImp::GetSpanIndex(Float64 Xb) const
{
   if ( Xb < 0 )
   {
      return INVALID_INDEX;
   }

   GET_IFACE(IBridgeDescription,pIBridgeDesc);
   const CBridgeDescription2* pBridgeDesc = pIBridgeDesc->GetBridgeDescription();

   Float64 span_station = pBridgeDesc->GetPier(0)->GetStation() + Xb;

   PierIndexType nPiers = pBridgeDesc->GetPierCount();
   for ( PierIndexType pierIdx = 0; pierIdx < nPiers; pierIdx++ )
   {
      if ( span_station < pBridgeDesc->GetPier(pierIdx)->GetStation() )
      {
         return (SpanIndexType)(pierIdx-1);
      }
   }

   return INVALID_INDEX;
}

void CBridgeAgentImp::GetGirderLine(const CSegmentKey& segmentKey,IGirderLine** ppGirderLine) const
{
   VALIDATE(BRIDGE);
   CComPtr<ISuperstructureMemberSegment> segment;
   GetSegment(segmentKey,&segment);
   segment->get_GirderLine(ppGirderLine);
}

void CBridgeAgentImp::GetSegmentAtPier(PierIndexType pierIdx,const CGirderKey& girderKey,ISuperstructureMemberSegment** ppSegment) const
{
   CSegmentKey segmentKey( GetSegmentAtPier(pierIdx,girderKey) );
   ATLASSERT(segmentKey.groupIndex != INVALID_INDEX && segmentKey.girderIndex != INVALID_INDEX && segmentKey.segmentIndex != INVALID_INDEX);
   GetSegment(segmentKey,ppSegment);
}

void CBridgeAgentImp::GetTemporarySupportLine(SupportIndexType tsIdx,IPierLine** ppPierLine) const
{
   VALIDATE(BRIDGE);

   CComPtr<IBridgeGeometry> bridgeGeometry;
   m_Bridge->get_BridgeGeometry(&bridgeGeometry);

   PierIDType pierID = ::GetTempSupportLineID(tsIdx);

   bridgeGeometry->FindPierLine(pierID,ppPierLine);
}

void CBridgeAgentImp::GetPierLine(PierIndexType pierIdx,IPierLine** ppPierLine) const
{
   VALIDATE(BRIDGE);

   CComPtr<IBridgeGeometry> bridgeGeometry;
   m_Bridge->get_BridgeGeometry(&bridgeGeometry);

   PierIDType pierID = ::GetPierLineID(pierIdx);

   bridgeGeometry->FindPierLine(pierID,ppPierLine);
}

void CBridgeAgentImp::GetSupports(const CSegmentKey& segmentKey, IPierLine** ppStartLine, IPierLine** ppEndLine) const
{
   GET_IFACE(IBridgeDescription, pIBridgeDesc);
   const CPrecastSegmentData* pSegment = pIBridgeDesc->GetPrecastSegmentData(segmentKey);

   const CPierData2* pStartPier;
   const CPierData2* pEndPier;
   const CTemporarySupportData* pStartTS;
   const CTemporarySupportData* pEndTS;
   pSegment->GetSupport(pgsTypes::metStart, &pStartPier, &pStartTS);
   pSegment->GetSupport(pgsTypes::metEnd, &pEndPier, &pEndTS);

   if (pStartPier)
   {
      GetPierLine(pStartPier->GetIndex(), ppStartLine);
   }
   else
   {
      GetTemporarySupportLine(pStartTS->GetIndex(), ppStartLine);
   }

   if (pEndPier)
   {
      GetPierLine(pEndPier->GetIndex(), ppEndLine);
   }
   else
   {
      GetTemporarySupportLine(pEndTS->GetIndex(), ppEndLine);
   }
}

PierIndexType CBridgeAgentImp::GetGenericBridgePierIndex(const CSegmentKey& segmentKey,pgsTypes::MemberEndType endType) const
{
   // Returns the index of a pier object in the generic bridge model
   // The pier index can be for a regular pier or a temporary support
   // ONLY USE THIS PIER INDEX FOR ACCESSING PIER OBJECTS IN THE GENERIC BRIDGE MODEL (m_Bridge)
   CComPtr<IGirderLine> girderLine;
   GetGirderLine(segmentKey,&girderLine);

   CComPtr<IPierLine> pierLine;
   if ( endType == pgsTypes::metStart )
   {
      girderLine->get_StartPier(&pierLine);
   }
   else
   {
      girderLine->get_EndPier(&pierLine);
   }

   PierIndexType pierIdx;
   pierLine->get_Index(&pierIdx);
   return pierIdx;
}

void CBridgeAgentImp::GetGenericBridgePier(PierIndexType pierIdx,IBridgePier** ppPier) const
{
   // pierIdx is a permanent pier index
   VALIDATE(BRIDGE);
   PierIDType pierID = ::GetPierLineID(pierIdx); // generic bridge pier ID

   CComPtr<IPierCollection> piers;
   m_Bridge->get_Piers(&piers);

   CComPtr<IBridgeGeometry> bridgeGeometry;
   m_Bridge->get_BridgeGeometry(&bridgeGeometry);
   IndexType nPierLines;
   bridgeGeometry->get_PierLineCount(&nPierLines);
   for (IndexType pierLineIdx = 0; pierLineIdx < nPierLines; pierLineIdx++ )
   {
      CComPtr<IPierLine> pierLine;
      bridgeGeometry->GetPierLine(pierLineIdx,&pierLine);
      PierIDType pierLineID;
      pierLine->get_ID(&pierLineID);

      if ( pierID == pierLineID )
      {
         piers->get_Item(pierLineIdx,ppPier);
         return;
      }
   }

   ATLASSERT(false); // should never get here
}

const GirderLibraryEntry* CBridgeAgentImp::GetGirderLibraryEntry(const CGirderKey& girderKey) const
{
   GET_IFACE(IBridgeDescription,pIBridgeDesc);
   const CBridgeDescription2* pBridgeDesc = pIBridgeDesc->GetBridgeDescription();
   const CGirderGroupData* pGroup = pBridgeDesc->GetGirderGroup(girderKey.groupIndex);
   const CSplicedGirderData* pGirder = pGroup->GetGirder(girderKey.girderIndex);
   return pGirder->GetGirderLibraryEntry();
}

GroupIndexType CBridgeAgentImp::GetGirderGroupAtPier(PierIndexType pierIdx,pgsTypes::PierFaceType pierFace) const
{
   // returns the girder group index for the girder group touching the subject pier
   GET_IFACE(IBridgeDescription,pIBridgeDesc);
   const CBridgeDescription2* pBridgeDesc = pIBridgeDesc->GetBridgeDescription();

   // Get the pier
   const CPierData2* pPier = pBridgeDesc->GetPier(pierIdx);

   // Get the span on the side of the pier that goes with the specified pier face
   const CSpanData2* pSpan = nullptr;
   if ( pierFace == pgsTypes::Back )
   {
      pSpan = pPier->GetPrevSpan();
   }
   else
   {
      pSpan = pPier->GetNextSpan();
   }

   // get the girder group that contains this span
   const CGirderGroupData* pGroup = nullptr;
   if ( pSpan )
   {
      pGroup = pBridgeDesc->GetGirderGroup(pSpan);
   }

   // get the group index
   if ( pGroup )
   {
      return pGroup->GetIndex();
   }
   else
   {
      ATLASSERT(false); // should never get here
      return INVALID_INDEX;
   }
}

bool CBridgeAgentImp::CreateTendons(const CPrecastSegmentData* pSegment, ISuperstructureMemberSegment* pSSMbrSegment, ITendonCollection** ppTendons) const
{
   const CSegmentPTData* pPTData = &(pSegment->Tendons);
   DuctIndexType nDucts = pPTData->GetDuctCount();
   if (nDucts == 0)
   {
      return false;
   }

   const CTimelineManager* pTimelineMgr = pSegment->GetGirder()->GetGirderGroup()->GetBridgeDescription()->GetTimelineManager();

   CComPtr<ITendonCollection> tendons;
   tendons.CoCreateInstance(CLSID_TendonCollection);

   const CSegmentKey& segmentKey(pSegment->GetSegmentKey());

   for (DuctIndexType ductIdx = 0; ductIdx < nDucts; ductIdx++)
   {
      const auto* pDuctData = pPTData->GetDuct(ductIdx);
      CComPtr<ITendonCollection> webTendons;
      if (pDuctData->DuctGeometryType == CSegmentDuctData::Parabolic)
      {
         CreateParabolicTendon(segmentKey, ductIdx, pSSMbrSegment, pDuctData, &webTendons);
      }
      else
      {
         ATLASSERT(pDuctData->DuctGeometryType == CSegmentDuctData::Linear); // fired? is there a new duct type
         CreateLinearTendon(segmentKey, ductIdx, pSSMbrSegment, pDuctData, &webTendons);
      }

      // create tendon material
      IntervalIndexType stressTendonIntervalIdx = m_IntervalManager.GetStressSegmentTendonInterval(segmentKey);
      CComPtr<IPrestressingStrand> tendonMaterial;
      tendonMaterial.CoCreateInstance(CLSID_PrestressingStrand);
      tendonMaterial->put_Name(CComBSTR(pPTData->m_pStrand->GetName().c_str()));
      tendonMaterial->put_Grade((StrandGrade)pPTData->m_pStrand->GetGrade());
      tendonMaterial->put_Type((StrandMaterialType)pPTData->m_pStrand->GetType());
      tendonMaterial->put_Size((StrandSize)pPTData->m_pStrand->GetSize());

      // the tendons aren't part of the cross section when then are installed because
      // they are not yet grouted. assume the tendons are grouted into the section
      // in the interval that follows the interval when they are installed
      // that is why there is a +1 
      tendonMaterial->put_InstallationStage(stressTendonIntervalIdx + 1);

      DuctIndexType nTendons;
      webTendons->get_Count(&nTendons);
      ATLASSERT(nTendons != 0); // should equal number of webs
      for (DuctIndexType tendonIdx = 0; tendonIdx < nTendons; tendonIdx++)
      {
         CComPtr<ITendon> tendon;
         webTendons->get_Item(tendonIdx, &tendon);

         tendon->put_OutsideDiameter(pDuctData->pDuctLibEntry->GetOD());
         tendon->put_InsideDiameter(pDuctData->pDuctLibEntry->GetID());
         tendon->put_NominalDiameter(pDuctData->pDuctLibEntry->GetNominalDiameter());
         tendon->put_StrandCount(pDuctData->nStrands);
         tendon->putref_Material(tendonMaterial);

         tendon->put_JackingEnd((JackingEndType)pDuctData->JackingEnd);

   #pragma Reminder("UPDATE: need to model duct CG to strand CG offset")
         // need offset in X and Y direction as ducts can be 3D

         tendon->putref_SuperstructureMemberSegment(pSSMbrSegment);

         tendons->Add(tendon);
      }
   }

   tendons.CopyTo(ppTendons);

   return true;
}

void CBridgeAgentImp::CreateParabolicTendon(const CSegmentKey& segmentKey, DuctIndexType ductIdx, ISuperstructureMemberSegment* pSSMbrSegment, const CSegmentDuctData* pDuctGeometry, ITendonCollection** ppTendons) const
{
   ATLASSERT(pDuctGeometry->DuctGeometryType == CSegmentDuctData::Parabolic);

   CComPtr<ITendonCollection> tendons;
   tendons.CoCreateInstance(CLSID_TendonCollection);

   // since we are in the process of validating the bridge model, we have to
   // dig into the segment object to get the number of webs
   Float64 Xs = 0;
   CComPtr<IShape> shape;
   pSSMbrSegment->get_GirderShape(Xs, sbRight, cstGirder, &shape);

   CComQIPtr<IGirderSection> section(shape);
   WebIndexType nWebs;
   section->get_WebCount(&nWebs);

   Float64 Ls;
   pSSMbrSegment->get_Length(&Ls);

   for (WebIndexType webIdx = 0; webIdx < nWebs; webIdx++)
   {
      CComPtr<ITendon> tendon;
      tendon.CoCreateInstance(CLSID_Tendon);
      tendons->Add(tendon);

      // distance along segment 
      Float64 z1 = 0;
      Float64 z2 = Ls / 2;
      Float64 z3 = Ls;

      Float64 y1 = ConvertSegmentDuctOffsetToDuctElevation(segmentKey, nullptr, z1, pDuctGeometry->DuctPoint[CSegmentDuctData::Left].first, pDuctGeometry->DuctPoint[CSegmentDuctData::Left].second);
      Float64 y2 = ConvertSegmentDuctOffsetToDuctElevation(segmentKey, nullptr, z2, pDuctGeometry->DuctPoint[CSegmentDuctData::Middle].first, pDuctGeometry->DuctPoint[CSegmentDuctData::Middle].second);
      Float64 y3 = ConvertSegmentDuctOffsetToDuctElevation(segmentKey, nullptr, z3, pDuctGeometry->DuctPoint[CSegmentDuctData::Right].first, pDuctGeometry->DuctPoint[CSegmentDuctData::Right].second);

      // locate the tendon horizontally in the girder cross section
      CComPtr<IPlane3d> webPlane;
      section->get_WebPlane(webIdx, &webPlane);

      Float64 x1, x2, x3;
      webPlane->GetX(y1, z1, &x1);
      webPlane->GetX(y2, z2, &x2);
      webPlane->GetX(y3, z3, &x3);

      // create a tendon segment for left half of parabola
      CComPtr<IParabolicTendonSegment> parabolicTendonSegment;
      parabolicTendonSegment.CoCreateInstance(CLSID_ParabolicTendonSegment);

      CComPtr<IPoint3d> pntStart;
      CComPtr<IPoint3d> pntEnd;

      pntStart.CoCreateInstance(CLSID_Point3d);
      pntStart->Move(x1, y1, z1);

      pntEnd.CoCreateInstance(CLSID_Point3d);
      pntEnd->Move(x2, y2, z2);

      ATLASSERT(z1 < z2);
      parabolicTendonSegment->put_Start(pntStart);
      parabolicTendonSegment->put_End(pntEnd);
      parabolicTendonSegment->put_Slope(0.0);
      parabolicTendonSegment->put_SlopeEnd(qcbRight);
      tendon->AddSegment(parabolicTendonSegment);

      // create a tendon segment for right half of parabola
      parabolicTendonSegment.Release();
      parabolicTendonSegment.CoCreateInstance(CLSID_ParabolicTendonSegment);

      pntStart = pntEnd;
      pntEnd.Release();
      pntEnd.CoCreateInstance(CLSID_Point3d);
      pntEnd->Move(x3, y3, z3);

      ATLASSERT(z2 < z3);
      parabolicTendonSegment->put_Start(pntStart);
      parabolicTendonSegment->put_End(pntEnd);
      parabolicTendonSegment->put_Slope(0.0);
      parabolicTendonSegment->put_SlopeEnd(qcbLeft);
      tendon->AddSegment(parabolicTendonSegment);
   } // next web

   tendons.CopyTo(ppTendons);
}

void CBridgeAgentImp::CreateLinearTendon(const CSegmentKey& segmentKey, DuctIndexType ductIdx, ISuperstructureMemberSegment* pSSMbrSegment, const CSegmentDuctData* pDuctGeometry, ITendonCollection** ppTendons) const
{
   ATLASSERT(pDuctGeometry->DuctGeometryType == CSegmentDuctData::Linear);
   CComPtr<ITendonCollection> tendons;
   tendons.CoCreateInstance(CLSID_TendonCollection);

   // since we are in the process of validating the bridge model, we have to
   // dig into the segment object to get the number of webs
   Float64 Xs = 0;
   CComPtr<IShape> shape;
   pSSMbrSegment->get_GirderShape(Xs, sbRight, cstGirder, &shape);

   CComQIPtr<IGirderSection> section(shape);
   WebIndexType nWebs;
   section->get_WebCount(&nWebs);

   Float64 Ls;
   pSSMbrSegment->get_Length(&Ls);

   for (WebIndexType webIdx = 0; webIdx < nWebs; webIdx++)
   {
      CComPtr<ITendon> tendon;
      tendon.CoCreateInstance(CLSID_Tendon);
      tendons->Add(tendon);

      // distance along segment 
      Float64 z1 = 0;
      Float64 z2 = Ls;

      Float64 y1 = ConvertSegmentDuctOffsetToDuctElevation(segmentKey, nullptr, z1, pDuctGeometry->DuctPoint[CSegmentDuctData::Left].first, pDuctGeometry->DuctPoint[CSegmentDuctData::Left].second);
      Float64 y2 = ConvertSegmentDuctOffsetToDuctElevation(segmentKey, nullptr, z2, pDuctGeometry->DuctPoint[CSegmentDuctData::Right].first, pDuctGeometry->DuctPoint[CSegmentDuctData::Right].second);

      // locate the tendon horizontally in the girder cross section
      CComPtr<IPlane3d> webPlane;
      section->get_WebPlane(webIdx, &webPlane);

      Float64 x1, x2;
      webPlane->GetX(y1, z1, &x1);
      webPlane->GetX(y2, z2, &x2);

      // create a tendon segment 
      CComPtr<IPoint3d> pntStart;
      CComPtr<IPoint3d> pntEnd;

      pntStart.CoCreateInstance(CLSID_Point3d);
      pntStart->Move(x1, y1, z1);

      pntEnd.CoCreateInstance(CLSID_Point3d);
      pntEnd->Move(x2, y2, z2);

      ATLASSERT(z1 < z2);
      CComPtr<ILinearTendonSegment> linearTendonSegment;
      linearTendonSegment.CoCreateInstance(CLSID_LinearTendonSegment);
      linearTendonSegment->put_Start(pntStart);
      linearTendonSegment->put_End(pntEnd);

      CComQIPtr<ITendonSegment> tendonSegment(linearTendonSegment);
      tendon->AddSegment(tendonSegment);
   } // next web

   tendons.CopyTo(ppTendons);
}

bool CBridgeAgentImp::CreateTendons(const CBridgeDescription2* pBridgeDesc,const CGirderKey& girderKey,ISuperstructureMember* pSSMbr,ITendonCollection** ppTendons) const
{
   const CGirderGroupData* pGroup = pBridgeDesc->GetGirderGroup(girderKey.groupIndex);
   const CSplicedGirderData* pGirder = pGroup->GetGirder(girderKey.girderIndex);
   const CPTData* pPTData = pGirder->GetPostTensioning();
   DuctIndexType nDucts = pPTData->GetDuctCount();

   if (nDucts == 0)
   {
      return false; // nothing created
   }

   const auto* pStrand = pPTData->pStrand;

   GirderIDType gdrID = pGirder->GetID();

   const CTimelineManager* pTimelineMgr = pBridgeDesc->GetTimelineManager();

   CComPtr<ITendonCollection> tendons;
   tendons.CoCreateInstance(CLSID_TendonCollection);
   for ( DuctIndexType ductIdx = 0; ductIdx < nDucts; ductIdx++ )
   {
      const CDuctData* pDuctData = pPTData->GetDuct(ductIdx);
      CComPtr<ITendonCollection> webTendons;

      switch (pDuctData->DuctGeometryType)
      {
      case CDuctGeometry::Parabolic:
         CreateParabolicTendon(girderKey,ductIdx,pSSMbr,pDuctData->ParabolicDuctGeometry,&webTendons);
         break;

      case CDuctGeometry::Linear:
         CreateLinearTendon(girderKey, ductIdx, pSSMbr,pDuctData->LinearDuctGeometry,&webTendons);
         break;

      case CDuctGeometry::Offset:
         CreateOffsetTendon(girderKey, ductIdx, pSSMbr,pDuctData->OffsetDuctGeometry,tendons,&webTendons);
         break;
      }

      // create tendon material
      std::vector<IntervalIndexType> vTendonStressingIntervals = m_IntervalManager.GetGirderTendonStressingIntervals(girderKey);
      std::map<IntervalIndexType,CComPtr<IPrestressingStrand>> tendonMaterials;
      for (const auto& stressTendonIntervalIdx : vTendonStressingIntervals)
      {
         CComPtr<IPrestressingStrand> tendonMaterial;
         tendonMaterial.CoCreateInstance(CLSID_PrestressingStrand);
         tendonMaterial->put_Name(CComBSTR(pStrand->GetName().c_str()));
         tendonMaterial->put_Grade((StrandGrade)pStrand->GetGrade());
         tendonMaterial->put_Type((StrandMaterialType)pStrand->GetType());
         tendonMaterial->put_Size((StrandSize)pStrand->GetSize());

         // the tendons aren't part of the cross section when then are installed because
         // they are not yet grouted. assume the tendons are grouted into the section
         // in the interval that follows the interval when they are installed
         // that is why there is a +1 
         tendonMaterial->put_InstallationStage(stressTendonIntervalIdx+1);

         tendonMaterials.emplace_hint(tendonMaterials.end(),stressTendonIntervalIdx, tendonMaterial);
      }

      DuctIndexType nTendons;
      webTendons->get_Count(&nTendons);
      ATLASSERT(nTendons != 0); // should equal number of webs
      for (DuctIndexType tendonIdx = 0; tendonIdx < nTendons; tendonIdx++)
      {
         IntervalIndexType stressTendonIntervalIdx = m_IntervalManager.GetStressGirderTendonInterval(girderKey,nTendons*ductIdx+tendonIdx);
         auto found = tendonMaterials.find(stressTendonIntervalIdx);
         ATLASSERT(found != tendonMaterials.end());

         CComPtr<IPrestressingStrand> tendonMaterial(found->second);

         CComPtr<ITendon> tendon;
         webTendons->get_Item(tendonIdx,&tendon);

         tendon->put_OutsideDiameter( pDuctData->pDuctLibEntry->GetOD() );
         tendon->put_InsideDiameter( pDuctData->pDuctLibEntry->GetID() );
         tendon->put_NominalDiameter(pDuctData->pDuctLibEntry->GetNominalDiameter());
         tendon->put_StrandCount(pDuctData->nStrands);
         tendon->putref_Material(tendonMaterial);

         tendon->put_JackingEnd( (JackingEndType)pDuctData->JackingEnd );

#pragma Reminder("UPDATE: need to model duct CG to strand CG offset")
         // need offset in X and Y direction as ducts can be 3D

         tendon->putref_SuperstructureMember(pSSMbr);

         tendons->Add(tendon);
      }
   } // next duct

   tendons.CopyTo(ppTendons);

   return true;
}

void CBridgeAgentImp::CreateParabolicTendon(const CGirderKey& girderKey, DuctIndexType ductIdx, ISuperstructureMember* pSSMbr,const CParabolicDuctGeometry& ductGeometry,ITendonCollection** ppTendons) const
{
   CComPtr<ITendonCollection> tendons;
   tendons.CoCreateInstance(CLSID_TendonCollection);

   PierIndexType startPierIdx, endPierIdx;
   ductGeometry.GetRange(&startPierIdx, &endPierIdx);
   SpanIndexType startSpanIdx = (SpanIndexType)startPierIdx;
   SpanIndexType endSpanIdx   = (SpanIndexType)(endPierIdx-1);

   SpanIndexType startGroupSpanIdx, endGroupSpanIdx;
   GetGirderGroupSpans(girderKey.groupIndex, &startGroupSpanIdx, &endGroupSpanIdx);

   // x = left/right position in the girder cross section
   // y = elevation in the girder cross section (0 is at the top of the girder, positive is up so expect all values to be negative)
   // z = distance along girder (in Girder Coordinates)

   SegmentIndexType nSegments;
   pSSMbr->get_SegmentCount(&nSegments);

   CComPtr<ISuperstructureMemberSegment> segment;
   pSSMbr->get_Segment(0,&segment);

   // since we are in the process of validating the bridge model, we have to
   // dig into the segment object to get the number of webs
   Float64 Xs = 0.0;
   CComPtr<IShape> shape;
   segment->get_GirderShape(Xs,sbRight,cstGirder,&shape);

   CComQIPtr<IGirderSection> section(shape);
   WebIndexType nWebs;
   section->get_WebCount(&nWebs);

   for ( WebIndexType webIdx = 0; webIdx < nWebs; webIdx++ )
   {
      Float64 Ls = 0;

      CComPtr<ITendon> tendon;
      tendon.CoCreateInstance(CLSID_Tendon);

      tendons->Add(tendon);

      Float64 x1 = 0;
      Float64 z1 = 0;

      // if the tendon begins in a span other than the first span in the group,
      // advance the z to the actual start of the tendon in girder coordinates
      for (SpanIndexType spanIdx = startGroupSpanIdx; spanIdx < startSpanIdx; spanIdx++)
      {
         Float64 L = GetSpanLength(spanIdx, girderKey.girderIndex); // advance by span length

         if (spanIdx == 0)
         {
	         // if this is the first span, span length is measured from CL Brg
            // we need to adjust for the end distance at the start of the girder
	         Float64 end_dist = GetSegmentStartEndDistance(CSegmentKey(girderKey.groupIndex, girderKey.girderIndex, 0));
	         L += end_dist;
         }

         Ls += L;
         z1 += L;
	  }

      if (startSpanIdx != startGroupSpanIdx && startPierIdx != 0)
      {
         // the tendon is starting relative to an interior pier. the tendon starts at the
         // face of the precast segment, not the CL Pier.
         // adjust the start location of the segment
         //
         // --------------------+       +--------------------------
         //                     |       |
         //                     |       |
         // --------------------+       +--------------------------
         //                         |<->|--- brg_offset - end_dist
         //                             |<-- tendon starts here
         //
         // Segment index will be INVALID_INDEX if the segment is continuous over the pier.... which which case, 
         // we don't make the end size adjustment

         CSegmentKey backSegmentKey, aheadSegmentKey;
         GetSegmentsAtPier(startPierIdx, girderKey.girderIndex, &backSegmentKey, &aheadSegmentKey);
         Float64 brg_offset = (backSegmentKey.segmentIndex == INVALID_INDEX ? 0 : GetSegmentStartBearingOffset(aheadSegmentKey));
         Float64 end_dist = (aheadSegmentKey.segmentIndex == INVALID_INDEX ? 0 : GetSegmentStartEndDistance(aheadSegmentKey));
         Ls += (brg_offset - end_dist);
         z1 += (brg_offset - end_dist);
      }

      //
      // Start point to first low point
      //

      // start point
      PierIndexType pierIdx;
      Float64 dist,offset;
      CDuctGeometry::OffsetType offsetType;
      ductGeometry.GetStartPoint(&pierIdx,&dist,&offset,&offsetType);

      if (dist < 0)
      {
         // fractional measure
         Float64 L = GetSpanLength(startSpanIdx, girderKey.girderIndex);

         // adjust for the end distance at the start of the girder
         if (startSpanIdx == 0)
         {
	         Float64 end_dist = GetSegmentStartEndDistance(CSegmentKey(girderKey.groupIndex, girderKey.girderIndex, 0));
	         L += end_dist;
         }

         if (startSpanIdx == endSpanIdx && endSpanIdx == endGroupSpanIdx)
         {
            // there is only one span for this tendon and the tendon ends at the end of the group
            // adjust for the end distance at the end of the girder
            Float64 end_dist = GetSegmentEndEndDistance(CSegmentKey(girderKey.groupIndex, girderKey.girderIndex, nSegments - 1));
            L += end_dist;
         }

         // get the start of the girder to low point distance
         dist *= -L;
      }

      z1 += dist;
      Float64 y1 = ConvertDuctOffsetToDuctElevation(girderKey,nullptr,z1,offset,offsetType);

      // Low Point
      ductGeometry.GetLowPoint(startSpanIdx,&dist,&offset,&offsetType);

      // dist is measured from the left end of the girder
      if ( dist < 0 ) // fraction of the distance between start and high point at first interior pier
      {
         Float64 L = GetSpanLength(startSpanIdx,girderKey.girderIndex);

         // adjust for the end distance at the start of the girder
         if (startSpanIdx == 0)
         {
	         Float64 end_dist = GetSegmentStartEndDistance(CSegmentKey(girderKey.groupIndex, girderKey.girderIndex, 0));
	         L += end_dist;
         }

         if (startSpanIdx == endSpanIdx && endSpanIdx == endGroupSpanIdx)
         {
            // there is only one span for this tendon and the tendon ends at the end of the group
            // adjust for the end distance at the end of the girder
            Float64 end_dist = GetSegmentEndEndDistance(CSegmentKey(girderKey.groupIndex,girderKey.girderIndex,nSegments-1));
            L += end_dist;
         }

         // get the start of girder to low point distance
         dist *= -L;
      }

      Float64 x2 = x1; // dummy (x1 and x2 are computed from the web plane below)
      Float64 z2 = z1 + dist; // this is the location of the low point

      if (IsLE(z2, z1))
      {
         GET_IFACE(IEAFStatusCenter, pStatusCenter);
         CString strMsg;
         strMsg.Format(_T("%s, Span %s, Duct %d: Start to Low segment is invalid. Correct duct definition."), LABEL_GIRDER(girderKey), LABEL_SPAN(startSpanIdx), LABEL_DUCT(ductIdx));
         std::unique_ptr<pgsGirderDescriptionStatusItem> pStatusItem = std::make_unique<pgsGirderDescriptionStatusItem>(CSegmentKey(girderKey, ALL_SEGMENTS), 0, m_StatusGroupID, m_scidGirderDescriptionError, strMsg);
         pStatusCenter->Add(pStatusItem.release());

         break; // get the heck outta here
      }

      ATLASSERT(z1 < z2);

      Float64 y2 = ConvertDuctOffsetToDuctElevation(girderKey,nullptr,z2,offset,offsetType);

      // locate the tendon horizontally in the girder cross section
      CComPtr<IPlane3d> webPlane;
      section->get_WebPlane(webIdx,&webPlane);

      webPlane->GetX(y1,z1,&x1);
      webPlane->GetX(y2,z2,&x2);

      // create a tendon segment
      CComPtr<IParabolicTendonSegment> parabolicTendonSegment;
      parabolicTendonSegment.CoCreateInstance(CLSID_ParabolicTendonSegment);

      CComPtr<IPoint3d> pntStart;
      CComPtr<IPoint3d> pntEnd;

      pntStart.CoCreateInstance(CLSID_Point3d);
      pntStart->Move(x1,y1,z1);

      pntEnd.CoCreateInstance(CLSID_Point3d);
      pntEnd->Move(x2,y2,z2);

      parabolicTendonSegment->put_Start(pntStart);
      parabolicTendonSegment->put_End(pntEnd);
      parabolicTendonSegment->put_Slope(0.0);
      parabolicTendonSegment->put_SlopeEnd(qcbRight);
      tendon->AddSegment(parabolicTendonSegment);

      // x1,y1,z1 become coordinates at the low point
      x1 = x2;
      y1 = y2;
      z1 = z2;

      //
      // Low Point to High Point to Low Point
      //
      Float64 x3, y3, z3;
      for ( PierIndexType pierIdx = startPierIdx+1; pierIdx < endPierIdx; pierIdx++ )
      {
         SpanIndexType prevSpanIdx = SpanIndexType(pierIdx-1);
         SpanIndexType nextSpanIdx = prevSpanIdx+1;

         Float64 distLeftIP, highOffset, distRightIP;
         CDuctGeometry::OffsetType highOffsetType;
         ductGeometry.GetHighPoint(pierIdx,&distLeftIP,&highOffset,&highOffsetType,&distRightIP);

         // low to inflection point
         Float64 L = GetSpanLength(prevSpanIdx,girderKey.girderIndex);
         if ( prevSpanIdx == startSpanIdx )
         {
            // adjust for the end distance at the start of the girder
            Float64 end_dist = GetSegmentStartEndDistance(CSegmentKey(girderKey.groupIndex,girderKey.girderIndex,0));
            L += end_dist;
         }
         Ls += L;

         x3 = x2; // dummy
         z3 = Ls;
         y3 = ConvertDuctOffsetToDuctElevation(girderKey,nullptr,z3,highOffset,highOffsetType);

         if ( distLeftIP < 0 ) // fraction of distance between low and high point
         {
            distLeftIP *= -(z3-z1);
         }

         z2 = z3 - distLeftIP; // inflection point measured from high point... want z2 measured from start of span

         if (IsLE(z2, z1))
         {
            GET_IFACE(IEAFStatusCenter, pStatusCenter);
            CString strMsg;
            strMsg.Format(_T("%s, Span %s, Duct %d: Low to IP segment is invalid. Correct duct definition."), LABEL_GIRDER(girderKey), LABEL_SPAN(prevSpanIdx), LABEL_DUCT(ductIdx));
            std::unique_ptr<pgsGirderDescriptionStatusItem> pStatusItem = std::make_unique<pgsGirderDescriptionStatusItem>(CSegmentKey(girderKey, ALL_SEGMENTS), 0, m_StatusGroupID, m_scidGirderDescriptionError, strMsg);
            pStatusCenter->Add(pStatusItem.release());

            break; // get the heck outta here
         }

         ATLASSERT(z1 < z2);

         // elevation at inflection point (slope at low and high points must be zero)
         Float64 y2 = (y3*(z2-z1) + y1*(z3-z2))/(z3-z1);

         webPlane->GetX(y2,z2,&x2);
         webPlane->GetX(y3,z3,&x3);

         CComPtr<IParabolicTendonSegment> leftParabolicTendonSegment;
         leftParabolicTendonSegment.CoCreateInstance(CLSID_ParabolicTendonSegment);

         CComPtr<IPoint3d> pntStart;
         pntStart.CoCreateInstance(CLSID_Point3d);
         pntStart->Move(x1,y1,z1);

         CComPtr<IPoint3d> pntInflection;
         pntInflection.CoCreateInstance(CLSID_Point3d);
         pntInflection->Move(x2,y2,z2);
         leftParabolicTendonSegment->put_Start(pntStart);
         leftParabolicTendonSegment->put_End(pntInflection);
         leftParabolicTendonSegment->put_Slope(0.0);
         leftParabolicTendonSegment->put_SlopeEnd(qcbLeft);
         tendon->AddSegment(leftParabolicTendonSegment);

         // inflection to high point
         CComPtr<IParabolicTendonSegment> rightParabolicTendonSegment;
         rightParabolicTendonSegment.CoCreateInstance(CLSID_ParabolicTendonSegment);

         CComPtr<IPoint3d> pntEnd;
         pntEnd.CoCreateInstance(CLSID_Point3d);
         pntEnd->Move(x3,y3,z3);


         if (IsLE(z3, z2))
         {
            GET_IFACE(IEAFStatusCenter, pStatusCenter);
            CString strMsg;
            strMsg.Format(_T("%s, Span %s, Duct %d: IP to High segment is invalid. Correct duct definition."), LABEL_GIRDER(girderKey), LABEL_SPAN(prevSpanIdx), LABEL_DUCT(ductIdx));
            std::unique_ptr<pgsGirderDescriptionStatusItem> pStatusItem = std::make_unique<pgsGirderDescriptionStatusItem>(CSegmentKey(girderKey, ALL_SEGMENTS), 0, m_StatusGroupID, m_scidGirderDescriptionError, strMsg);
            pStatusCenter->Add(pStatusItem.release());

            break; // get the heck outta here
         }
         ATLASSERT(z2 < z3);

         rightParabolicTendonSegment->put_Start(pntInflection);
         rightParabolicTendonSegment->put_End(pntEnd);
         rightParabolicTendonSegment->put_Slope(0.0);
         rightParabolicTendonSegment->put_SlopeEnd(qcbRight);
         tendon->AddSegment(rightParabolicTendonSegment);

         // high to inflection point
         ductGeometry.GetLowPoint(pierIdx,&dist,&offset,&offsetType);
         x1 = x3;
         z1 = z3; 
         y1 = y3;

         L = GetSpanLength(nextSpanIdx,girderKey.girderIndex);
         if ( nextSpanIdx == endSpanIdx )
         {
            // adjust for the end distance at the end of the girder
            Float64 end_dist = GetSegmentEndEndDistance(CSegmentKey(girderKey.groupIndex,girderKey.girderIndex,nSegments-1));
            L += end_dist;
         }

         if ( dist < 0 ) // fraction of span length
         {
            dist *= -L;
         }

         if ( nextSpanIdx == endSpanIdx )
         {
            // for the last span, low point is measured from right end... make it 
            // measured from the left end
            dist = L - dist;
         }

         z3 = z1 + dist; // low point, measured from previous high point
         y3 = ConvertDuctOffsetToDuctElevation(girderKey,nullptr,z3,offset,offsetType);

         if ( distRightIP < 0 ) // fraction of distance between high and low point
         {
            distRightIP *= -(z3 - z1);
         }

         z2 = z1 + distRightIP; // inflection point measured from high point

         if (IsLE(z2, z1))
         {
            GET_IFACE(IEAFStatusCenter, pStatusCenter);
            CString strMsg;
            strMsg.Format(_T("%s, Span %s, Duct %d: High to IP segment is invalid. Correct duct definition."), LABEL_GIRDER(girderKey), LABEL_SPAN(nextSpanIdx), LABEL_DUCT(ductIdx));
            std::unique_ptr<pgsGirderDescriptionStatusItem> pStatusItem = std::make_unique<pgsGirderDescriptionStatusItem>(CSegmentKey(girderKey, ALL_SEGMENTS), 0, m_StatusGroupID, m_scidGirderDescriptionError, strMsg);
            pStatusCenter->Add(pStatusItem.release());

            break; // get the heck outta here
         }

         ATLASSERT(z1 < z2);

         y2 = (y3*(z2-z1) + y1*(z3-z2))/(z3-z1);

         webPlane->GetX(y2,z2,&x2);
         webPlane->GetX(y3,z3,&x3);

         leftParabolicTendonSegment.Release();
         leftParabolicTendonSegment.CoCreateInstance(CLSID_ParabolicTendonSegment);

         pntStart.Release();
         pntStart.CoCreateInstance(CLSID_Point3d);
         pntStart->Move(x1,y1,z1);

         pntInflection.Release();
         pntInflection.CoCreateInstance(CLSID_Point3d);
         pntInflection->Move(x2,y2,z2);

         leftParabolicTendonSegment->put_Start(pntStart);
         leftParabolicTendonSegment->put_End(pntInflection);
         leftParabolicTendonSegment->put_Slope(0.0);
         leftParabolicTendonSegment->put_SlopeEnd(qcbLeft);
         tendon->AddSegment(leftParabolicTendonSegment);

         // inflection point to low point

         if (IsLE(z3, z2))
         {
            GET_IFACE(IEAFStatusCenter, pStatusCenter);
            CString strMsg;
            strMsg.Format(_T("%s, Span %s, Duct %d: IP to Low segment is invalid. Correct duct definition."), LABEL_GIRDER(girderKey), LABEL_SPAN(nextSpanIdx), LABEL_DUCT(ductIdx));
            std::unique_ptr<pgsGirderDescriptionStatusItem> pStatusItem = std::make_unique<pgsGirderDescriptionStatusItem>(CSegmentKey(girderKey, ALL_SEGMENTS), 0, m_StatusGroupID, m_scidGirderDescriptionError, strMsg);
            pStatusCenter->Add(pStatusItem.release());

            break; // get the heck outta here
         }

         ATLASSERT(z2 < z3);

         rightParabolicTendonSegment.Release();
         rightParabolicTendonSegment.CoCreateInstance(CLSID_ParabolicTendonSegment);

         pntEnd.Release();
         pntEnd.CoCreateInstance(CLSID_Point3d);
         pntEnd->Move(x3,y3,z3);

         rightParabolicTendonSegment->put_Start(pntInflection);
         rightParabolicTendonSegment->put_End(pntEnd);
         rightParabolicTendonSegment->put_Slope(0.0);
         rightParabolicTendonSegment->put_SlopeEnd(qcbRight);
         tendon->AddSegment(rightParabolicTendonSegment);

         z1 = z3;
         y1 = y3;
         x1 = x3;
      }

      //
      // last low point to end
      //

      // distance is measured from the right end of the girder
      ductGeometry.GetEndPoint(&pierIdx,&dist,&offset,&offsetType);
      if ( dist < 0 ) // fraction of last span length
      {
         // get the cl-brg to cl-brg length for this girder in the end span
         Float64 L = GetSpanLength(endSpanIdx,girderKey.girderIndex);

         // adjust for the end distance at the end of the girder
         Float64 end_dist = GetSegmentEndEndDistance(CSegmentKey(girderKey.groupIndex,girderKey.girderIndex,nSegments-1));
         L += end_dist;

         if (startSpanIdx == endSpanIdx && endSpanIdx == endGroupSpanIdx)
         {
            // there is only one span for this tendon and the tendon ends at the end of the group
            // adjust for the end distance at the end of the girder
            end_dist = GetSegmentEndEndDistance(CSegmentKey(girderKey.groupIndex,girderKey.girderIndex,0));
            L += end_dist;
         }

         dist *= -L;
      }

      // work backwards from the right end of the girder to the previous low point
      Float64 Lg = GetGirderLength(girderKey); // End-to-end length of full girder

      if (endSpanIdx < endGroupSpanIdx)
      {
         // if the tendon ends before the end of the girder, adjust for the end distance at the right end of the girder
	      Float64 end_dist = GetSegmentEndEndDistance(CSegmentKey(girderKey.groupIndex, girderKey.girderIndex, nSegments - 1));
	      Lg -= end_dist;
      }

      // remove the span length of all the spans at the right end of the girder that are after the end of the tendon
      for (SpanIndexType spanIdx = endSpanIdx+1; spanIdx <= endGroupSpanIdx; spanIdx++)
      {
         Float64 L = GetSpanLength(spanIdx, girderKey.girderIndex);
         Lg -= L;
      }

      PierIndexType endGroupPierIdx = (PierIndexType)(endGroupSpanIdx - 1);
      if (endSpanIdx != endGroupSpanIdx && endPierIdx != endGroupPierIdx)
      {
         // the tendon is ending relative to an interior pier. the tendon ends at the
         // face of the precast segment, not the CL Pier.
         // adjust the end location of the segment
         //
         // --------------------+       +--------------------------
         //                     |       |
         //                     |       |
         // --------------------+       +--------------------------
         //                     |<->|--- brg_offset - end_dist
         //                     |<-- tendon ends here

         // Segment index will be INVALID_INDEX if the segment is continuous over the pier.... which which case, 
         // we don't make the end size adjustment

         CSegmentKey backSegmentKey, aheadSegmentKey;
         GetSegmentsAtPier(endPierIdx, girderKey.girderIndex, &backSegmentKey, &aheadSegmentKey);
         Float64 brg_offset = (backSegmentKey.segmentIndex == INVALID_INDEX ? 0 : GetSegmentEndBearingOffset(backSegmentKey));
         Float64 end_dist = (aheadSegmentKey.segmentIndex == INVALID_INDEX ? 0 : GetSegmentEndEndDistance(backSegmentKey));
         Lg -= (brg_offset - end_dist);
      }

      x2 = x1; // dummy
      z2 = Lg - dist; // dist is measured from the end of the bridge

      if (IsLE(z2, z1))
      {
         GET_IFACE(IEAFStatusCenter, pStatusCenter);
         CString strMsg;
         strMsg.Format(_T("%s, Span %s, Duct %d: Low to End segment is invalid. Correct duct definition."), LABEL_GIRDER(girderKey), LABEL_SPAN(endSpanIdx), LABEL_DUCT(ductIdx));
         std::unique_ptr<pgsGirderDescriptionStatusItem> pStatusItem = std::make_unique<pgsGirderDescriptionStatusItem>(CSegmentKey(girderKey, ALL_SEGMENTS), 0, m_StatusGroupID, m_scidGirderDescriptionError, strMsg);
         pStatusCenter->Add(pStatusItem.release());

         break; // get the heck outta here
      }

      ATLASSERT(z1 < z2);

      y2 = ConvertDuctOffsetToDuctElevation(girderKey,nullptr,z2,offset,offsetType);

      webPlane->GetX(y1,z1,&x1);
      webPlane->GetX(y2,z2,&x2);

      parabolicTendonSegment.Release();
      parabolicTendonSegment.CoCreateInstance(CLSID_ParabolicTendonSegment);

      pntStart.Release();
      pntStart.CoCreateInstance(CLSID_Point3d);
      pntStart->Move(x1,y1,z1);

      pntEnd.Release();
      pntEnd.CoCreateInstance(CLSID_Point3d);
      pntEnd->Move(x2,y2,z2);

      parabolicTendonSegment->put_Start(pntStart);
      parabolicTendonSegment->put_End(pntEnd);
      parabolicTendonSegment->put_Slope(0.0);
      parabolicTendonSegment->put_SlopeEnd(qcbLeft);
      tendon->AddSegment(parabolicTendonSegment);
   } // next web

   tendons.CopyTo(ppTendons);
}

void CBridgeAgentImp::CreateLinearTendon(const CGirderKey& girderKey, DuctIndexType ductIdx, ISuperstructureMember* pSSMbr,const CLinearDuctGeometry& ductGeometry,ITendonCollection** ppTendons) const
{
   CComPtr<ITendonCollection> tendons;
   tendons.CoCreateInstance(CLSID_TendonCollection);

   CComPtr<ISuperstructureMemberSegment> segment;
   pSSMbr->get_Segment(0,&segment);

   CComPtr<IShape> shape;
   segment->get_GirderShape(0,sbRight,cstGirder,&shape);

   Float64 Lg = GetGirderLength(girderKey);

   CComQIPtr<IGirderSection> section(shape);
   WebIndexType nWebs;
   section->get_WebCount(&nWebs);

   for ( WebIndexType webIdx = 0; webIdx < nWebs; webIdx++ )
   {
      CComPtr<ITendon> tendon;
      tendon.CoCreateInstance(CLSID_Tendon);

      tendons->Add(tendon);

      Float64 xStart = 0; // horizontal position in Girder Section Coordinates (distance from CL girder)
      Float64 zStart = 0; // distance along girder (Girder Coordinate System... same as Xg)
      Float64 offset;
      CDuctGeometry::OffsetType offsetType;
      ductGeometry.GetPoint(0,&zStart,&offset,&offsetType);

      if (zStart < 0 )
      {
         // fractional measure
         zStart *= -Lg;
      }

      // vertical position in Girder Section Coordinates (distance from top of girder)
      Float64 yStart = ConvertDuctOffsetToDuctElevation(girderKey,nullptr,zStart,offset,offsetType);

      // get the location of the web plane in Girder Section Coordinates
      // this is the horizontal position of the web plane measured from the CL of girder
      CComPtr<IPlane3d> webPlane;
      section->get_WebPlane(webIdx,&webPlane);

      webPlane->GetX(yStart,zStart,&xStart);

      CLinearDuctGeometry::MeasurementType measurementType = ductGeometry.GetMeasurementType();

      CComPtr<ILinearTendonSegment> prevSegment;

      CollectionIndexType nPoints = ductGeometry.GetPointCount();
      ATLASSERT( 2 <= nPoints );
      for ( CollectionIndexType pointIdx = 1; pointIdx < nPoints; pointIdx++ )
      {
         Float64 location;
         ductGeometry.GetPoint(pointIdx,&location,&offset,&offsetType);

         // coordinates at end of girder
         Float64 xEnd = xStart; // assume web is constant distance away from CL Girder
         Float64 zEnd; // Xg at end. see below
         if ( measurementType == CLinearDuctGeometry::AlongGirder )
         {
            if ( location < 0 )
            {
               location *= -Lg;
            }

            zEnd = location;
         }
         else
         {
            // location is distance from previous point
            zEnd = zStart + location;
         }

         if (Lg < zEnd)
         {
            GET_IFACE(IEAFStatusCenter, pStatusCenter);
            CString strMsg;
            strMsg.Format(_T("%s, Duct %d: Point %d is beyond the end of the girder. This point has been ignored. Correct duct definition."),LABEL_GIRDER(girderKey),LABEL_DUCT(ductIdx),LABEL_INDEX(pointIdx));
            std::unique_ptr<pgsGirderDescriptionStatusItem> pStatusItem = std::make_unique<pgsGirderDescriptionStatusItem>(CSegmentKey(girderKey,ALL_SEGMENTS), 0, m_StatusGroupID, m_scidGirderDescriptionWarning, strMsg);
            pStatusCenter->Add(pStatusItem.release());
            continue; // skip to next point
         }

         Float64 yEnd = ConvertDuctOffsetToDuctElevation(girderKey,nullptr,zEnd,offset,offsetType);

         CComPtr<IPoint3d> pntStart;
         pntStart.CoCreateInstance(CLSID_Point3d);
         pntStart->Move(xStart,yStart,zStart);

         CComPtr<IPoint3d> pntEnd;
         pntEnd.CoCreateInstance(CLSID_Point3d);
         pntEnd->Move(xEnd,yEnd,zEnd);

         CComPtr<ILinearTendonSegment> linearTendonSegment;
         linearTendonSegment.CoCreateInstance(CLSID_LinearTendonSegment);
         linearTendonSegment->put_Start(pntStart);
         linearTendonSegment->put_End(pntEnd);

         CComQIPtr<ITendonSegment> tendonSegment(linearTendonSegment);
         tendon->AddSegment(tendonSegment);

         linearTendonSegment->putref_PrevTendonSegment(prevSegment);
         if ( prevSegment )
         {
            prevSegment->putref_NextTendonSegment(tendonSegment);
         }

         // start of next segment is end of this segment
         xStart = xEnd;
         yStart = yEnd;
         zStart = zEnd;

         prevSegment = tendonSegment;
      }
   }

   tendons.CopyTo(ppTendons);
}

void CBridgeAgentImp::CreateOffsetTendon(const CGirderKey& girderKey, DuctIndexType ductIdx, ISuperstructureMember* pSSMbr,const COffsetDuctGeometry& ductGeometry,ITendonCollection* refTendons,ITendonCollection** ppTendons) const
{
   ATLASSERT(false); // this option isn't fully supported so it should be called.
   CComPtr<ITendonCollection> tendons;
   tendons.CoCreateInstance(CLSID_TendonCollection);

   GET_IFACE(IBridgeDescription,pIBridgeDesc);
   const CBridgeDescription2* pBridgeDesc = pIBridgeDesc->GetBridgeDescription();
   const CGirderGroupData*    pGroup      = pBridgeDesc->GetGirderGroup(girderKey.groupIndex);
   const CSplicedGirderData*  pGirder     = pGroup->GetGirder(girderKey.girderIndex);
   const CPTData*             pPTData     = pGirder->GetPostTensioning();

   CComPtr<ISuperstructureMemberSegment> segment;
   pSSMbr->get_Segment(0,&segment);

   CComPtr<IShape> shape;
   segment->get_GirderShape(0,sbRight,cstGirder,&shape);

   CComQIPtr<IGirderSection> section(shape);
   WebIndexType nWebs;
   section->get_WebCount(&nWebs);

   for ( WebIndexType webIdx = 0; webIdx < nWebs; webIdx++ )
   {
      CComPtr<IOffsetTendon> offsetTendon;
      offsetTendon.CoCreateInstance(CLSID_OffsetTendon);

      CComPtr<IPlane3d> webPlane;
      section->get_WebPlane(webIdx,&webPlane);

      tendons->Add(offsetTendon);

      CComPtr<ITendon> refTendon;
      refTendons->get_Item(ductGeometry.RefDuctIdx+webIdx,&refTendon);
      offsetTendon->putref_RefTendon(refTendon);

      Float64 z = 0;
      std::vector<COffsetDuctGeometry::Point>::const_iterator iter( ductGeometry.Points.begin() );
      std::vector<COffsetDuctGeometry::Point>::const_iterator iterEnd( ductGeometry.Points.end() );
      for ( ; iter != iterEnd; iter++ )
      {
         const COffsetDuctGeometry::Point& point = *iter;
         z += point.distance;

         CComPtr<IPoint3d> refPoint;
         refTendon->get_CG(z,tmPath,&refPoint);

         Float64 x;
         Float64 y;
         refPoint->get_X(&x);
         refPoint->get_Y(&y);
         y += point.offset;

         Float64 x_offset;
         webPlane->GetX(y,z,&x_offset);
         offsetTendon->AddOffset(z,x_offset-x,point.offset);
      }
   }

   tendons.CopyTo(ppTendons);
}

void CBridgeAgentImp::CreateOverlayDeckEdgePaths(const CBridgeDescription2* pBridgeDesc,IPath** ppLeftPath,IPath** ppRightPath)
{
   CComPtr<IPath> left_path, right_path;
   left_path.CoCreateInstance(CLSID_Path);
   right_path.CoCreateInstance(CLSID_Path);

   // Build  path along exterior girders
   GroupIndexType nGroups = pBridgeDesc->GetGirderGroupCount();
   for ( GroupIndexType grpIdx = 0; grpIdx < nGroups; grpIdx++ )
   {
      GirderIndexType nGirders = pBridgeDesc->GetGirderGroup(grpIdx)->GetGirderCount();
      SegmentIndexType nSegments = pBridgeDesc->GetGirderGroup(grpIdx)->GetGirder(0)->GetSegmentCount();
      for ( SegmentIndexType segIdx = 0; segIdx < nSegments; segIdx++ )
      {
         CComPtr<IPoint2d> point_on_edge1;
         CComPtr<IPoint2d> point_on_edge2;
         CComPtr<IPoint2d> point_on_edge3;
         CComPtr<IPoint2d> point_on_edge4;

         // left edge - start of segment
         NoDeckEdgePoint(grpIdx,segIdx,pgsTypes::metStart,qcbLeft,&point_on_edge1);

         // left edge - end of segment
         NoDeckEdgePoint(grpIdx,segIdx,pgsTypes::metEnd,qcbLeft,&point_on_edge2);

         // right edge - start of segment
         NoDeckEdgePoint(grpIdx,segIdx,pgsTypes::metStart,qcbRight,&point_on_edge3);

         // right edge - end of segment
         NoDeckEdgePoint(grpIdx,segIdx,pgsTypes::metEnd,qcbRight,&point_on_edge4);

         CComPtr<IPathSegment> left_segment, right_segment;
         left_segment.CoCreateInstance(CLSID_PathSegment);
         right_segment.CoCreateInstance(CLSID_PathSegment);

         left_segment->ThroughPoints(point_on_edge1, point_on_edge2);
         right_segment->ThroughPoints(point_on_edge3, point_on_edge4);

         CComQIPtr<IPathElement> left_element(left_segment);
         CComQIPtr<IPathElement> right_element(right_segment);

         left_path->Add(left_element);
         right_path->Add(right_element);
      } // next segment
   } // next group

   left_path.CopyTo(ppLeftPath);
   right_path.CopyTo(ppRightPath);
}

/// Strand filler-related functions
CContinuousStrandFiller* CBridgeAgentImp::GetContinuousStrandFiller(const CSegmentKey& segmentKey) const
{
   StrandFillerCollection::iterator its = m_StrandFillers.find(segmentKey);
   if (its != m_StrandFillers.end())
   {
      CStrandFiller& pcfill = its->second;
      CContinuousStrandFiller* pfiller = dynamic_cast<CContinuousStrandFiller*>(&(pcfill));
      return pfiller;
   }
   else
   {
      ATLASSERT(false); // This will go badly. Filler should have been created already
      return nullptr;
   }
}

CDirectStrandFiller* CBridgeAgentImp::GetDirectStrandFiller(const CSegmentKey& segmentKey) const
{
   StrandFillerCollection::iterator its = m_StrandFillers.find(segmentKey);
   if (its != m_StrandFillers.end())
   {
      CStrandFiller& pcfill = its->second;
      CDirectStrandFiller* pfiller = dynamic_cast<CDirectStrandFiller*>(&(pcfill));
      return pfiller;
   }
   else
   {
      ATLASSERT(false); // This will go badly. Filler should have been created already
      return nullptr;
   }
}

void CBridgeAgentImp::InitializeStrandFiller(const GirderLibraryEntry* pGirderEntry, const CSegmentKey& segmentKey) const
{
   StrandFillerCollection::iterator its = m_StrandFillers.find(segmentKey);
   if (its != m_StrandFillers.end())
   {
      its->second.Init(pGirderEntry);
   }
   else
   {
      CStrandFiller filler;
      filler.Init(pGirderEntry);
      std::pair<StrandFillerCollection::iterator, bool>  sit = m_StrandFillers.insert(std::make_pair(segmentKey,filler));
      ATLASSERT(sit.second);
   }
}

void CBridgeAgentImp::CreateStrandMover(LPCTSTR strGirderName,Float64 Hg,pgsTypes::AdjustableStrandType adjType,IStrandMover** ppStrandMover) const
{
   GET_IFACE(ILibrary,pLib);
   const GirderLibraryEntry* pGirderEntry = pLib->GetGirderEntry(strGirderName);

   // get adjustable strand adjustment limits
   pgsTypes::FaceType endTopFace, endBottomFace;
   Float64 endTopLimit, endBottomLimit;
   IBeamFactory::BeamFace etf, ebf;
   IBeamFactory::BeamFace htf, hbf;
   pgsTypes::FaceType hpTopFace, hpBottomFace;
   Float64 hpTopLimit, hpBottomLimit;
   Float64 end_increment, hp_increment;

   if (adjType == pgsTypes::asHarped)
   {
      pGirderEntry->GetEndAdjustmentLimits(&endTopFace, &endTopLimit, &endBottomFace, &endBottomLimit);

      etf = endTopFace    == pgsTypes::BottomFace ? IBeamFactory::BeamBottom : IBeamFactory::BeamTop;
      ebf = endBottomFace == pgsTypes::BottomFace ? IBeamFactory::BeamBottom : IBeamFactory::BeamTop;

      pGirderEntry->GetHPAdjustmentLimits(&hpTopFace, &hpTopLimit, &hpBottomFace, &hpBottomLimit);

      htf = hpTopFace    == pgsTypes::BottomFace ? IBeamFactory::BeamBottom : IBeamFactory::BeamTop;
      hbf = hpBottomFace == pgsTypes::BottomFace ? IBeamFactory::BeamBottom : IBeamFactory::BeamTop;

      // only allow end adjustents if increment is non-negative
      end_increment = pGirderEntry->IsVerticalAdjustmentAllowedEnd() ?  pGirderEntry->GetEndStrandIncrement() : -1.0;
      hp_increment  = pGirderEntry->IsVerticalAdjustmentAllowedHP()  ?  pGirderEntry->GetHPStrandIncrement()  : -1.0;
   }
   else
   {
      ATLASSERT(adjType == pgsTypes::asStraight); // Should be only other option

      // Straight strands - ends and harp points are the same
      pGirderEntry->GetStraightAdjustmentLimits(&endTopFace, &endTopLimit, &endBottomFace, &endBottomLimit);

      hpTopLimit = endTopLimit;
      hpBottomLimit = endBottomLimit;

      etf = endTopFace    == pgsTypes::BottomFace ? IBeamFactory::BeamBottom : IBeamFactory::BeamTop;
      ebf = endBottomFace == pgsTypes::BottomFace ? IBeamFactory::BeamBottom : IBeamFactory::BeamTop;

      htf = etf;
      hbf = ebf;

      // only allow end adjustents if increment is non-negative
      end_increment = pGirderEntry->IsVerticalAdjustmentAllowedStraight() ?  pGirderEntry->GetStraightStrandIncrement() : -1.0;
      hp_increment  = end_increment;
   }

   // create the strand mover
   CComPtr<IBeamFactory> beamFactory;
   pGirderEntry->GetBeamFactory(&beamFactory);
   beamFactory->CreateStrandMover(pGirderEntry->GetDimensions(), Hg, 
                                  etf, endTopLimit, ebf, endBottomLimit, 
                                  htf, hpTopLimit,  hbf, hpBottomLimit, 
                                  end_increment, hp_increment, ppStrandMover);

   ATLASSERT(*ppStrandMover != nullptr);
}

INCREMENTALRELAXATIONDETAILS CBridgeAgentImp::GetIncrementalRelaxationDetails(Float64 fpi,const WBFL::Materials::PsStrand* pStrand,Float64 tStart,Float64 tEnd,Float64 tStress) const
{
   GET_IFACE(ILossParameters,pLossParameters);
#if defined _DEBUG
   ATLASSERT(pLossParameters->GetLossMethod() == pgsTypes::TIME_STEP);
#endif

   INCREMENTALRELAXATIONDETAILS details;

   WBFL::Materials::PsStrand::Type strandType = pStrand->GetType();
   Float64 fpy = pStrand->GetYieldStrength();
   Float64 fpu = pStrand->GetUltimateStrength();

   details.fpi = fpi;
   details.fpy = fpy;
   details.fpu = fpu;
   details.tStart = tStart - tStress;
   details.tEnd = tEnd - tStress;

   // This method computes the incremental strand relaxation during the time period tStart-tEnd
   // with the stress in the strand fpi at the beginning of the interval

   details.fr = 0;
   pgsTypes::TimeDependentModel model = pLossParameters->GetTimeDependentModel();
   if ( model == pgsTypes::tdmACI209 || model == pgsTypes::tdmAASHTO )
   {
      Float64 initial_stress_ratio = fpi/fpy;
      if ( tStart-tStress < 1./24. )
      {
         // don't want log10 to be less than zero (see "Recommendations for Estimating Prestress Losses",
         // PCI Journal July-August 1975, pg 51)
         tStart = tStress + 1./24.; 
      }

      if ( tEnd-tStress < 1./24. )
      {
         // don't want log10 to be less than zero (see "Recommendations for Estimating Prestress Losses",
         // PCI Journal July-August 1975, pg 51)
         tEnd = tStress + 1./24.; 
      }

      if ( initial_stress_ratio <= 0.55 )
      {
         details.fr = 0;
      }
      else
      {
         Float64 K = (strandType == WBFL::Materials::PsStrand::Type::LowRelaxation ? 0.0222 : 0.1);
         details.K = K;
         details.fr = K*fpi*(initial_stress_ratio - 0.55)*(log10(24*(tEnd-tStress)) - log10(24*(tStart-tStress))); // t is in days
      }
   }
   else if ( model == pgsTypes::tdmCEBFIP )
   {
      Float64 initial_stress_ratio = fpi/fpu; // See CEB-FIP Figure 2.3.3
      Float64 p; // relaxation ratio
      Float64 k;
      if ( strandType == WBFL::Materials::PsStrand::Type::StressRelieved )
      {
         // curve fit for Class 1 curve from CEB-FIP Figure 2.3.3
         p = 0.4*initial_stress_ratio + 0.2;
         k = 0.12;
      }
      else
      {
         // curve fit for Class 2 curve from CEB-FIP Figure 2.3.3
         p = initial_stress_ratio*initial_stress_ratio - 1.2*initial_stress_ratio + 0.37;
         k = 0.19;
      }
      details.p = p;
      details.k = k;

      // Assume ultimate relaxation to occur at 50 years
      // CEB-FIP 2.3.4.5, relxation at 50 years = 3 times relaxation at day 1000
      // Relaxation rate = 1/3 1000 hour relaxation
      p /= 3;

      Float64 t1 = tStart - tStress;
      Float64 t2 = tEnd   - tStress;
      details.fr = fpi*p*(pow(24*t2/1000,k) - pow(24*t1/1000,k)); // Equation in CEB-FEB commentary for 2.3.4.5
   }
   else
   {
      ATLASSERT(false); // is there a new type?
   }

   details.epoxyFactor = 1.0;
   if ( pStrand->GetCoating() != WBFL::Materials::PsStrand::Coating::None )
   {
      // strand is epoxy coated... double the relaxation
      // see PCI "Guidelines for the use of Epoxy-Coated Strand", PCI Journal, July-August 1993
      details.epoxyFactor = 2.0;
   }
   details.fr *= -details.epoxyFactor; // using a "-" because a negative value represents a reduction in the prestress force

   return details;
}

bool CBridgeAgentImp::GirderLineIntersect(const CGirderKey& girderKey,ILine2d* pLine,SegmentIndexType segIdxHint,SegmentIndexType* pSegIdx,Float64* pXs) const
{
   ASSERT_GIRDER_KEY(girderKey);
   // First try the hint... if it is right, we are done fast
   CSegmentKey segmentKey(girderKey,segIdxHint);
   if ( SegmentLineIntersect(segmentKey,pLine,pXs) )
   {
      *pSegIdx = segIdxHint;
      return true;
   }

   // work our way out from the hint segment
   // Let's say there are 10 segments and the hint is for segment index = 6
   // we want to try set 5, 7, 4, 8, 3, 9, 2, 1, 0... don't want to try 6 because
   // we already did... working out from the hint alternating sides
   SegmentIndexType nSegments = GetSegmentCount(girderKey);
   std::vector<SegmentIndexType> segments;
   segments.reserve(nSegments-1);

   SegmentIndexType e1 = segIdxHint;
   SegmentIndexType e2 = nSegments-1-segIdxHint;
   SegmentIndexType end = segIdxHint == 0 ? nSegments-1 : Max(e1,e2);
   for (SegmentIndexType i = 1; i <= end; i++ )
   {
      if ( i <= e1 )
      {
         segments.push_back(segIdxHint-i);
      }

      if ( i <= e2 )
      {
         segments.push_back(segIdxHint+i);
      }
   }

   for( const auto& segIdx : segments)
   {
      CSegmentKey segmentKey(girderKey,segIdx);
      if ( SegmentLineIntersect(segmentKey,pLine,pXs) )
      {
         *pSegIdx = segIdx;
         return true;
      }
   }

   return false;
}

bool CBridgeAgentImp::SegmentLineIntersect(const CSegmentKey& segmentKey,ILine2d* pLine,Float64* pXs) const
{
   ASSERT_SEGMENT_KEY(segmentKey);

   VALIDATE(BRIDGE); // the C4309 warning is because of the line number

   CComPtr<IGirderLine> girderLine;
   GetGirderLine(segmentKey,&girderLine);

   CComPtr<IPath> path;
   girderLine->get_Path(&path);

   CComPtr<IPoint2d> pntStartOfSegment;
   girderLine->get_EndPoint(etStart,&pntStartOfSegment);

   CComPtr<IPoint2d> pnt;
   HRESULT hr = path->IntersectEx(pLine,pntStartOfSegment,VARIANT_FALSE,VARIANT_FALSE,&pnt);
   if ( FAILED(hr) )
   {
      return false;
   }

   pntStartOfSegment->DistanceEx(pnt,pXs);

   return true;
}

void CBridgeAgentImp::ComputeHpFill(const GirderLibraryEntry* pGdrEntry,IStrandGridFiller* pStrandGridFiller, IIndexArray* pFill, IIndexArray** ppHPfill) const
{
   // Fill for harped strands at harping points can be different than at girder ends
   // if the odd number of strands option is activated
   if ( pGdrEntry->OddNumberOfHarpedStrands() )
   {
      StrandIndexType nStrands;
      pStrandGridFiller->GetStrandCountEx(pFill, &nStrands);

      if (1 < nStrands && nStrands%2 != 0) // if there is more than 1 harped strand and the number of strands is odd
      {
         // we allow, and have, an odd number of strands.

         // we are in business, start alternate fill of hp grid
         CComPtr<IIndexArray> oddHpFill;
         oddHpFill.CoCreateInstance(CLSID_IndexArray);
         CollectionIndexType fill_size;
         pFill->get_Count(&fill_size);
         oddHpFill->Reserve(fill_size);

         // put two strands in the first hp location
#if defined _DEBUG
         IndexType first_row;
         pFill->get_Item(0,&first_row);
         ASSERT(first_row == 1); // only one strand at the bottom... but we need it to be 2 for odd fill at top
#endif

         StrandIndexType running_cnt = (pGdrEntry->IsDifferentHarpedGridAtEndsUsed() ? 2 : 1);
         oddHpFill->Add(running_cnt); 

         for (CollectionIndexType is = 1; is < fill_size; is++)
         {
            if (running_cnt < nStrands)
            {
               // there are still strands to fill

               StrandIndexType fill_val;
               pFill->get_Item(is, &fill_val);
               
               running_cnt += fill_val;
               
               if (running_cnt <= nStrands)
               {
                  // not at the end yet, just fill it up
                  oddHpFill->Add(fill_val);
               }
               else
               {
                  // we are at the end... add the odd strand
                  if ( pGdrEntry->IsDifferentHarpedGridAtEndsUsed() )
                  {
                     oddHpFill->Add(fill_val-1);
                  }
                  else
                  {
                     oddHpFill->Add(fill_val);
                  }

                  running_cnt--;
               }
            }
            else
            {
               oddHpFill->Add(0);
            }
         }

         // Return with modified grid
         ATLASSERT(running_cnt==nStrands);
         oddHpFill.CopyTo(ppHPfill);
         return;
      }
   }

   // if we get to here, hp grid is same as end
   *ppHPfill = pFill;
   (*ppHPfill)->AddRef();
}

Float64 CBridgeAgentImp::ComputePierDiaphragmHeight(PierIndexType pierIdx,pgsTypes::PierFaceType pierFace) const
{
   // Compute Pier Diaphragm Height as Hgirder + "A" Dimension (slab offset) + Cross Slope Effect - tSlab
   // = SuperstructureDepth + Max(Cross Slope Effect - tSlab)

   Float64 Hss = GetSuperstructureDepth(pierIdx);

   // This makes the height of the diaphragm go from the bottom of the deepest girder to the bottom of the slab
   // In the future, we will want to include bearing heights and bearing recess dimensions

   GET_IFACE(IBridgeDescription, pIBridgeDesc);
   const CBridgeDescription2* pBridgeDesc = pIBridgeDesc->GetBridgeDescription();
   const CPierData2* pPier = pBridgeDesc->GetPier(pierIdx);

   Float64 Hpier = 0;
   if (pPier->IsBoundaryPier() || (pPier->IsInteriorPier() && !::IsSegmentContinuousOverPier(pPier->GetSegmentConnectionType())))
   {
      ATLASSERT(pPier->HasSlabOffset());

      // There are segments on each side of the pier (unless the pier is an abutment)
      const CGirderGroupData* pBackGroup = pPier->GetGirderGroup(pgsTypes::Back);
      if (pBackGroup)
      {
         GirderIndexType nGirders = pBackGroup->GetGirderCount();
         for (GirderIndexType gdrIdx = 0; gdrIdx < nGirders; gdrIdx++)
         {
            CGirderKey girderKey(pBackGroup->GetIndex(), gdrIdx);
            pgsPointOfInterest poi = GetPierPointOfInterest(girderKey, pierIdx);
            Float64 tSlab = GetGrossSlabDepth(poi);

            Float64 Wbf = GetBottomWidth(poi);

            Float64 station, offset;
            GetStationAndOffset(poi, &station, &offset);
            Float64 md = GetSlope(station, offset);
            Float64 mg = GetOrientation(poi.GetSegmentKey());

            Float64 girder_orientation_effect = Wbf*fabs((md - mg) / sqrt(1 + mg*mg));

            Float64 h = Hss + girder_orientation_effect - tSlab;
            Hpier = Max(Hpier, h);
         }
      }

      const CGirderGroupData* pAheadGroup = pPier->GetGirderGroup(pgsTypes::Ahead);
      if (pAheadGroup)
      {
         GirderIndexType nGirders = pAheadGroup->GetGirderCount();
         for (GirderIndexType gdrIdx = 0; gdrIdx < nGirders; gdrIdx++)
         {
            CGirderKey girderKey(pAheadGroup->GetIndex(), gdrIdx);
            pgsPointOfInterest poi = GetPierPointOfInterest(girderKey, pierIdx);
            Float64 tSlab = GetGrossSlabDepth(poi);

            Float64 Wbf = GetBottomWidth(poi);

            Float64 station, offset;
            GetStationAndOffset(poi, &station, &offset);
            Float64 md = GetSlope(station, offset);
            Float64 mg = GetOrientation(poi.GetSegmentKey());

            Float64 girder_orientation_effect = Wbf*fabs((md - mg) / sqrt(1 + mg*mg));

            Float64 h = Hss + girder_orientation_effect - tSlab;
            Hpier = Max(Hpier, h);
         }
      }
   }
   else
   {
      // Segment is continuous over the pier so there isn't a slab offset
      // at the pier
      ATLASSERT(!pPier->HasSlabOffset());
      GirderIndexType nGirders = GetGirderCountBySpan(pierIdx);
      for (GirderIndexType gdrIdx = 0; gdrIdx < nGirders; gdrIdx++)
      {
         CGirderKey girderKey(pPier->GetGirderGroup(pgsTypes::Back)->GetIndex(), gdrIdx);
         pgsPointOfInterest poi = GetPierPointOfInterest(girderKey, pierIdx);
         Float64 tSlab = GetGrossSlabDepth(poi);

         Float64 Wbf = GetBottomWidth(poi);

         Float64 station, offset;
         GetStationAndOffset(poi, &station, &offset);
         Float64 md = GetSlope(station, offset);
         Float64 mg = GetOrientation(poi.GetSegmentKey());

         Float64 girder_orientation_effect = Wbf*fabs((md - mg) / sqrt(1 + mg*mg));

         Float64 h = Hss + girder_orientation_effect - tSlab;
         Hpier = Max(Hpier, h);
      }
   }

   return Hpier;
}

Float64 CBridgeAgentImp::ComputePierDiaphragmWidth(PierIndexType pierIdx,pgsTypes::PierFaceType pierFace) const
{
   GET_IFACE(IBridgeDescription,pIBridgeDesc);
   const CBridgeDescription2* pBridgeDesc = pIBridgeDesc->GetBridgeDescription();
   const CPierData2* pPier = pBridgeDesc->GetPier(pierIdx);

   // Compute the maximum bearing offset... this is used by many of the geometry configurations
   GroupIndexType backGrpIdx, aheadGrpIdx;
   GetGirderGroupIndex(pierIdx,&backGrpIdx,&aheadGrpIdx);

   GroupIndexType grpIdx = (pierFace == pgsTypes::Back ? backGrpIdx : aheadGrpIdx);
   if ( grpIdx == INVALID_INDEX )
   {
      return 0.0;
   }

   Float64 Wsupport(0.0); // support width measured along CL girder... need to measure it normal
   // to CL Pier. See below for adjusting bearing offset. The same logic is used for adjusting the bearing offset
   // and the support width.
   // Take max among all girders framing into pier
   GirderIndexType nGirders = GetGirderCount(grpIdx);
   for (GirderIndexType gdrIdx = 0; gdrIdx < nGirders; gdrIdx++)
   {
      if (pPier->IsBoundaryPier())
      {
         Wsupport = max(Wsupport, pPier->GetSupportWidth(gdrIdx, pierFace));
      }
      else
      {
         ATLASSERT(pPier->IsInteriorPier());
         Wsupport = max(Wsupport, pPier->GetSupportWidth(gdrIdx, pgsTypes::Ahead));
      }
   }

   Float64 maxBrgOffset = 0;
   Float64 maxSupportWidth = 0;
   for ( GirderIndexType gdrIdx = 0; gdrIdx < nGirders; gdrIdx++ )
   {
      // get segment bearing offset
      CSegmentKey segmentKey = GetSegmentAtPier(pierIdx,CGirderKey(grpIdx, gdrIdx));
      Float64 brgOffset;


      // segment bearing offset is measured along the CL girder.
      // we need it to be measured normal to the CL pier
      // get the angle between the pier and the girder, then deduct 90 degrees
      // so that it is the angle between the pier normal and the girder.
      // multiply the bearing offset by this angle to get the bearing offset
      // normal to the pier.
      // Since the girders need not be parallel, each girder can have a different intersection
      // angle with the pier. For this reason, we have to compute the bearing offset and
      // support width normal to the pier uniquely for each girder.
      CComPtr<IAngle> objSegAngle;
      Float64 segAngle;
      if ( pierFace == pgsTypes::Back || (pierFace == pgsTypes::Ahead && pPier->IsInteriorPier() && !IsSegmentContinuousOverPier(pPier->GetSegmentConnectionType())) )
      {
         brgOffset = GetSegmentEndBearingOffset(segmentKey);
         GetSegmentAngle(segmentKey, pgsTypes::metEnd, &objSegAngle);
         objSegAngle->get_Value(&segAngle);
         segAngle -= PI_OVER_2;
      }
      else
      {
         brgOffset = GetSegmentStartBearingOffset(segmentKey);
         GetSegmentAngle(segmentKey, pgsTypes::metStart, &objSegAngle);
         objSegAngle->get_Value(&segAngle);
         segAngle -= PI_OVER_2;
      }

      brgOffset *= cos(segAngle);
      maxBrgOffset = Max(maxBrgOffset,brgOffset);
      maxSupportWidth = Max(maxSupportWidth,Wsupport*cos(segAngle));
   }

   Float64 W = 0;
   if ( pPier->IsBoundaryPier() )
   {
      pgsTypes::BoundaryConditionType bcType = pPier->GetBoundaryConditionType();
      if ( bcType == pgsTypes::bctHinge || bcType == pgsTypes::bctRoller )
      {
         W = maxSupportWidth;
      }
      else if ( bcType == pgsTypes::bctContinuousBeforeDeck || bcType == pgsTypes::bctContinuousAfterDeck )
      {
         W = maxBrgOffset - maxSupportWidth/2;
      }
      else if ( bcType == pgsTypes::bctIntegralBeforeDeck || bcType == pgsTypes::bctIntegralAfterDeck )
      {
         W = maxBrgOffset + maxSupportWidth/2;

         if ( pPier->GetPierModelType() == pgsTypes::pmtPhysical )
         {
            // The segment/pier connection is integral and there is a physical model of the pier.
            // Use the lower cross beam width as the minimum width of the pier diaphragm
            W = Max(W,pPier->GetXBeamWidth()/2);
         }
      }
      else if ( bcType == pgsTypes::bctIntegralBeforeDeckHingeBack || bcType == pgsTypes::bctIntegralAfterDeckHingeBack )
      {
         if ( pierFace == pgsTypes::Back )
         {
            W = maxSupportWidth;
         }
         else
         {
            W = maxBrgOffset + maxSupportWidth/2;
            if ( pPier->GetPierModelType() == pgsTypes::pmtPhysical )
            {
               W = Max(W,pPier->GetXBeamWidth()/2);
            }
         }
      }
      else if ( bcType == pgsTypes::bctIntegralBeforeDeckHingeAhead || bcType == pgsTypes::bctIntegralAfterDeckHingeAhead )
      {
         if ( pierFace == pgsTypes::Back )
         {
            W = maxBrgOffset + maxSupportWidth/2;
            if ( pPier->GetPierModelType() == pgsTypes::pmtPhysical )
            {
               W = Max(W,pPier->GetXBeamWidth()/2);
            }
         }
         else
         {
            W = maxSupportWidth;
         }
      }
      else
      {
         ATLASSERT(false); // Is there a new type?
         W = 0;
      }
   }
   else
   {
      ATLASSERT(pPier->IsInteriorPier());
      pgsTypes::PierSegmentConnectionType connectionType = pPier->GetSegmentConnectionType();

      if ( connectionType == pgsTypes::psctContinousClosureJoint )
      {
         W = 2*(maxBrgOffset - maxSupportWidth/2);
      }
      else if ( connectionType == pgsTypes::psctIntegralClosureJoint )
      {
         W = 2*(maxBrgOffset + maxSupportWidth/2);
      }
      else if ( connectionType == pgsTypes::psctContinuousSegment )
      {
         W = maxSupportWidth;
      }
      else if ( connectionType == pgsTypes::psctIntegralSegment )
      {
         W = maxSupportWidth;
         if ( pPier->GetPierModelType() == pgsTypes::pmtPhysical )
         {
            // The segment/pier connection is integral and there is a physical model of the pier.
            // Use the lower cross beam width as the minimum width of the pier diaphragm
            W = Max(W,pPier->GetXBeamWidth());
         }
      }
      else
      {
         ATLASSERT(false); // Is there a new type?
         W = 0;
      }
   }

   return W;
}

void CBridgeAgentImp::ValidateDeckParameters() const
{
   if ( m_bDeckParametersValidated )
   {
      return;
   }

   HRESULT hr = m_SectCutTool->GetDeckProperties(m_Bridge,10,&m_DeckSurfaceArea,&m_DeckVolume);
   ATLASSERT(SUCCEEDED(hr));
   m_bDeckParametersValidated = true;
}

void CBridgeAgentImp::InvalidateDeckParameters()
{
   m_bDeckParametersValidated = false;
   m_DeckSurfaceArea = -1;
   m_DeckVolume = -1;
}

void CBridgeAgentImp::ApplyDebonding(const CPrecastSegmentData* pSegment, IStrandGridModel* pStrandGridModel) const
{
   pStrandGridModel->ClearStraightStrandDebonding();

   const std::vector<CDebondData>& vDebond = pSegment->Strands.GetDebonding(pgsTypes::Straight);
   for ( const auto& debond_data : vDebond)
   {
      // debond data index is in same order as grid fill
      pStrandGridModel->DebondStraightStrandByGridIndex(debond_data.strandTypeGridIdx, debond_data.Length[pgsTypes::metStart], debond_data.Length[pgsTypes::metEnd]);
   }
}

Float64 CBridgeAgentImp::GetOverallHeight(const pgsPointOfInterest& poi) const
{
   VALIDATE(BRIDGE);

   CComPtr<IGirderSection> girder_section;
   HRESULT hr = GetGirderSection(poi, &girder_section);
   ATLASSERT(SUCCEEDED(hr));
   if (FAILED(hr))
   {
      return 0;
   }

   Float64 height;
   girder_section->get_OverallHeight(&height);

   return height;
}

const WBFL::Math::LinearFunction& CBridgeAgentImp::GetGirderTopChordElevationFunction(const CSegmentKey& segmentKey) const
{
   auto found = m_GirderTopChordElevationFunctions.find(segmentKey);
   if (found == m_GirderTopChordElevationFunctions.end())
   {
      ValidateGirderTopChordElevation(segmentKey);
      found = m_GirderTopChordElevationFunctions.find(segmentKey);
      ATLASSERT(found != m_GirderTopChordElevationFunctions.end());
   }

   return found->second;
}

void CBridgeAgentImp::ValidateGirderTopChordElevation(const CGirderKey& girderKey) const
{
   CSegmentKey segmentKey(girderKey, 0);
   auto found = m_GirderTopChordElevationFunctions.find(segmentKey);
   if (found != m_GirderTopChordElevationFunctions.end())
   {
      return; // we've already done this girder
   }
   
   GET_IFACE(IBridgeDescription,pIBridgeDesc);
   const CBridgeDescription2* pBridgeDesc = pIBridgeDesc->GetBridgeDescription();

   if (pBridgeDesc->GetHaunchInputDepthType() == pgsTypes::hidACamber)
   {
      // Old "A" dimension and assumed excess camber input
      ValidateGirderTopChordElevationADimInput(girderKey,pBridgeDesc,&m_GirderTopChordElevationFunctions);
   }
   else
   {
      ValidateGirderTopChordElevationDirectHaunchInput(girderKey,pBridgeDesc,&m_GirderTopChordElevationFunctions);
   }
}

void CBridgeAgentImp::ValidateGirderTopChordElevationADimInput(const CGirderKey& girderKey,const CBridgeDescription2* pBridgeDesc,std::map<CSegmentKey,WBFL::Math::LinearFunction>* pFunctions) const
{
   VALIDATE(BRIDGE);

   // overlay is measured at the GCE. If it exists prior to the GCE, then it's included in the chord elev
   IntervalIndexType gceInterval = GetGeometryControlInterval();
   Float64 overlayDepth = GetOverlayDepth(gceInterval);

   // Create the functions. Functions expect basis at start end of segment
   const CGirderGroupData* pGroup = pBridgeDesc->GetGirderGroup(girderKey.groupIndex);
   const CSplicedGirderData* pGirder = pGroup->GetGirder(girderKey.girderIndex);
   SegmentIndexType nSegments = pGirder->GetSegmentCount();
   for (SegmentIndexType segIdx = 0; segIdx < nSegments; segIdx++)
   {
      const CPrecastSegmentData* pSegment = pGirder->GetSegment(segIdx);
      const CSegmentKey& segmentKey(pSegment->GetSegmentKey());

      // get (X,Y), Station/Offset, and Elevation at bearing locations
      CComPtr<IPoint2d> pntPier1, pntEnd1, pntBrg1, pntBrg2, pntEnd2, pntPier2;
      GetSegmentEndPoints(segmentKey, pgsTypes::pcLocal, &pntPier1, &pntEnd1, &pntBrg1, &pntBrg2, &pntEnd2, &pntPier2);
      Float64 startStation, startOffset;
      GetStationAndOffset(pgsTypes::pcLocal,pntBrg1, &startStation, &startOffset);
      Float64 startProfileElevation = GetElevation(startStation, startOffset);

      Float64 endStation, endOffset;
      GetStationAndOffset(pgsTypes::pcLocal,pntBrg2, &endStation, &endOffset);
      Float64 endProfileElevation = GetElevation(endStation, endOffset);

      // Slab offsets are also at bearing locations, so sum them with end elevations
      std::array<Float64,2> slab_offset;
      pSegment->GetSlabOffset(&slab_offset[pgsTypes::metStart],&slab_offset[pgsTypes::metEnd]);

      // Compute unadjusted elevations at ends of segments
      Float64 segLength = GetSegmentLength(segmentKey);
      Float64 startLoc = GetSegmentStartEndDistance(segmentKey);
      Float64 endLoc = segLength - GetSegmentEndEndDistance(segmentKey);

      WBFL::Math::LinearFunction tmpf = GenerateLineFunc2dFromPoints(startLoc, startProfileElevation-slab_offset[pgsTypes::metStart]- overlayDepth, 
                                                                     endLoc,   endProfileElevation-slab_offset[pgsTypes::metEnd]    - overlayDepth);
      std::array<Float64,2> unadj_elev_ends;
      unadj_elev_ends[pgsTypes::metStart] = tmpf.Evaluate(0.0);
      unadj_elev_ends[pgsTypes::metEnd] = tmpf.Evaluate(segLength);

      // Elevation adjustments are always at segment ends, so these can be added directly
      std::array<Float64, 2> elev_adj{ 0.0,0.0 };
      for (int i = 0; i < 2; i++)
      {
         pgsTypes::MemberEndType end = (pgsTypes::MemberEndType)i;
         const CPierData2* pPier;
         const CTemporarySupportData* pTS;
         pSegment->GetSupport(end, &pPier, &pTS);
         if (pTS && pTS->HasElevationAdjustment())
         {
            elev_adj[end] = pTS->GetElevationAdjustment();
         }
      }

      // Create a function for the basic straight line that connects the top of the segment at the two ends
      Float64 elevStart = unadj_elev_ends[pgsTypes::metStart] + elev_adj[pgsTypes::metStart];
      Float64 elevEnd =   unadj_elev_ends[pgsTypes::metEnd]   + elev_adj[pgsTypes::metEnd];
      Float64 m = (elevEnd - elevStart) / segLength;
      // y = mx+b
      // x = 0 is at start pier CL Brg. so b = elevStart
      WBFL::Math::LinearFunction fnBasic(m, elevStart);

      pFunctions->insert(std::make_pair(segmentKey, fnBasic));
   }
}

void CBridgeAgentImp::ValidateGirderTopChordElevationDirectHaunchInput(const CGirderKey& girderKey,const CBridgeDescription2* pBridgeDesc,std::map<CSegmentKey,WBFL::Math::LinearFunction>* pFunctions) const
{
   VALIDATE(BRIDGE);

   const CGirderGroupData* pGroup = pBridgeDesc->GetGirderGroup(girderKey.groupIndex);
   const CSplicedGirderData* pGirder = pGroup->GetGirder(girderKey.girderIndex);

   Float64 deckDepth = GetGrossSlabDepth();

   // overlay is measured at the GCE
   IntervalIndexType gceInterval = GetGeometryControlInterval();

   Float64 overlayDepth = GetOverlayDepth(gceInterval);

   // Haunch depths come from WBFL
   CComPtr<ISuperstructureMember> ssmbr;
   IDType ssmbrID = ::GetSuperstructureMemberID(girderKey.groupIndex,girderKey.girderIndex);
   m_Bridge->get_SuperstructureMember(ssmbrID,&ssmbr);

   SegmentIndexType nSegments = pGirder->GetSegmentCount();
   for (SegmentIndexType segIdx = 0; segIdx < nSegments; segIdx++)
   {
      const CPrecastSegmentData* pSegment = pGirder->GetSegment(segIdx);
      const CSegmentKey& segmentKey(pSegment->GetSegmentKey());

      // Elevation adjustments 
      std::array<Float64,2> elev_adj{ 0.0,0.0 };
      for (int i = 0; i < 2; i++)
      {
         pgsTypes::MemberEndType end = (pgsTypes::MemberEndType)i;
         const CPierData2* pPier;
         const CTemporarySupportData* pTS;
         pSegment->GetSupport(end,&pPier,&pTS);
         if (pTS && pTS->HasElevationAdjustment())
         {
            elev_adj[end] = pTS->GetElevationAdjustment();
         }
      }

      // Controlling locations for direct haunch input are at ends of segments unless the
      // end of the segment is at then end of a group, then they are at bearing locations
      const CPierData2* pPier;
      const CTemporarySupportData* pTS;
      pSegment->GetSupport(pgsTypes::metStart,&pPier,&pTS);
      bool bAtStartBrg = nullptr != pPier && pPier->IsBoundaryPier();

      pSegment->GetSupport(pgsTypes::metEnd,&pPier,&pTS);
      bool bAtEndBrg = nullptr != pPier && pPier->IsBoundaryPier();

      // Get (X,Y), Station/Offset, and Elevation at control points
      CComPtr<IPoint2d> pntPierStart,pntEndStart,pntBrgStart,pntBrgEnd,pntEndEnd,pntPierEnd;
      GetSegmentEndPoints(segmentKey,pgsTypes::pcLocal,&pntPierStart,&pntEndStart,&pntBrgStart,&pntBrgEnd,&pntEndEnd,&pntPierEnd);

      Float64 startStation,startOffset;
      if (bAtStartBrg)
      {
         GetStationAndOffset(pgsTypes::pcLocal,pntBrgStart,&startStation,&startOffset);
      }
      else
      {
         GetStationAndOffset(pgsTypes::pcLocal,pntEndStart,&startStation,&startOffset);
      }

      Float64 startProfileElevation = GetElevation(startStation,startOffset);

      Float64 endStation,endOffset;
      if (bAtEndBrg)
      {
         GetStationAndOffset(pgsTypes::pcLocal,pntBrgEnd,&endStation,&endOffset);
      }
      else
      {
         GetStationAndOffset(pgsTypes::pcLocal,pntEndEnd,&endStation,&endOffset);
      }

      Float64 endProfileElevation = GetElevation(endStation,endOffset);

      // Get haunch depths at control points
      CComPtr<ISuperstructureMemberSegment> segment;
      ssmbr->get_Segment(segIdx,&segment);

      Float64 segLength = GetSegmentLength(segmentKey);
      Float64 startDist = bAtStartBrg ? GetSegmentStartEndDistance(segmentKey) : 0.0;
      Float64 endDist = bAtEndBrg ? GetSegmentEndEndDistance(segmentKey) : 0.0;

      Float64 startLoc = startDist;
      Float64 endLoc = segLength - endDist;

      Float64 haunchStart,haunchEnd;
      segment->ComputeHaunchDepth(startLoc,&haunchStart);
      segment->ComputeHaunchDepth(endLoc,&haunchEnd);

      Float64 elevStart = startProfileElevation - deckDepth - overlayDepth - haunchStart;
      Float64 elevEnd   = endProfileElevation - deckDepth - overlayDepth - haunchEnd;

      // At this point, we have elevations which may, or may not, be at the segment ends.
      // The function object we are building requires its basis at segment ends, so fix that if not so.
      if (bAtStartBrg || bAtEndBrg)
      {
         WBFL::Math::LinearFunction tmpf = GenerateLineFunc2dFromPoints(startLoc,elevStart,endLoc,elevEnd);
         elevStart = tmpf.Evaluate(0.0);
         elevEnd = tmpf.Evaluate(segLength);
      }

      // Elevation adjustments are always at ends
      elevStart += elev_adj[pgsTypes::metStart];
      elevEnd   += elev_adj[pgsTypes::metEnd];

      // this is a function for the basic straight line that connects at the top of the segment its ends
      Float64 m = (elevEnd - elevStart) / segLength;
      // y = mx+b
      // x = 0 is at start pier CL Brg. so b = elevStart
      WBFL::Math::LinearFunction fnBasic(m, elevStart);

      pFunctions->insert(std::make_pair(segmentKey,fnBasic));
   }
}

